package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
stress	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
PrintStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
concurrent	TokenNameIdentifier
.	TokenNameDOT
BlockingQueue	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
concurrent	TokenNameIdentifier
.	TokenNameDOT
SynchronousQueue	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
stress	TokenNameIdentifier
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
stress	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
CassandraClient	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
stress	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Operation	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
StressAction	TokenNameIdentifier
extends	TokenNameextends
Thread	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
BlockingQueue	TokenNameIdentifier
<	TokenNameLESS
Operation	TokenNameIdentifier
>	TokenNameGREATER
operations	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SynchronousQueue	TokenNameIdentifier
<	TokenNameLESS
Operation	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
Session	TokenNameIdentifier
client	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
PrintStream	TokenNameIdentifier
output	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
boolean	TokenNameboolean
stop	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
SUCCESS	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
FAILURE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
int	TokenNameint
returnCode	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
StressAction	TokenNameIdentifier
(	TokenNameLPAREN
Session	TokenNameIdentifier
session	TokenNameIdentifier
,	TokenNameCOMMA
PrintStream	TokenNameIdentifier
out	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
client	TokenNameIdentifier
=	TokenNameEQUAL
session	TokenNameIdentifier
;	TokenNameSEMICOLON
output	TokenNameIdentifier
=	TokenNameEQUAL
out	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
run	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
latency	TokenNameIdentifier
,	TokenNameCOMMA
oldLatency	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
epoch	TokenNameIdentifier
,	TokenNameCOMMA
total	TokenNameIdentifier
,	TokenNameCOMMA
oldTotal	TokenNameIdentifier
,	TokenNameCOMMA
keyCount	TokenNameIdentifier
,	TokenNameCOMMA
oldKeyCount	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
client	TokenNameIdentifier
.	TokenNameDOT
getOperation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
Stress	TokenNameIdentifier
.	TokenNameDOT
Operations	TokenNameIdentifier
.	TokenNameDOT
INSERT	TokenNameIdentifier
||	TokenNameOR_OR
client	TokenNameIdentifier
.	TokenNameDOT
getOperation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
Stress	TokenNameIdentifier
.	TokenNameDOT
Operations	TokenNameIdentifier
.	TokenNameDOT
COUNTER_ADD	TokenNameIdentifier
)	TokenNameRPAREN
client	TokenNameIdentifier
.	TokenNameDOT
createKeySpaces	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
threadCount	TokenNameIdentifier
=	TokenNameEQUAL
client	TokenNameIdentifier
.	TokenNameDOT
getThreads	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Consumer	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
consumers	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Consumer	TokenNameIdentifier
[	TokenNameLBRACKET
threadCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"total,interval_op_rate,interval_key_rate,avg_latency,elapsed_time"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
itemsPerThread	TokenNameIdentifier
=	TokenNameEQUAL
client	TokenNameIdentifier
.	TokenNameDOT
getKeysPerThread	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
modulo	TokenNameIdentifier
=	TokenNameEQUAL
client	TokenNameIdentifier
.	TokenNameDOT
getNumKeys	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
%	TokenNameREMAINDER
threadCount	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
threadCount	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
threadCount	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
itemsPerThread	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
modulo	TokenNameIdentifier
;	TokenNameSEMICOLON
consumers	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
Consumer	TokenNameIdentifier
(	TokenNameLPAREN
itemsPerThread	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Producer	TokenNameIdentifier
producer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Producer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
producer	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
threadCount	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
consumers	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
start	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
terminate	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
latency	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
epoch	TokenNameIdentifier
=	TokenNameEQUAL
total	TokenNameIdentifier
=	TokenNameEQUAL
keyCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
interval	TokenNameIdentifier
=	TokenNameEQUAL
client	TokenNameIdentifier
.	TokenNameDOT
getProgressInterval	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
epochIntervals	TokenNameIdentifier
=	TokenNameEQUAL
client	TokenNameIdentifier
.	TokenNameDOT
getProgressInterval	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
*	TokenNameMULTIPLY
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
testStartTime	TokenNameIdentifier
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
terminate	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
stop	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
producer	TokenNameIdentifier
.	TokenNameDOT
stopProducer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Consumer	TokenNameIdentifier
consumer	TokenNameIdentifier
:	TokenNameCOLON
consumers	TokenNameIdentifier
)	TokenNameRPAREN
consumer	TokenNameIdentifier
.	TokenNameDOT
stopConsume	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
Thread	TokenNameIdentifier
.	TokenNameDOT
sleep	TokenNameIdentifier
(	TokenNameLPAREN
100	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InterruptedException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
alive	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Thread	TokenNameIdentifier
thread	TokenNameIdentifier
:	TokenNameCOLON
consumers	TokenNameIdentifier
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
thread	TokenNameIdentifier
.	TokenNameDOT
isAlive	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
alive	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
alive	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
terminate	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
epoch	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
terminate	TokenNameIdentifier
||	TokenNameOR_OR
epoch	TokenNameIdentifier
>	TokenNameGREATER
epochIntervals	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
epoch	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
oldTotal	TokenNameIdentifier
=	TokenNameEQUAL
total	TokenNameIdentifier
;	TokenNameSEMICOLON
oldLatency	TokenNameIdentifier
=	TokenNameEQUAL
latency	TokenNameIdentifier
;	TokenNameSEMICOLON
oldKeyCount	TokenNameIdentifier
=	TokenNameEQUAL
keyCount	TokenNameIdentifier
;	TokenNameSEMICOLON
total	TokenNameIdentifier
=	TokenNameEQUAL
client	TokenNameIdentifier
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
keyCount	TokenNameIdentifier
=	TokenNameEQUAL
client	TokenNameIdentifier
.	TokenNameDOT
keys	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
latency	TokenNameIdentifier
=	TokenNameEQUAL
client	TokenNameIdentifier
.	TokenNameDOT
latency	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
opDelta	TokenNameIdentifier
=	TokenNameEQUAL
total	TokenNameIdentifier
-	TokenNameMINUS
oldTotal	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
keyDelta	TokenNameIdentifier
=	TokenNameEQUAL
keyCount	TokenNameIdentifier
-	TokenNameMINUS
oldKeyCount	TokenNameIdentifier
;	TokenNameSEMICOLON
double	TokenNamedouble
latencyDelta	TokenNameIdentifier
=	TokenNameEQUAL
latency	TokenNameIdentifier
-	TokenNameMINUS
oldLatency	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
currentTimeInSeconds	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
testStartTime	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
1000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
String	TokenNameIdentifier
formattedDelta	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
opDelta	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
Double	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
latencyDelta	TokenNameIdentifier
/	TokenNameDIVIDE
(	TokenNameLPAREN
opDelta	TokenNameIdentifier
*	TokenNameMULTIPLY
1000	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
"NaN"	TokenNameStringLiteral
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%d,%d,%d,%s,%d"	TokenNameStringLiteral
,	TokenNameCOMMA
total	TokenNameIdentifier
,	TokenNameCOMMA
opDelta	TokenNameIdentifier
/	TokenNameDIVIDE
interval	TokenNameIdentifier
,	TokenNameCOMMA
keyDelta	TokenNameIdentifier
/	TokenNameDIVIDE
interval	TokenNameIdentifier
,	TokenNameCOMMA
formattedDelta	TokenNameIdentifier
,	TokenNameCOMMA
currentTimeInSeconds	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
returnCode	TokenNameIdentifier
=	TokenNameEQUAL
SUCCESS	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
producer	TokenNameIdentifier
.	TokenNameDOT
isAlive	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
producer	TokenNameIdentifier
.	TokenNameDOT
interrupt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
returnCode	TokenNameIdentifier
=	TokenNameEQUAL
FAILURE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
Consumer	TokenNameIdentifier
consumer	TokenNameIdentifier
:	TokenNameCOLON
consumers	TokenNameIdentifier
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
consumer	TokenNameIdentifier
.	TokenNameDOT
getReturnCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
FAILURE	TokenNameIdentifier
)	TokenNameRPAREN
returnCode	TokenNameIdentifier
=	TokenNameEQUAL
FAILURE	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
returnCode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SUCCESS	TokenNameIdentifier
)	TokenNameRPAREN
output	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"END"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
output	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"FAILURE"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getReturnCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
returnCode	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
class	TokenNameclass
Producer	TokenNameIdentifier
extends	TokenNameextends
Thread	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
volatile	TokenNamevolatile
boolean	TokenNameboolean
stop	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
public	TokenNamepublic
void	TokenNamevoid
run	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
client	TokenNameIdentifier
.	TokenNameDOT
getNumKeys	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
stop	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
operations	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
createOperation	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
%	TokenNameREMAINDER
client	TokenNameIdentifier
.	TokenNameDOT
getNumDifferentKeys	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InterruptedException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"Producer error - "	TokenNameStringLiteral
+	TokenNamePLUS
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
stopProducer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
stop	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
class	TokenNameclass
Consumer	TokenNameIdentifier
extends	TokenNameextends
Thread	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
items	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
boolean	TokenNameboolean
stop	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
int	TokenNameint
returnCode	TokenNameIdentifier
=	TokenNameEQUAL
StressAction	TokenNameIdentifier
.	TokenNameDOT
SUCCESS	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Consumer	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
toConsume	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
items	TokenNameIdentifier
=	TokenNameEQUAL
toConsume	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
run	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
CassandraClient	TokenNameIdentifier
connection	TokenNameIdentifier
=	TokenNameEQUAL
client	TokenNameIdentifier
.	TokenNameDOT
getClient	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
items	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
stop	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
operations	TokenNameIdentifier
.	TokenNameDOT
take	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
run	TokenNameIdentifier
(	TokenNameLPAREN
connection	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
output	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
returnCode	TokenNameIdentifier
=	TokenNameEQUAL
StressAction	TokenNameIdentifier
.	TokenNameDOT
FAILURE	TokenNameIdentifier
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
exit	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
output	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
returnCode	TokenNameIdentifier
=	TokenNameEQUAL
StressAction	TokenNameIdentifier
.	TokenNameDOT
FAILURE	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
stopConsume	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
stop	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getReturnCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
returnCode	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
Operation	TokenNameIdentifier
createOperation	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
client	TokenNameIdentifier
.	TokenNameDOT
getOperation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
READ	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
client	TokenNameIdentifier
.	TokenNameDOT
isCQL	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
CqlReader	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
Reader	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
COUNTER_GET	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
client	TokenNameIdentifier
.	TokenNameDOT
isCQL	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
CqlCounterGetter	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
CounterGetter	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
INSERT	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
client	TokenNameIdentifier
.	TokenNameDOT
isCQL	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
CqlInserter	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
Inserter	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
COUNTER_ADD	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
client	TokenNameIdentifier
.	TokenNameDOT
isCQL	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
CqlCounterAdder	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
CounterAdder	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
RANGE_SLICE	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
client	TokenNameIdentifier
.	TokenNameDOT
isCQL	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
CqlRangeSlicer	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
RangeSlicer	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
INDEXED_RANGE_SLICE	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
client	TokenNameIdentifier
.	TokenNameDOT
isCQL	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
CqlIndexedRangeSlicer	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
IndexedRangeSlicer	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
MULTI_GET	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
client	TokenNameIdentifier
.	TokenNameDOT
isCQL	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
CqlMultiGetter	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
MultiGetter	TokenNameIdentifier
(	TokenNameLPAREN
client	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
UnsupportedOperationException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
stopAction	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
stop	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
