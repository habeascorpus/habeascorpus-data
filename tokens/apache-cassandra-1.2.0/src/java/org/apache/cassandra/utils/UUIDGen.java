package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
net	TokenNameIdentifier
.	TokenNameDOT
InetAddress	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
net	TokenNameIdentifier
.	TokenNameDOT
UnknownHostException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
ByteBuffer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
security	TokenNameIdentifier
.	TokenNameDOT
MessageDigest	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
security	TokenNameIdentifier
.	TokenNameDOT
NoSuchAlgorithmException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collection	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Enumeration	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashSet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Set	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Random	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
UUID	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
UUIDGen	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
START_EPOCH	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
12219292800000L	TokenNameLongLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
clockSeqAndNode	TokenNameIdentifier
=	TokenNameEQUAL
makeClockSeqAndNode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
UUIDGen	TokenNameIdentifier
instance	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
UUIDGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
lastNanos	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
UUIDGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
clockSeqAndNode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"singleton instantiation is misplaced."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
UUID	TokenNameIdentifier
getTimeUUID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
UUID	TokenNameIdentifier
(	TokenNameLPAREN
instance	TokenNameIdentifier
.	TokenNameDOT
createTimeSafe	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
clockSeqAndNode	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
UUID	TokenNameIdentifier
getUUID	TokenNameIdentifier
(	TokenNameLPAREN
ByteBuffer	TokenNameIdentifier
raw	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
UUID	TokenNameIdentifier
(	TokenNameLPAREN
raw	TokenNameIdentifier
.	TokenNameDOT
getLong	TokenNameIdentifier
(	TokenNameLPAREN
raw	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
raw	TokenNameIdentifier
.	TokenNameDOT
getLong	TokenNameIdentifier
(	TokenNameLPAREN
raw	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
decompose	TokenNameIdentifier
(	TokenNameLPAREN
UUID	TokenNameIdentifier
uuid	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
most	TokenNameIdentifier
=	TokenNameEQUAL
uuid	TokenNameIdentifier
.	TokenNameDOT
getMostSignificantBits	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
least	TokenNameIdentifier
=	TokenNameEQUAL
uuid	TokenNameIdentifier
.	TokenNameDOT
getLeastSignificantBits	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
b	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
most	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
(	TokenNameLPAREN
(	TokenNameLPAREN
7	TokenNameIntegerLiteral
-	TokenNameMINUS
i	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
b	TokenNameIdentifier
[	TokenNameLBRACKET
8	TokenNameIntegerLiteral
+	TokenNamePLUS
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
least	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
(	TokenNameLPAREN
(	TokenNameLPAREN
7	TokenNameIntegerLiteral
-	TokenNameMINUS
i	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
b	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getTimeUUIDBytes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
createTimeUUIDBytes	TokenNameIdentifier
(	TokenNameLPAREN
instance	TokenNameIdentifier
.	TokenNameDOT
createTimeSafe	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getTimeUUIDBytes	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
timeMillis	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
createTimeUUIDBytes	TokenNameIdentifier
(	TokenNameLPAREN
instance	TokenNameIdentifier
.	TokenNameDOT
createTimeUnsafe	TokenNameIdentifier
(	TokenNameLPAREN
timeMillis	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getTimeUUIDBytes	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
timeMillis	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
nanos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nanos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
10000	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
createTimeUUIDBytes	TokenNameIdentifier
(	TokenNameLPAREN
instance	TokenNameIdentifier
.	TokenNameDOT
createTimeUnsafe	TokenNameIdentifier
(	TokenNameLPAREN
timeMillis	TokenNameIdentifier
,	TokenNameCOMMA
nanos	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
createTimeUUIDBytes	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
msb	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
lsb	TokenNameIdentifier
=	TokenNameEQUAL
clockSeqAndNode	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
uuidBytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
uuidBytes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
msb	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
8	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
(	TokenNameLPAREN
7	TokenNameIntegerLiteral
-	TokenNameMINUS
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
uuidBytes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
lsb	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
8	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
(	TokenNameLPAREN
7	TokenNameIntegerLiteral
-	TokenNameMINUS
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
uuidBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
long	TokenNamelong
getAdjustedTimestamp	TokenNameIdentifier
(	TokenNameLPAREN
UUID	TokenNameIdentifier
uuid	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
uuid	TokenNameIdentifier
.	TokenNameDOT
version	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"incompatible with uuid version: "	TokenNameStringLiteral
+	TokenNamePLUS
uuid	TokenNameIdentifier
.	TokenNameDOT
version	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
uuid	TokenNameIdentifier
.	TokenNameDOT
timestamp	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
/	TokenNameDIVIDE
10000	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
START_EPOCH	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
long	TokenNamelong
makeClockSeqAndNode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
clock	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Random	TokenNameIdentifier
(	TokenNameLPAREN
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
nextLong	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
lsb	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
lsb	TokenNameIdentifier
|=	TokenNameOR_EQUAL
0x8000000000000000L	TokenNameLongLiteral
;	TokenNameSEMICOLON
lsb	TokenNameIdentifier
|=	TokenNameOR_EQUAL
(	TokenNameLPAREN
clock	TokenNameIdentifier
&	TokenNameAND
0x0000000000003FFFL	TokenNameLongLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
48	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
lsb	TokenNameIdentifier
|=	TokenNameOR_EQUAL
makeNode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
lsb	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
long	TokenNamelong
createTimeSafe	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
nanosSince	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
START_EPOCH	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
10000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nanosSince	TokenNameIdentifier
>	TokenNameGREATER
lastNanos	TokenNameIdentifier
)	TokenNameRPAREN
lastNanos	TokenNameIdentifier
=	TokenNameEQUAL
nanosSince	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
nanosSince	TokenNameIdentifier
=	TokenNameEQUAL
++	TokenNamePLUS_PLUS
lastNanos	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
createTime	TokenNameIdentifier
(	TokenNameLPAREN
nanosSince	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
long	TokenNamelong
createTimeUnsafe	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
when	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
createTimeUnsafe	TokenNameIdentifier
(	TokenNameLPAREN
when	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
long	TokenNamelong
createTimeUnsafe	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
when	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
nanos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
nanosSince	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
when	TokenNameIdentifier
-	TokenNameMINUS
START_EPOCH	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
10000	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
nanos	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
createTime	TokenNameIdentifier
(	TokenNameLPAREN
nanosSince	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
long	TokenNamelong
createTime	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
nanosSince	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
msb	TokenNameIdentifier
=	TokenNameEQUAL
0L	TokenNameLongLiteral
;	TokenNameSEMICOLON
msb	TokenNameIdentifier
|=	TokenNameOR_EQUAL
(	TokenNameLPAREN
0x00000000ffffffffL	TokenNameLongLiteral
&	TokenNameAND
nanosSince	TokenNameIdentifier
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
32	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
msb	TokenNameIdentifier
|=	TokenNameOR_EQUAL
(	TokenNameLPAREN
0x0000ffff00000000L	TokenNameLongLiteral
&	TokenNameAND
nanosSince	TokenNameIdentifier
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
msb	TokenNameIdentifier
|=	TokenNameOR_EQUAL
(	TokenNameLPAREN
0xffff000000000000L	TokenNameLongLiteral
&	TokenNameAND
nanosSince	TokenNameIdentifier
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
48	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
msb	TokenNameIdentifier
|=	TokenNameOR_EQUAL
0x0000000000001000L	TokenNameLongLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
msb	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
long	TokenNamelong
makeNode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Collection	TokenNameIdentifier
<	TokenNameLESS
InetAddress	TokenNameIdentifier
>	TokenNameGREATER
localAddresses	TokenNameIdentifier
=	TokenNameEQUAL
FBUtilities	TokenNameIdentifier
.	TokenNameDOT
getAllLocalAddresses	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
localAddresses	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot generate the node component of the UUID because cannot retrieve any IP addresses."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
(	TokenNameLPAREN
localAddresses	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
node	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
hash	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
node	TokenNameIdentifier
|=	TokenNameOR_EQUAL
(	TokenNameLPAREN
0x00000000000000ff	TokenNameIntegerLiteral
&	TokenNameAND
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
hash	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
(	TokenNameLPAREN
5	TokenNameIntegerLiteral
-	TokenNameMINUS
i	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
(	TokenNameLPAREN
0xff00000000000000L	TokenNameLongLiteral
&	TokenNameAND
node	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
node	TokenNameIdentifier
|	TokenNameOR
0x0000010000000000L	TokenNameLongLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
hash	TokenNameIdentifier
(	TokenNameLPAREN
Collection	TokenNameIdentifier
<	TokenNameLESS
InetAddress	TokenNameIdentifier
>	TokenNameGREATER
data	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
MessageDigest	TokenNameIdentifier
messageDigest	TokenNameIdentifier
=	TokenNameEQUAL
MessageDigest	TokenNameIdentifier
.	TokenNameDOT
getInstance	TokenNameIdentifier
(	TokenNameLPAREN
"MD5"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
InetAddress	TokenNameIdentifier
addr	TokenNameIdentifier
:	TokenNameCOLON
data	TokenNameIdentifier
)	TokenNameRPAREN
messageDigest	TokenNameIdentifier
.	TokenNameDOT
update	TokenNameIdentifier
(	TokenNameLPAREN
addr	TokenNameIdentifier
.	TokenNameDOT
getAddress	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
messageDigest	TokenNameIdentifier
.	TokenNameDOT
digest	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NoSuchAlgorithmException	TokenNameIdentifier
nsae	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"MD5 digest algorithm is not available"	TokenNameStringLiteral
,	TokenNameCOMMA
nsae	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
