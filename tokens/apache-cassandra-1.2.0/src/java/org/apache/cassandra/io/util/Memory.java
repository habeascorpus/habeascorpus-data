package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
sun	TokenNameIdentifier
.	TokenNameDOT
misc	TokenNameIdentifier
.	TokenNameDOT
Unsafe	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
lang	TokenNameIdentifier
.	TokenNameDOT
reflect	TokenNameIdentifier
.	TokenNameDOT
Field	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
Memory	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
Unsafe	TokenNameIdentifier
unsafe	TokenNameIdentifier
;	TokenNameSEMICOLON
static	TokenNamestatic
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
Field	TokenNameIdentifier
field	TokenNameIdentifier
=	TokenNameEQUAL
sun	TokenNameIdentifier
.	TokenNameDOT
misc	TokenNameIdentifier
.	TokenNameDOT
Unsafe	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
.	TokenNameDOT
getDeclaredField	TokenNameIdentifier
(	TokenNameLPAREN
"theUnsafe"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
field	TokenNameIdentifier
.	TokenNameDOT
setAccessible	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
unsafe	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
sun	TokenNameIdentifier
.	TokenNameDOT
misc	TokenNameIdentifier
.	TokenNameDOT
Unsafe	TokenNameIdentifier
)	TokenNameRPAREN
field	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AssertionError	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
long	TokenNamelong
peer	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
long	TokenNamelong
size	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
Memory	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
bytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
size	TokenNameIdentifier
=	TokenNameEQUAL
bytes	TokenNameIdentifier
;	TokenNameSEMICOLON
peer	TokenNameIdentifier
=	TokenNameEQUAL
unsafe	TokenNameIdentifier
.	TokenNameDOT
allocateMemory	TokenNameIdentifier
(	TokenNameLPAREN
size	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
Memory	TokenNameIdentifier
allocate	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
bytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bytes	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
new	TokenNamenew
Memory	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setByte	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
offset	TokenNameIdentifier
,	TokenNameCOMMA
byte	TokenNamebyte
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
checkPosition	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
unsafe	TokenNameIdentifier
.	TokenNameDOT
putByte	TokenNameIdentifier
(	TokenNameLPAREN
peer	TokenNameIdentifier
+	TokenNamePLUS
offset	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setMemory	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
offset	TokenNameIdentifier
,	TokenNameCOMMA
long	TokenNamelong
bytes	TokenNameIdentifier
,	TokenNameCOMMA
byte	TokenNamebyte
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
checkPosition	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
+	TokenNamePLUS
bytes	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
unsafe	TokenNameIdentifier
.	TokenNameDOT
setMemory	TokenNameIdentifier
(	TokenNameLPAREN
peer	TokenNameIdentifier
+	TokenNamePLUS
offset	TokenNameIdentifier
,	TokenNameCOMMA
bytes	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setLong	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
offset	TokenNameIdentifier
,	TokenNameCOMMA
long	TokenNamelong
l	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
checkPosition	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
unsafe	TokenNameIdentifier
.	TokenNameDOT
putLong	TokenNameIdentifier
(	TokenNameLPAREN
peer	TokenNameIdentifier
+	TokenNamePLUS
offset	TokenNameIdentifier
,	TokenNameCOMMA
l	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setBytes	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
memoryOffset	TokenNameIdentifier
,	TokenNameCOMMA
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
buffer	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
bufferOffset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
buffer	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
NullPointerException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
bufferOffset	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
count	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
bufferOffset	TokenNameIdentifier
+	TokenNamePLUS
count	TokenNameIdentifier
>	TokenNameGREATER
buffer	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IndexOutOfBoundsException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
checkPosition	TokenNameIdentifier
(	TokenNameLPAREN
memoryOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
end	TokenNameIdentifier
=	TokenNameEQUAL
memoryOffset	TokenNameIdentifier
+	TokenNamePLUS
count	TokenNameIdentifier
;	TokenNameSEMICOLON
checkPosition	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
memoryOffset	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
unsafe	TokenNameIdentifier
.	TokenNameDOT
putByte	TokenNameIdentifier
(	TokenNameLPAREN
peer	TokenNameIdentifier
+	TokenNamePLUS
memoryOffset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
buffer	TokenNameIdentifier
[	TokenNameLBRACKET
bufferOffset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
byte	TokenNamebyte
getByte	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
checkPosition	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
unsafe	TokenNameIdentifier
.	TokenNameDOT
getByte	TokenNameIdentifier
(	TokenNameLPAREN
peer	TokenNameIdentifier
+	TokenNamePLUS
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
getLong	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
checkPosition	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
unsafe	TokenNameIdentifier
.	TokenNameDOT
getLong	TokenNameIdentifier
(	TokenNameLPAREN
peer	TokenNameIdentifier
+	TokenNamePLUS
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
getBytes	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
memoryOffset	TokenNameIdentifier
,	TokenNameCOMMA
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
buffer	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
bufferOffset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
buffer	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
NullPointerException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
bufferOffset	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
count	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
count	TokenNameIdentifier
>	TokenNameGREATER
buffer	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
bufferOffset	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IndexOutOfBoundsException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
checkPosition	TokenNameIdentifier
(	TokenNameLPAREN
memoryOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
end	TokenNameIdentifier
=	TokenNameEQUAL
memoryOffset	TokenNameIdentifier
+	TokenNamePLUS
count	TokenNameIdentifier
;	TokenNameSEMICOLON
checkPosition	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
memoryOffset	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
buffer	TokenNameIdentifier
[	TokenNameLBRACKET
bufferOffset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
unsafe	TokenNameIdentifier
.	TokenNameDOT
getByte	TokenNameIdentifier
(	TokenNameLPAREN
peer	TokenNameIdentifier
+	TokenNamePLUS
memoryOffset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
checkPosition	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
peer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
:	TokenNameCOLON
"Memory was freed"	TokenNameStringLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
offset	TokenNameIdentifier
<	TokenNameLESS
size	TokenNameIdentifier
:	TokenNameCOLON
"Illegal offset: "	TokenNameStringLiteral
+	TokenNamePLUS
offset	TokenNameIdentifier
+	TokenNamePLUS
", size: "	TokenNameStringLiteral
+	TokenNamePLUS
size	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
free	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
peer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
unsafe	TokenNameIdentifier
.	TokenNameDOT
freeMemory	TokenNameIdentifier
(	TokenNameLPAREN
peer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
peer	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
size	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
o	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
==	TokenNameEQUAL_EQUAL
o	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
o	TokenNameIdentifier
instanceof	TokenNameinstanceof
Memory	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
Memory	TokenNameIdentifier
b	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Memory	TokenNameIdentifier
)	TokenNameRPAREN
o	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
peer	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
b	TokenNameIdentifier
.	TokenNameDOT
peer	TokenNameIdentifier
&&	TokenNameAND_AND
size	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
b	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
