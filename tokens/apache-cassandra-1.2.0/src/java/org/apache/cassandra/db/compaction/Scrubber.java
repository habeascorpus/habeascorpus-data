package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
compaction	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
ByteBuffer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
com	TokenNameIdentifier
.	TokenNameDOT
google	TokenNameIdentifier
.	TokenNameDOT
common	TokenNameIdentifier
.	TokenNameDOT
base	TokenNameIdentifier
.	TokenNameDOT
Throwables	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
config	TokenNameIdentifier
.	TokenNameDOT
DatabaseDescriptor	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
sstable	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
FileUtils	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
RandomAccessReader	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
.	TokenNameDOT
ByteBufferUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
.	TokenNameDOT
OutputHandler	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
Scrubber	TokenNameIdentifier
implements	TokenNameimplements
Closeable	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
final	TokenNamefinal
ColumnFamilyStore	TokenNameIdentifier
cfs	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
SSTableReader	TokenNameIdentifier
sstable	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
File	TokenNameIdentifier
destination	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
CompactionController	TokenNameIdentifier
controller	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
isCommutative	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
expectedBloomFilterSize	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
RandomAccessReader	TokenNameIdentifier
dataFile	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
RandomAccessReader	TokenNameIdentifier
indexFile	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
ScrubInfo	TokenNameIdentifier
scrubInfo	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
rowsRead	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
SSTableWriter	TokenNameIdentifier
writer	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
SSTableReader	TokenNameIdentifier
newSstable	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
SSTableReader	TokenNameIdentifier
newInOrderSstable	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
goodRows	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
badRows	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
emptyRows	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
OutputHandler	TokenNameIdentifier
outputHandler	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
Comparator	TokenNameIdentifier
<	TokenNameLESS
AbstractCompactedRow	TokenNameIdentifier
>	TokenNameGREATER
acrComparator	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Comparator	TokenNameIdentifier
<	TokenNameLESS
AbstractCompactedRow	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
AbstractCompactedRow	TokenNameIdentifier
r1	TokenNameIdentifier
,	TokenNameCOMMA
AbstractCompactedRow	TokenNameIdentifier
r2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
r1	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
r2	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
Set	TokenNameIdentifier
<	TokenNameLESS
AbstractCompactedRow	TokenNameIdentifier
>	TokenNameGREATER
outOfOrderRows	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
TreeSet	TokenNameIdentifier
<	TokenNameLESS
AbstractCompactedRow	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
acrComparator	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
Scrubber	TokenNameIdentifier
(	TokenNameLPAREN
ColumnFamilyStore	TokenNameIdentifier
cfs	TokenNameIdentifier
,	TokenNameCOMMA
SSTableReader	TokenNameIdentifier
sstable	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
cfs	TokenNameIdentifier
,	TokenNameCOMMA
sstable	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
OutputHandler	TokenNameIdentifier
.	TokenNameDOT
LogOutput	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Scrubber	TokenNameIdentifier
(	TokenNameLPAREN
ColumnFamilyStore	TokenNameIdentifier
cfs	TokenNameIdentifier
,	TokenNameCOMMA
SSTableReader	TokenNameIdentifier
sstable	TokenNameIdentifier
,	TokenNameCOMMA
OutputHandler	TokenNameIdentifier
outputHandler	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isOffline	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
cfs	TokenNameIdentifier
=	TokenNameEQUAL
cfs	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
sstable	TokenNameIdentifier
=	TokenNameEQUAL
sstable	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
outputHandler	TokenNameIdentifier
=	TokenNameEQUAL
outputHandler	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
destination	TokenNameIdentifier
=	TokenNameEQUAL
cfs	TokenNameIdentifier
.	TokenNameDOT
directories	TokenNameIdentifier
.	TokenNameDOT
getDirectoryForNewSSTables	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
.	TokenNameDOT
onDiskLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
destination	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"disk full"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
SSTableReader	TokenNameIdentifier
>	TokenNameGREATER
toScrub	TokenNameIdentifier
=	TokenNameEQUAL
Collections	TokenNameIdentifier
.	TokenNameDOT
singletonList	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
controller	TokenNameIdentifier
=	TokenNameEQUAL
isOffline	TokenNameIdentifier
?	TokenNameQUESTION
new	TokenNamenew
ScrubController	TokenNameIdentifier
(	TokenNameLPAREN
cfs	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
CompactionController	TokenNameIdentifier
(	TokenNameLPAREN
cfs	TokenNameIdentifier
,	TokenNameCOMMA
Collections	TokenNameIdentifier
.	TokenNameDOT
singletonList	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
CompactionManager	TokenNameIdentifier
.	TokenNameDOT
getDefaultGcBefore	TokenNameIdentifier
(	TokenNameLPAREN
cfs	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
isCommutative	TokenNameIdentifier
=	TokenNameEQUAL
cfs	TokenNameIdentifier
.	TokenNameDOT
metadata	TokenNameIdentifier
.	TokenNameDOT
getDefaultValidator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
isCommutative	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
expectedBloomFilterSize	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
DatabaseDescriptor	TokenNameIdentifier
.	TokenNameDOT
getIndexInterval	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
SSTableReader	TokenNameIdentifier
.	TokenNameDOT
getApproximateKeyCount	TokenNameIdentifier
(	TokenNameLPAREN
toScrub	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
dataFile	TokenNameIdentifier
=	TokenNameEQUAL
sstable	TokenNameIdentifier
.	TokenNameDOT
openDataReader	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
indexFile	TokenNameIdentifier
=	TokenNameEQUAL
RandomAccessReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
File	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
.	TokenNameDOT
descriptor	TokenNameIdentifier
.	TokenNameDOT
filenameFor	TokenNameIdentifier
(	TokenNameLPAREN
Component	TokenNameIdentifier
.	TokenNameDOT
PRIMARY_INDEX	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
scrubInfo	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ScrubInfo	TokenNameIdentifier
(	TokenNameLPAREN
dataFile	TokenNameIdentifier
,	TokenNameCOMMA
sstable	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
scrub	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
outputHandler	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
(	TokenNameLPAREN
"Scrubbing "	TokenNameStringLiteral
+	TokenNamePLUS
sstable	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
ByteBuffer	TokenNameIdentifier
nextIndexKey	TokenNameIdentifier
=	TokenNameEQUAL
ByteBufferUtil	TokenNameIdentifier
.	TokenNameDOT
readWithShortLength	TokenNameIdentifier
(	TokenNameLPAREN
indexFile	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
long	TokenNamelong
firstRowPositionFromIndex	TokenNameIdentifier
=	TokenNameEQUAL
RowIndexEntry	TokenNameIdentifier
.	TokenNameDOT
serializer	TokenNameIdentifier
.	TokenNameDOT
deserialize	TokenNameIdentifier
(	TokenNameLPAREN
indexFile	TokenNameIdentifier
,	TokenNameCOMMA
sstable	TokenNameIdentifier
.	TokenNameDOT
descriptor	TokenNameIdentifier
.	TokenNameDOT
version	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
position	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
firstRowPositionFromIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
:	TokenNameCOLON
firstRowPositionFromIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
writer	TokenNameIdentifier
=	TokenNameEQUAL
CompactionManager	TokenNameIdentifier
.	TokenNameDOT
maybeCreateWriter	TokenNameIdentifier
(	TokenNameLPAREN
cfs	TokenNameIdentifier
,	TokenNameCOMMA
destination	TokenNameIdentifier
,	TokenNameCOMMA
expectedBloomFilterSize	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
Collections	TokenNameIdentifier
.	TokenNameDOT
singletonList	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
AbstractCompactedRow	TokenNameIdentifier
prevRow	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
dataFile	TokenNameIdentifier
.	TokenNameDOT
isEOF	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
scrubInfo	TokenNameIdentifier
.	TokenNameDOT
isStopRequested	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
CompactionInterruptedException	TokenNameIdentifier
(	TokenNameLPAREN
scrubInfo	TokenNameIdentifier
.	TokenNameDOT
getCompactionInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
rowStart	TokenNameIdentifier
=	TokenNameEQUAL
dataFile	TokenNameIdentifier
.	TokenNameDOT
getFilePointer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputHandler	TokenNameIdentifier
.	TokenNameDOT
debug	TokenNameIdentifier
(	TokenNameLPAREN
"Reading row at "	TokenNameStringLiteral
+	TokenNamePLUS
rowStart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
DecoratedKey	TokenNameIdentifier
key	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
long	TokenNamelong
dataSize	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
key	TokenNameIdentifier
=	TokenNameEQUAL
SSTableReader	TokenNameIdentifier
.	TokenNameDOT
decodeKey	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
.	TokenNameDOT
partitioner	TokenNameIdentifier
,	TokenNameCOMMA
sstable	TokenNameIdentifier
.	TokenNameDOT
descriptor	TokenNameIdentifier
,	TokenNameCOMMA
ByteBufferUtil	TokenNameIdentifier
.	TokenNameDOT
readWithShortLength	TokenNameIdentifier
(	TokenNameLPAREN
dataFile	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataSize	TokenNameIdentifier
=	TokenNameEQUAL
sstable	TokenNameIdentifier
.	TokenNameDOT
descriptor	TokenNameIdentifier
.	TokenNameDOT
version	TokenNameIdentifier
.	TokenNameDOT
hasIntRowSize	TokenNameIdentifier
?	TokenNameQUESTION
dataFile	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
dataFile	TokenNameIdentifier
.	TokenNameDOT
readLong	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputHandler	TokenNameIdentifier
.	TokenNameDOT
debug	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"row %s is %s bytes"	TokenNameStringLiteral
,	TokenNameCOMMA
ByteBufferUtil	TokenNameIdentifier
.	TokenNameDOT
bytesToHex	TokenNameIdentifier
(	TokenNameLPAREN
key	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
dataSize	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
th	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throwIfFatal	TokenNameIdentifier
(	TokenNameLPAREN
th	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ByteBuffer	TokenNameIdentifier
currentIndexKey	TokenNameIdentifier
=	TokenNameEQUAL
nextIndexKey	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
nextRowPositionFromIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
nextIndexKey	TokenNameIdentifier
=	TokenNameEQUAL
indexFile	TokenNameIdentifier
.	TokenNameDOT
isEOF	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
ByteBufferUtil	TokenNameIdentifier
.	TokenNameDOT
readWithShortLength	TokenNameIdentifier
(	TokenNameLPAREN
indexFile	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
nextRowPositionFromIndex	TokenNameIdentifier
=	TokenNameEQUAL
indexFile	TokenNameIdentifier
.	TokenNameDOT
isEOF	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
dataFile	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
RowIndexEntry	TokenNameIdentifier
.	TokenNameDOT
serializer	TokenNameIdentifier
.	TokenNameDOT
deserialize	TokenNameIdentifier
(	TokenNameLPAREN
indexFile	TokenNameIdentifier
,	TokenNameCOMMA
sstable	TokenNameIdentifier
.	TokenNameDOT
descriptor	TokenNameIdentifier
.	TokenNameDOT
version	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
position	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
th	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputHandler	TokenNameIdentifier
.	TokenNameDOT
warn	TokenNameIdentifier
(	TokenNameLPAREN
"Error reading index file"	TokenNameStringLiteral
,	TokenNameCOMMA
th	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
nextIndexKey	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
nextRowPositionFromIndex	TokenNameIdentifier
=	TokenNameEQUAL
dataFile	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
long	TokenNamelong
dataStart	TokenNameIdentifier
=	TokenNameEQUAL
dataFile	TokenNameIdentifier
.	TokenNameDOT
getFilePointer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
dataStartFromIndex	TokenNameIdentifier
=	TokenNameEQUAL
currentIndexKey	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
rowStart	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
+	TokenNamePLUS
currentIndexKey	TokenNameIdentifier
.	TokenNameDOT
remaining	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
sstable	TokenNameIdentifier
.	TokenNameDOT
descriptor	TokenNameIdentifier
.	TokenNameDOT
version	TokenNameIdentifier
.	TokenNameDOT
hasIntRowSize	TokenNameIdentifier
?	TokenNameQUESTION
4	TokenNameIntegerLiteral
:	TokenNameCOLON
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
dataSizeFromIndex	TokenNameIdentifier
=	TokenNameEQUAL
nextRowPositionFromIndex	TokenNameIdentifier
-	TokenNameMINUS
dataStartFromIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
currentIndexKey	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
indexFile	TokenNameIdentifier
.	TokenNameDOT
isEOF	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentIndexKey	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
outputHandler	TokenNameIdentifier
.	TokenNameDOT
debug	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Index doublecheck: row %s is %s bytes"	TokenNameStringLiteral
,	TokenNameCOMMA
ByteBufferUtil	TokenNameIdentifier
.	TokenNameDOT
bytesToHex	TokenNameIdentifier
(	TokenNameLPAREN
currentIndexKey	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
dataSizeFromIndex	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
mark	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
key	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IOError	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"Unable to read row key from data file"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dataSize	TokenNameIdentifier
>	TokenNameGREATER
dataFile	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IOError	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"Impossible row size "	TokenNameStringLiteral
+	TokenNamePLUS
dataSize	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SSTableIdentityIterator	TokenNameIdentifier
row	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SSTableIdentityIterator	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
,	TokenNameCOMMA
dataFile	TokenNameIdentifier
,	TokenNameCOMMA
key	TokenNameIdentifier
,	TokenNameCOMMA
dataStart	TokenNameIdentifier
,	TokenNameCOMMA
dataSize	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
AbstractCompactedRow	TokenNameIdentifier
compactedRow	TokenNameIdentifier
=	TokenNameEQUAL
controller	TokenNameIdentifier
.	TokenNameDOT
getCompactedRow	TokenNameIdentifier
(	TokenNameLPAREN
row	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
compactedRow	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
emptyRows	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
prevRow	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
acrComparator	TokenNameIdentifier
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
prevRow	TokenNameIdentifier
,	TokenNameCOMMA
compactedRow	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
outOfOrderRows	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
compactedRow	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputHandler	TokenNameIdentifier
.	TokenNameDOT
warn	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Out of order row detected (%s found after %s)"	TokenNameStringLiteral
,	TokenNameCOMMA
compactedRow	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
,	TokenNameCOMMA
prevRow	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
compactedRow	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
prevRow	TokenNameIdentifier
=	TokenNameEQUAL
compactedRow	TokenNameIdentifier
;	TokenNameSEMICOLON
goodRows	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
key	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
currentIndexKey	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
dataStart	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
dataStartFromIndex	TokenNameIdentifier
)	TokenNameRPAREN
outputHandler	TokenNameIdentifier
.	TokenNameDOT
warn	TokenNameIdentifier
(	TokenNameLPAREN
"Index file contained a different key or row size; using key from data file"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
th	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throwIfFatal	TokenNameIdentifier
(	TokenNameLPAREN
th	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputHandler	TokenNameIdentifier
.	TokenNameDOT
warn	TokenNameIdentifier
(	TokenNameLPAREN
"Non-fatal error reading row (stacktrace follows)"	TokenNameStringLiteral
,	TokenNameCOMMA
th	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
resetAndTruncate	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentIndexKey	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
(	TokenNameLPAREN
key	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
!	TokenNameNOT
key	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
currentIndexKey	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
dataStart	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
dataStartFromIndex	TokenNameIdentifier
||	TokenNameOR_OR
dataSize	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
dataSizeFromIndex	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
outputHandler	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Retrying from row index; data is %s bytes starting at %s"	TokenNameStringLiteral
,	TokenNameCOMMA
dataSizeFromIndex	TokenNameIdentifier
,	TokenNameCOMMA
dataStartFromIndex	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
key	TokenNameIdentifier
=	TokenNameEQUAL
SSTableReader	TokenNameIdentifier
.	TokenNameDOT
decodeKey	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
.	TokenNameDOT
partitioner	TokenNameIdentifier
,	TokenNameCOMMA
sstable	TokenNameIdentifier
.	TokenNameDOT
descriptor	TokenNameIdentifier
,	TokenNameCOMMA
currentIndexKey	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
SSTableIdentityIterator	TokenNameIdentifier
row	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SSTableIdentityIterator	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
,	TokenNameCOMMA
dataFile	TokenNameIdentifier
,	TokenNameCOMMA
key	TokenNameIdentifier
,	TokenNameCOMMA
dataStartFromIndex	TokenNameIdentifier
,	TokenNameCOMMA
dataSizeFromIndex	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
AbstractCompactedRow	TokenNameIdentifier
compactedRow	TokenNameIdentifier
=	TokenNameEQUAL
controller	TokenNameIdentifier
.	TokenNameDOT
getCompactedRow	TokenNameIdentifier
(	TokenNameLPAREN
row	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
compactedRow	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
emptyRows	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
prevRow	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
acrComparator	TokenNameIdentifier
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
prevRow	TokenNameIdentifier
,	TokenNameCOMMA
compactedRow	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
outOfOrderRows	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
compactedRow	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputHandler	TokenNameIdentifier
.	TokenNameDOT
warn	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Out of order row detected (%s found after %s)"	TokenNameStringLiteral
,	TokenNameCOMMA
compactedRow	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
,	TokenNameCOMMA
prevRow	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
compactedRow	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
prevRow	TokenNameIdentifier
=	TokenNameEQUAL
compactedRow	TokenNameIdentifier
;	TokenNameSEMICOLON
goodRows	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
th2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throwIfFatal	TokenNameIdentifier
(	TokenNameLPAREN
th2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isCommutative	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IOError	TokenNameIdentifier
(	TokenNameLPAREN
th2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputHandler	TokenNameIdentifier
.	TokenNameDOT
warn	TokenNameIdentifier
(	TokenNameLPAREN
"Retry failed too. Skipping to next row (retry's stacktrace follows)"	TokenNameStringLiteral
,	TokenNameCOMMA
th2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
resetAndTruncate	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataFile	TokenNameIdentifier
.	TokenNameDOT
seek	TokenNameIdentifier
(	TokenNameLPAREN
nextRowPositionFromIndex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
badRows	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isCommutative	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IOError	TokenNameIdentifier
(	TokenNameLPAREN
th	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputHandler	TokenNameIdentifier
.	TokenNameDOT
warn	TokenNameIdentifier
(	TokenNameLPAREN
"Row at "	TokenNameStringLiteral
+	TokenNamePLUS
dataStart	TokenNameIdentifier
+	TokenNamePLUS
" is unreadable; skipping to next"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentIndexKey	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
dataFile	TokenNameIdentifier
.	TokenNameDOT
seek	TokenNameIdentifier
(	TokenNameLPAREN
nextRowPositionFromIndex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
badRows	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
rowsRead	TokenNameIdentifier
++	TokenNamePLUS_PLUS
%	TokenNameREMAINDER
1000	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
controller	TokenNameIdentifier
.	TokenNameDOT
mayThrottle	TokenNameIdentifier
(	TokenNameLPAREN
dataFile	TokenNameIdentifier
.	TokenNameDOT
getFilePointer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
writer	TokenNameIdentifier
.	TokenNameDOT
getFilePointer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
newSstable	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
closeAndOpenReader	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
.	TokenNameDOT
maxDataAge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
writer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
writer	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
Throwables	TokenNameIdentifier
.	TokenNameDOT
propagate	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
controller	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
outOfOrderRows	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
SSTableWriter	TokenNameIdentifier
inOrderWriter	TokenNameIdentifier
=	TokenNameEQUAL
CompactionManager	TokenNameIdentifier
.	TokenNameDOT
maybeCreateWriter	TokenNameIdentifier
(	TokenNameLPAREN
cfs	TokenNameIdentifier
,	TokenNameCOMMA
destination	TokenNameIdentifier
,	TokenNameCOMMA
expectedBloomFilterSize	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
Collections	TokenNameIdentifier
.	TokenNameDOT
singletonList	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
AbstractCompactedRow	TokenNameIdentifier
row	TokenNameIdentifier
:	TokenNameCOLON
outOfOrderRows	TokenNameIdentifier
)	TokenNameRPAREN
inOrderWriter	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
row	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
newInOrderSstable	TokenNameIdentifier
=	TokenNameEQUAL
inOrderWriter	TokenNameIdentifier
.	TokenNameDOT
closeAndOpenReader	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
.	TokenNameDOT
maxDataAge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputHandler	TokenNameIdentifier
.	TokenNameDOT
warn	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%d out of order rows found while scrubbing %s; Those have been written (in order) to a new sstable (%s)"	TokenNameStringLiteral
,	TokenNameCOMMA
outOfOrderRows	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
sstable	TokenNameIdentifier
,	TokenNameCOMMA
newInOrderSstable	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
newSstable	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
badRows	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
outputHandler	TokenNameIdentifier
.	TokenNameDOT
warn	TokenNameIdentifier
(	TokenNameLPAREN
"No valid rows found while scrubbing "	TokenNameStringLiteral
+	TokenNamePLUS
sstable	TokenNameIdentifier
+	TokenNamePLUS
"; it is marked for deletion now. If you want to attempt manual recovery, you can find a copy in the pre-scrub snapshot"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
outputHandler	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
(	TokenNameLPAREN
"Scrub of "	TokenNameStringLiteral
+	TokenNamePLUS
sstable	TokenNameIdentifier
+	TokenNamePLUS
" complete; looks like all "	TokenNameStringLiteral
+	TokenNamePLUS
emptyRows	TokenNameIdentifier
+	TokenNamePLUS
" rows were tombstoned"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
outputHandler	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
(	TokenNameLPAREN
"Scrub of "	TokenNameStringLiteral
+	TokenNamePLUS
sstable	TokenNameIdentifier
+	TokenNamePLUS
" complete: "	TokenNameStringLiteral
+	TokenNamePLUS
goodRows	TokenNameIdentifier
+	TokenNamePLUS
" rows in new sstable and "	TokenNameStringLiteral
+	TokenNamePLUS
emptyRows	TokenNameIdentifier
+	TokenNamePLUS
" empty (tombstoned) rows dropped"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
badRows	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
outputHandler	TokenNameIdentifier
.	TokenNameDOT
warn	TokenNameIdentifier
(	TokenNameLPAREN
"Unable to recover "	TokenNameStringLiteral
+	TokenNamePLUS
badRows	TokenNameIdentifier
+	TokenNamePLUS
" rows that were skipped.  You can attempt manual recovery from the pre-scrub snapshot.  You can also run nodetool repair to transfer the data from a healthy replica, if any"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
SSTableReader	TokenNameIdentifier
getNewSSTable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
newSstable	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
SSTableReader	TokenNameIdentifier
getNewInOrderSSTable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
newInOrderSstable	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
throwIfFatal	TokenNameIdentifier
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
th	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
th	TokenNameIdentifier
instanceof	TokenNameinstanceof
Error	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
th	TokenNameIdentifier
instanceof	TokenNameinstanceof
AssertionError	TokenNameIdentifier
||	TokenNameOR_OR
th	TokenNameIdentifier
instanceof	TokenNameinstanceof
IOError	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
(	TokenNameLPAREN
Error	TokenNameIdentifier
)	TokenNameRPAREN
th	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
FileUtils	TokenNameIdentifier
.	TokenNameDOT
closeQuietly	TokenNameIdentifier
(	TokenNameLPAREN
dataFile	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
FileUtils	TokenNameIdentifier
.	TokenNameDOT
closeQuietly	TokenNameIdentifier
(	TokenNameLPAREN
indexFile	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
CompactionInfo	TokenNameIdentifier
.	TokenNameDOT
Holder	TokenNameIdentifier
getScrubInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
scrubInfo	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
ScrubInfo	TokenNameIdentifier
extends	TokenNameextends
CompactionInfo	TokenNameIdentifier
.	TokenNameDOT
Holder	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
RandomAccessReader	TokenNameIdentifier
dataFile	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
SSTableReader	TokenNameIdentifier
sstable	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
ScrubInfo	TokenNameIdentifier
(	TokenNameLPAREN
RandomAccessReader	TokenNameIdentifier
dataFile	TokenNameIdentifier
,	TokenNameCOMMA
SSTableReader	TokenNameIdentifier
sstable	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
dataFile	TokenNameIdentifier
=	TokenNameEQUAL
dataFile	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
sstable	TokenNameIdentifier
=	TokenNameEQUAL
sstable	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
CompactionInfo	TokenNameIdentifier
getCompactionInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
CompactionInfo	TokenNameIdentifier
(	TokenNameLPAREN
sstable	TokenNameIdentifier
.	TokenNameDOT
metadata	TokenNameIdentifier
,	TokenNameCOMMA
OperationType	TokenNameIdentifier
.	TokenNameDOT
SCRUB	TokenNameIdentifier
,	TokenNameCOMMA
dataFile	TokenNameIdentifier
.	TokenNameDOT
getFilePointer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
dataFile	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
ScrubController	TokenNameIdentifier
extends	TokenNameextends
CompactionController	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
ScrubController	TokenNameIdentifier
(	TokenNameLPAREN
ColumnFamilyStore	TokenNameIdentifier
cfs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
cfs	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
shouldPurge	TokenNameIdentifier
(	TokenNameLPAREN
DecoratedKey	TokenNameIdentifier
key	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
