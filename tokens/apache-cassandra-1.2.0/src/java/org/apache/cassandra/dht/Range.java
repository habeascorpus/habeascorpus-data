package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
dht	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
Serializable	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
commons	TokenNameIdentifier
.	TokenNameDOT
lang	TokenNameIdentifier
.	TokenNameDOT
ObjectUtils	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
RowPosition	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
service	TokenNameIdentifier
.	TokenNameDOT
StorageService	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
.	TokenNameDOT
Pair	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
extends	TokenNameextends
RingPosition	TokenNameIdentifier
>	TokenNameGREATER
extends	TokenNameextends
AbstractBounds	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
implements	TokenNameimplements
Comparable	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
,	TokenNameCOMMA
Serializable	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
serialVersionUID	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
Range	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
left	TokenNameIdentifier
,	TokenNameCOMMA
T	TokenNameIdentifier
right	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
,	TokenNameCOMMA
StorageService	TokenNameIdentifier
.	TokenNameDOT
getPartitioner	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Range	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
left	TokenNameIdentifier
,	TokenNameCOMMA
T	TokenNameIdentifier
right	TokenNameIdentifier
,	TokenNameCOMMA
IPartitioner	TokenNameIdentifier
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
extends	TokenNameextends
RingPosition	TokenNameIdentifier
>	TokenNameGREATER
boolean	TokenNameboolean
contains	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
left	TokenNameIdentifier
,	TokenNameCOMMA
T	TokenNameIdentifier
right	TokenNameIdentifier
,	TokenNameCOMMA
T	TokenNameIdentifier
point	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
point	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
right	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
point	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
point	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
right	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
point	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
contains	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
that	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
thiswraps	TokenNameIdentifier
=	TokenNameEQUAL
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
thatwraps	TokenNameIdentifier
=	TokenNameEQUAL
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
that	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
thiswraps	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
thatwraps	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
left	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
that	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
right	TokenNameIdentifier
)	TokenNameRPAREN
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
thiswraps	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
left	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
that	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
right	TokenNameIdentifier
)	TokenNameRPAREN
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
contains	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
point	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
contains	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
,	TokenNameCOMMA
point	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
intersects	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
that	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
intersectionWith	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
intersects	TokenNameIdentifier
(	TokenNameLPAREN
AbstractBounds	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
that	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
that	TokenNameIdentifier
instanceof	TokenNameinstanceof
Range	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
intersects	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
Range	TokenNameIdentifier
)	TokenNameRPAREN
that	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
that	TokenNameIdentifier
instanceof	TokenNameinstanceof
Bounds	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
intersects	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
Bounds	TokenNameIdentifier
)	TokenNameRPAREN
that	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
UnsupportedOperationException	TokenNameIdentifier
(	TokenNameLPAREN
"Intersection is only supported for Bounds and Range objects; found "	TokenNameStringLiteral
+	TokenNamePLUS
that	TokenNameIdentifier
.	TokenNameDOT
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
intersects	TokenNameIdentifier
(	TokenNameLPAREN
Bounds	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
that	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
intersects	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
that	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
contains	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
extends	TokenNameextends
RingPosition	TokenNameIdentifier
>	TokenNameGREATER
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
rangeSet	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
...	TokenNameELLIPSIS
ranges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
Collections	TokenNameIdentifier
.	TokenNameDOT
unmodifiableSet	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
Arrays	TokenNameIdentifier
.	TokenNameDOT
asList	TokenNameIdentifier
(	TokenNameLPAREN
ranges	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
extends	TokenNameextends
RingPosition	TokenNameIdentifier
>	TokenNameGREATER
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
rangeSet	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
range	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
Collections	TokenNameIdentifier
.	TokenNameDOT
singleton	TokenNameIdentifier
(	TokenNameLPAREN
range	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
intersectionWith	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
that	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
rangeSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
rangeSet	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
thiswraps	TokenNameIdentifier
=	TokenNameEQUAL
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
thatwraps	TokenNameIdentifier
=	TokenNameEQUAL
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
that	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
thiswraps	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
thatwraps	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
left	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
that	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
right	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
Collections	TokenNameIdentifier
.	TokenNameDOT
emptySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
rangeSet	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
(	TokenNameLPAREN
T	TokenNameIdentifier
)	TokenNameRPAREN
ObjectUtils	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
that	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
T	TokenNameIdentifier
)	TokenNameRPAREN
ObjectUtils	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
right	TokenNameIdentifier
,	TokenNameCOMMA
that	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
thiswraps	TokenNameIdentifier
&&	TokenNameAND_AND
thatwraps	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
!	TokenNameNOT
this	TokenNamethis
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
intersectionBothWrapping	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
,	TokenNameCOMMA
that	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
intersectionBothWrapping	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
thiswraps	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
thatwraps	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
intersectionOneWrapping	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
,	TokenNameCOMMA
that	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
(	TokenNameLPAREN
!	TokenNameNOT
thiswraps	TokenNameIdentifier
&&	TokenNameAND_AND
thatwraps	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
intersectionOneWrapping	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
extends	TokenNameextends
RingPosition	TokenNameIdentifier
>	TokenNameGREATER
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
intersectionBothWrapping	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
first	TokenNameIdentifier
,	TokenNameCOMMA
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
that	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
intersection	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
first	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
intersection	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
first	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
that	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
,	TokenNameCOMMA
first	TokenNameIdentifier
.	TokenNameDOT
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
intersection	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
first	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
,	TokenNameCOMMA
first	TokenNameIdentifier
.	TokenNameDOT
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Collections	TokenNameIdentifier
.	TokenNameDOT
unmodifiableSet	TokenNameIdentifier
(	TokenNameLPAREN
intersection	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
extends	TokenNameextends
RingPosition	TokenNameIdentifier
>	TokenNameGREATER
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
intersectionOneWrapping	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
wrapping	TokenNameIdentifier
,	TokenNameCOMMA
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
intersection	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
wrapping	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
intersection	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
wrapping	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
,	TokenNameCOMMA
wrapping	TokenNameIdentifier
.	TokenNameDOT
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
wrapping	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
wrapping	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
intersection	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
wrapping	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
,	TokenNameCOMMA
wrapping	TokenNameIdentifier
.	TokenNameDOT
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Collections	TokenNameIdentifier
.	TokenNameDOT
unmodifiableSet	TokenNameIdentifier
(	TokenNameLPAREN
intersection	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Pair	TokenNameIdentifier
<	TokenNameLESS
AbstractBounds	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
,	TokenNameCOMMA
AbstractBounds	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
split	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
position	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
contains	TokenNameIdentifier
(	TokenNameLPAREN
position	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
left	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
position	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
position	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
position	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
right	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
AbstractBounds	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
lb	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
position	TokenNameIdentifier
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
AbstractBounds	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
rb	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
position	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Pair	TokenNameIdentifier
.	TokenNameDOT
create	TokenNameIdentifier
(	TokenNameLPAREN
lb	TokenNameIdentifier
,	TokenNameCOMMA
rb	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
List	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
unwrap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
T	TokenNameIdentifier
minValue	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
T	TokenNameIdentifier
)	TokenNameRPAREN
partitioner	TokenNameIdentifier
.	TokenNameDOT
minValue	TokenNameIdentifier
(	TokenNameLPAREN
right	TokenNameIdentifier
.	TokenNameDOT
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
right	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
minValue	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
Arrays	TokenNameIdentifier
.	TokenNameDOT
asList	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
unwrapped	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
unwrapped	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
minValue	TokenNameIdentifier
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
unwrapped	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
minValue	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
unwrapped	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
extends	TokenNameextends
RingPosition	TokenNameIdentifier
>	TokenNameGREATER
boolean	TokenNameboolean
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
left	TokenNameIdentifier
,	TokenNameCOMMA
T	TokenNameIdentifier
right	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
left	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
right	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
rhs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
rhs	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
rhs	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
right	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
rhs	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
ArrayList	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
subtractContained	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
contained	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ArrayList	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
difference	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
left	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
contained	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
difference	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
contained	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
right	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
contained	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
difference	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
contained	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
difference	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
subtract	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
rhs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
rhs	TokenNameIdentifier
.	TokenNameDOT
differenceToFetch	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
differenceToFetch	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
rhs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
result	TokenNameIdentifier
;	TokenNameSEMICOLON
Set	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
intersectionSet	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
intersectionWith	TokenNameIdentifier
(	TokenNameLPAREN
rhs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
intersectionSet	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
rhs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
Range	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
intersections	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Range	TokenNameIdentifier
[	TokenNameLBRACKET
intersectionSet	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
intersectionSet	TokenNameIdentifier
.	TokenNameDOT
toArray	TokenNameIdentifier
(	TokenNameLPAREN
intersections	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
intersections	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
rhs	TokenNameIdentifier
.	TokenNameDOT
subtractContained	TokenNameIdentifier
(	TokenNameLPAREN
intersections	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
first	TokenNameIdentifier
=	TokenNameEQUAL
intersections	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
second	TokenNameIdentifier
=	TokenNameEQUAL
intersections	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
temp	TokenNameIdentifier
=	TokenNameEQUAL
rhs	TokenNameIdentifier
.	TokenNameDOT
subtractContained	TokenNameIdentifier
(	TokenNameLPAREN
first	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
single	TokenNameIdentifier
=	TokenNameEQUAL
temp	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
single	TokenNameIdentifier
.	TokenNameDOT
subtractContained	TokenNameIdentifier
(	TokenNameLPAREN
second	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
extends	TokenNameextends
RingPosition	TokenNameIdentifier
>	TokenNameGREATER
boolean	TokenNameboolean
isInRanges	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
token	TokenNameIdentifier
,	TokenNameCOMMA
Iterable	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
ranges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
ranges	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
range	TokenNameIdentifier
:	TokenNameCOLON
ranges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
range	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
token	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
o	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
o	TokenNameIdentifier
instanceof	TokenNameinstanceof
Range	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
rhs	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
)	TokenNameRPAREN
o	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
left	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
rhs	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
right	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
rhs	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"("	TokenNameStringLiteral
+	TokenNamePLUS
left	TokenNameIdentifier
+	TokenNamePLUS
","	TokenNameStringLiteral
+	TokenNamePLUS
right	TokenNameIdentifier
+	TokenNamePLUS
"]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
String	TokenNameIdentifier
getOpeningString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"("	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
String	TokenNameIdentifier
getClosingString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
List	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
asList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
ret	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
right	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
isWrapAround	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
extends	TokenNameextends
RingPosition	TokenNameIdentifier
>	TokenNameGREATER
List	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
normalize	TokenNameIdentifier
(	TokenNameLPAREN
Collection	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
ranges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
output	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
ranges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
range	TokenNameIdentifier
:	TokenNameCOLON
ranges	TokenNameIdentifier
)	TokenNameRPAREN
output	TokenNameIdentifier
.	TokenNameDOT
addAll	TokenNameIdentifier
(	TokenNameLPAREN
range	TokenNameIdentifier
.	TokenNameDOT
unwrap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Collections	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
Comparator	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
b1	TokenNameIdentifier
,	TokenNameCOMMA
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
b2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
b1	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
b2	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
deoverlap	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
extends	TokenNameextends
RingPosition	TokenNameIdentifier
>	TokenNameGREATER
List	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
deoverlap	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
ranges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ranges	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
ranges	TokenNameIdentifier
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
output	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Iterator	TokenNameIdentifier
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
iter	TokenNameIdentifier
=	TokenNameEQUAL
ranges	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
current	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
T	TokenNameIdentifier
min	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
T	TokenNameIdentifier
)	TokenNameRPAREN
current	TokenNameIdentifier
.	TokenNameDOT
partitioner	TokenNameIdentifier
.	TokenNameDOT
minValue	TokenNameIdentifier
(	TokenNameLPAREN
current	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
min	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
min	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
Collections	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
singletonList	TokenNameIdentifier
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
current	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
min	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
output	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
next	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
next	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
current	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
next	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
min	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
current	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
next	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
current	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
current	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
,	TokenNameCOMMA
next	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
output	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
current	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
output	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
output	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
Range	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
makeRowRange	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
left	TokenNameIdentifier
,	TokenNameCOMMA
Token	TokenNameIdentifier
right	TokenNameIdentifier
,	TokenNameCOMMA
IPartitioner	TokenNameIdentifier
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
left	TokenNameIdentifier
.	TokenNameDOT
maxKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
right	TokenNameIdentifier
.	TokenNameDOT
maxKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
AbstractBounds	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
toRowBounds	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
left	TokenNameIdentifier
instanceof	TokenNameinstanceof
Token	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
makeRowRange	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
Token	TokenNameIdentifier
)	TokenNameRPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
Token	TokenNameIdentifier
)	TokenNameRPAREN
right	TokenNameIdentifier
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
)	TokenNameRPAREN
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
AbstractBounds	TokenNameIdentifier
<	TokenNameLESS
Token	TokenNameIdentifier
>	TokenNameGREATER
toTokenBounds	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
left	TokenNameIdentifier
instanceof	TokenNameinstanceof
RowPosition	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
Token	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
RowPosition	TokenNameIdentifier
)	TokenNameRPAREN
left	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
(	TokenNameLPAREN
RowPosition	TokenNameIdentifier
)	TokenNameRPAREN
right	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
partitioner	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
(	TokenNameLPAREN
Range	TokenNameIdentifier
<	TokenNameLESS
Token	TokenNameIdentifier
>	TokenNameGREATER
)	TokenNameRPAREN
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
