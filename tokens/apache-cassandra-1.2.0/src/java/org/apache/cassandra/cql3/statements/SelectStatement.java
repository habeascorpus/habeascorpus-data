package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
cql3	TokenNameIdentifier
.	TokenNameDOT
statements	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
ByteBuffer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
concurrent	TokenNameIdentifier
.	TokenNameDOT
ExecutionException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
com	TokenNameIdentifier
.	TokenNameDOT
google	TokenNameIdentifier
.	TokenNameDOT
common	TokenNameIdentifier
.	TokenNameDOT
collect	TokenNameIdentifier
.	TokenNameDOT
AbstractIterator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
slf4j	TokenNameIdentifier
.	TokenNameDOT
Logger	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
slf4j	TokenNameIdentifier
.	TokenNameDOT
LoggerFactory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
auth	TokenNameIdentifier
.	TokenNameDOT
Permission	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
cql3	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
transport	TokenNameIdentifier
.	TokenNameDOT
messages	TokenNameIdentifier
.	TokenNameDOT
ResultMessage	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
config	TokenNameIdentifier
.	TokenNameDOT
CFMetaData	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
config	TokenNameIdentifier
.	TokenNameDOT
ColumnDefinition	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
exceptions	TokenNameIdentifier
.	TokenNameDOT
ConfigurationException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
context	TokenNameIdentifier
.	TokenNameDOT
CounterContext	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
filter	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
SecondaryIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
SecondaryIndexManager	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
marshal	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
dht	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
exceptions	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
service	TokenNameIdentifier
.	TokenNameDOT
ClientState	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
service	TokenNameIdentifier
.	TokenNameDOT
QueryState	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
service	TokenNameIdentifier
.	TokenNameDOT
RangeSliceVerbHandler	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
service	TokenNameIdentifier
.	TokenNameDOT
StorageProxy	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
service	TokenNameIdentifier
.	TokenNameDOT
StorageService	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
ConsistencyLevel	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
thrift	TokenNameIdentifier
.	TokenNameDOT
IndexExpression	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
thrift	TokenNameIdentifier
.	TokenNameDOT
IndexOperator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
thrift	TokenNameIdentifier
.	TokenNameDOT
ThriftValidation	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
.	TokenNameDOT
ByteBufferUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
.	TokenNameDOT
FBUtilities	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
.	TokenNameDOT
Pair	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
SelectStatement	TokenNameIdentifier
implements	TokenNameimplements
CQLStatement	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
Logger	TokenNameIdentifier
logger	TokenNameIdentifier
=	TokenNameEQUAL
LoggerFactory	TokenNameIdentifier
.	TokenNameDOT
getLogger	TokenNameIdentifier
(	TokenNameLPAREN
SelectStatement	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
boundTerms	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
CFDefinition	TokenNameIdentifier
cfDef	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
Parameters	TokenNameIdentifier
parameters	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
selectedNames	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
Restriction	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
keyRestrictions	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
Restriction	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
columnRestrictions	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
Map	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Restriction	TokenNameIdentifier
>	TokenNameGREATER
metadataRestrictions	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Restriction	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
Restriction	TokenNameIdentifier
sliceRestriction	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
isReversed	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
onToken	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
isKeyRange	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
keyIsInRelation	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
enum	TokenNameenum
Bound	TokenNameIdentifier
{	TokenNameLBRACE
START	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
END	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
int	TokenNameint
idx	TokenNameIdentifier
;	TokenNameSEMICOLON
Bound	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
idx	TokenNameIdentifier
=	TokenNameEQUAL
idx	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
Bound	TokenNameIdentifier
reverse	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
b	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
START	TokenNameIdentifier
?	TokenNameQUESTION
END	TokenNameIdentifier
:	TokenNameCOLON
START	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
public	TokenNamepublic
SelectStatement	TokenNameIdentifier
(	TokenNameLPAREN
CFDefinition	TokenNameIdentifier
cfDef	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
boundTerms	TokenNameIdentifier
,	TokenNameCOMMA
Parameters	TokenNameIdentifier
parameters	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
cfDef	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
boundTerms	TokenNameIdentifier
=	TokenNameEQUAL
boundTerms	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
keyRestrictions	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Restriction	TokenNameIdentifier
[	TokenNameLBRACKET
cfDef	TokenNameIdentifier
.	TokenNameDOT
keys	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
columnRestrictions	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Restriction	TokenNameIdentifier
[	TokenNameLBRACKET
cfDef	TokenNameIdentifier
.	TokenNameDOT
columns	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
parameters	TokenNameIdentifier
=	TokenNameEQUAL
parameters	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getBoundsTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
boundTerms	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
checkAccess	TokenNameIdentifier
(	TokenNameLPAREN
ClientState	TokenNameIdentifier
state	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
,	TokenNameCOMMA
UnauthorizedException	TokenNameIdentifier
{	TokenNameLBRACE
state	TokenNameIdentifier
.	TokenNameDOT
hasColumnFamilyAccess	TokenNameIdentifier
(	TokenNameLPAREN
keyspace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
columnFamily	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
Permission	TokenNameIdentifier
.	TokenNameDOT
SELECT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
validate	TokenNameIdentifier
(	TokenNameLPAREN
ClientState	TokenNameIdentifier
state	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
ResultMessage	TokenNameIdentifier
.	TokenNameDOT
Rows	TokenNameIdentifier
execute	TokenNameIdentifier
(	TokenNameLPAREN
ConsistencyLevel	TokenNameIdentifier
cl	TokenNameIdentifier
,	TokenNameCOMMA
QueryState	TokenNameIdentifier
state	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
RequestExecutionException	TokenNameIdentifier
,	TokenNameCOMMA
RequestValidationException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cl	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Invalid empty consistency level"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cl	TokenNameIdentifier
.	TokenNameDOT
validateForRead	TokenNameIdentifier
(	TokenNameLPAREN
keyspace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
Row	TokenNameIdentifier
>	TokenNameGREATER
rows	TokenNameIdentifier
=	TokenNameEQUAL
isKeyRange	TokenNameIdentifier
?	TokenNameQUESTION
StorageProxy	TokenNameIdentifier
.	TokenNameDOT
getRangeSlice	TokenNameIdentifier
(	TokenNameLPAREN
getRangeCommand	TokenNameIdentifier
(	TokenNameLPAREN
variables	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
cl	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
StorageProxy	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
getSliceCommands	TokenNameIdentifier
(	TokenNameLPAREN
variables	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
cl	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
processResults	TokenNameIdentifier
(	TokenNameLPAREN
rows	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
ResultMessage	TokenNameIdentifier
.	TokenNameDOT
Rows	TokenNameIdentifier
processResults	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Row	TokenNameIdentifier
>	TokenNameGREATER
rows	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
RequestValidationException	TokenNameIdentifier
{	TokenNameLBRACE
ResultSet	TokenNameIdentifier
rset	TokenNameIdentifier
=	TokenNameEQUAL
process	TokenNameIdentifier
(	TokenNameLPAREN
rows	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
rset	TokenNameIdentifier
=	TokenNameEQUAL
parameters	TokenNameIdentifier
.	TokenNameDOT
isCount	TokenNameIdentifier
?	TokenNameQUESTION
rset	TokenNameIdentifier
.	TokenNameDOT
makeCountResult	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
rset	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
new	TokenNamenew
ResultMessage	TokenNameIdentifier
.	TokenNameDOT
Rows	TokenNameIdentifier
(	TokenNameLPAREN
rset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
List	TokenNameIdentifier
<	TokenNameLESS
Row	TokenNameIdentifier
>	TokenNameGREATER
readLocally	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
keyspace	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
ReadCommand	TokenNameIdentifier
>	TokenNameGREATER
cmds	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
Table	TokenNameIdentifier
table	TokenNameIdentifier
=	TokenNameEQUAL
Table	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
keyspace	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
Row	TokenNameIdentifier
>	TokenNameGREATER
rows	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
(	TokenNameLPAREN
cmds	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
ReadCommand	TokenNameIdentifier
cmd	TokenNameIdentifier
:	TokenNameCOLON
cmds	TokenNameIdentifier
)	TokenNameRPAREN
rows	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
cmd	TokenNameIdentifier
.	TokenNameDOT
getRow	TokenNameIdentifier
(	TokenNameLPAREN
table	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
rows	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
ResultMessage	TokenNameIdentifier
.	TokenNameDOT
Rows	TokenNameIdentifier
executeInternal	TokenNameIdentifier
(	TokenNameLPAREN
QueryState	TokenNameIdentifier
state	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
RequestExecutionException	TokenNameIdentifier
,	TokenNameCOMMA
RequestValidationException	TokenNameIdentifier
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
Row	TokenNameIdentifier
>	TokenNameGREATER
rows	TokenNameIdentifier
=	TokenNameEQUAL
isKeyRange	TokenNameIdentifier
?	TokenNameQUESTION
RangeSliceVerbHandler	TokenNameIdentifier
.	TokenNameDOT
executeLocally	TokenNameIdentifier
(	TokenNameLPAREN
getRangeCommand	TokenNameIdentifier
(	TokenNameLPAREN
Collections	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
emptyList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
readLocally	TokenNameIdentifier
(	TokenNameLPAREN
keyspace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
getSliceCommands	TokenNameIdentifier
(	TokenNameLPAREN
Collections	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
emptyList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
processResults	TokenNameIdentifier
(	TokenNameLPAREN
rows	TokenNameIdentifier
,	TokenNameCOMMA
Collections	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
emptyList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ExecutionException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InterruptedException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
ResultSet	TokenNameIdentifier
process	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Row	TokenNameIdentifier
>	TokenNameGREATER
rows	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
!	TokenNameNOT
parameters	TokenNameIdentifier
.	TokenNameDOT
isCount	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
process	TokenNameIdentifier
(	TokenNameLPAREN
rows	TokenNameIdentifier
,	TokenNameCOMMA
Collections	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
emptyList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
keyspace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
cfDef	TokenNameIdentifier
.	TokenNameDOT
cfm	TokenNameIdentifier
.	TokenNameDOT
ksName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
columnFamily	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
cfDef	TokenNameIdentifier
.	TokenNameDOT
cfm	TokenNameIdentifier
.	TokenNameDOT
cfName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
List	TokenNameIdentifier
<	TokenNameLESS
ReadCommand	TokenNameIdentifier
>	TokenNameGREATER
getSliceCommands	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
RequestValidationException	TokenNameIdentifier
{	TokenNameLBRACE
QueryPath	TokenNameIdentifier
queryPath	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
QueryPath	TokenNameIdentifier
(	TokenNameLPAREN
columnFamily	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Collection	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
keys	TokenNameIdentifier
=	TokenNameEQUAL
getKeys	TokenNameIdentifier
(	TokenNameLPAREN
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
ReadCommand	TokenNameIdentifier
>	TokenNameGREATER
commands	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
ReadCommand	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
keys	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isColumnRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
ByteBuffer	TokenNameIdentifier
key	TokenNameIdentifier
:	TokenNameCOLON
keys	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
QueryProcessor	TokenNameIdentifier
.	TokenNameDOT
validateKey	TokenNameIdentifier
(	TokenNameLPAREN
key	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
commands	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
SliceFromReadCommand	TokenNameIdentifier
(	TokenNameLPAREN
keyspace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
key	TokenNameIdentifier
,	TokenNameCOMMA
queryPath	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
SliceQueryFilter	TokenNameIdentifier
)	TokenNameRPAREN
makeFilter	TokenNameIdentifier
(	TokenNameLPAREN
variables	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
IDiskAtomFilter	TokenNameIdentifier
filter	TokenNameIdentifier
=	TokenNameEQUAL
makeFilter	TokenNameIdentifier
(	TokenNameLPAREN
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
ByteBuffer	TokenNameIdentifier
key	TokenNameIdentifier
:	TokenNameCOLON
keys	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
QueryProcessor	TokenNameIdentifier
.	TokenNameDOT
validateKey	TokenNameIdentifier
(	TokenNameLPAREN
key	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
commands	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
SliceByNamesReadCommand	TokenNameIdentifier
(	TokenNameLPAREN
keyspace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
key	TokenNameIdentifier
,	TokenNameCOMMA
queryPath	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
NamesQueryFilter	TokenNameIdentifier
)	TokenNameRPAREN
filter	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
commands	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
RangeSliceCommand	TokenNameIdentifier
getRangeCommand	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
RequestValidationException	TokenNameIdentifier
{	TokenNameLBRACE
IDiskAtomFilter	TokenNameIdentifier
filter	TokenNameIdentifier
=	TokenNameEQUAL
makeFilter	TokenNameIdentifier
(	TokenNameLPAREN
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
IndexExpression	TokenNameIdentifier
>	TokenNameGREATER
expressions	TokenNameIdentifier
=	TokenNameEQUAL
getIndexExpressions	TokenNameIdentifier
(	TokenNameLPAREN
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
new	TokenNamenew
RangeSliceCommand	TokenNameIdentifier
(	TokenNameLPAREN
keyspace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
columnFamily	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
filter	TokenNameIdentifier
,	TokenNameCOMMA
getKeyBounds	TokenNameIdentifier
(	TokenNameLPAREN
variables	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
expressions	TokenNameIdentifier
,	TokenNameCOMMA
getLimit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
AbstractBounds	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
getKeyBounds	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
IPartitioner	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>	TokenNameGREATER
p	TokenNameIdentifier
=	TokenNameEQUAL
StorageService	TokenNameIdentifier
.	TokenNameDOT
getPartitioner	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
AbstractBounds	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
bounds	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
onToken	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Token	TokenNameIdentifier
startToken	TokenNameIdentifier
=	TokenNameEQUAL
getTokenBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
,	TokenNameCOMMA
p	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
endToken	TokenNameIdentifier
=	TokenNameEQUAL
getTokenBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
,	TokenNameCOMMA
p	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
RowPosition	TokenNameIdentifier
start	TokenNameIdentifier
=	TokenNameEQUAL
includeKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
startToken	TokenNameIdentifier
.	TokenNameDOT
minKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
startToken	TokenNameIdentifier
.	TokenNameDOT
maxKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
RowPosition	TokenNameIdentifier
end	TokenNameIdentifier
=	TokenNameEQUAL
includeKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
endToken	TokenNameIdentifier
.	TokenNameDOT
maxKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
endToken	TokenNameIdentifier
.	TokenNameDOT
minKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bounds	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ByteBuffer	TokenNameIdentifier
startKeyBytes	TokenNameIdentifier
=	TokenNameEQUAL
getKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ByteBuffer	TokenNameIdentifier
finishKeyBytes	TokenNameIdentifier
=	TokenNameEQUAL
getKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
RowPosition	TokenNameIdentifier
startKey	TokenNameIdentifier
=	TokenNameEQUAL
RowPosition	TokenNameIdentifier
.	TokenNameDOT
forKey	TokenNameIdentifier
(	TokenNameLPAREN
startKeyBytes	TokenNameIdentifier
,	TokenNameCOMMA
p	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
RowPosition	TokenNameIdentifier
finishKey	TokenNameIdentifier
=	TokenNameEQUAL
RowPosition	TokenNameIdentifier
.	TokenNameDOT
forKey	TokenNameIdentifier
(	TokenNameLPAREN
finishKeyBytes	TokenNameIdentifier
,	TokenNameCOMMA
p	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startKey	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
finishKey	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
finishKey	TokenNameIdentifier
.	TokenNameDOT
isMinimum	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
instanceof	TokenNameinstanceof
RandomPartitioner	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Start key sorts after end key. This is not allowed; you probably should not specify end key at all, under RandomPartitioner"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Start key must sort before (or equal to) finish key in your partitioner!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
includeKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
bounds	TokenNameIdentifier
=	TokenNameEQUAL
includeKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
Bounds	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
startKey	TokenNameIdentifier
,	TokenNameCOMMA
finishKey	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
IncludingExcludingBounds	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
startKey	TokenNameIdentifier
,	TokenNameCOMMA
finishKey	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
bounds	TokenNameIdentifier
=	TokenNameEQUAL
includeKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
Range	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
startKey	TokenNameIdentifier
,	TokenNameCOMMA
finishKey	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
ExcludingBounds	TokenNameIdentifier
<	TokenNameLESS
RowPosition	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
startKey	TokenNameIdentifier
,	TokenNameCOMMA
finishKey	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
bounds	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
IDiskAtomFilter	TokenNameIdentifier
makeFilter	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isColumnRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
multiplier	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
isCompact	TokenNameIdentifier
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
metadata	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
toGroup	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
isCompact	TokenNameIdentifier
?	TokenNameQUESTION
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
cfDef	TokenNameIdentifier
.	TokenNameDOT
columns	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ColumnSlice	TokenNameIdentifier
slice	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ColumnSlice	TokenNameIdentifier
(	TokenNameLPAREN
getRequestedBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
getRequestedBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SliceQueryFilter	TokenNameIdentifier
filter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SliceQueryFilter	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
ColumnSlice	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
slice	TokenNameIdentifier
}	TokenNameRBRACE
,	TokenNameCOMMA
isReversed	TokenNameIdentifier
,	TokenNameCOMMA
getLimit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
toGroup	TokenNameIdentifier
,	TokenNameCOMMA
multiplier	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
QueryProcessor	TokenNameIdentifier
.	TokenNameDOT
validateSliceFilter	TokenNameIdentifier
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
cfm	TokenNameIdentifier
,	TokenNameCOMMA
filter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
filter	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
SortedSet	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
columnNames	TokenNameIdentifier
=	TokenNameEQUAL
getRequestedColumns	TokenNameIdentifier
(	TokenNameLPAREN
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
QueryProcessor	TokenNameIdentifier
.	TokenNameDOT
validateColumnNames	TokenNameIdentifier
(	TokenNameLPAREN
columnNames	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
new	TokenNamenew
NamesQueryFilter	TokenNameIdentifier
(	TokenNameLPAREN
columnNames	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
getLimit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
sliceRestriction	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
!	TokenNameNOT
sliceRestriction	TokenNameIdentifier
.	TokenNameDOT
isInclusive	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
parameters	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
Integer	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
?	TokenNameQUESTION
parameters	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
parameters	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Collection	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
getKeys	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
keys	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ColumnNameBuilder	TokenNameIdentifier
builder	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
getKeyNameBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
:	TokenNameCOLON
cfDef	TokenNameIdentifier
.	TokenNameDOT
keys	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Restriction	TokenNameIdentifier
r	TokenNameIdentifier
=	TokenNameEQUAL
keyRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
assert	TokenNameassert
r	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
builder	TokenNameIdentifier
.	TokenNameDOT
remainingCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Term	TokenNameIdentifier
t	TokenNameIdentifier
:	TokenNameCOLON
r	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
)	TokenNameRPAREN
keys	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
builder	TokenNameIdentifier
.	TokenNameDOT
copy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
,	TokenNameCOMMA
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
r	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"IN is only supported on the last column of the partition key"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
builder	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
r	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
keys	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
ByteBuffer	TokenNameIdentifier
getKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
buildBound	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
,	TokenNameCOMMA
cfDef	TokenNameIdentifier
.	TokenNameDOT
keys	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
keyRestrictions	TokenNameIdentifier
,	TokenNameCOMMA
isReversed	TokenNameIdentifier
,	TokenNameCOMMA
cfDef	TokenNameIdentifier
.	TokenNameDOT
getKeyNameBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Token	TokenNameIdentifier
getTokenBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
,	TokenNameCOMMA
IPartitioner	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>	TokenNameGREATER
p	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
onToken	TokenNameIdentifier
;	TokenNameSEMICOLON
Restriction	TokenNameIdentifier
keyRestriction	TokenNameIdentifier
=	TokenNameEQUAL
keyRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Term	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
keyRestriction	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
keyRestriction	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
keyRestriction	TokenNameIdentifier
.	TokenNameDOT
bound	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
p	TokenNameIdentifier
.	TokenNameDOT
getMinimumToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
.	TokenNameDOT
getType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
Term	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
t	TokenNameIdentifier
.	TokenNameDOT
isToken	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
String	TokenNameIdentifier
text	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
.	TokenNameDOT
getText	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
p	TokenNameIdentifier
.	TokenNameDOT
getTokenFactory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
validate	TokenNameIdentifier
(	TokenNameLPAREN
text	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
p	TokenNameIdentifier
.	TokenNameDOT
getTokenFactory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
fromString	TokenNameIdentifier
(	TokenNameLPAREN
text	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ConfigurationException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
assert	TokenNameassert
t	TokenNameIdentifier
.	TokenNameDOT
isToken	TokenNameIdentifier
;	TokenNameSEMICOLON
ColumnNameBuilder	TokenNameIdentifier
builder	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
getKeyNameBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
:	TokenNameCOLON
cfDef	TokenNameIdentifier
.	TokenNameDOT
keys	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Restriction	TokenNameIdentifier
r	TokenNameIdentifier
=	TokenNameEQUAL
keyRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
builder	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
r	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
r	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
r	TokenNameIdentifier
.	TokenNameDOT
bound	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
p	TokenNameIdentifier
.	TokenNameDOT
getToken	TokenNameIdentifier
(	TokenNameLPAREN
builder	TokenNameIdentifier
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
includeKeyBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Restriction	TokenNameIdentifier
r	TokenNameIdentifier
:	TokenNameCOLON
keyRestrictions	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
r	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
r	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
r	TokenNameIdentifier
.	TokenNameDOT
isInclusive	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
isColumnRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
cfDef	TokenNameIdentifier
.	TokenNameDOT
isCompact	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
cfDef	TokenNameIdentifier
.	TokenNameDOT
isComposite	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
hasCollections	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Restriction	TokenNameIdentifier
r	TokenNameIdentifier
:	TokenNameCOLON
columnRestrictions	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
r	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
!	TokenNameNOT
r	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
isWildcard	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
selectedNames	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
SortedSet	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
getRequestedColumns	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
!	TokenNameNOT
isColumnRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ColumnNameBuilder	TokenNameIdentifier
builder	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
getColumnNameBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Restriction	TokenNameIdentifier
r	TokenNameIdentifier
:	TokenNameCOLON
columnRestrictions	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
r	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
r	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
r	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
cfDef	TokenNameIdentifier
.	TokenNameDOT
isCompact	TokenNameIdentifier
;	TokenNameSEMICOLON
SortedSet	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
columns	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
TreeSet	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
cfm	TokenNameIdentifier
.	TokenNameDOT
comparator	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Iterator	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
>	TokenNameGREATER
iter	TokenNameIdentifier
=	TokenNameEQUAL
r	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Term	TokenNameIdentifier
v	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ColumnNameBuilder	TokenNameIdentifier
b	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
builder	TokenNameIdentifier
.	TokenNameDOT
copy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
builder	TokenNameIdentifier
;	TokenNameSEMICOLON
ByteBuffer	TokenNameIdentifier
cname	TokenNameIdentifier
=	TokenNameEQUAL
b	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
v	TokenNameIdentifier
,	TokenNameCOMMA
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
columns	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
cname	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
columns	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
builder	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
r	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
isCompact	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
FBUtilities	TokenNameIdentifier
.	TokenNameDOT
singleton	TokenNameIdentifier
(	TokenNameLPAREN
builder	TokenNameIdentifier
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
assert	TokenNameassert
!	TokenNameNOT
cfDef	TokenNameIdentifier
.	TokenNameDOT
hasCollections	TokenNameIdentifier
;	TokenNameSEMICOLON
SortedSet	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
columns	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
TreeSet	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
cfm	TokenNameIdentifier
.	TokenNameDOT
comparator	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
isComposite	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
columns	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
builder	TokenNameIdentifier
.	TokenNameDOT
copy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
ByteBufferUtil	TokenNameIdentifier
.	TokenNameDOT
EMPTY_BYTE_BUFFER	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>	TokenNameGREATER
p	TokenNameIdentifier
:	TokenNameCOLON
getExpandedSelection	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
columns	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
builder	TokenNameIdentifier
.	TokenNameDOT
copy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
id	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
Iterator	TokenNameIdentifier
<	TokenNameLESS
ColumnIdentifier	TokenNameIdentifier
>	TokenNameGREATER
iter	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
metadata	TokenNameIdentifier
.	TokenNameDOT
keySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ColumnIdentifier	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ColumnNameBuilder	TokenNameIdentifier
b	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
builder	TokenNameIdentifier
.	TokenNameDOT
copy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
builder	TokenNameIdentifier
;	TokenNameSEMICOLON
ByteBuffer	TokenNameIdentifier
cname	TokenNameIdentifier
=	TokenNameEQUAL
b	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
columns	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
cname	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
columns	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
ByteBuffer	TokenNameIdentifier
buildBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
bound	TokenNameIdentifier
,	TokenNameCOMMA
Collection	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
>	TokenNameGREATER
names	TokenNameIdentifier
,	TokenNameCOMMA
Restriction	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
restrictions	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isReversed	TokenNameIdentifier
,	TokenNameCOMMA
ColumnNameBuilder	TokenNameIdentifier
builder	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
Bound	TokenNameIdentifier
eocBound	TokenNameIdentifier
=	TokenNameEQUAL
isReversed	TokenNameIdentifier
?	TokenNameQUESTION
Bound	TokenNameIdentifier
.	TokenNameDOT
reverse	TokenNameIdentifier
(	TokenNameLPAREN
bound	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
bound	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
:	TokenNameCOLON
names	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Bound	TokenNameIdentifier
b	TokenNameIdentifier
=	TokenNameEQUAL
isReversed	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
isReversedType	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
bound	TokenNameIdentifier
:	TokenNameCOLON
Bound	TokenNameIdentifier
.	TokenNameDOT
reverse	TokenNameIdentifier
(	TokenNameLPAREN
bound	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Restriction	TokenNameIdentifier
r	TokenNameIdentifier
=	TokenNameEQUAL
restrictions	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
r	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
(	TokenNameLPAREN
!	TokenNameNOT
r	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
r	TokenNameIdentifier
.	TokenNameDOT
bound	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
builder	TokenNameIdentifier
.	TokenNameDOT
componentCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
eocBound	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
builder	TokenNameIdentifier
.	TokenNameDOT
buildAsEndOfRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
builder	TokenNameIdentifier
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
r	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
r	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
builder	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
r	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
Term	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
r	TokenNameIdentifier
.	TokenNameDOT
bound	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
t	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
return	TokenNamereturn
builder	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
,	TokenNameCOMMA
r	TokenNameIdentifier
.	TokenNameDOT
getRelation	TokenNameIdentifier
(	TokenNameLPAREN
eocBound	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
bound	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
builder	TokenNameIdentifier
.	TokenNameDOT
buildAsEndOfRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
builder	TokenNameIdentifier
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
ByteBuffer	TokenNameIdentifier
getRequestedBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
isColumnRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
buildBound	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
,	TokenNameCOMMA
cfDef	TokenNameIdentifier
.	TokenNameDOT
columns	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
columnRestrictions	TokenNameIdentifier
,	TokenNameCOMMA
isReversed	TokenNameIdentifier
,	TokenNameCOMMA
cfDef	TokenNameIdentifier
.	TokenNameDOT
getColumnNameBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
List	TokenNameIdentifier
<	TokenNameLESS
IndexExpression	TokenNameIdentifier
>	TokenNameGREATER
getIndexExpressions	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
metadataRestrictions	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
Collections	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
IndexExpression	TokenNameIdentifier
>	TokenNameGREATER
emptyList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
IndexExpression	TokenNameIdentifier
>	TokenNameGREATER
expressions	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
IndexExpression	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Map	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Restriction	TokenNameIdentifier
>	TokenNameGREATER
entry	TokenNameIdentifier
:	TokenNameCOLON
metadataRestrictions	TokenNameIdentifier
.	TokenNameDOT
entrySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
entry	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Restriction	TokenNameIdentifier
restriction	TokenNameIdentifier
=	TokenNameEQUAL
entry	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Term	TokenNameIdentifier
t	TokenNameIdentifier
:	TokenNameCOLON
restriction	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ByteBuffer	TokenNameIdentifier
value	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
.	TokenNameDOT
getByteBuffer	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
value	TokenNameIdentifier
.	TokenNameDOT
remaining	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0xFFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Index expression values may not be larger than 64K"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
expressions	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
IndexExpression	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
,	TokenNameCOMMA
IndexOperator	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
,	TokenNameCOMMA
value	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
:	TokenNameCOLON
Bound	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
.	TokenNameDOT
bound	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
ByteBuffer	TokenNameIdentifier
value	TokenNameIdentifier
=	TokenNameEQUAL
restriction	TokenNameIdentifier
.	TokenNameDOT
bound	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getByteBuffer	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
value	TokenNameIdentifier
.	TokenNameDOT
remaining	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0xFFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Index expression values may not be larger than 64K"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
expressions	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
IndexExpression	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
,	TokenNameCOMMA
restriction	TokenNameIdentifier
.	TokenNameDOT
getIndexOperator	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
value	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
expressions	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
List	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
getExpandedSelection	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
selectedNames	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
selection	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
:	TokenNameCOLON
cfDef	TokenNameIdentifier
)	TokenNameRPAREN
selection	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
Pair	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>	TokenNameGREATER
create	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
name	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
selection	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
selectedNames	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
ByteBuffer	TokenNameIdentifier
value	TokenNameIdentifier
(	TokenNameLPAREN
IColumn	TokenNameIdentifier
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
c	TokenNameIdentifier
instanceof	TokenNameinstanceof
CounterColumn	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
ByteBufferUtil	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
(	TokenNameLPAREN
CounterContext	TokenNameIdentifier
.	TokenNameDOT
instance	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
total	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
.	TokenNameDOT
value	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
c	TokenNameIdentifier
.	TokenNameDOT
value	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
addReturnValue	TokenNameIdentifier
(	TokenNameLPAREN
ResultSet	TokenNameIdentifier
cqlRows	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
s	TokenNameIdentifier
,	TokenNameCOMMA
IColumn	TokenNameIdentifier
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
c	TokenNameIdentifier
.	TokenNameDOT
isMarkedForDelete	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
s	TokenNameIdentifier
.	TokenNameDOT
hasFunction	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
s	TokenNameIdentifier
.	TokenNameDOT
function	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
WRITE_TIME	TokenNameIdentifier
:	TokenNameCOLON
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
ByteBufferUtil	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
.	TokenNameDOT
timestamp	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
TTL	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
instanceof	TokenNameinstanceof
ExpiringColumn	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ttl	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
ExpiringColumn	TokenNameIdentifier
)	TokenNameRPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getLocalDeletionTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
/	TokenNameDIVIDE
1000	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
ByteBufferUtil	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
(	TokenNameLPAREN
ttl	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
value	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
ResultSet	TokenNameIdentifier
createResult	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
selection	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
ColumnSpecification	TokenNameIdentifier
>	TokenNameGREATER
names	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
ColumnSpecification	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
selection	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>	TokenNameGREATER
p	TokenNameIdentifier
:	TokenNameCOLON
selection	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
hasFunction	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
function	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
WRITE_TIME	TokenNameIdentifier
:	TokenNameCOLON
names	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
ColumnSpecification	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
ksName	TokenNameIdentifier
,	TokenNameCOMMA
p	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
cfName	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
ColumnIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
LongType	TokenNameIdentifier
.	TokenNameDOT
instance	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
TTL	TokenNameIdentifier
:	TokenNameCOLON
names	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
ColumnSpecification	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
ksName	TokenNameIdentifier
,	TokenNameCOMMA
p	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
cfName	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
ColumnIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
Int32Type	TokenNameIdentifier
.	TokenNameDOT
instance	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
names	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
ResultSet	TokenNameIdentifier
(	TokenNameLPAREN
names	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Iterable	TokenNameIdentifier
<	TokenNameLESS
IColumn	TokenNameIdentifier
>	TokenNameGREATER
columnsInOrder	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
ColumnFamily	TokenNameIdentifier
cf	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
Restriction	TokenNameIdentifier
last	TokenNameIdentifier
=	TokenNameEQUAL
columnRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
columnRestrictions	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
last	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
!	TokenNameNOT
last	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
cf	TokenNameIdentifier
.	TokenNameDOT
getSortedColumns	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ColumnNameBuilder	TokenNameIdentifier
builder	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
getColumnNameBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
columnRestrictions	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
builder	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
columnRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
requested	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
last	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Iterator	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
>	TokenNameGREATER
iter	TokenNameIdentifier
=	TokenNameEQUAL
last	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Term	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ColumnNameBuilder	TokenNameIdentifier
b	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
builder	TokenNameIdentifier
.	TokenNameDOT
copy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
builder	TokenNameIdentifier
;	TokenNameSEMICOLON
requested	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
,	TokenNameCOMMA
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
build	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
Iterable	TokenNameIdentifier
<	TokenNameLESS
IColumn	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
Iterator	TokenNameIdentifier
<	TokenNameLESS
IColumn	TokenNameIdentifier
>	TokenNameGREATER
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
AbstractIterator	TokenNameIdentifier
<	TokenNameLESS
IColumn	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Iterator	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
iter	TokenNameIdentifier
=	TokenNameEQUAL
requested	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
IColumn	TokenNameIdentifier
computeNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
endOfData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
IColumn	TokenNameIdentifier
column	TokenNameIdentifier
=	TokenNameEQUAL
cf	TokenNameIdentifier
.	TokenNameDOT
getColumn	TokenNameIdentifier
(	TokenNameLPAREN
iter	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
column	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
computeNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
column	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
ResultSet	TokenNameIdentifier
process	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Row	TokenNameIdentifier
>	TokenNameGREATER
rows	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
variables	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
selection	TokenNameIdentifier
=	TokenNameEQUAL
getExpandedSelection	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ResultSet	TokenNameIdentifier
cqlRows	TokenNameIdentifier
=	TokenNameEQUAL
createResult	TokenNameIdentifier
(	TokenNameLPAREN
selection	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
cassandra	TokenNameIdentifier
.	TokenNameDOT
db	TokenNameIdentifier
.	TokenNameDOT
Row	TokenNameIdentifier
row	TokenNameIdentifier
:	TokenNameCOLON
rows	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
row	TokenNameIdentifier
.	TokenNameDOT
cf	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
ByteBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
keyComponents	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
hasCompositeKey	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
keyComponents	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
CompositeType	TokenNameIdentifier
)	TokenNameRPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
cfm	TokenNameIdentifier
.	TokenNameDOT
getKeyValidator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
split	TokenNameIdentifier
(	TokenNameLPAREN
row	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
keyComponents	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ByteBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
row	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
}	TokenNameRBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
isCompact	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
IColumn	TokenNameIdentifier
c	TokenNameIdentifier
:	TokenNameCOLON
columnsInOrder	TokenNameIdentifier
(	TokenNameLPAREN
row	TokenNameIdentifier
.	TokenNameDOT
cf	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
.	TokenNameDOT
isMarkedForDelete	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
ByteBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
components	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
isComposite	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
components	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
CompositeType	TokenNameIdentifier
)	TokenNameRPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
cfm	TokenNameIdentifier
.	TokenNameDOT
comparator	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
split	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
sliceRestriction	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
sliceRestriction	TokenNameIdentifier
.	TokenNameDOT
isInclusive	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
c	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
sliceRestriction	TokenNameIdentifier
.	TokenNameDOT
bound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getByteBuffer	TokenNameIdentifier
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
cfm	TokenNameIdentifier
.	TokenNameDOT
comparator	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
sliceRestriction	TokenNameIdentifier
.	TokenNameDOT
isInclusive	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
c	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
sliceRestriction	TokenNameIdentifier
.	TokenNameDOT
bound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getByteBuffer	TokenNameIdentifier
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
cfm	TokenNameIdentifier
.	TokenNameDOT
comparator	TokenNameIdentifier
,	TokenNameCOMMA
variables	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>	TokenNameGREATER
p	TokenNameIdentifier
:	TokenNameCOLON
selection	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
;	TokenNameSEMICOLON
Selector	TokenNameIdentifier
selector	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
KEY_ALIAS	TokenNameIdentifier
:	TokenNameCOLON
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
keyComponents	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
COLUMN_ALIAS	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
isComposite	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
<	TokenNameLESS
components	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
components	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
VALUE_ALIAS	TokenNameIdentifier
:	TokenNameCOLON
addReturnValue	TokenNameIdentifier
(	TokenNameLPAREN
cqlRows	TokenNameIdentifier
,	TokenNameCOMMA
selector	TokenNameIdentifier
,	TokenNameCOMMA
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
COLUMN_METADATA	TokenNameIdentifier
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
AssertionError	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
AssertionError	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
isComposite	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
CompositeType	TokenNameIdentifier
composite	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
CompositeType	TokenNameIdentifier
)	TokenNameRPAREN
cfDef	TokenNameIdentifier
.	TokenNameDOT
cfm	TokenNameIdentifier
.	TokenNameDOT
comparator	TokenNameIdentifier
;	TokenNameSEMICOLON
ColumnGroupMap	TokenNameIdentifier
.	TokenNameDOT
Builder	TokenNameIdentifier
builder	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ColumnGroupMap	TokenNameIdentifier
.	TokenNameDOT
Builder	TokenNameIdentifier
(	TokenNameLPAREN
composite	TokenNameIdentifier
,	TokenNameCOMMA
cfDef	TokenNameIdentifier
.	TokenNameDOT
hasCollections	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
IColumn	TokenNameIdentifier
c	TokenNameIdentifier
:	TokenNameCOLON
row	TokenNameIdentifier
.	TokenNameDOT
cf	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
.	TokenNameDOT
isMarkedForDelete	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
builder	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
ColumnGroupMap	TokenNameIdentifier
group	TokenNameIdentifier
:	TokenNameCOLON
builder	TokenNameIdentifier
.	TokenNameDOT
groups	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
handleGroup	TokenNameIdentifier
(	TokenNameLPAREN
selection	TokenNameIdentifier
,	TokenNameCOMMA
row	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
,	TokenNameCOMMA
keyComponents	TokenNameIdentifier
,	TokenNameCOMMA
group	TokenNameIdentifier
,	TokenNameCOMMA
cqlRows	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
row	TokenNameIdentifier
.	TokenNameDOT
cf	TokenNameIdentifier
.	TokenNameDOT
hasOnlyTombstones	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>	TokenNameGREATER
p	TokenNameIdentifier
:	TokenNameCOLON
selection	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
;	TokenNameSEMICOLON
Selector	TokenNameIdentifier
selector	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
.	TokenNameDOT
Kind	TokenNameIdentifier
.	TokenNameDOT
KEY_ALIAS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
keyComponents	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
IColumn	TokenNameIdentifier
c	TokenNameIdentifier
=	TokenNameEQUAL
row	TokenNameIdentifier
.	TokenNameDOT
cf	TokenNameIdentifier
.	TokenNameDOT
getColumn	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addReturnValue	TokenNameIdentifier
(	TokenNameLPAREN
cqlRows	TokenNameIdentifier
,	TokenNameCOMMA
selector	TokenNameIdentifier
,	TokenNameCOMMA
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
orderResults	TokenNameIdentifier
(	TokenNameLPAREN
selection	TokenNameIdentifier
,	TokenNameCOMMA
cqlRows	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isReversed	TokenNameIdentifier
)	TokenNameRPAREN
cqlRows	TokenNameIdentifier
.	TokenNameDOT
reverse	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cqlRows	TokenNameIdentifier
.	TokenNameDOT
trim	TokenNameIdentifier
(	TokenNameLPAREN
parameters	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
cqlRows	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
orderResults	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
selection	TokenNameIdentifier
,	TokenNameCOMMA
ResultSet	TokenNameIdentifier
cqlRows	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cqlRows	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
parameters	TokenNameIdentifier
.	TokenNameDOT
orderings	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
isKeyRange	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
keyIsInRelation	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
parameters	TokenNameIdentifier
.	TokenNameDOT
orderings	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
ordering	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
parameters	TokenNameIdentifier
.	TokenNameDOT
orderings	TokenNameIdentifier
.	TokenNameDOT
keySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Collections	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
cqlRows	TokenNameIdentifier
.	TokenNameDOT
rows	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
SingleColumnComparator	TokenNameIdentifier
(	TokenNameLPAREN
getColumnPositionInSelect	TokenNameIdentifier
(	TokenNameLPAREN
selection	TokenNameIdentifier
,	TokenNameCOMMA
ordering	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
ordering	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
List	TokenNameIdentifier
<	TokenNameLESS
AbstractType	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>>	TokenNameRIGHT_SHIFT
types	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
AbstractType	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
parameters	TokenNameIdentifier
.	TokenNameDOT
orderings	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
positions	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
parameters	TokenNameIdentifier
.	TokenNameDOT
orderings	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
ColumnIdentifier	TokenNameIdentifier
identifier	TokenNameIdentifier
:	TokenNameCOLON
parameters	TokenNameIdentifier
.	TokenNameDOT
orderings	TokenNameIdentifier
.	TokenNameDOT
keySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
orderingColumn	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
identifier	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
types	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
orderingColumn	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
positions	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
getColumnPositionInSelect	TokenNameIdentifier
(	TokenNameLPAREN
selection	TokenNameIdentifier
,	TokenNameCOMMA
orderingColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Collections	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
cqlRows	TokenNameIdentifier
.	TokenNameDOT
rows	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
CompositeComparator	TokenNameIdentifier
(	TokenNameLPAREN
types	TokenNameIdentifier
,	TokenNameCOMMA
positions	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
getColumnPositionInSelect	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
selection	TokenNameIdentifier
,	TokenNameCOMMA
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
columnName	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
selection	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
selection	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
columnName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
i	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Column %s wasn't found in select clause."	TokenNameStringLiteral
,	TokenNameCOMMA
columnName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isSameRow	TokenNameIdentifier
(	TokenNameLPAREN
ByteBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
c1	TokenNameIdentifier
,	TokenNameCOMMA
ByteBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
c2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
c1	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
c2	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
:	TokenNameCOLON
"Sparse composite should not have partial column names"	TokenNameStringLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
c1	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
c1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
c2	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
handleGroup	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
selection	TokenNameIdentifier
,	TokenNameCOMMA
ByteBuffer	TokenNameIdentifier
key	TokenNameIdentifier
,	TokenNameCOMMA
ByteBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
keyComponents	TokenNameIdentifier
,	TokenNameCOMMA
ColumnGroupMap	TokenNameIdentifier
columns	TokenNameIdentifier
,	TokenNameCOMMA
ResultSet	TokenNameIdentifier
cqlRows	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>	TokenNameGREATER
p	TokenNameIdentifier
:	TokenNameCOLON
selection	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
;	TokenNameSEMICOLON
Selector	TokenNameIdentifier
selector	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
right	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
KEY_ALIAS	TokenNameIdentifier
:	TokenNameCOLON
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
keyComponents	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
COLUMN_ALIAS	TokenNameIdentifier
:	TokenNameCOLON
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
columns	TokenNameIdentifier
.	TokenNameDOT
getKeyComponent	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
VALUE_ALIAS	TokenNameIdentifier
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
AssertionError	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
COLUMN_METADATA	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
.	TokenNameDOT
isCollection	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
Pair	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
,	TokenNameCOMMA
IColumn	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
collection	TokenNameIdentifier
=	TokenNameEQUAL
columns	TokenNameIdentifier
.	TokenNameDOT
getCollection	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
collection	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
cqlRows	TokenNameIdentifier
.	TokenNameDOT
addColumnValue	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
CollectionType	TokenNameIdentifier
)	TokenNameRPAREN
name	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
serialize	TokenNameIdentifier
(	TokenNameLPAREN
collection	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
IColumn	TokenNameIdentifier
c	TokenNameIdentifier
=	TokenNameEQUAL
columns	TokenNameIdentifier
.	TokenNameDOT
getSimple	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addReturnValue	TokenNameIdentifier
(	TokenNameLPAREN
cqlRows	TokenNameIdentifier
,	TokenNameCOMMA
selector	TokenNameIdentifier
,	TokenNameCOMMA
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
AssertionError	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isReversedType	TokenNameIdentifier
(	TokenNameLPAREN
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
name	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
instanceof	TokenNameinstanceof
ReversedType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
columnFilterIsIdentity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Restriction	TokenNameIdentifier
r	TokenNameIdentifier
:	TokenNameCOLON
columnRestrictions	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
r	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
RawStatement	TokenNameIdentifier
extends	TokenNameextends
CFStatement	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
Parameters	TokenNameIdentifier
parameters	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
Selector	TokenNameIdentifier
>	TokenNameGREATER
selectClause	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
Relation	TokenNameIdentifier
>	TokenNameGREATER
whereClause	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
RawStatement	TokenNameIdentifier
(	TokenNameLPAREN
CFName	TokenNameIdentifier
cfName	TokenNameIdentifier
,	TokenNameCOMMA
Parameters	TokenNameIdentifier
parameters	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
Selector	TokenNameIdentifier
>	TokenNameGREATER
selectClause	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
Relation	TokenNameIdentifier
>	TokenNameGREATER
whereClause	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
cfName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
parameters	TokenNameIdentifier
=	TokenNameEQUAL
parameters	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
selectClause	TokenNameIdentifier
=	TokenNameEQUAL
selectClause	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
whereClause	TokenNameIdentifier
=	TokenNameEQUAL
whereClause	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
Collections	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
Relation	TokenNameIdentifier
>	TokenNameGREATER
emptyList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
whereClause	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
ParsedStatement	TokenNameIdentifier
.	TokenNameDOT
Prepared	TokenNameIdentifier
prepare	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
CFMetaData	TokenNameIdentifier
cfm	TokenNameIdentifier
=	TokenNameEQUAL
ThriftValidation	TokenNameIdentifier
.	TokenNameDOT
validateColumnFamily	TokenNameIdentifier
(	TokenNameLPAREN
keyspace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
columnFamily	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
parameters	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"LIMIT must be strictly positive"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
CFDefinition	TokenNameIdentifier
cfDef	TokenNameIdentifier
=	TokenNameEQUAL
cfm	TokenNameIdentifier
.	TokenNameDOT
getCfDef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SelectStatement	TokenNameIdentifier
stmt	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SelectStatement	TokenNameIdentifier
(	TokenNameLPAREN
cfDef	TokenNameIdentifier
,	TokenNameCOMMA
getBoundsTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
parameters	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
names	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
[	TokenNameLBRACKET
getBoundsTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
parameters	TokenNameIdentifier
.	TokenNameDOT
isCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
selectClause	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Only COUNT(*) and COUNT(1) operations are currently supported."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Selector	TokenNameIdentifier
t	TokenNameIdentifier
:	TokenNameCOLON
selectClause	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
.	TokenNameDOT
id	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
name	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Undefined name %s in selection clause"	TokenNameStringLiteral
,	TokenNameCOMMA
t	TokenNameIdentifier
.	TokenNameDOT
id	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
.	TokenNameDOT
hasFunction	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
name	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
.	TokenNameDOT
Kind	TokenNameIdentifier
.	TokenNameDOT
COLUMN_METADATA	TokenNameIdentifier
&&	TokenNameAND_AND
name	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
.	TokenNameDOT
Kind	TokenNameIdentifier
.	TokenNameDOT
VALUE_ALIAS	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot use function %s on PRIMARY KEY part %s"	TokenNameStringLiteral
,	TokenNameCOMMA
t	TokenNameIdentifier
.	TokenNameDOT
function	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
.	TokenNameDOT
hasFunction	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
name	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
.	TokenNameDOT
isCollection	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Function %s is not supported on collections"	TokenNameStringLiteral
,	TokenNameCOMMA
t	TokenNameIdentifier
.	TokenNameDOT
function	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
selectedNames	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
Pair	TokenNameIdentifier
.	TokenNameDOT
create	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
t	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
Relation	TokenNameIdentifier
rel	TokenNameIdentifier
:	TokenNameCOLON
whereClause	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
rel	TokenNameIdentifier
.	TokenNameDOT
getEntity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
name	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Undefined name %s in where clause ('%s')"	TokenNameStringLiteral
,	TokenNameCOMMA
rel	TokenNameIdentifier
.	TokenNameDOT
getEntity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
rel	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
rel	TokenNameIdentifier
.	TokenNameDOT
operator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
IN	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Term	TokenNameIdentifier
value	TokenNameIdentifier
:	TokenNameCOLON
rel	TokenNameIdentifier
.	TokenNameDOT
getInValues	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
value	TokenNameIdentifier
.	TokenNameDOT
isBindMarker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
names	TokenNameIdentifier
[	TokenNameLBRACKET
value	TokenNameIdentifier
.	TokenNameDOT
bindIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
Term	TokenNameIdentifier
value	TokenNameIdentifier
=	TokenNameEQUAL
rel	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
value	TokenNameIdentifier
.	TokenNameDOT
isBindMarker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
names	TokenNameIdentifier
[	TokenNameLBRACKET
value	TokenNameIdentifier
.	TokenNameDOT
bindIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
KEY_ALIAS	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
rel	TokenNameIdentifier
.	TokenNameDOT
operator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
&&	TokenNameAND_AND
rel	TokenNameIdentifier
.	TokenNameDOT
operator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
IN	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
rel	TokenNameIdentifier
.	TokenNameDOT
onToken	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
StorageService	TokenNameIdentifier
.	TokenNameDOT
getPartitioner	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
preservesOrder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Only EQ and IN relation are supported on the partition key for RandomPartitioner (unless you use the token() function)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
keyRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
updateRestriction	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
stmt	TokenNameIdentifier
.	TokenNameDOT
keyRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
rel	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
COLUMN_ALIAS	TokenNameIdentifier
:	TokenNameCOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
columnRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
updateRestriction	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
stmt	TokenNameIdentifier
.	TokenNameDOT
columnRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
rel	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
VALUE_ALIAS	TokenNameIdentifier
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Restricting the value of a compact CF (%s) is not supported"	TokenNameStringLiteral
,	TokenNameCOMMA
name	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
COLUMN_METADATA	TokenNameIdentifier
:	TokenNameCOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
metadataRestrictions	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
updateRestriction	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
stmt	TokenNameIdentifier
.	TokenNameDOT
metadataRestrictions	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
rel	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
boolean	TokenNameboolean
shouldBeDone	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
previous	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
Iterator	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
>	TokenNameGREATER
iter	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
columns	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
stmt	TokenNameIdentifier
.	TokenNameDOT
columnRestrictions	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
cname	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Restriction	TokenNameIdentifier
restriction	TokenNameIdentifier
=	TokenNameEQUAL
stmt	TokenNameIdentifier
.	TokenNameDOT
columnRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
shouldBeDone	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
shouldBeDone	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"PRIMARY KEY part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)"	TokenNameStringLiteral
,	TokenNameCOMMA
cname	TokenNameIdentifier
,	TokenNameCOMMA
previous	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
restriction	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
shouldBeDone	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
cfDef	TokenNameIdentifier
.	TokenNameDOT
isComposite	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
!	TokenNameNOT
restriction	TokenNameIdentifier
.	TokenNameDOT
isInclusive	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
restriction	TokenNameIdentifier
.	TokenNameDOT
isInclusive	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
stmt	TokenNameIdentifier
.	TokenNameDOT
sliceRestriction	TokenNameIdentifier
=	TokenNameEQUAL
restriction	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
!	TokenNameNOT
cfDef	TokenNameIdentifier
.	TokenNameDOT
isCompact	TokenNameIdentifier
||	TokenNameOR_OR
i	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
stmt	TokenNameIdentifier
.	TokenNameDOT
columnRestrictions	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"PRIMARY KEY part %s cannot be restricted by IN relation"	TokenNameStringLiteral
,	TokenNameCOMMA
cname	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
previous	TokenNameIdentifier
=	TokenNameEQUAL
cname	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
shouldBeDone	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
previous	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
keyIsInRelation	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
iter	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
keys	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
stmt	TokenNameIdentifier
.	TokenNameDOT
keyRestrictions	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
cname	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Restriction	TokenNameIdentifier
restriction	TokenNameIdentifier
=	TokenNameEQUAL
stmt	TokenNameIdentifier
.	TokenNameDOT
keyRestrictions	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
stmt	TokenNameIdentifier
.	TokenNameDOT
onToken	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"The token() function must be applied to all partition key components or none of them"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
isKeyRange	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
shouldBeDone	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
shouldBeDone	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"partition key part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)"	TokenNameStringLiteral
,	TokenNameCOMMA
cname	TokenNameIdentifier
,	TokenNameCOMMA
previous	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
.	TokenNameDOT
onToken	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
stmt	TokenNameIdentifier
.	TokenNameDOT
isKeyRange	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
onToken	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
restriction	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Select using the token() function don't support IN clause"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
stmt	TokenNameIdentifier
.	TokenNameDOT
onToken	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"The token() function must be applied to all partition key components or none of them"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
stmt	TokenNameIdentifier
.	TokenNameDOT
keyRestrictions	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Partition KEY part %s cannot be restricted by IN relation (only the last part of the partition key can)"	TokenNameStringLiteral
,	TokenNameCOMMA
cname	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
keyIsInRelation	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
stmt	TokenNameIdentifier
.	TokenNameDOT
isKeyRange	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
shouldBeDone	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
previous	TokenNameIdentifier
=	TokenNameEQUAL
cname	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
stmt	TokenNameIdentifier
.	TokenNameDOT
metadataRestrictions	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
stmt	TokenNameIdentifier
.	TokenNameDOT
isKeyRange	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
boolean	TokenNameboolean
hasEq	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
SecondaryIndexManager	TokenNameIdentifier
idxManager	TokenNameIdentifier
=	TokenNameEQUAL
Table	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
keyspace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getColumnFamilyStore	TokenNameIdentifier
(	TokenNameLPAREN
columnFamily	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
indexManager	TokenNameIdentifier
;	TokenNameSEMICOLON
Set	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
indexedNames	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SecondaryIndex	TokenNameIdentifier
index	TokenNameIdentifier
:	TokenNameCOLON
idxManager	TokenNameIdentifier
.	TokenNameDOT
getIndexes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
ColumnDefinition	TokenNameIdentifier
cdef	TokenNameIdentifier
:	TokenNameCOLON
index	TokenNameIdentifier
.	TokenNameDOT
getColumnDefs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
indexedNames	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
cdef	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
Map	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Restriction	TokenNameIdentifier
>	TokenNameGREATER
entry	TokenNameIdentifier
:	TokenNameCOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
metadataRestrictions	TokenNameIdentifier
.	TokenNameDOT
entrySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Restriction	TokenNameIdentifier
restriction	TokenNameIdentifier
=	TokenNameEQUAL
entry	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
restriction	TokenNameIdentifier
.	TokenNameDOT
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
.	TokenNameDOT
eqValues	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot use IN operator on column not part of the PRIMARY KEY"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
indexedNames	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
entry	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
name	TokenNameIdentifier
.	TokenNameDOT
key	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
hasEq	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
hasEq	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"No indexed columns present in by-columns clause with Equal operator"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
stmt	TokenNameIdentifier
.	TokenNameDOT
keyIsInRelation	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Select on indexed columns and with IN clause for the PRIMARY KEY are not supported"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
stmt	TokenNameIdentifier
.	TokenNameDOT
parameters	TokenNameIdentifier
.	TokenNameDOT
orderings	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
stmt	TokenNameIdentifier
.	TokenNameDOT
metadataRestrictions	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"ORDER BY with 2ndary indexes is not supported."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
stmt	TokenNameIdentifier
.	TokenNameDOT
isKeyRange	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"ORDER BY is only supported when the partition key is restricted by an EQ or an IN."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
stmt	TokenNameIdentifier
.	TokenNameDOT
keyIsInRelation	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
stmt	TokenNameIdentifier
.	TokenNameDOT
selectedNames	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
ColumnIdentifier	TokenNameIdentifier
column	TokenNameIdentifier
:	TokenNameCOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
parameters	TokenNameIdentifier
.	TokenNameDOT
orderings	TokenNameIdentifier
.	TokenNameDOT
keySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
column	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
hasColumn	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Pair	TokenNameIdentifier
<	TokenNameLESS
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
,	TokenNameCOMMA
Selector	TokenNameIdentifier
>	TokenNameGREATER
selectPair	TokenNameIdentifier
:	TokenNameCOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
selectedNames	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
selectPair	TokenNameIdentifier
.	TokenNameDOT
left	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
hasColumn	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
hasColumn	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"ORDER BY could not be used on columns missing in select clause."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
Boolean	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
reversedMap	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Boolean	TokenNameIdentifier
[	TokenNameLBRACKET
cfDef	TokenNameIdentifier
.	TokenNameDOT
columns	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Map	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
<	TokenNameLESS
ColumnIdentifier	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
>	TokenNameGREATER
entry	TokenNameIdentifier
:	TokenNameCOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
parameters	TokenNameIdentifier
.	TokenNameDOT
orderings	TokenNameIdentifier
.	TokenNameDOT
entrySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ColumnIdentifier	TokenNameIdentifier
column	TokenNameIdentifier
=	TokenNameEQUAL
entry	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
reversed	TokenNameIdentifier
=	TokenNameEQUAL
entry	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
cfDef	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
column	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
name	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Order by on unknown column %s"	TokenNameStringLiteral
,	TokenNameCOMMA
column	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
.	TokenNameDOT
Kind	TokenNameIdentifier
.	TokenNameDOT
COLUMN_ALIAS	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Order by is currently only supported on the clustered columns of the PRIMARY KEY, got %s"	TokenNameStringLiteral
,	TokenNameCOMMA
column	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
!=	TokenNameNOT_EQUAL
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Order by currently only support the ordering of columns following their declared order in the PRIMARY KEY"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reversedMap	TokenNameIdentifier
[	TokenNameLBRACKET
name	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
reversed	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
isReversedType	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Boolean	TokenNameIdentifier
isReversed	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Boolean	TokenNameIdentifier
b	TokenNameIdentifier
:	TokenNameCOLON
reversedMap	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isReversed	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
isReversed	TokenNameIdentifier
=	TokenNameEQUAL
b	TokenNameIdentifier
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isReversed	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
b	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Unsupported order by relation"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
isReversed	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
stmt	TokenNameIdentifier
.	TokenNameDOT
isReversed	TokenNameIdentifier
=	TokenNameEQUAL
isReversed	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
parameters	TokenNameIdentifier
.	TokenNameDOT
allowFiltering	TokenNameIdentifier
&&	TokenNameAND_AND
stmt	TokenNameIdentifier
.	TokenNameDOT
isKeyRange	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
stmt	TokenNameIdentifier
.	TokenNameDOT
metadataRestrictions	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
stmt	TokenNameIdentifier
.	TokenNameDOT
metadataRestrictions	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
stmt	TokenNameIdentifier
.	TokenNameDOT
columnFilterIsIdentity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. "	TokenNameStringLiteral
+	TokenNamePLUS
"If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
ParsedStatement	TokenNameIdentifier
.	TokenNameDOT
Prepared	TokenNameIdentifier
(	TokenNameLPAREN
stmt	TokenNameIdentifier
,	TokenNameCOMMA
Arrays	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
ColumnSpecification	TokenNameIdentifier
>	TokenNameGREATER
asList	TokenNameIdentifier
(	TokenNameLPAREN
names	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Restriction	TokenNameIdentifier
updateRestriction	TokenNameIdentifier
(	TokenNameLPAREN
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
Restriction	TokenNameIdentifier
restriction	TokenNameIdentifier
,	TokenNameCOMMA
Relation	TokenNameIdentifier
newRel	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
newRel	TokenNameIdentifier
.	TokenNameDOT
onToken	TokenNameIdentifier
&&	TokenNameAND_AND
name	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CFDefinition	TokenNameIdentifier
.	TokenNameDOT
Name	TokenNameIdentifier
.	TokenNameDOT
Kind	TokenNameIdentifier
.	TokenNameDOT
KEY_ALIAS	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"The token() function is only supported on the partition key, found on %s"	TokenNameStringLiteral
,	TokenNameCOMMA
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
newRel	TokenNameIdentifier
.	TokenNameDOT
operator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
EQ	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%s cannot be restricted by more than one relation if it includes an Equal"	TokenNameStringLiteral
,	TokenNameCOMMA
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
restriction	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Restriction	TokenNameIdentifier
(	TokenNameLPAREN
newRel	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
newRel	TokenNameIdentifier
.	TokenNameDOT
onToken	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
IN	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%s cannot be restricted by more than one reation if it includes a IN"	TokenNameStringLiteral
,	TokenNameCOMMA
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
restriction	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Restriction	TokenNameIdentifier
(	TokenNameLPAREN
newRel	TokenNameIdentifier
.	TokenNameDOT
getInValues	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
GT	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
GTE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LT	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LTE	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
restriction	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
restriction	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Restriction	TokenNameIdentifier
(	TokenNameLPAREN
newRel	TokenNameIdentifier
.	TokenNameDOT
onToken	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
restriction	TokenNameIdentifier
.	TokenNameDOT
setBound	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
,	TokenNameCOMMA
newRel	TokenNameIdentifier
.	TokenNameDOT
operator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
newRel	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
restriction	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"SelectRawStatement[name=%s, selectClause=%s, whereClause=%s, isCount=%s, limit=%s]"	TokenNameStringLiteral
,	TokenNameCOMMA
cfName	TokenNameIdentifier
,	TokenNameCOMMA
selectClause	TokenNameIdentifier
,	TokenNameCOMMA
whereClause	TokenNameIdentifier
,	TokenNameCOMMA
parameters	TokenNameIdentifier
.	TokenNameDOT
isCount	TokenNameIdentifier
,	TokenNameCOMMA
parameters	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
Restriction	TokenNameIdentifier
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
>	TokenNameGREATER
eqValues	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
Term	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bounds	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
boundInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
onToken	TokenNameIdentifier
;	TokenNameSEMICOLON
Restriction	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
>	TokenNameGREATER
values	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
eqValues	TokenNameIdentifier
=	TokenNameEQUAL
values	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
bounds	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
boundInclusive	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
onToken	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Restriction	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
value	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
onToken	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
Collections	TokenNameIdentifier
.	TokenNameDOT
singletonList	TokenNameIdentifier
(	TokenNameLPAREN
value	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Restriction	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
onToken	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
eqValues	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
bounds	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Term	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
boundInclusive	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
onToken	TokenNameIdentifier
=	TokenNameEQUAL
onToken	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
isEquality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
eqValues	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setBound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
,	TokenNameCOMMA
Term	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bounds	TokenNameIdentifier
[	TokenNameLBRACKET
b	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setInclusive	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
boundInclusive	TokenNameIdentifier
[	TokenNameLBRACKET
b	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Term	TokenNameIdentifier
bound	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bounds	TokenNameIdentifier
[	TokenNameLBRACKET
b	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isInclusive	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bounds	TokenNameIdentifier
[	TokenNameLBRACKET
b	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
boundInclusive	TokenNameIdentifier
[	TokenNameLBRACKET
b	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
getRelation	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
eocBound	TokenNameIdentifier
,	TokenNameCOMMA
Bound	TokenNameIdentifier
inclusiveBound	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
eocBound	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
START	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
boundInclusive	TokenNameIdentifier
[	TokenNameLBRACKET
inclusiveBound	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
?	TokenNameQUESTION
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
GTE	TokenNameIdentifier
:	TokenNameCOLON
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
GT	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
END	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
boundInclusive	TokenNameIdentifier
[	TokenNameLBRACKET
inclusiveBound	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
?	TokenNameQUESTION
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
LTE	TokenNameIdentifier
:	TokenNameCOLON
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
.	TokenNameDOT
LT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
AssertionError	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
IndexOperator	TokenNameIdentifier
getIndexOperator	TokenNameIdentifier
(	TokenNameLPAREN
Bound	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
START	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
boundInclusive	TokenNameIdentifier
[	TokenNameLBRACKET
b	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
?	TokenNameQUESTION
IndexOperator	TokenNameIdentifier
.	TokenNameDOT
GTE	TokenNameIdentifier
:	TokenNameCOLON
IndexOperator	TokenNameIdentifier
.	TokenNameDOT
GT	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
END	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
boundInclusive	TokenNameIdentifier
[	TokenNameLBRACKET
b	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
?	TokenNameQUESTION
IndexOperator	TokenNameIdentifier
.	TokenNameDOT
LTE	TokenNameIdentifier
:	TokenNameCOLON
IndexOperator	TokenNameIdentifier
.	TokenNameDOT
LT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
AssertionError	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setBound	TokenNameIdentifier
(	TokenNameLPAREN
ColumnIdentifier	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
Relation	TokenNameIdentifier
.	TokenNameDOT
Type	TokenNameIdentifier
type	TokenNameIdentifier
,	TokenNameCOMMA
Term	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidRequestException	TokenNameIdentifier
{	TokenNameLBRACE
Bound	TokenNameIdentifier
b	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
inclusive	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
GT	TokenNameIdentifier
:	TokenNameCOLON
b	TokenNameIdentifier
=	TokenNameEQUAL
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
;	TokenNameSEMICOLON
inclusive	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
GTE	TokenNameIdentifier
:	TokenNameCOLON
b	TokenNameIdentifier
=	TokenNameEQUAL
Bound	TokenNameIdentifier
.	TokenNameDOT
START	TokenNameIdentifier
;	TokenNameSEMICOLON
inclusive	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
LT	TokenNameIdentifier
:	TokenNameCOLON
b	TokenNameIdentifier
=	TokenNameEQUAL
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
;	TokenNameSEMICOLON
inclusive	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
LTE	TokenNameIdentifier
:	TokenNameCOLON
b	TokenNameIdentifier
=	TokenNameEQUAL
Bound	TokenNameIdentifier
.	TokenNameDOT
END	TokenNameIdentifier
;	TokenNameSEMICOLON
inclusive	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
bounds	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%s cannot be restricted by both an equal and an inequal relation"	TokenNameStringLiteral
,	TokenNameCOMMA
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bounds	TokenNameIdentifier
[	TokenNameLBRACKET
b	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
InvalidRequestException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"Invalid restrictions found on %s"	TokenNameStringLiteral
,	TokenNameCOMMA
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bounds	TokenNameIdentifier
[	TokenNameLBRACKET
b	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
boundInclusive	TokenNameIdentifier
[	TokenNameLBRACKET
b	TokenNameIdentifier
.	TokenNameDOT
idx	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
inclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
s	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
eqValues	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
s	TokenNameIdentifier
=	TokenNameEQUAL
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"SLICE(%s %s, %s %s)"	TokenNameStringLiteral
,	TokenNameCOMMA
boundInclusive	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
?	TokenNameQUESTION
">="	TokenNameStringLiteral
:	TokenNameCOLON
">"	TokenNameStringLiteral
,	TokenNameCOMMA
bounds	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
boundInclusive	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
?	TokenNameQUESTION
"<="	TokenNameStringLiteral
:	TokenNameCOLON
"<"	TokenNameStringLiteral
,	TokenNameCOMMA
bounds	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
s	TokenNameIdentifier
=	TokenNameEQUAL
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"EQ(%s)"	TokenNameStringLiteral
,	TokenNameCOMMA
eqValues	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
onToken	TokenNameIdentifier
?	TokenNameQUESTION
s	TokenNameIdentifier
+	TokenNamePLUS
"*"	TokenNameStringLiteral
:	TokenNameCOLON
s	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
Parameters	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
Map	TokenNameIdentifier
<	TokenNameLESS
ColumnIdentifier	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
>	TokenNameGREATER
orderings	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
isCount	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
allowFiltering	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Parameters	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
Map	TokenNameIdentifier
<	TokenNameLESS
ColumnIdentifier	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
>	TokenNameGREATER
orderings	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isCount	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
allowFiltering	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
limit	TokenNameIdentifier
=	TokenNameEQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
orderings	TokenNameIdentifier
=	TokenNameEQUAL
orderings	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
isCount	TokenNameIdentifier
=	TokenNameEQUAL
isCount	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
allowFiltering	TokenNameIdentifier
=	TokenNameEQUAL
allowFiltering	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
SingleColumnComparator	TokenNameIdentifier
implements	TokenNameimplements
Comparator	TokenNameIdentifier
<	TokenNameLESS
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
index	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
AbstractType	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>	TokenNameGREATER
comparator	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
SingleColumnComparator	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
columnIndex	TokenNameIdentifier
,	TokenNameCOMMA
AbstractType	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>	TokenNameGREATER
orderer	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
=	TokenNameEQUAL
columnIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
comparator	TokenNameIdentifier
=	TokenNameEQUAL
orderer	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
a	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
comparator	TokenNameIdentifier
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
CompositeComparator	TokenNameIdentifier
implements	TokenNameimplements
Comparator	TokenNameIdentifier
<	TokenNameLESS
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
AbstractType	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>>	TokenNameRIGHT_SHIFT
orderTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
positions	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
CompositeComparator	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
AbstractType	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>>	TokenNameRIGHT_SHIFT
orderTypes	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
positions	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
orderTypes	TokenNameIdentifier
=	TokenNameEQUAL
orderTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
positions	TokenNameIdentifier
=	TokenNameEQUAL
positions	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
a	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
ByteBuffer	TokenNameIdentifier
>	TokenNameGREATER
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
positions	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
AbstractType	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>	TokenNameGREATER
type	TokenNameIdentifier
=	TokenNameEQUAL
orderTypes	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
columnPos	TokenNameIdentifier
=	TokenNameEQUAL
positions	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
ByteBuffer	TokenNameIdentifier
aValue	TokenNameIdentifier
=	TokenNameEQUAL
a	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
columnPos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ByteBuffer	TokenNameIdentifier
bValue	TokenNameIdentifier
=	TokenNameEQUAL
b	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
columnPos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
comparison	TokenNameIdentifier
=	TokenNameEQUAL
type	TokenNameIdentifier
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
aValue	TokenNameIdentifier
,	TokenNameCOMMA
bValue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
comparison	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
comparison	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
