package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
serialize	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
OutputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
Writer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
DOMMessageFormatter	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
NamespaceSupport	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
SymbolTable	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
XML11Char	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
XMLChar	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
DOMError	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
Document	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
SAXException	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
XML11Serializer	TokenNameIdentifier
extends	TokenNameextends
XMLSerializer	TokenNameIdentifier
{	TokenNameLBRACE
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
DEBUG	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
protected	TokenNameprotected
NamespaceSupport	TokenNameIdentifier
fNSBinder	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
NamespaceSupport	TokenNameIdentifier
fLocalNSBinder	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
SymbolTable	TokenNameIdentifier
fSymbolTable	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
fDOML1	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
fNamespaceCounter	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
final	TokenNamefinal
static	TokenNamestatic
String	TokenNameIdentifier
PREFIX	TokenNameIdentifier
=	TokenNameEQUAL
"NS"	TokenNameStringLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
fNamespaces	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
public	TokenNamepublic
XML11Serializer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_format	TokenNameIdentifier
.	TokenNameDOT
setVersion	TokenNameIdentifier
(	TokenNameLPAREN
"1.1"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XML11Serializer	TokenNameIdentifier
(	TokenNameLPAREN
OutputFormat	TokenNameIdentifier
format	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
format	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_format	TokenNameIdentifier
.	TokenNameDOT
setVersion	TokenNameIdentifier
(	TokenNameLPAREN
"1.1"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XML11Serializer	TokenNameIdentifier
(	TokenNameLPAREN
Writer	TokenNameIdentifier
writer	TokenNameIdentifier
,	TokenNameCOMMA
OutputFormat	TokenNameIdentifier
format	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
writer	TokenNameIdentifier
,	TokenNameCOMMA
format	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_format	TokenNameIdentifier
.	TokenNameDOT
setVersion	TokenNameIdentifier
(	TokenNameLPAREN
"1.1"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XML11Serializer	TokenNameIdentifier
(	TokenNameLPAREN
OutputStream	TokenNameIdentifier
output	TokenNameIdentifier
,	TokenNameCOMMA
OutputFormat	TokenNameIdentifier
format	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
output	TokenNameIdentifier
,	TokenNameCOMMA
format	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
format	TokenNameIdentifier
:	TokenNameCOLON
new	TokenNamenew
OutputFormat	TokenNameIdentifier
(	TokenNameLPAREN
Method	TokenNameIdentifier
.	TokenNameDOT
XML	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_format	TokenNameIdentifier
.	TokenNameDOT
setVersion	TokenNameIdentifier
(	TokenNameLPAREN
"1.1"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
characters	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
chars	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
SAXException	TokenNameIdentifier
{	TokenNameLBRACE
ElementState	TokenNameIdentifier
state	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
state	TokenNameIdentifier
=	TokenNameEQUAL
content	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
state	TokenNameIdentifier
.	TokenNameDOT
inCData	TokenNameIdentifier
||	TokenNameOR_OR
state	TokenNameIdentifier
.	TokenNameDOT
doCData	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
saveIndent	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
state	TokenNameIdentifier
.	TokenNameDOT
inCData	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"<![CDATA["	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
state	TokenNameIdentifier
.	TokenNameDOT
inCData	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
saveIndent	TokenNameIdentifier
=	TokenNameEQUAL
_printer	TokenNameIdentifier
.	TokenNameDOT
getNextIndent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_printer	TokenNameIdentifier
.	TokenNameDOT
setNextIndent	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
chars	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
']'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
<	TokenNameLESS
end	TokenNameIdentifier
&&	TokenNameAND_AND
chars	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
']'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
chars	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
'>'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"]]]]><![CDATA[>"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11Valid	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
surrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
chars	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fatalError	TokenNameIdentifier
(	TokenNameLPAREN
"The character '"	TokenNameStringLiteral
+	TokenNamePLUS
ch	TokenNameIdentifier
+	TokenNamePLUS
"' is an invalid XML character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
_encodingInfo	TokenNameIdentifier
.	TokenNameDOT
isPrintable	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11ValidLiteral	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"]]>&#x"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
Integer	TokenNameIdentifier
.	TokenNameDOT
toHexString	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
";<![CDATA["	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
setNextIndent	TokenNameIdentifier
(	TokenNameLPAREN
saveIndent	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
saveIndent	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
state	TokenNameIdentifier
.	TokenNameDOT
preserveSpace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
saveIndent	TokenNameIdentifier
=	TokenNameEQUAL
_printer	TokenNameIdentifier
.	TokenNameDOT
getNextIndent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_printer	TokenNameIdentifier
.	TokenNameDOT
setNextIndent	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
printText	TokenNameIdentifier
(	TokenNameLPAREN
chars	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
state	TokenNameIdentifier
.	TokenNameDOT
unescaped	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_printer	TokenNameIdentifier
.	TokenNameDOT
setNextIndent	TokenNameIdentifier
(	TokenNameLPAREN
saveIndent	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
printText	TokenNameIdentifier
(	TokenNameLPAREN
chars	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
state	TokenNameIdentifier
.	TokenNameDOT
unescaped	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
except	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
SAXException	TokenNameIdentifier
(	TokenNameLPAREN
except	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
printEscaped	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
source	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
length	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11Valid	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
<	TokenNameLESS
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
surrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
source	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fatalError	TokenNameIdentifier
(	TokenNameLPAREN
"The character '"	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
ch	TokenNameIdentifier
+	TokenNamePLUS
"' is an invalid XML character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'\n'	TokenNameCharacterLiteral
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'\r'	TokenNameCharacterLiteral
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'\t'	TokenNameCharacterLiteral
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x0085	TokenNameIntegerLiteral
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x2028	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
printHex	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'<'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"&lt;"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'&'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"&amp;"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'"'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"&quot;"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
ch	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
' '	TokenNameCharacterLiteral
&&	TokenNameAND_AND
_encodingInfo	TokenNameIdentifier
.	TokenNameDOT
isPrintable	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
printHex	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
final	TokenNamefinal
void	TokenNamevoid
printCDATAText	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
text	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
length	TokenNameIdentifier
=	TokenNameEQUAL
text	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
text	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
']'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
<	TokenNameLESS
length	TokenNameIdentifier
&&	TokenNameAND_AND
text	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
']'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
text	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'>'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fDOMErrorHandler	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
features	TokenNameIdentifier
&	TokenNameAND
DOMSerializerImpl	TokenNameIdentifier
.	TokenNameDOT
SPLITCDATA	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
features	TokenNameIdentifier
&	TokenNameAND
DOMSerializerImpl	TokenNameIdentifier
.	TokenNameDOT
WELLFORMED	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
msg	TokenNameIdentifier
=	TokenNameEQUAL
DOMMessageFormatter	TokenNameIdentifier
.	TokenNameDOT
formatMessage	TokenNameIdentifier
(	TokenNameLPAREN
DOMMessageFormatter	TokenNameIdentifier
.	TokenNameDOT
SERIALIZER_DOMAIN	TokenNameIdentifier
,	TokenNameCOMMA
"EndingCDATA"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
modifyDOMError	TokenNameIdentifier
(	TokenNameLPAREN
msg	TokenNameIdentifier
,	TokenNameCOMMA
DOMError	TokenNameIdentifier
.	TokenNameDOT
SEVERITY_FATAL_ERROR	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
fCurrentNode	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
continueProcess	TokenNameIdentifier
=	TokenNameEQUAL
fDOMErrorHandler	TokenNameIdentifier
.	TokenNameDOT
handleError	TokenNameIdentifier
(	TokenNameLPAREN
fDOMError	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
continueProcess	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
String	TokenNameIdentifier
msg	TokenNameIdentifier
=	TokenNameEQUAL
DOMMessageFormatter	TokenNameIdentifier
.	TokenNameDOT
formatMessage	TokenNameIdentifier
(	TokenNameLPAREN
DOMMessageFormatter	TokenNameIdentifier
.	TokenNameDOT
SERIALIZER_DOMAIN	TokenNameIdentifier
,	TokenNameCOMMA
"SplittingCDATA"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
modifyDOMError	TokenNameIdentifier
(	TokenNameLPAREN
msg	TokenNameIdentifier
,	TokenNameCOMMA
DOMError	TokenNameIdentifier
.	TokenNameDOT
SEVERITY_WARNING	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
fCurrentNode	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fDOMErrorHandler	TokenNameIdentifier
.	TokenNameDOT
handleError	TokenNameIdentifier
(	TokenNameLPAREN
fDOMError	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"]]]]><![CDATA[>"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11Valid	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
<	TokenNameLESS
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
surrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
text	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fatalError	TokenNameIdentifier
(	TokenNameLPAREN
"The character '"	TokenNameStringLiteral
+	TokenNamePLUS
ch	TokenNameIdentifier
+	TokenNamePLUS
"' is an invalid XML character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
_encodingInfo	TokenNameIdentifier
.	TokenNameDOT
isPrintable	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11ValidLiteral	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"]]>&#x"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
Integer	TokenNameIdentifier
.	TokenNameDOT
toHexString	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
";<![CDATA["	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
final	TokenNamefinal
void	TokenNamevoid
printXMLChar	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
ch	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'\r'	TokenNameCharacterLiteral
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x0085	TokenNameIntegerLiteral
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x2028	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
printHex	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'<'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"&lt;"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'&'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"&amp;"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'>'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"&gt;"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
_encodingInfo	TokenNameIdentifier
.	TokenNameDOT
isPrintable	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11ValidLiteral	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
printHex	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
final	TokenNamefinal
void	TokenNamevoid
surrogates	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
high	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
low	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
inContent	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
XMLChar	TokenNameIdentifier
.	TokenNameDOT
isHighSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
high	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XMLChar	TokenNameIdentifier
.	TokenNameDOT
isLowSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
low	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fatalError	TokenNameIdentifier
(	TokenNameLPAREN
"The character '"	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
low	TokenNameIdentifier
+	TokenNamePLUS
"' is an invalid XML character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
supplemental	TokenNameIdentifier
=	TokenNameEQUAL
XMLChar	TokenNameIdentifier
.	TokenNameDOT
supplemental	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
high	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
low	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11Valid	TokenNameIdentifier
(	TokenNameLPAREN
supplemental	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fatalError	TokenNameIdentifier
(	TokenNameLPAREN
"The character '"	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
supplemental	TokenNameIdentifier
+	TokenNamePLUS
"' is an invalid XML character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
inContent	TokenNameIdentifier
&&	TokenNameAND_AND
content	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
inCData	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
"]]>&#x"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
Integer	TokenNameIdentifier
.	TokenNameDOT
toHexString	TokenNameIdentifier
(	TokenNameLPAREN
supplemental	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
";<![CDATA["	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
printHex	TokenNameIdentifier
(	TokenNameLPAREN
supplemental	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fatalError	TokenNameIdentifier
(	TokenNameLPAREN
"The character '"	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
high	TokenNameIdentifier
+	TokenNamePLUS
"' is an invalid XML character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
printText	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
text	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
preserveSpace	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
unescaped	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
index	TokenNameIdentifier
;	TokenNameSEMICOLON
char	TokenNamechar
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
length	TokenNameIdentifier
=	TokenNameEQUAL
text	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
preserveSpace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
text	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11Valid	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
<	TokenNameLESS
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
surrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
text	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fatalError	TokenNameIdentifier
(	TokenNameLPAREN
"The character '"	TokenNameStringLiteral
+	TokenNamePLUS
ch	TokenNameIdentifier
+	TokenNamePLUS
"' is an invalid XML character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
unescaped	TokenNameIdentifier
&&	TokenNameAND_AND
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11ValidLiteral	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
printXMLChar	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
text	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11Valid	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
<	TokenNameLESS
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
surrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
text	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fatalError	TokenNameIdentifier
(	TokenNameLPAREN
"The character '"	TokenNameStringLiteral
+	TokenNamePLUS
ch	TokenNameIdentifier
+	TokenNamePLUS
"' is an invalid XML character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
unescaped	TokenNameIdentifier
&&	TokenNameAND_AND
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11ValidLiteral	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
printXMLChar	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
printText	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
chars	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
preserveSpace	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
unescaped	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
preserveSpace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
length	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
ch	TokenNameIdentifier
=	TokenNameEQUAL
chars	TokenNameIdentifier
[	TokenNameLBRACKET
start	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11Valid	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
length	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
surrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
chars	TokenNameIdentifier
[	TokenNameLBRACKET
start	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fatalError	TokenNameIdentifier
(	TokenNameLPAREN
"The character '"	TokenNameStringLiteral
+	TokenNamePLUS
ch	TokenNameIdentifier
+	TokenNamePLUS
"' is an invalid XML character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
unescaped	TokenNameIdentifier
&&	TokenNameAND_AND
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11ValidLiteral	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
printXMLChar	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
length	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
ch	TokenNameIdentifier
=	TokenNameEQUAL
chars	TokenNameIdentifier
[	TokenNameLBRACKET
start	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11Valid	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
length	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
surrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
chars	TokenNameIdentifier
[	TokenNameLBRACKET
start	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fatalError	TokenNameIdentifier
(	TokenNameLPAREN
"The character '"	TokenNameStringLiteral
+	TokenNamePLUS
ch	TokenNameIdentifier
+	TokenNamePLUS
"' is an invalid XML character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
unescaped	TokenNameIdentifier
&&	TokenNameAND_AND
XML11Char	TokenNameIdentifier
.	TokenNameDOT
isXML11ValidLiteral	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_printer	TokenNameIdentifier
.	TokenNameDOT
printText	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
printXMLChar	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
