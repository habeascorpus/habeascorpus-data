package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xpointer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashMap	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
XMLErrorReporter	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
SymbolTable	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
XMLChar	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xni	TokenNameIdentifier
.	TokenNameDOT
Augmentations	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xni	TokenNameIdentifier
.	TokenNameDOT
QName	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xni	TokenNameIdentifier
.	TokenNameDOT
XMLAttributes	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xni	TokenNameIdentifier
.	TokenNameDOT
XNIException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xni	TokenNameIdentifier
.	TokenNameDOT
parser	TokenNameIdentifier
.	TokenNameDOT
XMLErrorHandler	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
class	TokenNameclass
ElementSchemePointer	TokenNameIdentifier
implements	TokenNameimplements
XPointerPart	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
String	TokenNameIdentifier
fSchemeName	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
fSchemeData	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
fShortHandPointerName	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
fIsResolveElement	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
fIsElementFound	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
fWasOnlyEmptyElementFound	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
fIsShortHand	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
int	TokenNameint
fFoundDepth	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fCurrentChildPosition	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fCurrentChildDepth	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fCurrentChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
fIsFragmentResolved	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
ShortHandPointer	TokenNameIdentifier
fShortHandPointer	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
XMLErrorReporter	TokenNameIdentifier
fErrorReporter	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
XMLErrorHandler	TokenNameIdentifier
fErrorHandler	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
SymbolTable	TokenNameIdentifier
fSymbolTable	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
ElementSchemePointer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
ElementSchemePointer	TokenNameIdentifier
(	TokenNameLPAREN
SymbolTable	TokenNameIdentifier
symbolTable	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fSymbolTable	TokenNameIdentifier
=	TokenNameEQUAL
symbolTable	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
ElementSchemePointer	TokenNameIdentifier
(	TokenNameLPAREN
SymbolTable	TokenNameIdentifier
symbolTable	TokenNameIdentifier
,	TokenNameCOMMA
XMLErrorReporter	TokenNameIdentifier
errorReporter	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fSymbolTable	TokenNameIdentifier
=	TokenNameEQUAL
symbolTable	TokenNameIdentifier
;	TokenNameSEMICOLON
fErrorReporter	TokenNameIdentifier
=	TokenNameEQUAL
errorReporter	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
parseXPointer	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
xpointer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
Tokens	TokenNameIdentifier
tokens	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Tokens	TokenNameIdentifier
(	TokenNameLPAREN
fSymbolTable	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Scanner	TokenNameIdentifier
scanner	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Scanner	TokenNameIdentifier
(	TokenNameLPAREN
fSymbolTable	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
protected	TokenNameprotected
void	TokenNamevoid
addToken	TokenNameIdentifier
(	TokenNameLPAREN
Tokens	TokenNameIdentifier
tokens	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
token	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
token	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Tokens	TokenNameIdentifier
.	TokenNameDOT
XPTRTOKEN_ELEM_CHILD	TokenNameIdentifier
||	TokenNameOR_OR
token	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Tokens	TokenNameIdentifier
.	TokenNameDOT
XPTRTOKEN_ELEM_NCNAME	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
.	TokenNameDOT
addToken	TokenNameIdentifier
(	TokenNameLPAREN
tokens	TokenNameIdentifier
,	TokenNameCOMMA
token	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"InvalidElementSchemeToken"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
tokens	TokenNameIdentifier
.	TokenNameDOT
getTokenString	TokenNameIdentifier
(	TokenNameLPAREN
token	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
int	TokenNameint
length	TokenNameIdentifier
=	TokenNameEQUAL
xpointer	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
scanner	TokenNameIdentifier
.	TokenNameDOT
scanExpr	TokenNameIdentifier
(	TokenNameLPAREN
fSymbolTable	TokenNameIdentifier
,	TokenNameCOMMA
tokens	TokenNameIdentifier
,	TokenNameCOMMA
xpointer	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"InvalidElementSchemeXPointer"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
xpointer	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
tmpChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
tokens	TokenNameIdentifier
.	TokenNameDOT
getTokenCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
tokens	TokenNameIdentifier
.	TokenNameDOT
hasMore	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
token	TokenNameIdentifier
=	TokenNameEQUAL
tokens	TokenNameIdentifier
.	TokenNameDOT
nextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
token	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
Tokens	TokenNameIdentifier
.	TokenNameDOT
XPTRTOKEN_ELEM_NCNAME	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
token	TokenNameIdentifier
=	TokenNameEQUAL
tokens	TokenNameIdentifier
.	TokenNameDOT
nextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fShortHandPointerName	TokenNameIdentifier
=	TokenNameEQUAL
tokens	TokenNameIdentifier
.	TokenNameDOT
getTokenString	TokenNameIdentifier
(	TokenNameLPAREN
token	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fShortHandPointer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ShortHandPointer	TokenNameIdentifier
(	TokenNameLPAREN
fSymbolTable	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fShortHandPointer	TokenNameIdentifier
.	TokenNameDOT
setSchemeName	TokenNameIdentifier
(	TokenNameLPAREN
fShortHandPointerName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
Tokens	TokenNameIdentifier
.	TokenNameDOT
XPTRTOKEN_ELEM_CHILD	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
tmpChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
tokens	TokenNameIdentifier
.	TokenNameDOT
nextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"InvalidElementSchemeXPointer"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
xpointer	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
fChildSequence	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fCurrentChildSequence	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
tmpChildSequence	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
fChildSequence	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getSchemeName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fSchemeName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getSchemeData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fSchemeData	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setSchemeName	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
schemeName	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fSchemeName	TokenNameIdentifier
=	TokenNameEQUAL
schemeName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setSchemeData	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
schemeData	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fSchemeData	TokenNameIdentifier
=	TokenNameEQUAL
schemeData	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
resolveXPointer	TokenNameIdentifier
(	TokenNameLPAREN
QName	TokenNameIdentifier
element	TokenNameIdentifier
,	TokenNameCOMMA
XMLAttributes	TokenNameIdentifier
attributes	TokenNameIdentifier
,	TokenNameCOMMA
Augmentations	TokenNameIdentifier
augs	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
event	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
isShortHandPointerResolved	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fShortHandPointerName	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
isShortHandPointerResolved	TokenNameIdentifier
=	TokenNameEQUAL
fShortHandPointer	TokenNameIdentifier
.	TokenNameDOT
resolveXPointer	TokenNameIdentifier
(	TokenNameLPAREN
element	TokenNameIdentifier
,	TokenNameCOMMA
attributes	TokenNameIdentifier
,	TokenNameCOMMA
augs	TokenNameIdentifier
,	TokenNameCOMMA
event	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isShortHandPointerResolved	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fIsResolveElement	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
fIsShortHand	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fIsResolveElement	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fIsResolveElement	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fIsFragmentResolved	TokenNameIdentifier
=	TokenNameEQUAL
matchChildSequence	TokenNameIdentifier
(	TokenNameLPAREN
element	TokenNameIdentifier
,	TokenNameCOMMA
event	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
isShortHandPointerResolved	TokenNameIdentifier
&&	TokenNameAND_AND
fChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fIsFragmentResolved	TokenNameIdentifier
=	TokenNameEQUAL
isShortHandPointerResolved	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fIsFragmentResolved	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fIsFragmentResolved	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
boolean	TokenNameboolean
matchChildSequence	TokenNameIdentifier
(	TokenNameLPAREN
QName	TokenNameIdentifier
element	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
event	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fCurrentChildDepth	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
fCurrentChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
tmpCurrentChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
fCurrentChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
fCurrentChildSequence	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
tmpCurrentChildSequence	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
fCurrentChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fCurrentChildSequence	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
fCurrentChildDepth	TokenNameIdentifier
*	TokenNameMULTIPLY
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
tmpCurrentChildSequence	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
fCurrentChildSequence	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
tmpCurrentChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fIsResolveElement	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
event	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XPointerPart	TokenNameIdentifier
.	TokenNameDOT
EVENT_ELEMENT_START	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fCurrentChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
fCurrentChildDepth	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
fCurrentChildPosition	TokenNameIdentifier
;	TokenNameSEMICOLON
fCurrentChildDepth	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
fCurrentChildPosition	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fCurrentChildDepth	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
fFoundDepth	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
fFoundDepth	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
checkMatch	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fIsElementFound	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
fFoundDepth	TokenNameIdentifier
=	TokenNameEQUAL
fCurrentChildDepth	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fIsElementFound	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fFoundDepth	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
event	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XPointerPart	TokenNameIdentifier
.	TokenNameDOT
EVENT_ELEMENT_END	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fCurrentChildDepth	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
fFoundDepth	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fIsElementFound	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fCurrentChildDepth	TokenNameIdentifier
<	TokenNameLESS
fFoundDepth	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
fFoundDepth	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
fCurrentChildDepth	TokenNameIdentifier
>	TokenNameGREATER
fFoundDepth	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
fFoundDepth	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fIsElementFound	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fCurrentChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
fCurrentChildDepth	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fCurrentChildDepth	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
fCurrentChildPosition	TokenNameIdentifier
=	TokenNameEQUAL
fCurrentChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
fCurrentChildDepth	TokenNameIdentifier
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
event	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XPointerPart	TokenNameIdentifier
.	TokenNameDOT
EVENT_ELEMENT_EMPTY	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fCurrentChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
fCurrentChildDepth	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
fCurrentChildPosition	TokenNameIdentifier
;	TokenNameSEMICOLON
fCurrentChildPosition	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
checkMatch	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
fIsElementFound	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fWasOnlyEmptyElementFound	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fWasOnlyEmptyElementFound	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fIsElementFound	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fIsElementFound	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fWasOnlyEmptyElementFound	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
fIsElementFound	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
boolean	TokenNameboolean
checkMatch	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
fIsShortHand	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
fCurrentChildDepth	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
fCurrentChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
fCurrentChildDepth	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fCurrentChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
i	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
fCurrentChildSequence	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isFragmentResolved	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
fIsFragmentResolved	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isChildFragmentResolved	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fIsShortHand	TokenNameIdentifier
&&	TokenNameAND_AND
fShortHandPointer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
fChildSequence	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fShortHandPointer	TokenNameIdentifier
.	TokenNameDOT
isChildFragmentResolved	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
fWasOnlyEmptyElementFound	TokenNameIdentifier
?	TokenNameQUESTION
!	TokenNameNOT
fWasOnlyEmptyElementFound	TokenNameIdentifier
:	TokenNameCOLON
(	TokenNameLPAREN
fIsFragmentResolved	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
fCurrentChildDepth	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
fFoundDepth	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
reportError	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
key	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
arguments	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XNIException	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
fErrorReporter	TokenNameIdentifier
.	TokenNameDOT
getMessageFormatter	TokenNameIdentifier
(	TokenNameLPAREN
XPointerMessageFormatter	TokenNameIdentifier
.	TokenNameDOT
XPOINTER_DOMAIN	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
formatMessage	TokenNameIdentifier
(	TokenNameLPAREN
fErrorReporter	TokenNameIdentifier
.	TokenNameDOT
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
key	TokenNameIdentifier
,	TokenNameCOMMA
arguments	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
initErrorReporter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fErrorReporter	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
fErrorReporter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XMLErrorReporter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fErrorHandler	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
fErrorHandler	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XPointerErrorHandler	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fErrorReporter	TokenNameIdentifier
.	TokenNameDOT
putMessageFormatter	TokenNameIdentifier
(	TokenNameLPAREN
XPointerMessageFormatter	TokenNameIdentifier
.	TokenNameDOT
XPOINTER_DOMAIN	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
XPointerMessageFormatter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fSchemeName	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fSchemeData	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fShortHandPointerName	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fIsResolveElement	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fIsElementFound	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fWasOnlyEmptyElementFound	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fFoundDepth	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fCurrentChildPosition	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fCurrentChildDepth	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fIsFragmentResolved	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fShortHandPointer	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
initErrorReporter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
class	TokenNameclass
Tokens	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
XPTRTOKEN_ELEM_NCNAME	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
XPTRTOKEN_ELEM_CHILD	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fgTokenNames	TokenNameIdentifier
=	TokenNameEQUAL
{	TokenNameLBRACE
"XPTRTOKEN_ELEM_NCNAME"	TokenNameStringLiteral
,	TokenNameCOMMA
"XPTRTOKEN_ELEM_CHILD"	TokenNameStringLiteral
}	TokenNameRBRACE
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
INITIAL_TOKEN_COUNT	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fTokens	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
INITIAL_TOKEN_COUNT	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fTokenCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fCurrentTokenIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
SymbolTable	TokenNameIdentifier
fSymbolTable	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
HashMap	TokenNameIdentifier
fTokenNames	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
Tokens	TokenNameIdentifier
(	TokenNameLPAREN
SymbolTable	TokenNameIdentifier
symbolTable	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fSymbolTable	TokenNameIdentifier
=	TokenNameEQUAL
symbolTable	TokenNameIdentifier
;	TokenNameSEMICOLON
fTokenNames	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Integer	TokenNameIdentifier
(	TokenNameLPAREN
XPTRTOKEN_ELEM_NCNAME	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
"XPTRTOKEN_ELEM_NCNAME"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fTokenNames	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Integer	TokenNameIdentifier
(	TokenNameLPAREN
XPTRTOKEN_ELEM_CHILD	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
"XPTRTOKEN_ELEM_CHILD"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
String	TokenNameIdentifier
getTokenString	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
token	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
String	TokenNameIdentifier
)	TokenNameRPAREN
fTokenNames	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Integer	TokenNameIdentifier
(	TokenNameLPAREN
token	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Integer	TokenNameIdentifier
getToken	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
token	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
Integer	TokenNameIdentifier
)	TokenNameRPAREN
fTokenNames	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Integer	TokenNameIdentifier
(	TokenNameLPAREN
token	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
addToken	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
tokenStr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Integer	TokenNameIdentifier
tokenInt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Integer	TokenNameIdentifier
)	TokenNameRPAREN
fTokenNames	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
tokenStr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
tokenInt	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
tokenInt	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Integer	TokenNameIdentifier
(	TokenNameLPAREN
fTokenNames	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fTokenNames	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
tokenInt	TokenNameIdentifier
,	TokenNameCOMMA
tokenStr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
addToken	TokenNameIdentifier
(	TokenNameLPAREN
tokenInt	TokenNameIdentifier
.	TokenNameDOT
intValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
addToken	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
token	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
fTokens	TokenNameIdentifier
[	TokenNameLBRACKET
fTokenCount	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
token	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ArrayIndexOutOfBoundsException	TokenNameIdentifier
ex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
oldList	TokenNameIdentifier
=	TokenNameEQUAL
fTokens	TokenNameIdentifier
;	TokenNameSEMICOLON
fTokens	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
fTokenCount	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
oldList	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
fTokens	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
fTokenCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fTokens	TokenNameIdentifier
[	TokenNameLBRACKET
fTokenCount	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
token	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fTokenCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
rewind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fCurrentTokenIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
hasMore	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fCurrentTokenIndex	TokenNameIdentifier
<	TokenNameLESS
fTokenCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
nextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fCurrentTokenIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
fTokenCount	TokenNameIdentifier
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"XPointerElementSchemeProcessingError"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
fTokens	TokenNameIdentifier
[	TokenNameLBRACKET
fCurrentTokenIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
peekToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fCurrentTokenIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
fTokenCount	TokenNameIdentifier
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"XPointerElementSchemeProcessingError"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
fTokens	TokenNameIdentifier
[	TokenNameLBRACKET
fCurrentTokenIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
String	TokenNameIdentifier
nextTokenAsString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
String	TokenNameIdentifier
s	TokenNameIdentifier
=	TokenNameEQUAL
getTokenString	TokenNameIdentifier
(	TokenNameLPAREN
nextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
s	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"XPointerElementSchemeProcessingError"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
s	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
getTokenCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fTokenCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
class	TokenNameclass
Scanner	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
byte	TokenNamebyte
CHARTYPE_INVALID	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
CHARTYPE_OTHER	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
CHARTYPE_MINUS	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
,	TokenNameCOMMA
CHARTYPE_PERIOD	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
,	TokenNameCOMMA
CHARTYPE_SLASH	TokenNameIdentifier
=	TokenNameEQUAL
4	TokenNameIntegerLiteral
,	TokenNameCOMMA
CHARTYPE_DIGIT	TokenNameIdentifier
=	TokenNameEQUAL
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
CHARTYPE_LETTER	TokenNameIdentifier
=	TokenNameEQUAL
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
CHARTYPE_UNDERSCORE	TokenNameIdentifier
=	TokenNameEQUAL
7	TokenNameIntegerLiteral
,	TokenNameCOMMA
CHARTYPE_NONASCII	TokenNameIdentifier
=	TokenNameEQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fASCIICharMap	TokenNameIdentifier
=	TokenNameEQUAL
{	TokenNameLBRACE
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
2	TokenNameIntegerLiteral
,	TokenNameCOMMA
2	TokenNameIntegerLiteral
,	TokenNameCOMMA
4	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
7	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
}	TokenNameRBRACE
;	TokenNameSEMICOLON
private	TokenNameprivate
SymbolTable	TokenNameIdentifier
fSymbolTable	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Scanner	TokenNameIdentifier
(	TokenNameLPAREN
SymbolTable	TokenNameIdentifier
symbolTable	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fSymbolTable	TokenNameIdentifier
=	TokenNameEQUAL
symbolTable	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
scanExpr	TokenNameIdentifier
(	TokenNameLPAREN
SymbolTable	TokenNameIdentifier
symbolTable	TokenNameIdentifier
,	TokenNameCOMMA
Tokens	TokenNameIdentifier
tokens	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
data	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
currentOffset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
endOffset	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
nameOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
String	TokenNameIdentifier
nameHandle	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
currentOffset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
endOffset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
data	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
currentOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
byte	TokenNamebyte
chartype	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
ch	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0x80	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
CHARTYPE_NONASCII	TokenNameIdentifier
:	TokenNameCOLON
fASCIICharMap	TokenNameIdentifier
[	TokenNameLBRACKET
ch	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
chartype	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
CHARTYPE_SLASH	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
currentOffset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
endOffset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
addToken	TokenNameIdentifier
(	TokenNameLPAREN
tokens	TokenNameIdentifier
,	TokenNameCOMMA
Tokens	TokenNameIdentifier
.	TokenNameDOT
XPTRTOKEN_ELEM_CHILD	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
=	TokenNameEQUAL
data	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
currentOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
child	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
ch	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'0'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
child	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
child	TokenNameIdentifier
*	TokenNameMULTIPLY
10	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
ch	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
currentOffset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
endOffset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
data	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
currentOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
child	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"InvalidChildSequenceCharacter"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
new	TokenNamenew
Character	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
tokens	TokenNameIdentifier
.	TokenNameDOT
addToken	TokenNameIdentifier
(	TokenNameLPAREN
child	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
CHARTYPE_DIGIT	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
CHARTYPE_LETTER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
CHARTYPE_MINUS	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
CHARTYPE_NONASCII	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
CHARTYPE_OTHER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
CHARTYPE_PERIOD	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
CHARTYPE_UNDERSCORE	TokenNameIdentifier
:	TokenNameCOLON
nameOffset	TokenNameIdentifier
=	TokenNameEQUAL
currentOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
currentOffset	TokenNameIdentifier
=	TokenNameEQUAL
scanNCName	TokenNameIdentifier
(	TokenNameLPAREN
data	TokenNameIdentifier
,	TokenNameCOMMA
endOffset	TokenNameIdentifier
,	TokenNameCOMMA
currentOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentOffset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
nameOffset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"InvalidNCNameInElementSchemeData"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
data	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
currentOffset	TokenNameIdentifier
<	TokenNameLESS
endOffset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
data	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
currentOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nameHandle	TokenNameIdentifier
=	TokenNameEQUAL
symbolTable	TokenNameIdentifier
.	TokenNameDOT
addSymbol	TokenNameIdentifier
(	TokenNameLPAREN
data	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
nameOffset	TokenNameIdentifier
,	TokenNameCOMMA
currentOffset	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addToken	TokenNameIdentifier
(	TokenNameLPAREN
tokens	TokenNameIdentifier
,	TokenNameCOMMA
Tokens	TokenNameIdentifier
.	TokenNameDOT
XPTRTOKEN_ELEM_NCNAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tokens	TokenNameIdentifier
.	TokenNameDOT
addToken	TokenNameIdentifier
(	TokenNameLPAREN
nameHandle	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
scanNCName	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
data	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
endOffset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
currentOffset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
data	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
currentOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0x80	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XMLChar	TokenNameIdentifier
.	TokenNameDOT
isNameStart	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
currentOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
byte	TokenNamebyte
chartype	TokenNameIdentifier
=	TokenNameEQUAL
fASCIICharMap	TokenNameIdentifier
[	TokenNameLBRACKET
ch	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
chartype	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CHARTYPE_LETTER	TokenNameIdentifier
&&	TokenNameAND_AND
chartype	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CHARTYPE_UNDERSCORE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
currentOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
currentOffset	TokenNameIdentifier
<	TokenNameLESS
endOffset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
data	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
currentOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0x80	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XMLChar	TokenNameIdentifier
.	TokenNameDOT
isName	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
byte	TokenNamebyte
chartype	TokenNameIdentifier
=	TokenNameEQUAL
fASCIICharMap	TokenNameIdentifier
[	TokenNameLBRACKET
ch	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
chartype	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CHARTYPE_LETTER	TokenNameIdentifier
&&	TokenNameAND_AND
chartype	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CHARTYPE_DIGIT	TokenNameIdentifier
&&	TokenNameAND_AND
chartype	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CHARTYPE_PERIOD	TokenNameIdentifier
&&	TokenNameAND_AND
chartype	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CHARTYPE_MINUS	TokenNameIdentifier
&&	TokenNameAND_AND
chartype	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CHARTYPE_UNDERSCORE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
currentOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
addToken	TokenNameIdentifier
(	TokenNameLPAREN
Tokens	TokenNameIdentifier
tokens	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
token	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XNIException	TokenNameIdentifier
{	TokenNameLBRACE
tokens	TokenNameIdentifier
.	TokenNameDOT
addToken	TokenNameIdentifier
(	TokenNameLPAREN
token	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
