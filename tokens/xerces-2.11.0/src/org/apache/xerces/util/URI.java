package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
Serializable	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Locale	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
URI	TokenNameIdentifier
implements	TokenNameimplements
Serializable	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
MalformedURIException	TokenNameIdentifier
extends	TokenNameextends
IOException	TokenNameIdentifier
{	TokenNameLBRACE
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
serialVersionUID	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
6695054834342951930L	TokenNameLongLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_msg	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
p_msg	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
serialVersionUID	TokenNameIdentifier
=	TokenNameEQUAL
1601921774685357214L	TokenNameLongLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fgLookupTable	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
128	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
RESERVED_CHARACTERS	TokenNameIdentifier
=	TokenNameEQUAL
0x01	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MARK_CHARACTERS	TokenNameIdentifier
=	TokenNameEQUAL
0x02	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
SCHEME_CHARACTERS	TokenNameIdentifier
=	TokenNameEQUAL
0x04	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
USERINFO_CHARACTERS	TokenNameIdentifier
=	TokenNameEQUAL
0x08	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
ASCII_ALPHA_CHARACTERS	TokenNameIdentifier
=	TokenNameEQUAL
0x10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
ASCII_DIGIT_CHARACTERS	TokenNameIdentifier
=	TokenNameEQUAL
0x20	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
ASCII_HEX_CHARACTERS	TokenNameIdentifier
=	TokenNameEQUAL
0x40	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
PATH_CHARACTERS	TokenNameIdentifier
=	TokenNameEQUAL
0x80	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MASK_ALPHA_NUMERIC	TokenNameIdentifier
=	TokenNameEQUAL
ASCII_ALPHA_CHARACTERS	TokenNameIdentifier
|	TokenNameOR
ASCII_DIGIT_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MASK_UNRESERVED_MASK	TokenNameIdentifier
=	TokenNameEQUAL
MASK_ALPHA_NUMERIC	TokenNameIdentifier
|	TokenNameOR
MARK_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MASK_URI_CHARACTER	TokenNameIdentifier
=	TokenNameEQUAL
MASK_UNRESERVED_MASK	TokenNameIdentifier
|	TokenNameOR
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MASK_SCHEME_CHARACTER	TokenNameIdentifier
=	TokenNameEQUAL
MASK_ALPHA_NUMERIC	TokenNameIdentifier
|	TokenNameOR
SCHEME_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MASK_USERINFO_CHARACTER	TokenNameIdentifier
=	TokenNameEQUAL
MASK_UNRESERVED_MASK	TokenNameIdentifier
|	TokenNameOR
USERINFO_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MASK_PATH_CHARACTER	TokenNameIdentifier
=	TokenNameEQUAL
MASK_UNRESERVED_MASK	TokenNameIdentifier
|	TokenNameOR
PATH_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
static	TokenNamestatic
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
ASCII_DIGIT_CHARACTERS	TokenNameIdentifier
|	TokenNameOR
ASCII_HEX_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
'A'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'F'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
ASCII_ALPHA_CHARACTERS	TokenNameIdentifier
|	TokenNameOR
ASCII_HEX_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
0x00000020	TokenNameIntegerLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
ASCII_ALPHA_CHARACTERS	TokenNameIdentifier
|	TokenNameOR
ASCII_HEX_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
'G'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'Z'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
ASCII_ALPHA_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
0x00000020	TokenNameIntegerLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
ASCII_ALPHA_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
';'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'/'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'?'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
':'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'@'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'&'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'='	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'+'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'$'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
','	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'['	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
']'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
RESERVED_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'-'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
MARK_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'_'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
MARK_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'.'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
MARK_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'!'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
MARK_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'~'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
MARK_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'*'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
MARK_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'\''	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
MARK_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'('	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
MARK_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
')'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
MARK_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'+'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
SCHEME_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'-'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
SCHEME_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'.'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
SCHEME_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
';'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
USERINFO_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
':'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
USERINFO_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'&'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
USERINFO_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'='	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
USERINFO_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'+'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
USERINFO_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'$'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
USERINFO_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
','	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
USERINFO_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
';'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
PATH_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'/'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
PATH_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
':'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
PATH_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'@'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
PATH_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'&'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
PATH_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'='	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
PATH_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'+'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
PATH_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
'$'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
PATH_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
','	TokenNameCharacterLiteral
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
PATH_CHARACTERS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
String	TokenNameIdentifier
m_scheme	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
m_userinfo	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
m_host	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
m_port	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
m_regAuthority	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
m_path	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
m_queryString	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
m_fragment	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
DEBUG	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
public	TokenNamepublic
URI	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
URI	TokenNameIdentifier
(	TokenNameLPAREN
URI	TokenNameIdentifier
p_other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
initialize	TokenNameIdentifier
(	TokenNameLPAREN
p_other	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
URI	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_uriSpec	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
(	TokenNameLPAREN
URI	TokenNameIdentifier
)	TokenNameRPAREN
null	TokenNamenull
,	TokenNameCOMMA
p_uriSpec	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
URI	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_uriSpec	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
allowNonAbsoluteURI	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
(	TokenNameLPAREN
URI	TokenNameIdentifier
)	TokenNameRPAREN
null	TokenNamenull
,	TokenNameCOMMA
p_uriSpec	TokenNameIdentifier
,	TokenNameCOMMA
allowNonAbsoluteURI	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
URI	TokenNameIdentifier
(	TokenNameLPAREN
URI	TokenNameIdentifier
p_base	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_uriSpec	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
initialize	TokenNameIdentifier
(	TokenNameLPAREN
p_base	TokenNameIdentifier
,	TokenNameCOMMA
p_uriSpec	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
URI	TokenNameIdentifier
(	TokenNameLPAREN
URI	TokenNameIdentifier
p_base	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_uriSpec	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
allowNonAbsoluteURI	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
initialize	TokenNameIdentifier
(	TokenNameLPAREN
p_base	TokenNameIdentifier
,	TokenNameCOMMA
p_uriSpec	TokenNameIdentifier
,	TokenNameCOMMA
allowNonAbsoluteURI	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
URI	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_scheme	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_schemeSpecificPart	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_scheme	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
p_scheme	TokenNameIdentifier
.	TokenNameDOT
trim	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot construct URI with null/empty scheme!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
p_schemeSpecificPart	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
p_schemeSpecificPart	TokenNameIdentifier
.	TokenNameDOT
trim	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot construct URI with null/empty scheme-specific part!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
setScheme	TokenNameIdentifier
(	TokenNameLPAREN
p_scheme	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setPath	TokenNameIdentifier
(	TokenNameLPAREN
p_schemeSpecificPart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
URI	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_scheme	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_host	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_path	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_queryString	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_fragment	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
p_scheme	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
p_host	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
p_path	TokenNameIdentifier
,	TokenNameCOMMA
p_queryString	TokenNameIdentifier
,	TokenNameCOMMA
p_fragment	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
URI	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_scheme	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_userinfo	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_host	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
p_port	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_path	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_queryString	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_fragment	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_scheme	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
p_scheme	TokenNameIdentifier
.	TokenNameDOT
trim	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Scheme is required!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
p_host	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_userinfo	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Userinfo may not be specified if host is not specified!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
p_port	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Port may not be specified if host is not specified!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
p_path	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_path	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
'?'	TokenNameCharacterLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
p_queryString	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Query string cannot be specified in path and query string!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
p_path	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
p_fragment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Fragment cannot be specified in both the path and fragment!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
setScheme	TokenNameIdentifier
(	TokenNameLPAREN
p_scheme	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setHost	TokenNameIdentifier
(	TokenNameLPAREN
p_host	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setPort	TokenNameIdentifier
(	TokenNameLPAREN
p_port	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setUserinfo	TokenNameIdentifier
(	TokenNameLPAREN
p_userinfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setPath	TokenNameIdentifier
(	TokenNameLPAREN
p_path	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setQueryString	TokenNameIdentifier
(	TokenNameLPAREN
p_queryString	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setFragment	TokenNameIdentifier
(	TokenNameLPAREN
p_fragment	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
initialize	TokenNameIdentifier
(	TokenNameLPAREN
URI	TokenNameIdentifier
p_other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_scheme	TokenNameIdentifier
=	TokenNameEQUAL
p_other	TokenNameIdentifier
.	TokenNameDOT
getScheme	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_userinfo	TokenNameIdentifier
=	TokenNameEQUAL
p_other	TokenNameIdentifier
.	TokenNameDOT
getUserinfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_host	TokenNameIdentifier
=	TokenNameEQUAL
p_other	TokenNameIdentifier
.	TokenNameDOT
getHost	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_port	TokenNameIdentifier
=	TokenNameEQUAL
p_other	TokenNameIdentifier
.	TokenNameDOT
getPort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_regAuthority	TokenNameIdentifier
=	TokenNameEQUAL
p_other	TokenNameIdentifier
.	TokenNameDOT
getRegBasedAuthority	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_path	TokenNameIdentifier
=	TokenNameEQUAL
p_other	TokenNameIdentifier
.	TokenNameDOT
getPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_queryString	TokenNameIdentifier
=	TokenNameEQUAL
p_other	TokenNameIdentifier
.	TokenNameDOT
getQueryString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_fragment	TokenNameIdentifier
=	TokenNameEQUAL
p_other	TokenNameIdentifier
.	TokenNameDOT
getFragment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
initialize	TokenNameIdentifier
(	TokenNameLPAREN
URI	TokenNameIdentifier
p_base	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_uriSpec	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
allowNonAbsoluteURI	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
String	TokenNameIdentifier
uriSpec	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
uriSpecLen	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
uriSpec	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
uriSpec	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
p_base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
uriSpecLen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
allowNonAbsoluteURI	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_path	TokenNameIdentifier
=	TokenNameEQUAL
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot initialize URI with empty parameters."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
uriSpecLen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
initialize	TokenNameIdentifier
(	TokenNameLPAREN
p_base	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
colonIdx	TokenNameIdentifier
=	TokenNameEQUAL
uriSpec	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
colonIdx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
searchFrom	TokenNameIdentifier
=	TokenNameEQUAL
colonIdx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
slashIdx	TokenNameIdentifier
=	TokenNameEQUAL
uriSpec	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'/'	TokenNameCharacterLiteral
,	TokenNameCOMMA
searchFrom	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
queryIdx	TokenNameIdentifier
=	TokenNameEQUAL
uriSpec	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'?'	TokenNameCharacterLiteral
,	TokenNameCOMMA
searchFrom	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
fragmentIdx	TokenNameIdentifier
=	TokenNameEQUAL
uriSpec	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'#'	TokenNameCharacterLiteral
,	TokenNameCOMMA
searchFrom	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
colonIdx	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
slashIdx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
queryIdx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
fragmentIdx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
colonIdx	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
p_base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
fragmentIdx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
allowNonAbsoluteURI	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"No scheme found in URI."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
initializeScheme	TokenNameIdentifier
(	TokenNameLPAREN
uriSpec	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
index	TokenNameIdentifier
=	TokenNameEQUAL
m_scheme	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
colonIdx	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
uriSpecLen	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
colonIdx	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Scheme specific part cannot be empty."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
p_base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
uriSpec	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
allowNonAbsoluteURI	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"No scheme found in URI."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
<	TokenNameLESS
uriSpecLen	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'/'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'/'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
startPos	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
;	TokenNameSEMICOLON
char	TokenNamechar
testChar	TokenNameIdentifier
=	TokenNameEQUAL
'\0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
uriSpecLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'/'	TokenNameCharacterLiteral
||	TokenNameOR_OR
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'?'	TokenNameCharacterLiteral
||	TokenNameOR_OR
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
>	TokenNameGREATER
startPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
initializeAuthority	TokenNameIdentifier
(	TokenNameLPAREN
uriSpec	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startPos	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
=	TokenNameEQUAL
startPos	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_host	TokenNameIdentifier
=	TokenNameEQUAL
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
initializePath	TokenNameIdentifier
(	TokenNameLPAREN
uriSpec	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
p_base	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
absolutize	TokenNameIdentifier
(	TokenNameLPAREN
p_base	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
initialize	TokenNameIdentifier
(	TokenNameLPAREN
URI	TokenNameIdentifier
p_base	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
p_uriSpec	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
String	TokenNameIdentifier
uriSpec	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
uriSpecLen	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
uriSpec	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
uriSpec	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
p_base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
uriSpecLen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot initialize URI with empty parameters."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
uriSpecLen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
initialize	TokenNameIdentifier
(	TokenNameLPAREN
p_base	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
colonIdx	TokenNameIdentifier
=	TokenNameEQUAL
uriSpec	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
colonIdx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
searchFrom	TokenNameIdentifier
=	TokenNameEQUAL
colonIdx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
slashIdx	TokenNameIdentifier
=	TokenNameEQUAL
uriSpec	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'/'	TokenNameCharacterLiteral
,	TokenNameCOMMA
searchFrom	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
queryIdx	TokenNameIdentifier
=	TokenNameEQUAL
uriSpec	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'?'	TokenNameCharacterLiteral
,	TokenNameCOMMA
searchFrom	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
fragmentIdx	TokenNameIdentifier
=	TokenNameEQUAL
uriSpec	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'#'	TokenNameCharacterLiteral
,	TokenNameCOMMA
searchFrom	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
colonIdx	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
slashIdx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
queryIdx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
fragmentIdx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
colonIdx	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
p_base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
fragmentIdx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"No scheme found in URI."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
initializeScheme	TokenNameIdentifier
(	TokenNameLPAREN
uriSpec	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
index	TokenNameIdentifier
=	TokenNameEQUAL
m_scheme	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
colonIdx	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
uriSpecLen	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
colonIdx	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Scheme specific part cannot be empty."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
p_base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
uriSpec	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"No scheme found in URI."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
<	TokenNameLESS
uriSpecLen	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'/'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'/'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
startPos	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
;	TokenNameSEMICOLON
char	TokenNamechar
testChar	TokenNameIdentifier
=	TokenNameEQUAL
'\0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
uriSpecLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'/'	TokenNameCharacterLiteral
||	TokenNameOR_OR
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'?'	TokenNameCharacterLiteral
||	TokenNameOR_OR
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
>	TokenNameGREATER
startPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
initializeAuthority	TokenNameIdentifier
(	TokenNameLPAREN
uriSpec	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startPos	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
=	TokenNameEQUAL
startPos	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_host	TokenNameIdentifier
=	TokenNameEQUAL
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
initializePath	TokenNameIdentifier
(	TokenNameLPAREN
uriSpec	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
p_base	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
absolutize	TokenNameIdentifier
(	TokenNameLPAREN
p_base	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
absolutize	TokenNameIdentifier
(	TokenNameLPAREN
URI	TokenNameIdentifier
p_base	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_path	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_scheme	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
m_host	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
m_regAuthority	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_scheme	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getScheme	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_userinfo	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getUserinfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_host	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getHost	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_port	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getPort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_regAuthority	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getRegBasedAuthority	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_path	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_queryString	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_queryString	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getQueryString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_fragment	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_fragment	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getFragment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
m_scheme	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_scheme	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getScheme	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
m_host	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
m_regAuthority	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_userinfo	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getUserinfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_host	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getHost	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_port	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getPort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_regAuthority	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getRegBasedAuthority	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
m_path	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_path	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
"/"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
String	TokenNameIdentifier
path	TokenNameIdentifier
=	TokenNameEQUAL
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
String	TokenNameIdentifier
basePath	TokenNameIdentifier
=	TokenNameEQUAL
p_base	TokenNameIdentifier
.	TokenNameDOT
getPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
basePath	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
basePath	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
lastSlash	TokenNameIdentifier
=	TokenNameEQUAL
basePath	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'/'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lastSlash	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
path	TokenNameIdentifier
=	TokenNameEQUAL
basePath	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
lastSlash	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
m_path	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
path	TokenNameIdentifier
=	TokenNameEQUAL
"/"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
path	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
concat	TokenNameIdentifier
(	TokenNameLPAREN
m_path	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
"/./"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
path	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
.	TokenNameDOT
concat	TokenNameIdentifier
(	TokenNameLPAREN
path	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
path	TokenNameIdentifier
.	TokenNameDOT
endsWith	TokenNameIdentifier
(	TokenNameLPAREN
"/."	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
path	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
path	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
segIndex	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
String	TokenNameIdentifier
tempString	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
"/../"	TokenNameStringLiteral
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
tempString	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
path	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
"/../"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segIndex	TokenNameIdentifier
=	TokenNameEQUAL
tempString	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'/'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segIndex	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
tempString	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
segIndex	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
".."	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
path	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
segIndex	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
.	TokenNameDOT
concat	TokenNameIdentifier
(	TokenNameLPAREN
path	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
index	TokenNameIdentifier
=	TokenNameEQUAL
segIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
path	TokenNameIdentifier
.	TokenNameDOT
endsWith	TokenNameIdentifier
(	TokenNameLPAREN
"/.."	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
tempString	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
path	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segIndex	TokenNameIdentifier
=	TokenNameEQUAL
tempString	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'/'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segIndex	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
path	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
segIndex	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
m_path	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
initializeScheme	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_uriSpec	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
uriSpecLen	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
String	TokenNameIdentifier
scheme	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
char	TokenNamechar
testChar	TokenNameIdentifier
=	TokenNameEQUAL
'\0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
uriSpecLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
':'	TokenNameCharacterLiteral
||	TokenNameOR_OR
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'/'	TokenNameCharacterLiteral
||	TokenNameOR_OR
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'?'	TokenNameCharacterLiteral
||	TokenNameOR_OR
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
scheme	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
scheme	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"No scheme found in URI."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
setScheme	TokenNameIdentifier
(	TokenNameLPAREN
scheme	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
initializeAuthority	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_uriSpec	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
testChar	TokenNameIdentifier
=	TokenNameEQUAL
'\0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
String	TokenNameIdentifier
userinfo	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
'@'	TokenNameCharacterLiteral
,	TokenNameCOMMA
start	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'@'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
userinfo	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
String	TokenNameIdentifier
host	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
start	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
hasPort	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'['	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
bracketIndex	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
']'	TokenNameCharacterLiteral
,	TokenNameCOMMA
start	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
index	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bracketIndex	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
bracketIndex	TokenNameIdentifier
:	TokenNameCOLON
end	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
end	TokenNameIdentifier
&&	TokenNameAND_AND
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
;	TokenNameSEMICOLON
hasPort	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
index	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
colonIndex	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
':'	TokenNameCharacterLiteral
,	TokenNameCOMMA
end	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
index	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
colonIndex	TokenNameIdentifier
>	TokenNameGREATER
start	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
colonIndex	TokenNameIdentifier
:	TokenNameCOLON
end	TokenNameIdentifier
;	TokenNameSEMICOLON
hasPort	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
index	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
end	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
host	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
port	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
host	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hasPort	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
start	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
String	TokenNameIdentifier
portStr	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
portStr	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
port	TokenNameIdentifier
=	TokenNameEQUAL
Integer	TokenNameIdentifier
.	TokenNameDOT
parseInt	TokenNameIdentifier
(	TokenNameLPAREN
portStr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
port	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
--	TokenNameMINUS_MINUS
port	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NumberFormatException	TokenNameIdentifier
nfe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
port	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isValidServerBasedAuthority	TokenNameIdentifier
(	TokenNameLPAREN
host	TokenNameIdentifier
,	TokenNameCOMMA
port	TokenNameIdentifier
,	TokenNameCOMMA
userinfo	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
m_host	TokenNameIdentifier
=	TokenNameEQUAL
host	TokenNameIdentifier
;	TokenNameSEMICOLON
m_port	TokenNameIdentifier
=	TokenNameEQUAL
port	TokenNameIdentifier
;	TokenNameSEMICOLON
m_userinfo	TokenNameIdentifier
=	TokenNameEQUAL
userinfo	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
isValidRegistryBasedAuthority	TokenNameIdentifier
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
m_regAuthority	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
isValidServerBasedAuthority	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
host	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
port	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
userinfo	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isWellFormedAddress	TokenNameIdentifier
(	TokenNameLPAREN
host	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
port	TokenNameIdentifier
<	TokenNameLESS
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
port	TokenNameIdentifier
>	TokenNameGREATER
65535	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
userinfo	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
userinfo	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
testChar	TokenNameIdentifier
=	TokenNameEQUAL
'\0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
userinfo	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
>=	TokenNameGREATER_EQUAL
end	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
userinfo	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
userinfo	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isUserinfoCharacter	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
isValidRegistryBasedAuthority	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
authority	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
authority	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
testChar	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
authority	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
>=	TokenNameGREATER_EQUAL
end	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
authority	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
authority	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isPathCharacter	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
initializePath	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_uriSpec	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
p_nStartIndex	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot initialize path from null string!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
p_nStartIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
p_nStartIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
testChar	TokenNameIdentifier
=	TokenNameEQUAL
'\0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
start	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
getScheme	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'/'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
>=	TokenNameGREATER_EQUAL
end	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Path contains invalid escape sequence!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isPathCharacter	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'?'	TokenNameCharacterLiteral
||	TokenNameOR_OR
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Path contains invalid character: "	TokenNameStringLiteral
+	TokenNamePLUS
testChar	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'?'	TokenNameCharacterLiteral
||	TokenNameOR_OR
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
>=	TokenNameGREATER_EQUAL
end	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Opaque part contains invalid escape sequence!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isURICharacter	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Opaque part contains invalid character: "	TokenNameStringLiteral
+	TokenNamePLUS
testChar	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
m_path	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'?'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
start	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
>=	TokenNameGREATER_EQUAL
end	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Query string contains invalid escape sequence!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isURICharacter	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Query string contains invalid character: "	TokenNameStringLiteral
+	TokenNamePLUS
testChar	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_queryString	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
start	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
>=	TokenNameGREATER_EQUAL
end	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Fragment contains invalid escape sequence!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isURICharacter	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Fragment contains invalid character: "	TokenNameStringLiteral
+	TokenNamePLUS
testChar	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_fragment	TokenNameIdentifier
=	TokenNameEQUAL
p_uriSpec	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getScheme	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
m_scheme	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getSchemeSpecificPart	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuffer	TokenNameIdentifier
schemespec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_host	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
m_regAuthority	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"//"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_host	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_userinfo	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_userinfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'@'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_host	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_port	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_port	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_regAuthority	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
m_path	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
m_path	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
m_queryString	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'?'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_queryString	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
m_fragment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
schemespec	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_fragment	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
schemespec	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getUserinfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
m_userinfo	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getHost	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
m_host	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getPort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
m_port	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getRegBasedAuthority	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
m_regAuthority	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getAuthority	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuffer	TokenNameIdentifier
authority	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_host	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
m_regAuthority	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
authority	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"//"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_host	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_userinfo	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
authority	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_userinfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
authority	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'@'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
authority	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_host	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_port	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
authority	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
authority	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_port	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
authority	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_regAuthority	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
authority	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getPath	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
p_includeQueryString	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
p_includeFragment	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuffer	TokenNameIdentifier
pathString	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
m_path	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
p_includeQueryString	TokenNameIdentifier
&&	TokenNameAND_AND
m_queryString	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
pathString	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'?'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pathString	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_queryString	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
p_includeFragment	TokenNameIdentifier
&&	TokenNameAND_AND
m_fragment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
pathString	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pathString	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_fragment	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
pathString	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
m_path	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getQueryString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
m_queryString	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getFragment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
m_fragment	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setScheme	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_scheme	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_scheme	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot set scheme from null string!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isConformantSchemeName	TokenNameIdentifier
(	TokenNameLPAREN
p_scheme	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"The scheme is not conformant."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_scheme	TokenNameIdentifier
=	TokenNameEQUAL
p_scheme	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
Locale	TokenNameIdentifier
.	TokenNameDOT
ENGLISH	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setUserinfo	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_userinfo	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_userinfo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_userinfo	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_host	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Userinfo cannot be set when host is null!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
p_userinfo	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
testChar	TokenNameIdentifier
=	TokenNameEQUAL
'\0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
p_userinfo	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
>=	TokenNameGREATER_EQUAL
end	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_userinfo	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_userinfo	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Userinfo contains invalid escape sequence!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isUserinfoCharacter	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Userinfo contains invalid character:"	TokenNameStringLiteral
+	TokenNamePLUS
testChar	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
m_userinfo	TokenNameIdentifier
=	TokenNameEQUAL
p_userinfo	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setHost	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_host	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_host	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
p_host	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_host	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_regAuthority	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_host	TokenNameIdentifier
=	TokenNameEQUAL
p_host	TokenNameIdentifier
;	TokenNameSEMICOLON
m_userinfo	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
m_port	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isWellFormedAddress	TokenNameIdentifier
(	TokenNameLPAREN
p_host	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Host is not a well formed address!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_host	TokenNameIdentifier
=	TokenNameEQUAL
p_host	TokenNameIdentifier
;	TokenNameSEMICOLON
m_regAuthority	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPort	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
p_port	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_port	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
p_port	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
65535	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_host	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Port cannot be set when host is null!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
p_port	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Invalid port number!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_port	TokenNameIdentifier
=	TokenNameEQUAL
p_port	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setRegBasedAuthority	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
authority	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
authority	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_regAuthority	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
authority	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
<	TokenNameLESS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
isValidRegistryBasedAuthority	TokenNameIdentifier
(	TokenNameLPAREN
authority	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
authority	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
'/'	TokenNameCharacterLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Registry based authority is not well formed."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_regAuthority	TokenNameIdentifier
=	TokenNameEQUAL
authority	TokenNameIdentifier
;	TokenNameSEMICOLON
m_host	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
m_userinfo	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
m_port	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPath	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_path	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_path	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_path	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
m_queryString	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
m_fragment	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
initializePath	TokenNameIdentifier
(	TokenNameLPAREN
p_path	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
appendPath	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_addToPath	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_addToPath	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
p_addToPath	TokenNameIdentifier
.	TokenNameDOT
trim	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isURIString	TokenNameIdentifier
(	TokenNameLPAREN
p_addToPath	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Path contains invalid character!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
m_path	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
m_path	TokenNameIdentifier
.	TokenNameDOT
trim	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_addToPath	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
"/"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
m_path	TokenNameIdentifier
=	TokenNameEQUAL
p_addToPath	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_path	TokenNameIdentifier
=	TokenNameEQUAL
"/"	TokenNameStringLiteral
+	TokenNamePLUS
p_addToPath	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
m_path	TokenNameIdentifier
.	TokenNameDOT
endsWith	TokenNameIdentifier
(	TokenNameLPAREN
"/"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_addToPath	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
"/"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
m_path	TokenNameIdentifier
=	TokenNameEQUAL
m_path	TokenNameIdentifier
.	TokenNameDOT
concat	TokenNameIdentifier
(	TokenNameLPAREN
p_addToPath	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_path	TokenNameIdentifier
=	TokenNameEQUAL
m_path	TokenNameIdentifier
.	TokenNameDOT
concat	TokenNameIdentifier
(	TokenNameLPAREN
p_addToPath	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_addToPath	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
"/"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
m_path	TokenNameIdentifier
=	TokenNameEQUAL
m_path	TokenNameIdentifier
.	TokenNameDOT
concat	TokenNameIdentifier
(	TokenNameLPAREN
p_addToPath	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_path	TokenNameIdentifier
=	TokenNameEQUAL
m_path	TokenNameIdentifier
.	TokenNameDOT
concat	TokenNameIdentifier
(	TokenNameLPAREN
"/"	TokenNameStringLiteral
+	TokenNamePLUS
p_addToPath	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setQueryString	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_queryString	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_queryString	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_queryString	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isGenericURI	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Query string can only be set for a generic URI!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
getPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Query string cannot be set when path is null!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isURIString	TokenNameIdentifier
(	TokenNameLPAREN
p_queryString	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Query string contains invalid character!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_queryString	TokenNameIdentifier
=	TokenNameEQUAL
p_queryString	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setFragment	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_fragment	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MalformedURIException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_fragment	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_fragment	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isGenericURI	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Fragment can only be set for a generic URI!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
getPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Fragment cannot be set when path is null!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isURIString	TokenNameIdentifier
(	TokenNameLPAREN
p_fragment	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MalformedURIException	TokenNameIdentifier
(	TokenNameLPAREN
"Fragment contains invalid character!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_fragment	TokenNameIdentifier
=	TokenNameEQUAL
p_fragment	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
p_test	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_test	TokenNameIdentifier
instanceof	TokenNameinstanceof
URI	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
URI	TokenNameIdentifier
testURI	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
URI	TokenNameIdentifier
)	TokenNameRPAREN
p_test	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
m_scheme	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_scheme	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
m_scheme	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_scheme	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
m_scheme	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
testURI	TokenNameIdentifier
.	TokenNameDOT
m_scheme	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
m_userinfo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_userinfo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
m_userinfo	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_userinfo	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
m_userinfo	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
testURI	TokenNameIdentifier
.	TokenNameDOT
m_userinfo	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
m_host	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_host	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
m_host	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_host	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
m_host	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
testURI	TokenNameIdentifier
.	TokenNameDOT
m_host	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
m_port	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
testURI	TokenNameIdentifier
.	TokenNameDOT
m_port	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
m_path	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_path	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
m_path	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_path	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
m_path	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
testURI	TokenNameIdentifier
.	TokenNameDOT
m_path	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
m_queryString	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_queryString	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
m_queryString	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_queryString	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
m_queryString	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
testURI	TokenNameIdentifier
.	TokenNameDOT
m_queryString	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
m_fragment	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_fragment	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
m_fragment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
testURI	TokenNameIdentifier
.	TokenNameDOT
m_fragment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
m_fragment	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
testURI	TokenNameIdentifier
.	TokenNameDOT
m_fragment	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuffer	TokenNameIdentifier
uriSpecString	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_scheme	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
uriSpecString	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_scheme	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uriSpecString	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
uriSpecString	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
getSchemeSpecificPart	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
uriSpecString	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isGenericURI	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
m_host	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isAbsoluteURI	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
m_scheme	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
isConformantSchemeName	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_scheme	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_scheme	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
p_scheme	TokenNameIdentifier
.	TokenNameDOT
trim	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isAlpha	TokenNameIdentifier
(	TokenNameLPAREN
p_scheme	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
char	TokenNamechar
testChar	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
schemeLength	TokenNameIdentifier
=	TokenNameEQUAL
p_scheme	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
schemeLength	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
p_scheme	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isSchemeCharacter	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
isWellFormedAddress	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
address	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
address	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
addrLength	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
addrLength	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
"["	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
isWellFormedIPv6Reference	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
"."	TokenNameStringLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
address	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
"-"	TokenNameStringLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
address	TokenNameIdentifier
.	TokenNameDOT
endsWith	TokenNameIdentifier
(	TokenNameLPAREN
"-"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'.'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
endsWith	TokenNameIdentifier
(	TokenNameLPAREN
"."	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
index	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
lastIndexOf	TokenNameIdentifier
(	TokenNameLPAREN
'.'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
addrLength	TokenNameIdentifier
&&	TokenNameAND_AND
isDigit	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
isWellFormedIPv4Address	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
addrLength	TokenNameIdentifier
>	TokenNameGREATER
255	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
char	TokenNamechar
testChar	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
labelCharCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
addrLength	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'.'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isAlphanum	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
addrLength	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
isAlphanum	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
labelCharCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isAlphanum	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
testChar	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'-'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
labelCharCount	TokenNameIdentifier
>	TokenNameGREATER
63	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
isWellFormedIPv4Address	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
address	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
addrLength	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
testChar	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
numDots	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
numDigits	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
addrLength	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'.'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
i	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
isDigit	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
addrLength	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
isDigit	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
numDigits	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
numDots	TokenNameIdentifier
>	TokenNameGREATER
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isDigit	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
numDigits	TokenNameIdentifier
>	TokenNameGREATER
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
numDigits	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
first	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
second	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
first	TokenNameIdentifier
<	TokenNameLESS
'2'	TokenNameCharacterLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
first	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'2'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
second	TokenNameIdentifier
<	TokenNameLESS
'5'	TokenNameCharacterLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
second	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'5'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
testChar	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'5'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
numDots	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
isWellFormedIPv6Reference	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
address	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
addrLength	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
addrLength	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
addrLength	TokenNameIdentifier
>	TokenNameGREATER
2	TokenNameIntegerLiteral
&&	TokenNameAND_AND
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'['	TokenNameCharacterLiteral
&&	TokenNameAND_AND
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
']'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
counter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
index	TokenNameIdentifier
=	TokenNameEQUAL
scanHexSequence	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
,	TokenNameCOMMA
counter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
counter	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
end	TokenNameIdentifier
&&	TokenNameAND_AND
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
counter	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
>	TokenNameGREATER
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
index	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
counter	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
isWellFormedIPv4Address	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
end	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
prevCount	TokenNameIdentifier
=	TokenNameEQUAL
counter	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
index	TokenNameIdentifier
=	TokenNameEQUAL
scanHexSequence	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
,	TokenNameCOMMA
counter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
index	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
end	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
index	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
isWellFormedIPv4Address	TokenNameIdentifier
(	TokenNameLPAREN
address	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
counter	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
>	TokenNameGREATER
prevCount	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
index	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
int	TokenNameint
scanHexSequence	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
address	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
index	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
end	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
counter	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
testChar	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
numDigits	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
numDigits	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
++	TokenNamePLUS_PLUS
counter	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
>	TokenNameGREATER
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
numDigits	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
address	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
index	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
numDigits	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'.'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
numDigits	TokenNameIdentifier
<	TokenNameLESS
4	TokenNameIntegerLiteral
&&	TokenNameAND_AND
numDigits	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
counter	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
<=	TokenNameLESS_EQUAL
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
back	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
-	TokenNameMINUS
numDigits	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
back	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
start	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
back	TokenNameIdentifier
:	TokenNameCOLON
(	TokenNameLPAREN
back	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
numDigits	TokenNameIdentifier
>	TokenNameGREATER
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
numDigits	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
++	TokenNamePLUS_PLUS
counter	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
<=	TokenNameLESS_EQUAL
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
end	TokenNameIdentifier
:	TokenNameCOLON
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isDigit	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
p_char	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
p_char	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'0'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isHex	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
p_char	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'f'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
p_char	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
ASCII_HEX_CHARACTERS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isAlpha	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
p_char	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
p_char	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'a'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'z'	TokenNameCharacterLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
p_char	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'A'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'Z'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isAlphanum	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
p_char	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'z'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
p_char	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
MASK_ALPHA_NUMERIC	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isReservedCharacter	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
p_char	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
']'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
p_char	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
RESERVED_CHARACTERS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isUnreservedCharacter	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
p_char	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'~'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
p_char	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
MASK_UNRESERVED_MASK	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isURICharacter	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
p_char	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'~'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
p_char	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
MASK_URI_CHARACTER	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isSchemeCharacter	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
p_char	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'z'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
p_char	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
MASK_SCHEME_CHARACTER	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isUserinfoCharacter	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
p_char	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'z'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
p_char	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
MASK_USERINFO_CHARACTER	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isPathCharacter	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
p_char	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
p_char	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'~'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fgLookupTable	TokenNameIdentifier
[	TokenNameLBRACKET
p_char	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
MASK_PATH_CHARACTER	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
isURIString	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
p_uric	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p_uric	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
p_uric	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
testChar	TokenNameIdentifier
=	TokenNameEQUAL
'\0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
testChar	TokenNameIdentifier
=	TokenNameEQUAL
p_uric	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
testChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
>=	TokenNameGREATER_EQUAL
end	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_uric	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isHex	TokenNameIdentifier
(	TokenNameLPAREN
p_uric	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
i	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isURICharacter	TokenNameIdentifier
(	TokenNameLPAREN
testChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
