package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
class	TokenNameclass
Base64	TokenNameIdentifier
{	TokenNameLBRACE
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
BASELENGTH	TokenNameIdentifier
=	TokenNameEQUAL
128	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
LOOKUPLENGTH	TokenNameIdentifier
=	TokenNameEQUAL
64	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
TWENTYFOURBITGROUP	TokenNameIdentifier
=	TokenNameEQUAL
24	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
EIGHTBIT	TokenNameIdentifier
=	TokenNameEQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
SIXTEENBIT	TokenNameIdentifier
=	TokenNameEQUAL
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
SIXBIT	TokenNameIdentifier
=	TokenNameEQUAL
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
FOURBYTE	TokenNameIdentifier
=	TokenNameEQUAL
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
SIGN	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
128	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
char	TokenNamechar
PAD	TokenNameIdentifier
=	TokenNameEQUAL
'='	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
fDebug	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
private	TokenNameprivate
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
base64Alphabet	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
BASELENGTH	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
private	TokenNameprivate
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
lookUpBase64Alphabet	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
LOOKUPLENGTH	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
static	TokenNamestatic
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
BASELENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
'Z'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'A'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
i	TokenNameIdentifier
-	TokenNameMINUS
'A'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
'z'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'a'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
i	TokenNameIdentifier
-	TokenNameMINUS
'a'	TokenNameCharacterLiteral
+	TokenNamePLUS
26	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
'9'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
i	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
+	TokenNamePLUS
52	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
'+'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
62	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
'/'	TokenNameCharacterLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
63	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
25	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
'A'	TokenNameCharacterLiteral
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
26	TokenNameIntegerLiteral
,	TokenNameCOMMA
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
51	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
'a'	TokenNameCharacterLiteral
+	TokenNamePLUS
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
52	TokenNameIntegerLiteral
,	TokenNameCOMMA
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
61	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
'0'	TokenNameCharacterLiteral
+	TokenNamePLUS
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
62	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
'+'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
63	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
'/'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
static	TokenNamestatic
boolean	TokenNameboolean
isWhiteSpace	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
octect	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
octect	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x20	TokenNameIntegerLiteral
||	TokenNameOR_OR
octect	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0xd	TokenNameIntegerLiteral
||	TokenNameOR_OR
octect	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0xa	TokenNameIntegerLiteral
||	TokenNameOR_OR
octect	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x9	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
static	TokenNamestatic
boolean	TokenNameboolean
isPad	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
octect	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
octect	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
PAD	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
static	TokenNamestatic
boolean	TokenNameboolean
isData	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
octect	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
octect	TokenNameIdentifier
<	TokenNameLESS
BASELENGTH	TokenNameIdentifier
&&	TokenNameAND_AND
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
octect	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
static	TokenNamestatic
boolean	TokenNameboolean
isBase64	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
octect	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
isWhiteSpace	TokenNameIdentifier
(	TokenNameLPAREN
octect	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
isPad	TokenNameIdentifier
(	TokenNameLPAREN
octect	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
isData	TokenNameIdentifier
(	TokenNameLPAREN
octect	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
String	TokenNameIdentifier
encode	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
binaryData	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
binaryData	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
lengthDataBits	TokenNameIdentifier
=	TokenNameEQUAL
binaryData	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
*	TokenNameMULTIPLY
EIGHTBIT	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lengthDataBits	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
fewerThan24bits	TokenNameIdentifier
=	TokenNameEQUAL
lengthDataBits	TokenNameIdentifier
%	TokenNameREMAINDER
TWENTYFOURBITGROUP	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
numberTriplets	TokenNameIdentifier
=	TokenNameEQUAL
lengthDataBits	TokenNameIdentifier
/	TokenNameDIVIDE
TWENTYFOURBITGROUP	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
numberQuartet	TokenNameIdentifier
=	TokenNameEQUAL
fewerThan24bits	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
numberTriplets	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
numberTriplets	TokenNameIdentifier
;	TokenNameSEMICOLON
char	TokenNamechar
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
numberQuartet	TokenNameIdentifier
*	TokenNameMULTIPLY
4	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
byte	TokenNamebyte
k	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
l	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
b1	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
b2	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
b3	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
encodedIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
dataIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fDebug	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"number of triplets = "	TokenNameStringLiteral
+	TokenNamePLUS
numberTriplets	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numberTriplets	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
b1	TokenNameIdentifier
=	TokenNameEQUAL
binaryData	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
b2	TokenNameIdentifier
=	TokenNameEQUAL
binaryData	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
b3	TokenNameIdentifier
=	TokenNameEQUAL
binaryData	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fDebug	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"b1= "	TokenNameStringLiteral
+	TokenNamePLUS
b1	TokenNameIdentifier
+	TokenNamePLUS
", b2= "	TokenNameStringLiteral
+	TokenNamePLUS
b2	TokenNameIdentifier
+	TokenNamePLUS
", b3= "	TokenNameStringLiteral
+	TokenNamePLUS
b3	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
l	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
&	TokenNameAND
0x0f	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
k	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
&	TokenNameAND
0x03	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
byte	TokenNamebyte
val1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
&	TokenNameAND
SIGN	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
2	TokenNameIntegerLiteral
^	TokenNameXOR
0xc0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
byte	TokenNamebyte
val2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
&	TokenNameAND
SIGN	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
4	TokenNameIntegerLiteral
^	TokenNameXOR
0xf0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
byte	TokenNamebyte
val3	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
b3	TokenNameIdentifier
&	TokenNameAND
SIGN	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b3	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b3	TokenNameIdentifier
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
^	TokenNameXOR
0xfc	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fDebug	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"val2 = "	TokenNameStringLiteral
+	TokenNamePLUS
val2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"k4   = "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
k	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"vak  = "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
val2	TokenNameIdentifier
|	TokenNameOR
(	TokenNameLPAREN
k	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
val1	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
val2	TokenNameIdentifier
|	TokenNameOR
(	TokenNameLPAREN
k	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
(	TokenNameLPAREN
l	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
val3	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
b3	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fewerThan24bits	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
EIGHTBIT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
b1	TokenNameIdentifier
=	TokenNameEQUAL
binaryData	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
k	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
&	TokenNameAND
0x03	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fDebug	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"b1="	TokenNameStringLiteral
+	TokenNamePLUS
b1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"b1<<2 = "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
b1	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
byte	TokenNamebyte
val1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
&	TokenNameAND
SIGN	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
2	TokenNameIntegerLiteral
^	TokenNameXOR
0xc0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
val1	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
PAD	TokenNameIdentifier
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
PAD	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fewerThan24bits	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SIXTEENBIT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
b1	TokenNameIdentifier
=	TokenNameEQUAL
binaryData	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
b2	TokenNameIdentifier
=	TokenNameEQUAL
binaryData	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
l	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
&	TokenNameAND
0x0f	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
k	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
&	TokenNameAND
0x03	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
byte	TokenNamebyte
val1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
&	TokenNameAND
SIGN	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
2	TokenNameIntegerLiteral
^	TokenNameXOR
0xc0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
byte	TokenNamebyte
val2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
&	TokenNameAND
SIGN	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
4	TokenNameIntegerLiteral
^	TokenNameXOR
0xf0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
val1	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
val2	TokenNameIdentifier
|	TokenNameOR
(	TokenNameLPAREN
k	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
lookUpBase64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
l	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
encodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
PAD	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
String	TokenNameIdentifier
(	TokenNameLPAREN
encodedData	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
decode	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
encoded	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
encoded	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
base64Data	TokenNameIdentifier
=	TokenNameEQUAL
encoded	TokenNameIdentifier
.	TokenNameDOT
toCharArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
removeWhiteSpace	TokenNameIdentifier
(	TokenNameLPAREN
base64Data	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
len	TokenNameIdentifier
%	TokenNameREMAINDER
FOURBYTE	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
numberQuadruple	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
len	TokenNameIdentifier
/	TokenNameDIVIDE
FOURBYTE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numberQuadruple	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
byte	TokenNamebyte
decodedData	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
byte	TokenNamebyte
b1	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
b2	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
b3	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
b4	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
char	TokenNamechar
d1	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
d2	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
d3	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
d4	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
encodedIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
dataIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
decodedData	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
(	TokenNameLPAREN
numberQuadruple	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numberQuadruple	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isData	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
d1	TokenNameIdentifier
=	TokenNameEQUAL
base64Data	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isData	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
d2	TokenNameIdentifier
=	TokenNameEQUAL
base64Data	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isData	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
d3	TokenNameIdentifier
=	TokenNameEQUAL
base64Data	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isData	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
d4	TokenNameIdentifier
=	TokenNameEQUAL
base64Data	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
b1	TokenNameIdentifier
=	TokenNameEQUAL
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
d1	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
b2	TokenNameIdentifier
=	TokenNameEQUAL
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
d2	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
b3	TokenNameIdentifier
=	TokenNameEQUAL
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
d3	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
b4	TokenNameIdentifier
=	TokenNameEQUAL
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
d4	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
decodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
2	TokenNameIntegerLiteral
|	TokenNameOR
b2	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
decodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
&	TokenNameAND
0xf	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
b3	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0xf	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
decodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b3	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
|	TokenNameOR
b4	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isData	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
d1	TokenNameIdentifier
=	TokenNameEQUAL
base64Data	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isData	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
d2	TokenNameIdentifier
=	TokenNameEQUAL
base64Data	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
b1	TokenNameIdentifier
=	TokenNameEQUAL
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
d1	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
b2	TokenNameIdentifier
=	TokenNameEQUAL
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
d2	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
d3	TokenNameIdentifier
=	TokenNameEQUAL
base64Data	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
d4	TokenNameIdentifier
=	TokenNameEQUAL
base64Data	TokenNameIdentifier
[	TokenNameLBRACKET
dataIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isData	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
d3	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
!	TokenNameNOT
isData	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
d4	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isPad	TokenNameIdentifier
(	TokenNameLPAREN
d3	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
isPad	TokenNameIdentifier
(	TokenNameLPAREN
d4	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
&	TokenNameAND
0xf	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
tmp	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
i	TokenNameIdentifier
*	TokenNameMULTIPLY
3	TokenNameIntegerLiteral
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
decodedData	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
tmp	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
i	TokenNameIdentifier
*	TokenNameMULTIPLY
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tmp	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
2	TokenNameIntegerLiteral
|	TokenNameOR
b2	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tmp	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isPad	TokenNameIdentifier
(	TokenNameLPAREN
d3	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
isPad	TokenNameIdentifier
(	TokenNameLPAREN
d4	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
b3	TokenNameIdentifier
=	TokenNameEQUAL
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
d3	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
b3	TokenNameIdentifier
&	TokenNameAND
0x3	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
tmp	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
i	TokenNameIdentifier
*	TokenNameMULTIPLY
3	TokenNameIntegerLiteral
+	TokenNamePLUS
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
decodedData	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
tmp	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
i	TokenNameIdentifier
*	TokenNameMULTIPLY
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tmp	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
2	TokenNameIntegerLiteral
|	TokenNameOR
b2	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tmp	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
&	TokenNameAND
0xf	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
b3	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0xf	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tmp	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
b3	TokenNameIdentifier
=	TokenNameEQUAL
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
d3	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
b4	TokenNameIdentifier
=	TokenNameEQUAL
base64Alphabet	TokenNameIdentifier
[	TokenNameLBRACKET
d4	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
decodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b1	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
2	TokenNameIntegerLiteral
|	TokenNameOR
b2	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
decodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b2	TokenNameIdentifier
&	TokenNameAND
0xf	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
b3	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0xf	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
decodedData	TokenNameIdentifier
[	TokenNameLBRACKET
encodedIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
b3	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
|	TokenNameOR
b4	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
decodedData	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
static	TokenNamestatic
int	TokenNameint
removeWhiteSpace	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
data	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
data	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
newSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
data	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isWhiteSpace	TokenNameIdentifier
(	TokenNameLPAREN
data	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
data	TokenNameIdentifier
[	TokenNameLBRACKET
newSize	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
data	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
newSize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
