package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
math	TokenNameIdentifier
.	TokenNameDOT
BigInteger	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
AbstractList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Locale	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
StringTokenizer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Vector	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
Constants	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
DatatypeException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
InvalidDatatypeFacetException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
InvalidDatatypeValueException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
ValidatedInfo	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
ValidationContext	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
XSFacets	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
XSSimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
RegularExpression	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
SchemaSymbols	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ObjectListImpl	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ShortListImpl	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
StringListImpl	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
XSObjectListImpl	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
XMLChar	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xni	TokenNameIdentifier
.	TokenNameDOT
NamespaceContext	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
ShortList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
StringList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSConstants	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSFacet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSMultiValueFacet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSNamespaceItem	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSObject	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSObjectList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSSimpleTypeDefinition	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSTypeDefinition	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
datatypes	TokenNameIdentifier
.	TokenNameDOT
ObjectList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
TypeInfo	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
XSSimpleTypeDecl	TokenNameIdentifier
implements	TokenNameimplements
XSSimpleType	TokenNameIdentifier
,	TokenNameCOMMA
TypeInfo	TokenNameIdentifier
{	TokenNameLBRACE
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_STRING	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_BOOLEAN	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_BOOLEAN	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_DECIMAL	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_DECIMAL	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_FLOAT	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_FLOAT	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_DOUBLE	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_DOUBLE	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_DURATION	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_DURATION	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_DATETIME	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_DATETIME	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_TIME	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_TIME	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_DATE	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_DATE	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_GYEARMONTH	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_GYEARMONTH	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_GYEAR	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_GYEAR	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_GMONTHDAY	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_GMONTHDAY	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_GDAY	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_GDAY	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_GMONTH	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_GMONTH	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_HEXBINARY	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_HEXBINARY	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_BASE64BINARY	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_BASE64BINARY	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_ANYURI	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_ANYURI	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_QNAME	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_QNAME	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_PRECISIONDECIMAL	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_PRECISIONDECIMAL	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_NOTATION	TokenNameIdentifier
=	TokenNameEQUAL
PRIMITIVE_NOTATION	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_ANYSIMPLETYPE	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_ID	TokenNameIdentifier
=	TokenNameEQUAL
DV_NOTATION	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_IDREF	TokenNameIdentifier
=	TokenNameEQUAL
DV_NOTATION	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_ENTITY	TokenNameIdentifier
=	TokenNameEQUAL
DV_NOTATION	TokenNameIdentifier
+	TokenNamePLUS
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_INTEGER	TokenNameIdentifier
=	TokenNameEQUAL
DV_NOTATION	TokenNameIdentifier
+	TokenNamePLUS
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_LIST	TokenNameIdentifier
=	TokenNameEQUAL
DV_NOTATION	TokenNameIdentifier
+	TokenNamePLUS
5	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_UNION	TokenNameIdentifier
=	TokenNameEQUAL
DV_NOTATION	TokenNameIdentifier
+	TokenNamePLUS
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_YEARMONTHDURATION	TokenNameIdentifier
=	TokenNameEQUAL
DV_NOTATION	TokenNameIdentifier
+	TokenNamePLUS
7	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_DAYTIMEDURATION	TokenNameIdentifier
=	TokenNameEQUAL
DV_NOTATION	TokenNameIdentifier
+	TokenNamePLUS
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DV_ANYATOMICTYPE	TokenNameIdentifier
=	TokenNameEQUAL
DV_NOTATION	TokenNameIdentifier
+	TokenNamePLUS
9	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
TypeValidator	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
gDVs	TokenNameIdentifier
=	TokenNameEQUAL
{	TokenNameLBRACE
new	TokenNamenew
AnySimpleDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
StringDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
BooleanDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
DecimalDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
FloatDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
DoubleDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
DurationDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
DateTimeDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
TimeDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
DateDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
YearMonthDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
YearDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
MonthDayDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
DayDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
MonthDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
HexBinaryDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
Base64BinaryDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
AnyURIDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
QNameDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
PrecisionDecimalDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
QNameDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
IDDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
IDREFDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
EntityDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
IntegerDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
ListDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
UnionDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
YearMonthDurationDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
DayTimeDurationDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
AnyAtomicDV	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
NORMALIZE_NONE	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
NORMALIZE_TRIM	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
NORMALIZE_FULL	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fDVNormalizeType	TokenNameIdentifier
=	TokenNameEQUAL
{	TokenNameLBRACE
NORMALIZE_NONE	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_FULL	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_NONE	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_FULL	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_NONE	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_TRIM	TokenNameIdentifier
,	TokenNameCOMMA
NORMALIZE_NONE	TokenNameIdentifier
,	TokenNameCOMMA
}	TokenNameRBRACE
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
SPECIAL_PATTERN_NONE	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
SPECIAL_PATTERN_NMTOKEN	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
SPECIAL_PATTERN_NAME	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
SPECIAL_PATTERN_NCNAME	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
SPECIAL_PATTERN_STRING	TokenNameIdentifier
=	TokenNameEQUAL
{	TokenNameLBRACE
"NONE"	TokenNameStringLiteral
,	TokenNameCOMMA
"NMTOKEN"	TokenNameStringLiteral
,	TokenNameCOMMA
"Name"	TokenNameStringLiteral
,	TokenNameCOMMA
"NCName"	TokenNameStringLiteral
}	TokenNameRBRACE
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
WS_FACET_STRING	TokenNameIdentifier
=	TokenNameEQUAL
{	TokenNameLBRACE
"preserve"	TokenNameStringLiteral
,	TokenNameCOMMA
"replace"	TokenNameStringLiteral
,	TokenNameCOMMA
"collapse"	TokenNameStringLiteral
}	TokenNameRBRACE
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
String	TokenNameIdentifier
URI_SCHEMAFORSCHEMA	TokenNameIdentifier
=	TokenNameEQUAL
"http://www.w3.org/2001/XMLSchema"	TokenNameStringLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
String	TokenNameIdentifier
ANY_TYPE	TokenNameIdentifier
=	TokenNameEQUAL
"anyType"	TokenNameStringLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
YEARMONTHDURATION_DT	TokenNameIdentifier
=	TokenNameEQUAL
46	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
DAYTIMEDURATION_DT	TokenNameIdentifier
=	TokenNameEQUAL
47	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
PRECISIONDECIMAL_DT	TokenNameIdentifier
=	TokenNameEQUAL
48	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
short	TokenNameshort
ANYATOMICTYPE_DT	TokenNameIdentifier
=	TokenNameEQUAL
49	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DERIVATION_ANY	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DERIVATION_RESTRICTION	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DERIVATION_EXTENSION	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DERIVATION_UNION	TokenNameIdentifier
=	TokenNameEQUAL
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DERIVATION_LIST	TokenNameIdentifier
=	TokenNameEQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
ValidationContext	TokenNameIdentifier
fEmptyContext	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ValidationContext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
boolean	TokenNameboolean
needFacetChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
needExtraChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
needToNormalize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
useNamespaces	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isEntityDeclared	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isEntityUnparsed	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isIdDeclared	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addId	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addIdRef	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getSymbol	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
symbol	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
symbol	TokenNameIdentifier
.	TokenNameDOT
intern	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getURI	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
prefix	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Locale	TokenNameIdentifier
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
Locale	TokenNameIdentifier
.	TokenNameDOT
getDefault	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
TypeValidator	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getGDVs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
TypeValidator	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
)	TokenNameRPAREN
gDVs	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
TypeValidator	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fDVs	TokenNameIdentifier
=	TokenNameEQUAL
gDVs	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
void	TokenNamevoid
setDVs	TokenNameIdentifier
(	TokenNameLPAREN
TypeValidator	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
dvs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fDVs	TokenNameIdentifier
=	TokenNameEQUAL
dvs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
fIsImmutable	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
XSSimpleTypeDecl	TokenNameIdentifier
fItemType	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
XSSimpleTypeDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fMemberTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
short	TokenNameshort
fBuiltInKind	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
fTypeName	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
fTargetNamespace	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
short	TokenNameshort
fFinalSet	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
XSSimpleTypeDecl	TokenNameIdentifier
fBase	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
short	TokenNameshort
fVariety	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
short	TokenNameshort
fValidationDV	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
short	TokenNameshort
fFacetsDefined	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
short	TokenNameshort
fFixedFacet	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
short	TokenNameshort
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fLength	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fMinLength	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fMaxLength	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fTotalDigits	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fFractionDigits	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
Vector	TokenNameIdentifier
fPattern	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Vector	TokenNameIdentifier
fPatternStr	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
ValidatedInfo	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fEnumeration	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fEnumerationSize	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
ShortList	TokenNameIdentifier
fEnumerationTypeList	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
ObjectList	TokenNameIdentifier
fEnumerationItemTypeList	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
StringList	TokenNameIdentifier
fLexicalPattern	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
StringList	TokenNameIdentifier
fLexicalEnumeration	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
ObjectList	TokenNameIdentifier
fActualEnumeration	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Object	TokenNameIdentifier
fMaxInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Object	TokenNameIdentifier
fMaxExclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Object	TokenNameIdentifier
fMinExclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Object	TokenNameIdentifier
fMinInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
lengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
minLengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
maxLengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
whiteSpaceAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
totalDigitsAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
fractionDigitsAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSObjectListImpl	TokenNameIdentifier
patternAnnotations	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSObjectList	TokenNameIdentifier
enumerationAnnotations	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
maxInclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
maxExclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
minInclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
minExclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
XSObjectListImpl	TokenNameIdentifier
fFacets	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
XSObjectListImpl	TokenNameIdentifier
fMultiValueFacets	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
XSObjectList	TokenNameIdentifier
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
short	TokenNameshort
fPatternType	TokenNameIdentifier
=	TokenNameEQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
short	TokenNameshort
fOrdered	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
fFinite	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
fBounded	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
fNumeric	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
XSNamespaceItem	TokenNameIdentifier
fNamespaceItem	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
public	TokenNamepublic
XSSimpleTypeDecl	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
XSSimpleTypeDecl	TokenNameIdentifier
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
base	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
validateDV	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
ordered	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
bounded	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
finite	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
numeric	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isImmutable	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
builtInKind	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fIsImmutable	TokenNameIdentifier
=	TokenNameEQUAL
isImmutable	TokenNameIdentifier
;	TokenNameSEMICOLON
fBase	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
;	TokenNameSEMICOLON
fTypeName	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
fTargetNamespace	TokenNameIdentifier
=	TokenNameEQUAL
URI_SCHEMAFORSCHEMA	TokenNameIdentifier
;	TokenNameSEMICOLON
fVariety	TokenNameIdentifier
=	TokenNameEQUAL
VARIETY_ATOMIC	TokenNameIdentifier
;	TokenNameSEMICOLON
fValidationDV	TokenNameIdentifier
=	TokenNameEQUAL
validateDV	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
=	TokenNameEQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
validateDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ANYSIMPLETYPE	TokenNameIdentifier
||	TokenNameOR_OR
validateDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ANYATOMICTYPE	TokenNameIdentifier
||	TokenNameOR_OR
validateDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_STRING	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
WS_PRESERVE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
WS_COLLAPSE	TokenNameIdentifier
;	TokenNameSEMICOLON
fFixedFacet	TokenNameIdentifier
=	TokenNameEQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
fOrdered	TokenNameIdentifier
=	TokenNameEQUAL
ordered	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fBounded	TokenNameIdentifier
=	TokenNameEQUAL
bounded	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fFinite	TokenNameIdentifier
=	TokenNameEQUAL
finite	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fNumeric	TokenNameIdentifier
=	TokenNameEQUAL
numeric	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fBuiltInKind	TokenNameIdentifier
=	TokenNameEQUAL
builtInKind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
XSSimpleTypeDecl	TokenNameIdentifier
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
base	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
uri	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
finalSet	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isImmutable	TokenNameIdentifier
,	TokenNameCOMMA
XSObjectList	TokenNameIdentifier
annotations	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
builtInKind	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
base	TokenNameIdentifier
,	TokenNameCOMMA
name	TokenNameIdentifier
,	TokenNameCOMMA
uri	TokenNameIdentifier
,	TokenNameCOMMA
finalSet	TokenNameIdentifier
,	TokenNameCOMMA
isImmutable	TokenNameIdentifier
,	TokenNameCOMMA
annotations	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fBuiltInKind	TokenNameIdentifier
=	TokenNameEQUAL
builtInKind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
XSSimpleTypeDecl	TokenNameIdentifier
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
base	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
uri	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
finalSet	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isImmutable	TokenNameIdentifier
,	TokenNameCOMMA
XSObjectList	TokenNameIdentifier
annotations	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fBase	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
;	TokenNameSEMICOLON
fTypeName	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
fTargetNamespace	TokenNameIdentifier
=	TokenNameEQUAL
uri	TokenNameIdentifier
;	TokenNameSEMICOLON
fFinalSet	TokenNameIdentifier
=	TokenNameEQUAL
finalSet	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
annotations	TokenNameIdentifier
;	TokenNameSEMICOLON
fVariety	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fVariety	TokenNameIdentifier
;	TokenNameSEMICOLON
fValidationDV	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
VARIETY_ATOMIC	TokenNameIdentifier
:	TokenNameCOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
VARIETY_LIST	TokenNameIdentifier
:	TokenNameCOLON
fItemType	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fItemType	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
VARIETY_UNION	TokenNameIdentifier
:	TokenNameCOLON
fMemberTypes	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMemberTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fLength	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fLength	TokenNameIdentifier
;	TokenNameSEMICOLON
fMinLength	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
;	TokenNameSEMICOLON
fMaxLength	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
;	TokenNameSEMICOLON
fPattern	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fPattern	TokenNameIdentifier
;	TokenNameSEMICOLON
fPatternStr	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fPatternStr	TokenNameIdentifier
;	TokenNameSEMICOLON
fEnumeration	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fEnumeration	TokenNameIdentifier
;	TokenNameSEMICOLON
fEnumerationSize	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fEnumerationSize	TokenNameIdentifier
;	TokenNameSEMICOLON
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fWhiteSpace	TokenNameIdentifier
;	TokenNameSEMICOLON
fMaxExclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxExclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
fMaxInclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
fMinExclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinExclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
fMinInclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
fTotalDigits	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fTotalDigits	TokenNameIdentifier
;	TokenNameSEMICOLON
fFractionDigits	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fFractionDigits	TokenNameIdentifier
;	TokenNameSEMICOLON
fPatternType	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fPatternType	TokenNameIdentifier
;	TokenNameSEMICOLON
fFixedFacet	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
;	TokenNameSEMICOLON
lengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
lengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
minLengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
minLengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
maxLengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
maxLengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
patternAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
patternAnnotations	TokenNameIdentifier
;	TokenNameSEMICOLON
enumerationAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
enumerationAnnotations	TokenNameIdentifier
;	TokenNameSEMICOLON
whiteSpaceAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
whiteSpaceAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
maxExclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
maxExclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
maxInclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
maxInclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
minExclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
minExclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
minInclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
minInclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
totalDigitsAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
totalDigitsAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
fractionDigitsAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fractionDigitsAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
calcFundamentalFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fIsImmutable	TokenNameIdentifier
=	TokenNameEQUAL
isImmutable	TokenNameIdentifier
;	TokenNameSEMICOLON
fBuiltInKind	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
.	TokenNameDOT
fBuiltInKind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
XSSimpleTypeDecl	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
uri	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
finalSet	TokenNameIdentifier
,	TokenNameCOMMA
XSSimpleTypeDecl	TokenNameIdentifier
itemType	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isImmutable	TokenNameIdentifier
,	TokenNameCOMMA
XSObjectList	TokenNameIdentifier
annotations	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fBase	TokenNameIdentifier
=	TokenNameEQUAL
fAnySimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
fTypeName	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
fTargetNamespace	TokenNameIdentifier
=	TokenNameEQUAL
uri	TokenNameIdentifier
;	TokenNameSEMICOLON
fFinalSet	TokenNameIdentifier
=	TokenNameEQUAL
finalSet	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
annotations	TokenNameIdentifier
;	TokenNameSEMICOLON
fVariety	TokenNameIdentifier
=	TokenNameEQUAL
VARIETY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
fItemType	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
itemType	TokenNameIdentifier
;	TokenNameSEMICOLON
fValidationDV	TokenNameIdentifier
=	TokenNameEQUAL
DV_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
=	TokenNameEQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
fFixedFacet	TokenNameIdentifier
=	TokenNameEQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
WS_COLLAPSE	TokenNameIdentifier
;	TokenNameSEMICOLON
calcFundamentalFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fIsImmutable	TokenNameIdentifier
=	TokenNameEQUAL
isImmutable	TokenNameIdentifier
;	TokenNameSEMICOLON
fBuiltInKind	TokenNameIdentifier
=	TokenNameEQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
LIST_DT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
XSSimpleTypeDecl	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
uri	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
finalSet	TokenNameIdentifier
,	TokenNameCOMMA
XSSimpleTypeDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
memberTypes	TokenNameIdentifier
,	TokenNameCOMMA
XSObjectList	TokenNameIdentifier
annotations	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fBase	TokenNameIdentifier
=	TokenNameEQUAL
fAnySimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
fTypeName	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
fTargetNamespace	TokenNameIdentifier
=	TokenNameEQUAL
uri	TokenNameIdentifier
;	TokenNameSEMICOLON
fFinalSet	TokenNameIdentifier
=	TokenNameEQUAL
finalSet	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
annotations	TokenNameIdentifier
;	TokenNameSEMICOLON
fVariety	TokenNameIdentifier
=	TokenNameEQUAL
VARIETY_UNION	TokenNameIdentifier
;	TokenNameSEMICOLON
fMemberTypes	TokenNameIdentifier
=	TokenNameEQUAL
memberTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
fValidationDV	TokenNameIdentifier
=	TokenNameEQUAL
DV_UNION	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
=	TokenNameEQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
WS_COLLAPSE	TokenNameIdentifier
;	TokenNameSEMICOLON
calcFundamentalFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fIsImmutable	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fBuiltInKind	TokenNameIdentifier
=	TokenNameEQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
UNAVAILABLE_DT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
XSSimpleTypeDecl	TokenNameIdentifier
setRestrictionValues	TokenNameIdentifier
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
base	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
uri	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
finalSet	TokenNameIdentifier
,	TokenNameCOMMA
XSObjectList	TokenNameIdentifier
annotations	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fIsImmutable	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
fBase	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnonymous	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fTypeName	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
fTargetNamespace	TokenNameIdentifier
=	TokenNameEQUAL
uri	TokenNameIdentifier
;	TokenNameSEMICOLON
fFinalSet	TokenNameIdentifier
=	TokenNameEQUAL
finalSet	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
annotations	TokenNameIdentifier
;	TokenNameSEMICOLON
fVariety	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fVariety	TokenNameIdentifier
;	TokenNameSEMICOLON
fValidationDV	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
VARIETY_ATOMIC	TokenNameIdentifier
:	TokenNameCOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
VARIETY_LIST	TokenNameIdentifier
:	TokenNameCOLON
fItemType	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fItemType	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
VARIETY_UNION	TokenNameIdentifier
:	TokenNameCOLON
fMemberTypes	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMemberTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fLength	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fLength	TokenNameIdentifier
;	TokenNameSEMICOLON
fMinLength	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
;	TokenNameSEMICOLON
fMaxLength	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
;	TokenNameSEMICOLON
fPattern	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fPattern	TokenNameIdentifier
;	TokenNameSEMICOLON
fPatternStr	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fPatternStr	TokenNameIdentifier
;	TokenNameSEMICOLON
fEnumeration	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fEnumeration	TokenNameIdentifier
;	TokenNameSEMICOLON
fEnumerationSize	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fEnumerationSize	TokenNameIdentifier
;	TokenNameSEMICOLON
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fWhiteSpace	TokenNameIdentifier
;	TokenNameSEMICOLON
fMaxExclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxExclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
fMaxInclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
fMinExclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinExclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
fMinInclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
fTotalDigits	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fTotalDigits	TokenNameIdentifier
;	TokenNameSEMICOLON
fFractionDigits	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fFractionDigits	TokenNameIdentifier
;	TokenNameSEMICOLON
fPatternType	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fPatternType	TokenNameIdentifier
;	TokenNameSEMICOLON
fFixedFacet	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
;	TokenNameSEMICOLON
calcFundamentalFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fBuiltInKind	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
.	TokenNameDOT
fBuiltInKind	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
XSSimpleTypeDecl	TokenNameIdentifier
setListValues	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
uri	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
finalSet	TokenNameIdentifier
,	TokenNameCOMMA
XSSimpleTypeDecl	TokenNameIdentifier
itemType	TokenNameIdentifier
,	TokenNameCOMMA
XSObjectList	TokenNameIdentifier
annotations	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fIsImmutable	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
fBase	TokenNameIdentifier
=	TokenNameEQUAL
fAnySimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnonymous	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fTypeName	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
fTargetNamespace	TokenNameIdentifier
=	TokenNameEQUAL
uri	TokenNameIdentifier
;	TokenNameSEMICOLON
fFinalSet	TokenNameIdentifier
=	TokenNameEQUAL
finalSet	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
annotations	TokenNameIdentifier
;	TokenNameSEMICOLON
fVariety	TokenNameIdentifier
=	TokenNameEQUAL
VARIETY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
fItemType	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
itemType	TokenNameIdentifier
;	TokenNameSEMICOLON
fValidationDV	TokenNameIdentifier
=	TokenNameEQUAL
DV_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
=	TokenNameEQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
fFixedFacet	TokenNameIdentifier
=	TokenNameEQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
WS_COLLAPSE	TokenNameIdentifier
;	TokenNameSEMICOLON
calcFundamentalFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fBuiltInKind	TokenNameIdentifier
=	TokenNameEQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
LIST_DT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
XSSimpleTypeDecl	TokenNameIdentifier
setUnionValues	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
uri	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
finalSet	TokenNameIdentifier
,	TokenNameCOMMA
XSSimpleTypeDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
memberTypes	TokenNameIdentifier
,	TokenNameCOMMA
XSObjectList	TokenNameIdentifier
annotations	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fIsImmutable	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
fBase	TokenNameIdentifier
=	TokenNameEQUAL
fAnySimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnonymous	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fTypeName	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
fTargetNamespace	TokenNameIdentifier
=	TokenNameEQUAL
uri	TokenNameIdentifier
;	TokenNameSEMICOLON
fFinalSet	TokenNameIdentifier
=	TokenNameEQUAL
finalSet	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
annotations	TokenNameIdentifier
;	TokenNameSEMICOLON
fVariety	TokenNameIdentifier
=	TokenNameEQUAL
VARIETY_UNION	TokenNameIdentifier
;	TokenNameSEMICOLON
fMemberTypes	TokenNameIdentifier
=	TokenNameEQUAL
memberTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
fValidationDV	TokenNameIdentifier
=	TokenNameEQUAL
DV_UNION	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
=	TokenNameEQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
WS_COLLAPSE	TokenNameIdentifier
;	TokenNameSEMICOLON
calcFundamentalFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fBuiltInKind	TokenNameIdentifier
=	TokenNameEQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
UNAVAILABLE_DT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
XSConstants	TokenNameIdentifier
.	TokenNameDOT
TYPE_DEFINITION	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getTypeCategory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
SIMPLE_TYPE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getAnonymous	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
fTypeName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getTypeName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fTypeName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fTargetNamespace	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getFinal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fFinalSet	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isFinal	TokenNameIdentifier
(	TokenNameLPAREN
short	TokenNameshort
derivation	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
fFinalSet	TokenNameIdentifier
&	TokenNameAND
derivation	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSTypeDefinition	TokenNameIdentifier
getBaseType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fBase	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getAnonymous	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fAnonymous	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
fTypeName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ANYSIMPLETYPE	TokenNameIdentifier
?	TokenNameQUESTION
VARIETY_ABSENT	TokenNameIdentifier
:	TokenNameCOLON
fVariety	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isIDType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
VARIETY_ATOMIC	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ID	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
VARIETY_LIST	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
fItemType	TokenNameIdentifier
.	TokenNameDOT
isIDType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
VARIETY_UNION	TokenNameIdentifier
:	TokenNameCOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fMemberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
isIDType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getWhitespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
DatatypeException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
DatatypeException	TokenNameIdentifier
(	TokenNameLPAREN
"dt-whitespace"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fWhiteSpace	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getPrimitiveKind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_ATOMIC	TokenNameIdentifier
&&	TokenNameAND_AND
fValidationDV	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
DV_ANYSIMPLETYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ID	TokenNameIdentifier
||	TokenNameOR_OR
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_IDREF	TokenNameIdentifier
||	TokenNameOR_OR
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ENTITY	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
DV_STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
DV_DECIMAL	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
Constants	TokenNameIdentifier
.	TokenNameDOT
SCHEMA_1_1_SUPPORT	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_YEARMONTHDURATION	TokenNameIdentifier
||	TokenNameOR_OR
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_DAYTIMEDURATION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
DV_DURATION	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
fValidationDV	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getBuiltInKind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
fBuiltInKind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSSimpleTypeDefinition	TokenNameIdentifier
getPrimitiveType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_ATOMIC	TokenNameIdentifier
&&	TokenNameAND_AND
fValidationDV	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
DV_ANYSIMPLETYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSSimpleTypeDecl	TokenNameIdentifier
pri	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
pri	TokenNameIdentifier
.	TokenNameDOT
fBase	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fAnySimpleType	TokenNameIdentifier
)	TokenNameRPAREN
pri	TokenNameIdentifier
=	TokenNameEQUAL
pri	TokenNameIdentifier
.	TokenNameDOT
fBase	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
pri	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
XSSimpleTypeDefinition	TokenNameIdentifier
getItemType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_LIST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fItemType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
XSObjectList	TokenNameIdentifier
getMemberTypes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
XSObjectListImpl	TokenNameIdentifier
(	TokenNameLPAREN
fMemberTypes	TokenNameIdentifier
,	TokenNameCOMMA
fMemberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
XSObjectListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
applyFacets	TokenNameIdentifier
(	TokenNameLPAREN
XSFacets	TokenNameIdentifier
facets	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
presentFacet	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
fixedFacet	TokenNameIdentifier
,	TokenNameCOMMA
ValidationContext	TokenNameIdentifier
context	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeFacetException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
fEmptyContext	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
applyFacets	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
,	TokenNameCOMMA
presentFacet	TokenNameIdentifier
,	TokenNameCOMMA
fixedFacet	TokenNameIdentifier
,	TokenNameCOMMA
SPECIAL_PATTERN_NONE	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
applyFacets1	TokenNameIdentifier
(	TokenNameLPAREN
XSFacets	TokenNameIdentifier
facets	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
presentFacet	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
fixedFacet	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
applyFacets	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
,	TokenNameCOMMA
presentFacet	TokenNameIdentifier
,	TokenNameCOMMA
fixedFacet	TokenNameIdentifier
,	TokenNameCOMMA
SPECIAL_PATTERN_NONE	TokenNameIdentifier
,	TokenNameCOMMA
fDummyContext	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeFacetException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"internal error"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fIsImmutable	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
applyFacets1	TokenNameIdentifier
(	TokenNameLPAREN
XSFacets	TokenNameIdentifier
facets	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
presentFacet	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
fixedFacet	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
patternType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
applyFacets	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
,	TokenNameCOMMA
presentFacet	TokenNameIdentifier
,	TokenNameCOMMA
fixedFacet	TokenNameIdentifier
,	TokenNameCOMMA
patternType	TokenNameIdentifier
,	TokenNameCOMMA
fDummyContext	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeFacetException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"internal error"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fIsImmutable	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
applyFacets	TokenNameIdentifier
(	TokenNameLPAREN
XSFacets	TokenNameIdentifier
facets	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
presentFacet	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
fixedFacet	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
patternType	TokenNameIdentifier
,	TokenNameCOMMA
ValidationContext	TokenNameIdentifier
context	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeFacetException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fIsImmutable	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
ValidatedInfo	TokenNameIdentifier
tempInfo	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ValidatedInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fFixedFacet	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
result	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
short	TokenNameshort
allowedFacet	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getAllowedFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"length"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fLength	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
lengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
lengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_LENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_LENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"minLength"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fMinLength	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
minLength	TokenNameIdentifier
;	TokenNameSEMICOLON
minLengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
minLengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MINLENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MINLENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"maxLength"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fMaxLength	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
maxLength	TokenNameIdentifier
;	TokenNameSEMICOLON
maxLengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
maxLengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MAXLENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MAXLENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"pattern"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
patternAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
patternAnnotations	TokenNameIdentifier
;	TokenNameSEMICOLON
RegularExpression	TokenNameIdentifier
regex	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
regex	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
RegularExpression	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
.	TokenNameDOT
pattern	TokenNameIdentifier
,	TokenNameCOMMA
"X"	TokenNameStringLiteral
,	TokenNameCOMMA
context	TokenNameIdentifier
.	TokenNameDOT
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"InvalidRegex"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
facets	TokenNameIdentifier
.	TokenNameDOT
pattern	TokenNameIdentifier
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
getLocalizedMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
regex	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
fPattern	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fPattern	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
regex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fPatternStr	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fPatternStr	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
.	TokenNameDOT
pattern	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_PATTERN	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_PATTERN	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"whiteSpace"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
whiteSpace	TokenNameIdentifier
;	TokenNameSEMICOLON
whiteSpaceAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
whiteSpaceAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_ENUMERATION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_ENUMERATION	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"enumeration"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
Vector	TokenNameIdentifier
enumVals	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
enumeration	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
enumVals	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fEnumeration	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ValidatedInfo	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Vector	TokenNameIdentifier
enumNSDecls	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
enumNSDecls	TokenNameIdentifier
;	TokenNameSEMICOLON
ValidationContextImpl	TokenNameIdentifier
ctx	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ValidationContextImpl	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
enumerationAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
enumAnnotations	TokenNameIdentifier
;	TokenNameSEMICOLON
fEnumerationSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
size	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
enumNSDecls	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
ctx	TokenNameIdentifier
.	TokenNameDOT
setNSContext	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
NamespaceContext	TokenNameIdentifier
)	TokenNameRPAREN
enumNSDecls	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
ValidatedInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
getActualEnumValue	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
String	TokenNameIdentifier
)	TokenNameRPAREN
enumVals	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
ctx	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
fEnumerationSize	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
info	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
ide	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"enumeration-valid-restriction"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
enumVals	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
getBaseType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_ENUMERATION	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_ENUMERATION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_ENUMERATION	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"maxInclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
maxInclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
maxInclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
fMaxInclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
.	TokenNameDOT
maxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
tempInfo	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MAXINCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MAXINCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
ide	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
ide	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ide	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FacetValueFromBase"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
maxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
"maxInclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
fMaxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxInclusive	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FixedFacetValue"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"maxInclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fMaxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
fBase	TokenNameIdentifier
.	TokenNameDOT
validate	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
tempInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
ide	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
ide	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ide	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FacetValueFromBase"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
maxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
"maxInclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
boolean	TokenNameboolean
needCheckBase	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"maxExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
maxExclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
maxExclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
fMaxExclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
.	TokenNameDOT
maxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
tempInfo	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MAXEXCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MAXEXCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
ide	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
ide	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ide	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FacetValueFromBase"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
maxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
"maxExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
fMaxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxExclusive	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
result	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FixedFacetValue"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"maxExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
maxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
needCheckBase	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
needCheckBase	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
fBase	TokenNameIdentifier
.	TokenNameDOT
validate	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
tempInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
ide	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
ide	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ide	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FacetValueFromBase"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
maxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
"maxExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
fMaxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxInclusive	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"maxExclusive-valid-restriction.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
facets	TokenNameIdentifier
.	TokenNameDOT
maxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxInclusive	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
needCheckBase	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"minExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
minExclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
minExclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
fMinExclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
.	TokenNameDOT
minExclusive	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
tempInfo	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MINEXCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MINEXCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
ide	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
ide	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ide	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FacetValueFromBase"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
minExclusive	TokenNameIdentifier
,	TokenNameCOMMA
"minExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
fMinExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinExclusive	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
result	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FixedFacetValue"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"minExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
minExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
needCheckBase	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
needCheckBase	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
fBase	TokenNameIdentifier
.	TokenNameDOT
validate	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
tempInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
ide	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
ide	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ide	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FacetValueFromBase"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
minExclusive	TokenNameIdentifier
,	TokenNameCOMMA
"minExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
fMinExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinInclusive	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"minExclusive-valid-restriction.3"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
facets	TokenNameIdentifier
.	TokenNameDOT
minExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinInclusive	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"minInclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
minInclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
minInclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
fMinInclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
.	TokenNameDOT
minInclusive	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
tempInfo	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MININCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MININCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
ide	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
ide	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ide	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FacetValueFromBase"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
minInclusive	TokenNameIdentifier
,	TokenNameCOMMA
"minInclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
fMinInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinInclusive	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FixedFacetValue"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"minInclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
minInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
fBase	TokenNameIdentifier
.	TokenNameDOT
validate	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
tempInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
ide	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
ide	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ide	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FacetValueFromBase"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
facets	TokenNameIdentifier
.	TokenNameDOT
minInclusive	TokenNameIdentifier
,	TokenNameCOMMA
"minInclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
fBase	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"totalDigits"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
totalDigitsAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
totalDigitsAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
fTotalDigits	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
totalDigits	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_TOTALDIGITS	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_TOTALDIGITS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
presentFacet	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
allowedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"cos-applicable-facets"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"fractionDigits"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fFractionDigits	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
fractionDigits	TokenNameIdentifier
;	TokenNameSEMICOLON
fractionDigitsAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
facets	TokenNameIdentifier
.	TokenNameDOT
fractionDigitsAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_FRACTIONDIGITS	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_FRACTIONDIGITS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
patternType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fPatternType	TokenNameIdentifier
=	TokenNameEQUAL
patternType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
>	TokenNameGREATER
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"minLength-less-than-equal-to-maxLength"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"maxInclusive-maxExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fMaxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fMaxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"minInclusive-minExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fMinInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fMinExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
fMinInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fMaxInclusive	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
result	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"minInclusive-less-than-equal-to-maxInclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fMinInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fMaxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
fMinExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fMaxExclusive	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
result	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"minExclusive-less-than-equal-to-maxExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fMinExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fMaxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
fMinExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fMaxInclusive	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"minExclusive-less-than-maxInclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fMinExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fMaxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
fMinInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fMaxExclusive	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"minInclusive-less-than-maxExclusive"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fMinInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fMaxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
>	TokenNameGREATER
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"fractionDigits-totalDigits"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fLength	TokenNameIdentifier
<	TokenNameLESS
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"length-minLength-maxLength.1.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fLength	TokenNameIdentifier
>	TokenNameGREATER
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"length-minLength-maxLength.2.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fLength	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fLength	TokenNameIdentifier
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"length-valid-restriction"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fLength	TokenNameIdentifier
<	TokenNameLESS
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"length-minLength-maxLength.1.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"length-minLength-maxLength.1.2.a"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"length-minLength-maxLength.1.2.b"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fLength	TokenNameIdentifier
>	TokenNameGREATER
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"length-minLength-maxLength.2.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"length-minLength-maxLength.2.2.a"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"length-minLength-maxLength.2.2.b"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
>	TokenNameGREATER
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"minLength-less-than-equal-to-maxLength"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fMinLength	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FixedFacetValue"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"minLength"	TokenNameStringLiteral
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
<	TokenNameLESS
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"minLength-valid-restriction"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
<	TokenNameLESS
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"minLength-less-than-equal-to-maxLength"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
fMaxLength	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FixedFacetValue"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"maxLength"	TokenNameStringLiteral
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
>	TokenNameGREATER
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"maxLength-valid-restriction"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fTotalDigits	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FixedFacetValue"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"totalDigits"	TokenNameStringLiteral
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fTotalDigits	TokenNameIdentifier
>	TokenNameGREATER
fBase	TokenNameIdentifier
.	TokenNameDOT
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"totalDigits-valid-restriction"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
>	TokenNameGREATER
fBase	TokenNameIdentifier
.	TokenNameDOT
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"fractionDigits-totalDigits"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fFractionDigits	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
&&	TokenNameAND_AND
fFractionDigits	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FixedFacetValue"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"fractionDigits"	TokenNameStringLiteral
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
>	TokenNameGREATER
fBase	TokenNameIdentifier
.	TokenNameDOT
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"fractionDigits-valid-restriction"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
&&	TokenNameAND_AND
fFractionDigits	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FixedFacetValue"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"fractionDigits"	TokenNameStringLiteral
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
"0"	TokenNameStringLiteral
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fWhiteSpace	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fWhiteSpace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"FixedFacetValue"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"whiteSpace"	TokenNameStringLiteral
,	TokenNameCOMMA
whiteSpaceValue	TokenNameIdentifier
(	TokenNameLPAREN
fWhiteSpace	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
whiteSpaceValue	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fWhiteSpace	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fWhiteSpace	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WS_PRESERVE	TokenNameIdentifier
&&	TokenNameAND_AND
fBase	TokenNameIdentifier
.	TokenNameDOT
fWhiteSpace	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WS_COLLAPSE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"whiteSpace-valid-restriction.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
"preserve"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fWhiteSpace	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WS_REPLACE	TokenNameIdentifier
&&	TokenNameAND_AND
fBase	TokenNameIdentifier
.	TokenNameDOT
fWhiteSpace	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WS_COLLAPSE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"whiteSpace-valid-restriction.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
"replace"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fWhiteSpace	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WS_PRESERVE	TokenNameIdentifier
&&	TokenNameAND_AND
fBase	TokenNameIdentifier
.	TokenNameDOT
fWhiteSpace	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WS_REPLACE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportError	TokenNameIdentifier
(	TokenNameLPAREN
"whiteSpace-valid-restriction.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_LENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
fLength	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fLength	TokenNameIdentifier
;	TokenNameSEMICOLON
lengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
lengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MINLENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
fMinLength	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinLength	TokenNameIdentifier
;	TokenNameSEMICOLON
minLengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
minLengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MAXLENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
fMaxLength	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxLength	TokenNameIdentifier
;	TokenNameSEMICOLON
maxLengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
maxLengthAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_PATTERN	TokenNameIdentifier
;	TokenNameSEMICOLON
fPattern	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fPattern	TokenNameIdentifier
;	TokenNameSEMICOLON
fPatternStr	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fPatternStr	TokenNameIdentifier
;	TokenNameSEMICOLON
patternAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
patternAnnotations	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fPattern	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fPattern	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fPattern	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fPatternStr	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fPatternStr	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
patternAnnotations	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
patternAnnotations	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
patternAnnotations	TokenNameIdentifier
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
patternAnnotations	TokenNameIdentifier
.	TokenNameDOT
addXSObject	TokenNameIdentifier
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
patternAnnotations	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
patternAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
patternAnnotations	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_WHITESPACE	TokenNameIdentifier
;	TokenNameSEMICOLON
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fWhiteSpace	TokenNameIdentifier
;	TokenNameSEMICOLON
whiteSpaceAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
whiteSpaceAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_ENUMERATION	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_ENUMERATION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_ENUMERATION	TokenNameIdentifier
;	TokenNameSEMICOLON
fEnumeration	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fEnumeration	TokenNameIdentifier
;	TokenNameSEMICOLON
fEnumerationSize	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fEnumerationSize	TokenNameIdentifier
;	TokenNameSEMICOLON
enumerationAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
enumerationAnnotations	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MAXEXCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
fMaxExclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxExclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
maxExclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
maxExclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MAXINCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
fMaxInclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMaxInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
maxInclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
maxInclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MINEXCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
fMinExclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinExclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
minExclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
minExclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_MININCLUSIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
fMinInclusive	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fMinInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
minInclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
minInclusiveAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_TOTALDIGITS	TokenNameIdentifier
;	TokenNameSEMICOLON
fTotalDigits	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fTotalDigits	TokenNameIdentifier
;	TokenNameSEMICOLON
totalDigitsAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
totalDigitsAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fFacetsDefined	TokenNameIdentifier
|=	TokenNameOR_EQUAL
FACET_FRACTIONDIGITS	TokenNameIdentifier
;	TokenNameSEMICOLON
fFractionDigits	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fFractionDigits	TokenNameIdentifier
;	TokenNameSEMICOLON
fractionDigitsAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fractionDigitsAnnotation	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fPatternType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fPatternType	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fPatternType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fFixedFacet	TokenNameIdentifier
|=	TokenNameOR_EQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fFixedFacet	TokenNameIdentifier
;	TokenNameSEMICOLON
calcFundamentalFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
validate	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
content	TokenNameIdentifier
,	TokenNameCOMMA
ValidationContext	TokenNameIdentifier
context	TokenNameIdentifier
,	TokenNameCOMMA
ValidatedInfo	TokenNameIdentifier
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeValueException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
context	TokenNameIdentifier
=	TokenNameEQUAL
fEmptyContext	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
validatedInfo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
validatedInfo	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ValidatedInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberType	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
needNormalize	TokenNameIdentifier
=	TokenNameEQUAL
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
context	TokenNameIdentifier
.	TokenNameDOT
needToNormalize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Object	TokenNameIdentifier
ob	TokenNameIdentifier
=	TokenNameEQUAL
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
content	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
,	TokenNameCOMMA
needNormalize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
validate	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
ob	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
ValidatedInfo	TokenNameIdentifier
getActualEnumValue	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
lexical	TokenNameIdentifier
,	TokenNameCOMMA
ValidationContext	TokenNameIdentifier
ctx	TokenNameIdentifier
,	TokenNameCOMMA
ValidatedInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeValueException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
fBase	TokenNameIdentifier
.	TokenNameDOT
validateWithInfo	TokenNameIdentifier
(	TokenNameLPAREN
lexical	TokenNameIdentifier
,	TokenNameCOMMA
ctx	TokenNameIdentifier
,	TokenNameCOMMA
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
ValidatedInfo	TokenNameIdentifier
validateWithInfo	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
content	TokenNameIdentifier
,	TokenNameCOMMA
ValidationContext	TokenNameIdentifier
context	TokenNameIdentifier
,	TokenNameCOMMA
ValidatedInfo	TokenNameIdentifier
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeValueException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
context	TokenNameIdentifier
=	TokenNameEQUAL
fEmptyContext	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
validatedInfo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
validatedInfo	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ValidatedInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberType	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
needNormalize	TokenNameIdentifier
=	TokenNameEQUAL
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
context	TokenNameIdentifier
.	TokenNameDOT
needToNormalize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
content	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
,	TokenNameCOMMA
needNormalize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
validate	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
validatedInfo	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
validate	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
content	TokenNameIdentifier
,	TokenNameCOMMA
ValidationContext	TokenNameIdentifier
context	TokenNameIdentifier
,	TokenNameCOMMA
ValidatedInfo	TokenNameIdentifier
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeValueException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
context	TokenNameIdentifier
=	TokenNameEQUAL
fEmptyContext	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
validatedInfo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
validatedInfo	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ValidatedInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberType	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
needNormalize	TokenNameIdentifier
=	TokenNameEQUAL
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
context	TokenNameIdentifier
.	TokenNameDOT
needToNormalize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Object	TokenNameIdentifier
ob	TokenNameIdentifier
=	TokenNameEQUAL
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
content	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
,	TokenNameCOMMA
needNormalize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
validate	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
ob	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
validate	TokenNameIdentifier
(	TokenNameLPAREN
ValidationContext	TokenNameIdentifier
context	TokenNameIdentifier
,	TokenNameCOMMA
ValidatedInfo	TokenNameIdentifier
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeValueException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
context	TokenNameIdentifier
=	TokenNameEQUAL
fEmptyContext	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
context	TokenNameIdentifier
.	TokenNameDOT
needFacetChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fFacetsDefined	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
checkFacets	TokenNameIdentifier
(	TokenNameLPAREN
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
context	TokenNameIdentifier
.	TokenNameDOT
needExtraChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
checkExtraRules	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
checkFacets	TokenNameIdentifier
(	TokenNameLPAREN
ValidatedInfo	TokenNameIdentifier
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeValueException	TokenNameIdentifier
{	TokenNameLBRACE
Object	TokenNameIdentifier
ob	TokenNameIdentifier
=	TokenNameEQUAL
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualValue	TokenNameIdentifier
;	TokenNameSEMICOLON
String	TokenNameIdentifier
content	TokenNameIdentifier
=	TokenNameEQUAL
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
normalizedValue	TokenNameIdentifier
;	TokenNameSEMICOLON
short	TokenNameshort
type	TokenNameIdentifier
=	TokenNameEQUAL
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualValueType	TokenNameIdentifier
;	TokenNameSEMICOLON
ShortList	TokenNameIdentifier
itemType	TokenNameIdentifier
=	TokenNameEQUAL
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
itemValueTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
DV_QNAME	TokenNameIdentifier
&&	TokenNameAND_AND
fValidationDV	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
DV_NOTATION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
length	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getDataLength	TokenNameIdentifier
(	TokenNameLPAREN
ob	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
length	TokenNameIdentifier
>	TokenNameGREATER
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-maxLength-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
length	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
length	TokenNameIdentifier
<	TokenNameLESS
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-minLength-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
length	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
length	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-length-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
length	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_ENUMERATION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
present	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
enumSize	TokenNameIdentifier
=	TokenNameEQUAL
fEnumerationSize	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
short	TokenNameshort
primitiveType1	TokenNameIdentifier
=	TokenNameEQUAL
convertToPrimitiveKind	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
enumSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
short	TokenNameshort
primitiveType2	TokenNameIdentifier
=	TokenNameEQUAL
convertToPrimitiveKind	TokenNameIdentifier
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
actualValueType	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
primitiveType1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
primitiveType2	TokenNameIdentifier
||	TokenNameOR_OR
primitiveType1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
ANYSIMPLETYPE_DT	TokenNameIdentifier
&&	TokenNameAND_AND
primitiveType2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
STRING_DT	TokenNameIdentifier
||	TokenNameOR_OR
primitiveType1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
STRING_DT	TokenNameIdentifier
&&	TokenNameAND_AND
primitiveType2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
ANYSIMPLETYPE_DT	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
actualValue	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
ob	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
primitiveType1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
LIST_DT	TokenNameIdentifier
||	TokenNameOR_OR
primitiveType1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
LISTOFUNION_DT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ShortList	TokenNameIdentifier
enumItemType	TokenNameIdentifier
=	TokenNameEQUAL
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
itemValueTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
typeList1Length	TokenNameIdentifier
=	TokenNameEQUAL
itemType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
itemType	TokenNameIdentifier
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
typeList2Length	TokenNameIdentifier
=	TokenNameEQUAL
enumItemType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
enumItemType	TokenNameIdentifier
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
typeList1Length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
typeList2Length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
j	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
typeList1Length	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
j	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
short	TokenNameshort
primitiveItem1	TokenNameIdentifier
=	TokenNameEQUAL
convertToPrimitiveKind	TokenNameIdentifier
(	TokenNameLPAREN
itemType	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
short	TokenNameshort
primitiveItem2	TokenNameIdentifier
=	TokenNameEQUAL
convertToPrimitiveKind	TokenNameIdentifier
(	TokenNameLPAREN
enumItemType	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
primitiveItem1	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
primitiveItem2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
primitiveItem1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
ANYSIMPLETYPE_DT	TokenNameIdentifier
&&	TokenNameAND_AND
primitiveItem2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
STRING_DT	TokenNameIdentifier
||	TokenNameOR_OR
primitiveItem1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
STRING_DT	TokenNameIdentifier
&&	TokenNameAND_AND
primitiveItem2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
ANYSIMPLETYPE_DT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
j	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
typeList1Length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
present	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
present	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
present	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuffer	TokenNameIdentifier
sb	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
appendEnumString	TokenNameIdentifier
(	TokenNameLPAREN
sb	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-enumeration-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
sb	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
scale	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getFractionDigits	TokenNameIdentifier
(	TokenNameLPAREN
ob	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
scale	TokenNameIdentifier
>	TokenNameGREATER
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-fractionDigits-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
scale	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
totalDigits	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getTotalDigits	TokenNameIdentifier
(	TokenNameLPAREN
ob	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
totalDigits	TokenNameIdentifier
>	TokenNameGREATER
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-totalDigits-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
totalDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
compare	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
compare	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
ob	TokenNameIdentifier
,	TokenNameCOMMA
fMaxInclusive	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
compare	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-maxInclusive-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
fMaxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
compare	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
ob	TokenNameIdentifier
,	TokenNameCOMMA
fMaxExclusive	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-maxExclusive-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
fMaxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
compare	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
ob	TokenNameIdentifier
,	TokenNameCOMMA
fMinInclusive	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
compare	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-minInclusive-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
fMinInclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
compare	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
ob	TokenNameIdentifier
,	TokenNameCOMMA
fMinExclusive	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-minExclusive-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
fMinExclusive	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
checkExtraRules	TokenNameIdentifier
(	TokenNameLPAREN
ValidationContext	TokenNameIdentifier
context	TokenNameIdentifier
,	TokenNameCOMMA
ValidatedInfo	TokenNameIdentifier
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeValueException	TokenNameIdentifier
{	TokenNameLBRACE
Object	TokenNameIdentifier
ob	TokenNameIdentifier
=	TokenNameEQUAL
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualValue	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_ATOMIC	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
checkExtraRules	TokenNameIdentifier
(	TokenNameLPAREN
ob	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_LIST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ListDV	TokenNameIdentifier
.	TokenNameDOT
ListData	TokenNameIdentifier
values	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
ListDV	TokenNameIdentifier
.	TokenNameDOT
ListData	TokenNameIdentifier
)	TokenNameRPAREN
ob	TokenNameIdentifier
;	TokenNameSEMICOLON
XSSimpleType	TokenNameIdentifier
memberType	TokenNameIdentifier
=	TokenNameEQUAL
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberType	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
values	TokenNameIdentifier
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fItemType	TokenNameIdentifier
.	TokenNameDOT
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSSimpleTypeDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
memberTypes	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
)	TokenNameRPAREN
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
len	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualValue	TokenNameIdentifier
=	TokenNameEQUAL
values	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberType	TokenNameIdentifier
=	TokenNameEQUAL
memberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fItemType	TokenNameIdentifier
.	TokenNameDOT
checkExtraRules	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
len	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualValue	TokenNameIdentifier
=	TokenNameEQUAL
values	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fItemType	TokenNameIdentifier
.	TokenNameDOT
checkExtraRules	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualValue	TokenNameIdentifier
=	TokenNameEQUAL
values	TokenNameIdentifier
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberType	TokenNameIdentifier
=	TokenNameEQUAL
memberType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberType	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
checkExtraRules	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
Object	TokenNameIdentifier
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
content	TokenNameIdentifier
,	TokenNameCOMMA
ValidationContext	TokenNameIdentifier
context	TokenNameIdentifier
,	TokenNameCOMMA
ValidatedInfo	TokenNameIdentifier
validatedInfo	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
needNormalize	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeValueException	TokenNameIdentifier
{	TokenNameLBRACE
String	TokenNameIdentifier
nvalue	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
needNormalize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
nvalue	TokenNameIdentifier
=	TokenNameEQUAL
normalize	TokenNameIdentifier
(	TokenNameLPAREN
content	TokenNameIdentifier
,	TokenNameCOMMA
fWhiteSpace	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
nvalue	TokenNameIdentifier
=	TokenNameEQUAL
content	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
RegularExpression	TokenNameIdentifier
regex	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
fPattern	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
regex	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
)	TokenNameRPAREN
fPattern	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
idx	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
regex	TokenNameIdentifier
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
nvalue	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-pattern-valid"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
fPatternStr	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
idx	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_ATOMIC	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
seenErr	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SPECIAL_PATTERN_NMTOKEN	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
seenErr	TokenNameIdentifier
=	TokenNameEQUAL
!	TokenNameNOT
XMLChar	TokenNameIdentifier
.	TokenNameDOT
isValidNmtoken	TokenNameIdentifier
(	TokenNameLPAREN
nvalue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SPECIAL_PATTERN_NAME	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
seenErr	TokenNameIdentifier
=	TokenNameEQUAL
!	TokenNameNOT
XMLChar	TokenNameIdentifier
.	TokenNameDOT
isValidName	TokenNameIdentifier
(	TokenNameLPAREN
nvalue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SPECIAL_PATTERN_NCNAME	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
seenErr	TokenNameIdentifier
=	TokenNameEQUAL
!	TokenNameNOT
XMLChar	TokenNameIdentifier
.	TokenNameDOT
isValidNCName	TokenNameIdentifier
(	TokenNameLPAREN
nvalue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
seenErr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-datatype-valid.1.2.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
nvalue	TokenNameIdentifier
,	TokenNameCOMMA
SPECIAL_PATTERN_STRING	TokenNameIdentifier
[	TokenNameLBRACKET
fPatternType	TokenNameIdentifier
]	TokenNameRBRACKET
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
normalizedValue	TokenNameIdentifier
=	TokenNameEQUAL
nvalue	TokenNameIdentifier
;	TokenNameSEMICOLON
Object	TokenNameIdentifier
avalue	TokenNameIdentifier
=	TokenNameEQUAL
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
nvalue	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualValue	TokenNameIdentifier
=	TokenNameEQUAL
avalue	TokenNameIdentifier
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualValueType	TokenNameIdentifier
=	TokenNameEQUAL
fBuiltInKind	TokenNameIdentifier
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualType	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
return	TokenNamereturn
avalue	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_LIST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
StringTokenizer	TokenNameIdentifier
parsedList	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringTokenizer	TokenNameIdentifier
(	TokenNameLPAREN
nvalue	TokenNameIdentifier
,	TokenNameCOMMA
" "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
countOfTokens	TokenNameIdentifier
=	TokenNameEQUAL
parsedList	TokenNameIdentifier
.	TokenNameDOT
countTokens	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
avalue	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
countOfTokens	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isUnion	TokenNameIdentifier
=	TokenNameEQUAL
fItemType	TokenNameIdentifier
.	TokenNameDOT
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
VARIETY_UNION	TokenNameIdentifier
;	TokenNameSEMICOLON
short	TokenNameshort
[	TokenNameLBRACKET
]	TokenNameRBRACKET
itemTypes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
short	TokenNameshort
[	TokenNameLBRACKET
isUnion	TokenNameIdentifier
?	TokenNameQUESTION
countOfTokens	TokenNameIdentifier
:	TokenNameCOLON
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isUnion	TokenNameIdentifier
)	TokenNameRPAREN
itemTypes	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
fItemType	TokenNameIdentifier
.	TokenNameDOT
fBuiltInKind	TokenNameIdentifier
;	TokenNameSEMICOLON
XSSimpleTypeDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
memberTypes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSSimpleTypeDecl	TokenNameIdentifier
[	TokenNameLBRACKET
countOfTokens	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
countOfTokens	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
avalue	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
fItemType	TokenNameIdentifier
.	TokenNameDOT
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
parsedList	TokenNameIdentifier
.	TokenNameDOT
nextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
context	TokenNameIdentifier
.	TokenNameDOT
needFacetChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
fItemType	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fItemType	TokenNameIdentifier
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fItemType	TokenNameIdentifier
.	TokenNameDOT
checkFacets	TokenNameIdentifier
(	TokenNameLPAREN
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
memberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberType	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isUnion	TokenNameIdentifier
)	TokenNameRPAREN
itemTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
memberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fBuiltInKind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ListDV	TokenNameIdentifier
.	TokenNameDOT
ListData	TokenNameIdentifier
v	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ListDV	TokenNameIdentifier
.	TokenNameDOT
ListData	TokenNameIdentifier
(	TokenNameLPAREN
avalue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualValue	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualValueType	TokenNameIdentifier
=	TokenNameEQUAL
isUnion	TokenNameIdentifier
?	TokenNameQUESTION
XSConstants	TokenNameIdentifier
.	TokenNameDOT
LISTOFUNION_DT	TokenNameIdentifier
:	TokenNameCOLON
XSConstants	TokenNameIdentifier
.	TokenNameDOT
LIST_DT	TokenNameIdentifier
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberType	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberTypes	TokenNameIdentifier
=	TokenNameEQUAL
memberTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
itemValueTypes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ShortListImpl	TokenNameIdentifier
(	TokenNameLPAREN
itemTypes	TokenNameIdentifier
,	TokenNameCOMMA
itemTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
normalizedValue	TokenNameIdentifier
=	TokenNameEQUAL
nvalue	TokenNameIdentifier
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualType	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
return	TokenNamereturn
v	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
Object	TokenNameIdentifier
_content	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
fMemberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
content	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
content	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
content	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fMemberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
Object	TokenNameIdentifier
aValue	TokenNameIdentifier
=	TokenNameEQUAL
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
_content	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
validatedInfo	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
context	TokenNameIdentifier
.	TokenNameDOT
needFacetChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
checkFacets	TokenNameIdentifier
(	TokenNameLPAREN
validatedInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
memberType	TokenNameIdentifier
=	TokenNameEQUAL
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
validatedInfo	TokenNameIdentifier
.	TokenNameDOT
actualType	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
return	TokenNamereturn
aValue	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
invalidValue	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
StringBuffer	TokenNameIdentifier
typesBuffer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
XSSimpleTypeDecl	TokenNameIdentifier
decl	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fMemberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
typesBuffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" | "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
decl	TokenNameIdentifier
=	TokenNameEQUAL
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
decl	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
typesBuffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'{'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
typesBuffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
decl	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
typesBuffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'}'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
typesBuffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
decl	TokenNameIdentifier
.	TokenNameDOT
fTypeName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
decl	TokenNameIdentifier
.	TokenNameDOT
fEnumeration	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
typesBuffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" : "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
decl	TokenNameIdentifier
.	TokenNameDOT
appendEnumString	TokenNameIdentifier
(	TokenNameLPAREN
typesBuffer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeValueException	TokenNameIdentifier
(	TokenNameLPAREN
"cvc-datatype-valid.1.2.3"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
content	TokenNameIdentifier
,	TokenNameCOMMA
fTypeName	TokenNameIdentifier
,	TokenNameCOMMA
typesBuffer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isEqual	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
value1	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
value2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
value1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
value1	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
value2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isIdentical	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
value1	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
value2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
value1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fDVs	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
isIdentical	TokenNameIdentifier
(	TokenNameLPAREN
value1	TokenNameIdentifier
,	TokenNameCOMMA
value2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
String	TokenNameIdentifier
normalize	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
content	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
ws	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
content	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
0	TokenNameIntegerLiteral
:	TokenNameCOLON
content	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
len	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
ws	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WS_PRESERVE	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
content	TokenNameIdentifier
;	TokenNameSEMICOLON
StringBuffer	TokenNameIdentifier
sb	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ws	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WS_REPLACE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
content	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x9	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0xa	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0xd	TokenNameIntegerLiteral
)	TokenNameRPAREN
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
0x20	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
char	TokenNamechar
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isLeading	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
content	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x9	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0xa	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0xd	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x20	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
isLeading	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
content	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x9	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0xa	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0xd	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x20	TokenNameIntegerLiteral
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
isLeading	TokenNameIdentifier
)	TokenNameRPAREN
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
0x20	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
sb	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
String	TokenNameIdentifier
normalize	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
content	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
ws	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
content	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
short	TokenNameshort
norm_type	TokenNameIdentifier
=	TokenNameEQUAL
fDVNormalizeType	TokenNameIdentifier
[	TokenNameLBRACKET
fValidationDV	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
norm_type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
NORMALIZE_NONE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
content	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
norm_type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
NORMALIZE_TRIM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
XMLChar	TokenNameIdentifier
.	TokenNameDOT
trim	TokenNameIdentifier
(	TokenNameLPAREN
content	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
content	TokenNameIdentifier
instanceof	TokenNameinstanceof
StringBuffer	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
strContent	TokenNameIdentifier
=	TokenNameEQUAL
content	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
normalize	TokenNameIdentifier
(	TokenNameLPAREN
strContent	TokenNameIdentifier
,	TokenNameCOMMA
ws	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
StringBuffer	TokenNameIdentifier
sb	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
StringBuffer	TokenNameIdentifier
)	TokenNameRPAREN
content	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
sb	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
len	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ws	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WS_PRESERVE	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
sb	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ws	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WS_REPLACE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
sb	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x9	TokenNameIntegerLiteral
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0xa	TokenNameIntegerLiteral
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0xd	TokenNameIntegerLiteral
)	TokenNameRPAREN
sb	TokenNameIdentifier
.	TokenNameDOT
setCharAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
0x20	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
char	TokenNamechar
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
,	TokenNameCOMMA
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isLeading	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
sb	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x9	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0xa	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0xd	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x20	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
sb	TokenNameIdentifier
.	TokenNameDOT
setCharAt	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
isLeading	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
sb	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x9	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0xa	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0xd	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x20	TokenNameIntegerLiteral
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
isLeading	TokenNameIdentifier
)	TokenNameRPAREN
sb	TokenNameIdentifier
.	TokenNameDOT
setCharAt	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
0x20	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
sb	TokenNameIdentifier
.	TokenNameDOT
setLength	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
sb	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
reportError	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
key	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
args	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidDatatypeFacetException	TokenNameIdentifier
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidDatatypeFacetException	TokenNameIdentifier
(	TokenNameLPAREN
key	TokenNameIdentifier
,	TokenNameCOMMA
args	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
String	TokenNameIdentifier
whiteSpaceValue	TokenNameIdentifier
(	TokenNameLPAREN
short	TokenNameshort
ws	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
WS_FACET_STRING	TokenNameIdentifier
[	TokenNameLBRACKET
ws	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getOrdered	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fOrdered	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getBounded	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fBounded	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getFinite	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fFinite	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getNumeric	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fNumeric	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isDefinedFacet	TokenNameIdentifier
(	TokenNameLPAREN
short	TokenNameshort
facetName	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ANYSIMPLETYPE	TokenNameIdentifier
||	TokenNameOR_OR
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ANYATOMICTYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
facetName	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
facetName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
FACET_PATTERN	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
facetName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
FACET_PATTERN	TokenNameIdentifier
||	TokenNameOR_OR
facetName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
FACET_FRACTIONDIGITS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getDefinedFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ANYSIMPLETYPE	TokenNameIdentifier
||	TokenNameOR_OR
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ANYATOMICTYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
FACET_NONE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
|	TokenNameOR
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
|	TokenNameOR
FACET_PATTERN	TokenNameIdentifier
|	TokenNameOR
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fFacetsDefined	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isFixedFacet	TokenNameIdentifier
(	TokenNameLPAREN
short	TokenNameshort
facetName	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
facetName	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
facetName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
FACET_FRACTIONDIGITS	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getFixedFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
|	TokenNameOR
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
fFixedFacet	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getLexicalFacetValue	TokenNameIdentifier
(	TokenNameLPAREN
short	TokenNameshort
facetName	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
facetName	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
FACET_LENGTH	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
(	TokenNameLPAREN
fLength	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
FACET_MINLENGTH	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
FACET_MAXLENGTH	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
FACET_WHITESPACE	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ANYSIMPLETYPE	TokenNameIdentifier
||	TokenNameOR_OR
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ANYATOMICTYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
WS_FACET_STRING	TokenNameIdentifier
[	TokenNameLBRACKET
fWhiteSpace	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
case	TokenNamecase
FACET_MAXINCLUSIVE	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
(	TokenNameLPAREN
fMaxInclusive	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
fMaxInclusive	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
FACET_MAXEXCLUSIVE	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
(	TokenNameLPAREN
fMaxExclusive	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
fMaxExclusive	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
FACET_MINEXCLUSIVE	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
(	TokenNameLPAREN
fMinExclusive	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
fMinExclusive	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
FACET_MININCLUSIVE	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
(	TokenNameLPAREN
fMinInclusive	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
fMinInclusive	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
FACET_TOTALDIGITS	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
(	TokenNameLPAREN
fTotalDigits	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
FACET_FRACTIONDIGITS	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"0"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
StringList	TokenNameIdentifier
getLexicalEnumeration	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fLexicalEnumeration	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
StringListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
fEnumerationSize	TokenNameIdentifier
;	TokenNameSEMICOLON
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
strs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
String	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
size	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
strs	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
normalizedValue	TokenNameIdentifier
;	TokenNameSEMICOLON
fLexicalEnumeration	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringListImpl	TokenNameIdentifier
(	TokenNameLPAREN
strs	TokenNameIdentifier
,	TokenNameCOMMA
size	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fLexicalEnumeration	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
ObjectList	TokenNameIdentifier
getActualEnumeration	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fActualEnumeration	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
fActualEnumeration	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AbstractObjectList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
fEnumerationSize	TokenNameIdentifier
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
contains	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
item	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fEnumerationSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
item	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
item	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getActualValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fActualEnumeration	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
ObjectList	TokenNameIdentifier
getEnumerationItemTypeList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fEnumerationItemTypeList	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fEnumerationItemTypeList	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AbstractObjectList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
fEnumerationSize	TokenNameIdentifier
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
contains	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
item	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
!	TokenNameNOT
(	TokenNameLPAREN
item	TokenNameIdentifier
instanceof	TokenNameinstanceof
ShortList	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fEnumerationSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
itemValueTypes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
item	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
item	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
itemValueTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fEnumerationItemTypeList	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
ShortList	TokenNameIdentifier
getEnumerationTypeList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fEnumerationTypeList	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
ShortListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
short	TokenNameshort
[	TokenNameLBRACKET
]	TokenNameRBRACKET
list	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
short	TokenNameshort
[	TokenNameLBRACKET
fEnumerationSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fEnumerationSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
list	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
actualValueType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fEnumerationTypeList	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ShortListImpl	TokenNameIdentifier
(	TokenNameLPAREN
list	TokenNameIdentifier
,	TokenNameCOMMA
fEnumerationSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fEnumerationTypeList	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
StringList	TokenNameIdentifier
getLexicalPattern	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
&&	TokenNameAND_AND
fValidationDV	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
DV_INTEGER	TokenNameIdentifier
&&	TokenNameAND_AND
fPatternStr	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
StringListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fLexicalPattern	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
fPatternStr	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
0	TokenNameIntegerLiteral
:	TokenNameCOLON
fPatternStr	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
strs	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SPECIAL_PATTERN_NMTOKEN	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
strs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
String	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
strs	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
"\c+"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SPECIAL_PATTERN_NAME	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
strs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
String	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
strs	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
"\i\c*"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fPatternType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SPECIAL_PATTERN_NCNAME	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
strs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
String	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
strs	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
"\i\c*"	TokenNameStringLiteral
;	TokenNameSEMICOLON
strs	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
"[\i-[:]][\c-[:]]*"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
strs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
String	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
strs	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
"[\-+]?[0-9]+"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
strs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
String	TokenNameIdentifier
[	TokenNameLBRACKET
size	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
size	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
strs	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
String	TokenNameIdentifier
)	TokenNameRPAREN
fPatternStr	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fLexicalPattern	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringListImpl	TokenNameIdentifier
(	TokenNameLPAREN
strs	TokenNameIdentifier
,	TokenNameCOMMA
strs	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fLexicalPattern	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSObjectList	TokenNameIdentifier
getAnnotations	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
fAnnotations	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
fAnnotations	TokenNameIdentifier
:	TokenNameCOLON
XSObjectListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
calcFundamentalFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
setOrdered	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setNumeric	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setBounded	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setCardinality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setOrdered	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_ATOMIC	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fOrdered	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fOrdered	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_LIST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fOrdered	TokenNameIdentifier
=	TokenNameEQUAL
ORDERED_FALSE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
length	TokenNameIdentifier
=	TokenNameEQUAL
fMemberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fOrdered	TokenNameIdentifier
=	TokenNameEQUAL
ORDERED_PARTIAL	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
short	TokenNameshort
ancestorId	TokenNameIdentifier
=	TokenNameEQUAL
getPrimitiveDV	TokenNameIdentifier
(	TokenNameLPAREN
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
commonAnc	TokenNameIdentifier
=	TokenNameEQUAL
ancestorId	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
DV_ANYSIMPLETYPE	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
allFalse	TokenNameIdentifier
=	TokenNameEQUAL
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
fOrdered	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ORDERED_FALSE	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fMemberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
commonAnc	TokenNameIdentifier
||	TokenNameOR_OR
allFalse	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
commonAnc	TokenNameIdentifier
)	TokenNameRPAREN
commonAnc	TokenNameIdentifier
=	TokenNameEQUAL
ancestorId	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
getPrimitiveDV	TokenNameIdentifier
(	TokenNameLPAREN
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
allFalse	TokenNameIdentifier
)	TokenNameRPAREN
allFalse	TokenNameIdentifier
=	TokenNameEQUAL
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fOrdered	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ORDERED_FALSE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
commonAnc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fOrdered	TokenNameIdentifier
=	TokenNameEQUAL
fMemberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
fOrdered	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
allFalse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fOrdered	TokenNameIdentifier
=	TokenNameEQUAL
ORDERED_FALSE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fOrdered	TokenNameIdentifier
=	TokenNameEQUAL
ORDERED_PARTIAL	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setNumeric	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_ATOMIC	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fNumeric	TokenNameIdentifier
=	TokenNameEQUAL
fBase	TokenNameIdentifier
.	TokenNameDOT
fNumeric	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_LIST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fNumeric	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSSimpleType	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
memberTypes	TokenNameIdentifier
=	TokenNameEQUAL
fMemberTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
memberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
memberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getNumeric	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fNumeric	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
fNumeric	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setBounded	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_ATOMIC	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fBounded	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fBounded	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_LIST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fBounded	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fBounded	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSSimpleTypeDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
memberTypes	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
fMemberTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
short	TokenNameshort
ancestorId	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
memberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
ancestorId	TokenNameIdentifier
=	TokenNameEQUAL
getPrimitiveDV	TokenNameIdentifier
(	TokenNameLPAREN
memberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
memberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
memberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getBounded	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
ancestorId	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
getPrimitiveDV	TokenNameIdentifier
(	TokenNameLPAREN
memberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fBounded	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
fBounded	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
specialCardinalityCheck	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSSimpleTypeDecl	TokenNameIdentifier
.	TokenNameDOT
DV_DATE	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSSimpleTypeDecl	TokenNameIdentifier
.	TokenNameDOT
DV_GYEARMONTH	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSSimpleTypeDecl	TokenNameIdentifier
.	TokenNameDOT
DV_GYEAR	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSSimpleTypeDecl	TokenNameIdentifier
.	TokenNameDOT
DV_GMONTHDAY	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSSimpleTypeDecl	TokenNameIdentifier
.	TokenNameDOT
DV_GDAY	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSSimpleTypeDecl	TokenNameIdentifier
.	TokenNameDOT
DV_GMONTH	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setCardinality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_ATOMIC	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fBase	TokenNameIdentifier
.	TokenNameDOT
fFinite	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fFinite	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fFinite	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
specialCardinalityCheck	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fFinite	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fFinite	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fFinite	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_LIST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fFinite	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fFinite	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fVariety	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSSimpleType	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
memberTypes	TokenNameIdentifier
=	TokenNameEQUAL
fMemberTypes	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
memberTypes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
memberTypes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getFinite	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fFinite	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
fFinite	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
short	TokenNameshort
getPrimitiveDV	TokenNameIdentifier
(	TokenNameLPAREN
short	TokenNameshort
validationDV	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
validationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ID	TokenNameIdentifier
||	TokenNameOR_OR
validationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_IDREF	TokenNameIdentifier
||	TokenNameOR_OR
validationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_ENTITY	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
DV_STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
validationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
DV_DECIMAL	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
Constants	TokenNameIdentifier
.	TokenNameDOT
SCHEMA_1_1_SUPPORT	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
validationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_YEARMONTHDURATION	TokenNameIdentifier
||	TokenNameOR_OR
validationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_DAYTIMEDURATION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
DV_DURATION	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
validationDV	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
derivedFromType	TokenNameIdentifier
(	TokenNameLPAREN
XSTypeDefinition	TokenNameIdentifier
ancestor	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
derivation	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ancestor	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
ancestor	TokenNameIdentifier
instanceof	TokenNameinstanceof
XSSimpleTypeDelegate	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ancestor	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDelegate	TokenNameIdentifier
)	TokenNameRPAREN
ancestor	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
type	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
ancestor	TokenNameIdentifier
.	TokenNameDOT
getBaseType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
ancestor	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
XSTypeDefinition	TokenNameIdentifier
type	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
ancestor	TokenNameIdentifier
&&	TokenNameAND_AND
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fAnySimpleType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
type	TokenNameIdentifier
=	TokenNameEQUAL
type	TokenNameIdentifier
.	TokenNameDOT
getBaseType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ancestor	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
derivedFrom	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
derivation	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ancestorName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
URI_SCHEMAFORSCHEMA	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
ANY_TYPE	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
ancestorName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
XSTypeDefinition	TokenNameIdentifier
type	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
ancestorName	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
type	TokenNameIdentifier
.	TokenNameDOT
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
ancestorNS	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
.	TokenNameDOT
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fAnySimpleType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
type	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSTypeDefinition	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
.	TokenNameDOT
getBaseType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
fAnySimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isDOMDerivedFrom	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
derivationMethod	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ancestorName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
URI_SCHEMAFORSCHEMA	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
ATTVAL_ANYTYPE	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
ancestorName	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_RESTRICTION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DERIVATION_ANY	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_RESTRICTION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isDerivedByRestriction	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_LIST	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isDerivedByList	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_UNION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isDerivedByUnion	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_RESTRICTION	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_LIST	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_UNION	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_RESTRICTION	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_LIST	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
derivationMethod	TokenNameIdentifier
&	TokenNameAND
DERIVATION_UNION	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
isDerivedByAny	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
isDerivedByAny	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
XSTypeDefinition	TokenNameIdentifier
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
derivedFrom	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
XSTypeDefinition	TokenNameIdentifier
oldType	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
oldType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
ancestorName	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
type	TokenNameIdentifier
.	TokenNameDOT
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
ancestorNS	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
.	TokenNameDOT
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
derivedFrom	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isDerivedByRestriction	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
type	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
isDerivedByList	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
type	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
isDerivedByUnion	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
type	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
oldType	TokenNameIdentifier
=	TokenNameEQUAL
type	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
VARIETY_ABSENT	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
VARIETY_ATOMIC	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
type	TokenNameIdentifier
=	TokenNameEQUAL
type	TokenNameIdentifier
.	TokenNameDOT
getBaseType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getMemberTypes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
isDerivedByAny	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSTypeDefinition	TokenNameIdentifier
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getMemberTypes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
VARIETY_LIST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
type	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getItemType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
derivedFrom	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
isDerivedByRestriction	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
XSTypeDefinition	TokenNameIdentifier
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSTypeDefinition	TokenNameIdentifier
oldType	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
oldType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
ancestorName	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
ancestorNS	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
.	TokenNameDOT
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
type	TokenNameIdentifier
.	TokenNameDOT
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
ancestorNS	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
oldType	TokenNameIdentifier
=	TokenNameEQUAL
type	TokenNameIdentifier
;	TokenNameSEMICOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
type	TokenNameIdentifier
.	TokenNameDOT
getBaseType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
isDerivedByList	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
XSTypeDefinition	TokenNameIdentifier
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDefinition	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
VARIETY_LIST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSTypeDefinition	TokenNameIdentifier
itemType	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDefinition	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getItemType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
itemType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isDerivedByRestriction	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
itemType	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
isDerivedByUnion	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
XSTypeDefinition	TokenNameIdentifier
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDefinition	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSObjectList	TokenNameIdentifier
memberTypes	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleTypeDefinition	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getMemberTypes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
memberTypes	TokenNameIdentifier
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
memberTypes	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isDerivedByRestriction	TokenNameIdentifier
(	TokenNameLPAREN
ancestorNS	TokenNameIdentifier
,	TokenNameCOMMA
ancestorName	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSSimpleTypeDefinition	TokenNameIdentifier
)	TokenNameRPAREN
memberTypes	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
XSSimpleTypeDecl	TokenNameIdentifier
fAnySimpleType	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSSimpleTypeDecl	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
"anySimpleType"	TokenNameStringLiteral
,	TokenNameCOMMA
DV_ANYSIMPLETYPE	TokenNameIdentifier
,	TokenNameCOMMA
ORDERED_FALSE	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
XSConstants	TokenNameIdentifier
.	TokenNameDOT
ANYSIMPLETYPE_DT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
XSSimpleTypeDecl	TokenNameIdentifier
fAnyAtomicType	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSSimpleTypeDecl	TokenNameIdentifier
(	TokenNameLPAREN
fAnySimpleType	TokenNameIdentifier
,	TokenNameCOMMA
"anyAtomicType"	TokenNameStringLiteral
,	TokenNameCOMMA
DV_ANYATOMICTYPE	TokenNameIdentifier
,	TokenNameCOMMA
ORDERED_FALSE	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
XSSimpleTypeDecl	TokenNameIdentifier
.	TokenNameDOT
ANYATOMICTYPE_DT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
ValidationContext	TokenNameIdentifier
fDummyContext	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ValidationContext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
boolean	TokenNameboolean
needFacetChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
needExtraChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
needToNormalize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
useNamespaces	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isEntityDeclared	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isEntityUnparsed	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isIdDeclared	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addId	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addIdRef	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getSymbol	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
symbol	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
symbol	TokenNameIdentifier
.	TokenNameDOT
intern	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getURI	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
prefix	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Locale	TokenNameIdentifier
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
Locale	TokenNameIdentifier
.	TokenNameDOT
getDefault	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
fAnonymous	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
ValidationContextImpl	TokenNameIdentifier
implements	TokenNameimplements
ValidationContext	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
ValidationContext	TokenNameIdentifier
fExternal	TokenNameIdentifier
;	TokenNameSEMICOLON
ValidationContextImpl	TokenNameIdentifier
(	TokenNameLPAREN
ValidationContext	TokenNameIdentifier
external	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fExternal	TokenNameIdentifier
=	TokenNameEQUAL
external	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
NamespaceContext	TokenNameIdentifier
fNSContext	TokenNameIdentifier
;	TokenNameSEMICOLON
void	TokenNamevoid
setNSContext	TokenNameIdentifier
(	TokenNameLPAREN
NamespaceContext	TokenNameIdentifier
nsContext	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fNSContext	TokenNameIdentifier
=	TokenNameEQUAL
nsContext	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
needFacetChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fExternal	TokenNameIdentifier
.	TokenNameDOT
needFacetChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
needExtraChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fExternal	TokenNameIdentifier
.	TokenNameDOT
needExtraChecking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
needToNormalize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fExternal	TokenNameIdentifier
.	TokenNameDOT
needToNormalize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
useNamespaces	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isEntityDeclared	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fExternal	TokenNameIdentifier
.	TokenNameDOT
isEntityDeclared	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isEntityUnparsed	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fExternal	TokenNameIdentifier
.	TokenNameDOT
isEntityUnparsed	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isIdDeclared	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fExternal	TokenNameIdentifier
.	TokenNameDOT
isIdDeclared	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addId	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fExternal	TokenNameIdentifier
.	TokenNameDOT
addId	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addIdRef	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fExternal	TokenNameIdentifier
.	TokenNameDOT
addIdRef	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getSymbol	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
symbol	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fExternal	TokenNameIdentifier
.	TokenNameDOT
getSymbol	TokenNameIdentifier
(	TokenNameLPAREN
symbol	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getURI	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
prefix	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fNSContext	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fExternal	TokenNameIdentifier
.	TokenNameDOT
getURI	TokenNameIdentifier
(	TokenNameLPAREN
prefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
fNSContext	TokenNameIdentifier
.	TokenNameDOT
getURI	TokenNameIdentifier
(	TokenNameLPAREN
prefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
Locale	TokenNameIdentifier
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fExternal	TokenNameIdentifier
.	TokenNameDOT
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fIsImmutable	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
fItemType	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fMemberTypes	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fTypeName	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fTargetNamespace	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fFinalSet	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fBase	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fVariety	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fValidationDV	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fFacetsDefined	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fFixedFacet	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fWhiteSpace	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fLength	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fMinLength	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fMaxLength	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fTotalDigits	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fFractionDigits	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fPattern	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fPatternStr	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fEnumeration	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fLexicalPattern	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fLexicalEnumeration	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fActualEnumeration	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fEnumerationTypeList	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fEnumerationItemTypeList	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fMaxInclusive	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fMaxExclusive	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fMinExclusive	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fMinInclusive	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
lengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
minLengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
maxLengthAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
whiteSpaceAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
totalDigitsAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fractionDigitsAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
patternAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
enumerationAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
maxInclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
maxExclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
minInclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
minExclusiveAnnotation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fPatternType	TokenNameIdentifier
=	TokenNameEQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
;	TokenNameSEMICOLON
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fFacets	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSNamespaceItem	TokenNameIdentifier
getNamespaceItem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fNamespaceItem	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setNamespaceItem	TokenNameIdentifier
(	TokenNameLPAREN
XSNamespaceItem	TokenNameIdentifier
namespaceItem	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fNamespaceItem	TokenNameIdentifier
=	TokenNameEQUAL
namespaceItem	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
+	TokenNamePLUS
","	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
.	TokenNameDOT
fTypeName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSObjectList	TokenNameIdentifier
getFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fFacets	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
XSFacetImpl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
facets	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
[	TokenNameLBRACKET
10	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fValidationDV	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
DV_ANYSIMPLETYPE	TokenNameIdentifier
&&	TokenNameAND_AND
fValidationDV	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
DV_ANYATOMICTYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_WHITESPACE	TokenNameIdentifier
,	TokenNameCOMMA
WS_FACET_STRING	TokenNameIdentifier
[	TokenNameLBRACKET
fWhiteSpace	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
whiteSpaceAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fLength	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_LENGTH	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fLength	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
lengthAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_MINLENGTH	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMinLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fMinLength	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MINLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
minLengthAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_MAXLENGTH	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fMaxLength	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fMaxLength	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXLENGTH	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
maxLengthAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fTotalDigits	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_TOTALDIGITS	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fTotalDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fTotalDigits	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_TOTALDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
totalDigitsAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_FRACTIONDIGITS	TokenNameIdentifier
,	TokenNameCOMMA
"0"	TokenNameStringLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
fractionDigitsAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_FRACTIONDIGITS	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
fFractionDigits	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
fFractionDigits	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_FRACTIONDIGITS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
fractionDigitsAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fMaxInclusive	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_MAXINCLUSIVE	TokenNameIdentifier
,	TokenNameCOMMA
fMaxInclusive	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
fMaxInclusive	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXINCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
maxInclusiveAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fMaxExclusive	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_MAXEXCLUSIVE	TokenNameIdentifier
,	TokenNameCOMMA
fMaxExclusive	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
fMaxExclusive	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MAXEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
maxExclusiveAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fMinExclusive	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_MINEXCLUSIVE	TokenNameIdentifier
,	TokenNameCOMMA
fMinExclusive	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
fMinExclusive	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MINEXCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
minExclusiveAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fMinInclusive	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_MININCLUSIVE	TokenNameIdentifier
,	TokenNameCOMMA
fMinInclusive	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
fMinInclusive	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
fFixedFacet	TokenNameIdentifier
&	TokenNameAND
FACET_MININCLUSIVE	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
minInclusiveAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fFacets	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
count	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
XSObjectListImpl	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
,	TokenNameCOMMA
count	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
XSObjectListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
fFacets	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
fFacets	TokenNameIdentifier
:	TokenNameCOLON
XSObjectListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSObject	TokenNameIdentifier
getFacet	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
facetType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
facetType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
FACET_ENUMERATION	TokenNameIdentifier
||	TokenNameOR_OR
facetType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSObjectList	TokenNameIdentifier
list	TokenNameIdentifier
=	TokenNameEQUAL
getMultiValueFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
list	TokenNameIdentifier
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSMultiValueFacet	TokenNameIdentifier
f	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSMultiValueFacet	TokenNameIdentifier
)	TokenNameRPAREN
list	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
f	TokenNameIdentifier
.	TokenNameDOT
getFacetKind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
facetType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
f	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
XSObjectList	TokenNameIdentifier
list	TokenNameIdentifier
=	TokenNameEQUAL
getFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
list	TokenNameIdentifier
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSFacet	TokenNameIdentifier
f	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSFacet	TokenNameIdentifier
)	TokenNameRPAREN
list	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
f	TokenNameIdentifier
.	TokenNameDOT
getFacetKind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
facetType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
f	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSObjectList	TokenNameIdentifier
getMultiValueFacets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fMultiValueFacets	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_ENUMERATION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
fPatternType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
||	TokenNameOR_OR
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
XSMVFacetImpl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
facets	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSMVFacetImpl	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
fFacetsDefined	TokenNameIdentifier
&	TokenNameAND
FACET_PATTERN	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
fPatternType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SPECIAL_PATTERN_NONE	TokenNameIdentifier
||	TokenNameOR_OR
fValidationDV	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
DV_INTEGER	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSMVFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_PATTERN	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
getLexicalPattern	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
patternAnnotations	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
facets	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
XSMVFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
FACET_ENUMERATION	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
getLexicalEnumeration	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
ObjectListImpl	TokenNameIdentifier
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
,	TokenNameCOMMA
fEnumerationSize	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
enumerationAnnotations	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fMultiValueFacets	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSObjectListImpl	TokenNameIdentifier
(	TokenNameLPAREN
facets	TokenNameIdentifier
,	TokenNameCOMMA
count	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
fMultiValueFacets	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
fMultiValueFacets	TokenNameIdentifier
:	TokenNameCOLON
XSObjectListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
getMinInclusiveValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fMinInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
getMinExclusiveValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fMinExclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
getMaxInclusiveValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fMaxInclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
getMaxExclusiveValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fMaxExclusive	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setAnonymous	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
anon	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fAnonymous	TokenNameIdentifier
=	TokenNameEQUAL
anon	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
XSFacetImpl	TokenNameIdentifier
implements	TokenNameimplements
XSFacet	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
short	TokenNameshort
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
svalue	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
ivalue	TokenNameIdentifier
;	TokenNameSEMICOLON
Object	TokenNameIdentifier
avalue	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
fixed	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
XSObjectList	TokenNameIdentifier
annotations	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
short	TokenNameshort
kind	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
svalue	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
ivalue	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
avalue	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
fixed	TokenNameIdentifier
,	TokenNameCOMMA
XSAnnotation	TokenNameIdentifier
annotation	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
kind	TokenNameIdentifier
=	TokenNameEQUAL
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
svalue	TokenNameIdentifier
=	TokenNameEQUAL
svalue	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
ivalue	TokenNameIdentifier
=	TokenNameEQUAL
ivalue	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
avalue	TokenNameIdentifier
=	TokenNameEQUAL
avalue	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fixed	TokenNameIdentifier
=	TokenNameEQUAL
fixed	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
annotation	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
annotations	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSObjectListImpl	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
(	TokenNameLPAREN
(	TokenNameLPAREN
XSObjectListImpl	TokenNameIdentifier
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
annotations	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
addXSObject	TokenNameIdentifier
(	TokenNameLPAREN
annotation	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
annotations	TokenNameIdentifier
=	TokenNameEQUAL
XSObjectListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
XSAnnotation	TokenNameIdentifier
getAnnotation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
XSAnnotation	TokenNameIdentifier
)	TokenNameRPAREN
annotations	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSObjectList	TokenNameIdentifier
getAnnotations	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
annotations	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getFacetKind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getLexicalFacetValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
svalue	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
getActualFacetValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
avalue	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
kind	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
FACET_WHITESPACE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
avalue	TokenNameIdentifier
=	TokenNameEQUAL
svalue	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
avalue	TokenNameIdentifier
=	TokenNameEQUAL
BigInteger	TokenNameIdentifier
.	TokenNameDOT
valueOf	TokenNameIdentifier
(	TokenNameLPAREN
ivalue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
avalue	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getIntFacetValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
ivalue	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getFixed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fixed	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSNamespaceItem	TokenNameIdentifier
getNamespaceItem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
XSConstants	TokenNameIdentifier
.	TokenNameDOT
FACET	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
XSMVFacetImpl	TokenNameIdentifier
implements	TokenNameimplements
XSMultiValueFacet	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
short	TokenNameshort
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
XSObjectList	TokenNameIdentifier
annotations	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
StringList	TokenNameIdentifier
svalues	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
ObjectList	TokenNameIdentifier
avalues	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSMVFacetImpl	TokenNameIdentifier
(	TokenNameLPAREN
short	TokenNameshort
kind	TokenNameIdentifier
,	TokenNameCOMMA
StringList	TokenNameIdentifier
svalues	TokenNameIdentifier
,	TokenNameCOMMA
ObjectList	TokenNameIdentifier
avalues	TokenNameIdentifier
,	TokenNameCOMMA
XSObjectList	TokenNameIdentifier
annotations	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
kind	TokenNameIdentifier
=	TokenNameEQUAL
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
svalues	TokenNameIdentifier
=	TokenNameEQUAL
svalues	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
avalues	TokenNameIdentifier
=	TokenNameEQUAL
avalues	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
annotations	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
annotations	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
annotations	TokenNameIdentifier
:	TokenNameCOLON
XSObjectListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getFacetKind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSObjectList	TokenNameIdentifier
getAnnotations	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
annotations	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
StringList	TokenNameIdentifier
getLexicalFacetValues	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
svalues	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
ObjectList	TokenNameIdentifier
getEnumerationValues	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
avalues	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
XSNamespaceItem	TokenNameIdentifier
getNamespaceItem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
short	TokenNameshort
getType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
XSConstants	TokenNameIdentifier
.	TokenNameDOT
MULTIVALUE_FACET	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
abstract	TokenNameabstract
class	TokenNameclass
AbstractObjectList	TokenNameIdentifier
extends	TokenNameextends
AbstractList	TokenNameIdentifier
implements	TokenNameimplements
ObjectList	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
get	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
item	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
IndexOutOfBoundsException	TokenNameIdentifier
(	TokenNameLPAREN
"Index: "	TokenNameStringLiteral
+	TokenNamePLUS
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getTypeNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isDerivedFrom	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
typeNamespaceArg	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
typeNameArg	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
derivationMethod	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
isDOMDerivedFrom	TokenNameIdentifier
(	TokenNameLPAREN
typeNamespaceArg	TokenNameIdentifier
,	TokenNameCOMMA
typeNameArg	TokenNameIdentifier
,	TokenNameCOMMA
derivationMethod	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
short	TokenNameshort
convertToPrimitiveKind	TokenNameIdentifier
(	TokenNameLPAREN
short	TokenNameshort
valueType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
valueType	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
NOTATION_DT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
valueType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
valueType	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
ENTITY_DT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
XSConstants	TokenNameIdentifier
.	TokenNameDOT
STRING_DT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
valueType	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
POSITIVEINTEGER_DT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
XSConstants	TokenNameIdentifier
.	TokenNameDOT
DECIMAL_DT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
valueType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
appendEnumString	TokenNameIdentifier
(	TokenNameLPAREN
StringBuffer	TokenNameIdentifier
sb	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'['	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fEnumerationSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
", "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
fEnumeration	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
actualValue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
']'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
