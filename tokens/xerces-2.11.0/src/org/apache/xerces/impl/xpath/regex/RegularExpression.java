package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
regex	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
text	TokenNameIdentifier
.	TokenNameDOT
CharacterIterator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Locale	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Stack	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
IntStack	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
RegularExpression	TokenNameIdentifier
implements	TokenNameimplements
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
Serializable	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
serialVersionUID	TokenNameIdentifier
=	TokenNameEQUAL
6242499334195006401L	TokenNameLongLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
DEBUG	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
synchronized	TokenNamesynchronized
void	TokenNamevoid
compile	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
tok	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
numberOfClosures	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Op	TokenNameIdentifier
compile	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
tok	TokenNameIdentifier
,	TokenNameCOMMA
Op	TokenNameIdentifier
next	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
reverse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Op	TokenNameIdentifier
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
DOT	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createDot	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
CHAR	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createChar	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
ANCHOR	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createAnchor	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
RANGE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
NRANGE	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createRange	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
CONCAT	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
reverse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
tok	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
ret	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
tok	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
ret	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
UNION	TokenNameIdentifier
:	TokenNameCOLON
Op	TokenNameIdentifier
.	TokenNameDOT
UnionOp	TokenNameIdentifier
uni	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createUnion	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
tok	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
uni	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
uni	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
CLOSURE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
NONGREEDYCLOSURE	TokenNameIdentifier
:	TokenNameCOLON
Token	TokenNameIdentifier
child	TokenNameIdentifier
=	TokenNameEQUAL
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
min	TokenNameIdentifier
=	TokenNameEQUAL
tok	TokenNameIdentifier
.	TokenNameDOT
getMin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
max	TokenNameIdentifier
=	TokenNameEQUAL
tok	TokenNameIdentifier
.	TokenNameDOT
getMax	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
min	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
min	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
max	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
min	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
compile	TokenNameIdentifier
(	TokenNameLPAREN
child	TokenNameIdentifier
,	TokenNameCOMMA
ret	TokenNameIdentifier
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
min	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
max	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
max	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
min	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
max	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
max	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
Op	TokenNameIdentifier
.	TokenNameDOT
ChildOp	TokenNameIdentifier
q	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createQuestion	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
NONGREEDYCLOSURE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
q	TokenNameIdentifier
.	TokenNameDOT
setChild	TokenNameIdentifier
(	TokenNameLPAREN
compile	TokenNameIdentifier
(	TokenNameLPAREN
child	TokenNameIdentifier
,	TokenNameCOMMA
ret	TokenNameIdentifier
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
q	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
Op	TokenNameIdentifier
.	TokenNameDOT
ChildOp	TokenNameIdentifier
op	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
NONGREEDYCLOSURE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createNonGreedyClosure	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createClosure	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
numberOfClosures	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
op	TokenNameIdentifier
.	TokenNameDOT
setChild	TokenNameIdentifier
(	TokenNameLPAREN
compile	TokenNameIdentifier
(	TokenNameLPAREN
child	TokenNameIdentifier
,	TokenNameCOMMA
op	TokenNameIdentifier
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
min	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
min	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
compile	TokenNameIdentifier
(	TokenNameLPAREN
child	TokenNameIdentifier
,	TokenNameCOMMA
ret	TokenNameIdentifier
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
EMPTY	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createString	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
BACKREFERENCE	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createBackReference	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getReferenceNumber	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
PAREN	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getParenNumber	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
reverse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
next	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createCapture	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getParenNumber	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
next	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
next	TokenNameIdentifier
=	TokenNameEQUAL
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createCapture	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
tok	TokenNameIdentifier
.	TokenNameDOT
getParenNumber	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
next	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
next	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createCapture	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
tok	TokenNameIdentifier
.	TokenNameDOT
getParenNumber	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
next	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
next	TokenNameIdentifier
=	TokenNameEQUAL
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createCapture	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getParenNumber	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
next	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
LOOKAHEAD	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createLook	TokenNameIdentifier
(	TokenNameLPAREN
Op	TokenNameIdentifier
.	TokenNameDOT
LOOKAHEAD	TokenNameIdentifier
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKAHEAD	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createLook	TokenNameIdentifier
(	TokenNameLPAREN
Op	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKAHEAD	TokenNameIdentifier
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
LOOKBEHIND	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createLook	TokenNameIdentifier
(	TokenNameLPAREN
Op	TokenNameIdentifier
.	TokenNameDOT
LOOKBEHIND	TokenNameIdentifier
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKBEHIND	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createLook	TokenNameIdentifier
(	TokenNameLPAREN
Op	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKBEHIND	TokenNameIdentifier
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
INDEPENDENT	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createIndependent	TokenNameIdentifier
(	TokenNameLPAREN
next	TokenNameIdentifier
,	TokenNameCOMMA
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
MODIFIERGROUP	TokenNameIdentifier
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createModifier	TokenNameIdentifier
(	TokenNameLPAREN
next	TokenNameIdentifier
,	TokenNameCOMMA
compile	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
ModifierToken	TokenNameIdentifier
)	TokenNameRPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getOptions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
ModifierToken	TokenNameIdentifier
)	TokenNameRPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getOptionsMask	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
CONDITION	TokenNameIdentifier
:	TokenNameCOLON
Token	TokenNameIdentifier
.	TokenNameDOT
ConditionToken	TokenNameIdentifier
ctok	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
ConditionToken	TokenNameIdentifier
)	TokenNameRPAREN
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
ref	TokenNameIdentifier
=	TokenNameEQUAL
ctok	TokenNameIdentifier
.	TokenNameDOT
refNumber	TokenNameIdentifier
;	TokenNameSEMICOLON
Op	TokenNameIdentifier
condition	TokenNameIdentifier
=	TokenNameEQUAL
ctok	TokenNameIdentifier
.	TokenNameDOT
condition	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
compile	TokenNameIdentifier
(	TokenNameLPAREN
ctok	TokenNameIdentifier
.	TokenNameDOT
condition	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Op	TokenNameIdentifier
yes	TokenNameIdentifier
=	TokenNameEQUAL
compile	TokenNameIdentifier
(	TokenNameLPAREN
ctok	TokenNameIdentifier
.	TokenNameDOT
yes	TokenNameIdentifier
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Op	TokenNameIdentifier
no	TokenNameIdentifier
=	TokenNameEQUAL
ctok	TokenNameIdentifier
.	TokenNameDOT
no	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
compile	TokenNameIdentifier
(	TokenNameLPAREN
ctok	TokenNameIdentifier
.	TokenNameDOT
no	TokenNameIdentifier
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
reverse	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
createCondition	TokenNameIdentifier
(	TokenNameLPAREN
next	TokenNameIdentifier
,	TokenNameCOMMA
ref	TokenNameIdentifier
,	TokenNameCOMMA
condition	TokenNameIdentifier
,	TokenNameCOMMA
yes	TokenNameIdentifier
,	TokenNameCOMMA
no	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Unknown token type: "	TokenNameStringLiteral
+	TokenNamePLUS
tok	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
matches	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
target	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
Match	TokenNameIdentifier
)	TokenNameRPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
matches	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
target	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
Match	TokenNameIdentifier
)	TokenNameRPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
matches	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
target	TokenNameIdentifier
,	TokenNameCOMMA
Match	TokenNameIdentifier
match	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
target	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
,	TokenNameCOMMA
match	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
matches	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
target	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
end	TokenNameIdentifier
,	TokenNameCOMMA
Match	TokenNameIdentifier
match	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
prepare	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Context	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Context	TokenNameIdentifier
con	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
.	TokenNameDOT
inuse	TokenNameIdentifier
?	TokenNameQUESTION
new	TokenNamenew
Context	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
numberOfClosures	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
match	TokenNameIdentifier
.	TokenNameDOT
setNumberOfGroups	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
match	TokenNameIdentifier
.	TokenNameDOT
setSource	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
hasBackReferences	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
match	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Match	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
match	TokenNameIdentifier
.	TokenNameDOT
setNumberOfGroups	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
=	TokenNameEQUAL
match	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
matchEnd	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedStringOnly	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
o	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
fixedStringTable	TokenNameIdentifier
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
o	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
o	TokenNameIdentifier
+	TokenNamePLUS
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
o	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
fixedStringTable	TokenNameIdentifier
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
limit	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
-	TokenNameMINUS
this	TokenNamethis
.	TokenNameDOT
minlength	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
matchStart	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
CLOSURE	TokenNameIdentifier
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
DOT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
SINGLE_LINE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
boolean	TokenNameboolean
previousIsEOL	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
[	TokenNameLBRACKET
matchStart	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isEOLChar	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
previousIsEOL	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
previousIsEOL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
previousIsEOL	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
firstChar	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
RangeToken	TokenNameIdentifier
range	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
firstChar	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
[	TokenNameLBRACKET
matchStart	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
REUtil	TokenNameIdentifier
.	TokenNameDOT
isHighSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
matchStart	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
REUtil	TokenNameIdentifier
.	TokenNameDOT
composeFromSurrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
target	TokenNameIdentifier
[	TokenNameLBRACKET
matchStart	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
range	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
matchEnd	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
matches	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
target	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
Match	TokenNameIdentifier
)	TokenNameRPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
matches	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
target	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
Match	TokenNameIdentifier
)	TokenNameRPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
matches	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
target	TokenNameIdentifier
,	TokenNameCOMMA
Match	TokenNameIdentifier
match	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
target	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
match	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
matches	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
target	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
end	TokenNameIdentifier
,	TokenNameCOMMA
Match	TokenNameIdentifier
match	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
prepare	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Context	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Context	TokenNameIdentifier
con	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
.	TokenNameDOT
inuse	TokenNameIdentifier
?	TokenNameQUESTION
new	TokenNamenew
Context	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
numberOfClosures	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
match	TokenNameIdentifier
.	TokenNameDOT
setNumberOfGroups	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
match	TokenNameIdentifier
.	TokenNameDOT
setSource	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
hasBackReferences	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
match	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Match	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
match	TokenNameIdentifier
.	TokenNameDOT
setNumberOfGroups	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
=	TokenNameEQUAL
match	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"target string="	TokenNameStringLiteral
+	TokenNamePLUS
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"matchEnd="	TokenNameStringLiteral
+	TokenNamePLUS
matchEnd	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"con.limit="	TokenNameStringLiteral
+	TokenNamePLUS
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
matchEnd	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedStringOnly	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
o	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
fixedStringTable	TokenNameIdentifier
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
o	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
o	TokenNameIdentifier
+	TokenNamePLUS
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
o	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
fixedStringTable	TokenNameIdentifier
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
limit	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
-	TokenNameMINUS
this	TokenNamethis
.	TokenNameDOT
minlength	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
matchStart	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
CLOSURE	TokenNameIdentifier
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
DOT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
SINGLE_LINE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
boolean	TokenNameboolean
previousIsEOL	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isEOLChar	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
previousIsEOL	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
previousIsEOL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
previousIsEOL	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
firstChar	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
RangeToken	TokenNameIdentifier
range	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
firstChar	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
REUtil	TokenNameIdentifier
.	TokenNameDOT
isHighSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
matchStart	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
REUtil	TokenNameIdentifier
.	TokenNameDOT
composeFromSurrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
range	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
matchEnd	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
match	TokenNameIdentifier
(	TokenNameLPAREN
Context	TokenNameIdentifier
con	TokenNameIdentifier
,	TokenNameCOMMA
Op	TokenNameIdentifier
op	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
dx	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
opts	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
ExpressionTarget	TokenNameIdentifier
target	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
Stack	TokenNameIdentifier
opStack	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Stack	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
IntStack	TokenNameIdentifier
dataStack	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IntStack	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
isSetIgnoreCase	TokenNameIdentifier
=	TokenNameEQUAL
isSet	TokenNameIdentifier
(	TokenNameLPAREN
opts	TokenNameIdentifier
,	TokenNameCOMMA
IGNORE_CASE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
retValue	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
returned	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
op	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
offset	TokenNameIdentifier
>	TokenNameGREATER
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
||	TokenNameOR_OR
offset	TokenNameIdentifier
<	TokenNameLESS
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
op	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
retValue	TokenNameIdentifier
=	TokenNameEQUAL
isSet	TokenNameIdentifier
(	TokenNameLPAREN
opts	TokenNameIdentifier
,	TokenNameCOMMA
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
offset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
?	TokenNameQUESTION
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
retValue	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
retValue	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
op	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
CHAR	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
o1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dx	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
offset	TokenNameIdentifier
:	TokenNameCOLON
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o1	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
||	TokenNameOR_OR
o1	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
matchChar	TokenNameIdentifier
(	TokenNameLPAREN
op	TokenNameIdentifier
.	TokenNameDOT
getData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
o1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
isSetIgnoreCase	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
offset	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dx	TokenNameIdentifier
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
DOT	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
int	TokenNameint
o1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dx	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
offset	TokenNameIdentifier
:	TokenNameCOLON
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o1	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
||	TokenNameOR_OR
o1	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isSet	TokenNameIdentifier
(	TokenNameLPAREN
opts	TokenNameIdentifier
,	TokenNameCOMMA
SINGLE_LINE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
REUtil	TokenNameIdentifier
.	TokenNameDOT
isHighSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
o1	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
o1	TokenNameIdentifier
+	TokenNamePLUS
dx	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
o1	TokenNameIdentifier
+	TokenNamePLUS
dx	TokenNameIdentifier
<	TokenNameLESS
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
o1	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dx	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
o1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
REUtil	TokenNameIdentifier
.	TokenNameDOT
isHighSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
o1	TokenNameIdentifier
+	TokenNamePLUS
dx	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
o1	TokenNameIdentifier
+	TokenNamePLUS
dx	TokenNameIdentifier
<	TokenNameLESS
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
o1	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dx	TokenNameIdentifier
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
=	TokenNameEQUAL
REUtil	TokenNameIdentifier
.	TokenNameDOT
composeFromSurrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
o1	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isEOLChar	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
offset	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dx	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
o1	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
o1	TokenNameIdentifier
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
RANGE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
NRANGE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
int	TokenNameint
o1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dx	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
offset	TokenNameIdentifier
:	TokenNameCOLON
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o1	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
||	TokenNameOR_OR
o1	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
REUtil	TokenNameIdentifier
.	TokenNameDOT
isHighSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
o1	TokenNameIdentifier
+	TokenNamePLUS
dx	TokenNameIdentifier
<	TokenNameLESS
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
&&	TokenNameAND_AND
o1	TokenNameIdentifier
+	TokenNamePLUS
dx	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
o1	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dx	TokenNameIdentifier
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
=	TokenNameEQUAL
REUtil	TokenNameIdentifier
.	TokenNameDOT
composeFromSurrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
o1	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
RangeToken	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
tok	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
offset	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dx	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
o1	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
o1	TokenNameIdentifier
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
ANCHOR	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
matchAnchor	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
op	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
BACKREFERENCE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
int	TokenNameint
refno	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
refno	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
refno	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Internal Error: Reference number must be more than zero: "	TokenNameStringLiteral
+	TokenNamePLUS
refno	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
getBeginning	TokenNameIdentifier
(	TokenNameLPAREN
refno	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
refno	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
o2	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
getBeginning	TokenNameIdentifier
(	TokenNameLPAREN
refno	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
literallen	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
refno	TokenNameIdentifier
)	TokenNameRPAREN
-	TokenNameMINUS
o2	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dx	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
target	TokenNameIdentifier
.	TokenNameDOT
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
isSetIgnoreCase	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
o2	TokenNameIdentifier
,	TokenNameCOMMA
literallen	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
offset	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
literallen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
target	TokenNameIdentifier
.	TokenNameDOT
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
isSetIgnoreCase	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
-	TokenNameMINUS
literallen	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
o2	TokenNameIdentifier
,	TokenNameCOMMA
literallen	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
offset	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
literallen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
String	TokenNameIdentifier
literal	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
literallen	TokenNameIdentifier
=	TokenNameEQUAL
literal	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dx	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
target	TokenNameIdentifier
.	TokenNameDOT
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
isSetIgnoreCase	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
literal	TokenNameIdentifier
,	TokenNameCOMMA
literallen	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
offset	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
literallen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
target	TokenNameIdentifier
.	TokenNameDOT
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
isSetIgnoreCase	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
-	TokenNameMINUS
literallen	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
literal	TokenNameIdentifier
,	TokenNameCOMMA
literallen	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
offset	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
literallen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
CLOSURE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
id	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
closureContexts	TokenNameIdentifier
[	TokenNameLBRACKET
id	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
closureContexts	TokenNameIdentifier
[	TokenNameLBRACKET
id	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
addOffset	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
QUESTION	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
opStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
op	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
NONGREEDYCLOSURE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
NONGREEDYQUESTION	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
opStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
op	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
UNION	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
op	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
opStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
op	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
CAPTURE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
refno	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
refno	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
getBeginning	TokenNameIdentifier
(	TokenNameLPAREN
refno	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
refno	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
refno	TokenNameIdentifier
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
opStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
op	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
LOOKAHEAD	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKAHEAD	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
LOOKBEHIND	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKBEHIND	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
opStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
op	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
dx	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dx	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
op	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
LOOKAHEAD	TokenNameIdentifier
||	TokenNameOR_OR
op	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKAHEAD	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
INDEPENDENT	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
opStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
op	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
MODIFIER	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
int	TokenNameint
localopts	TokenNameIdentifier
=	TokenNameEQUAL
opts	TokenNameIdentifier
;	TokenNameSEMICOLON
localopts	TokenNameIdentifier
|=	TokenNameOR_EQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
localopts	TokenNameIdentifier
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
op	TokenNameIdentifier
.	TokenNameDOT
getData2	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
opStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
op	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
opts	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
opts	TokenNameIdentifier
=	TokenNameEQUAL
localopts	TokenNameIdentifier
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
CONDITION	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
Op	TokenNameIdentifier
.	TokenNameDOT
ConditionOp	TokenNameIdentifier
cop	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Op	TokenNameIdentifier
.	TokenNameDOT
ConditionOp	TokenNameIdentifier
)	TokenNameRPAREN
op	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cop	TokenNameIdentifier
.	TokenNameDOT
refNumber	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cop	TokenNameIdentifier
.	TokenNameDOT
refNumber	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Internal Error: Reference number must be more than zero: "	TokenNameStringLiteral
+	TokenNamePLUS
cop	TokenNameIdentifier
.	TokenNameDOT
refNumber	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
getBeginning	TokenNameIdentifier
(	TokenNameLPAREN
cop	TokenNameIdentifier
.	TokenNameDOT
refNumber	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
cop	TokenNameIdentifier
.	TokenNameDOT
refNumber	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
cop	TokenNameIdentifier
.	TokenNameDOT
yes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
cop	TokenNameIdentifier
.	TokenNameDOT
no	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
cop	TokenNameIdentifier
.	TokenNameDOT
no	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
cop	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
opStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
op	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
cop	TokenNameIdentifier
.	TokenNameDOT
condition	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Unknown operation type: "	TokenNameStringLiteral
+	TokenNamePLUS
op	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
returned	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
opStack	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
retValue	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Op	TokenNameIdentifier
)	TokenNameRPAREN
opStack	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
offset	TokenNameIdentifier
=	TokenNameEQUAL
dataStack	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
op	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
CLOSURE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
QUESTION	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
retValue	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
returned	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
NONGREEDYCLOSURE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
NONGREEDYQUESTION	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
retValue	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
returned	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
UNION	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
int	TokenNameint
unionIndex	TokenNameIdentifier
=	TokenNameEQUAL
dataStack	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"UNION: "	TokenNameStringLiteral
+	TokenNamePLUS
unionIndex	TokenNameIdentifier
+	TokenNamePLUS
", ret="	TokenNameStringLiteral
+	TokenNamePLUS
retValue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
retValue	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
unionIndex	TokenNameIdentifier
<	TokenNameLESS
op	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
opStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
op	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
unionIndex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dataStack	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
unionIndex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
returned	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
retValue	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
CAPTURE	TokenNameIdentifier
:	TokenNameCOLON
final	TokenNamefinal
int	TokenNameint
refno	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
getData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
saved	TokenNameIdentifier
=	TokenNameEQUAL
dataStack	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
retValue	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
refno	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
refno	TokenNameIdentifier
,	TokenNameCOMMA
saved	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
refno	TokenNameIdentifier
,	TokenNameCOMMA
saved	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
LOOKAHEAD	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
LOOKBEHIND	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
dx	TokenNameIdentifier
=	TokenNameEQUAL
dataStack	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
retValue	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
returned	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
retValue	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKAHEAD	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKBEHIND	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
dx	TokenNameIdentifier
=	TokenNameEQUAL
dataStack	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
>	TokenNameGREATER
retValue	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
returned	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
retValue	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
MODIFIER	TokenNameIdentifier
:	TokenNameCOLON
opts	TokenNameIdentifier
=	TokenNameEQUAL
dataStack	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
INDEPENDENT	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
retValue	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
offset	TokenNameIdentifier
=	TokenNameEQUAL
retValue	TokenNameIdentifier
;	TokenNameSEMICOLON
op	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
returned	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Op	TokenNameIdentifier
.	TokenNameDOT
CONDITION	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
final	TokenNamefinal
Op	TokenNameIdentifier
.	TokenNameDOT
ConditionOp	TokenNameIdentifier
cop	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Op	TokenNameIdentifier
.	TokenNameDOT
ConditionOp	TokenNameIdentifier
)	TokenNameRPAREN
op	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
retValue	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
cop	TokenNameIdentifier
.	TokenNameDOT
yes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
cop	TokenNameIdentifier
.	TokenNameDOT
no	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
cop	TokenNameIdentifier
.	TokenNameDOT
no	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
op	TokenNameIdentifier
=	TokenNameEQUAL
cop	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
returned	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
matchChar	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
ch	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
other	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
ignoreCase	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
ignoreCase	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
matchIgnoreCase	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
other	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
matchAnchor	TokenNameIdentifier
(	TokenNameLPAREN
ExpressionTarget	TokenNameIdentifier
target	TokenNameIdentifier
,	TokenNameCOMMA
Op	TokenNameIdentifier
op	TokenNameIdentifier
,	TokenNameCOMMA
Context	TokenNameIdentifier
con	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
opts	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
go	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
op	TokenNameIdentifier
.	TokenNameDOT
getData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'^'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
isSet	TokenNameIdentifier
(	TokenNameLPAREN
opts	TokenNameIdentifier
,	TokenNameCOMMA
MULTIPLE_LINES	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
||	TokenNameOR_OR
offset	TokenNameIdentifier
>	TokenNameGREATER
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
&&	TokenNameAND_AND
offset	TokenNameIdentifier
<	TokenNameLESS
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
&&	TokenNameAND_AND
isEOLChar	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'@'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
||	TokenNameOR_OR
offset	TokenNameIdentifier
>	TokenNameGREATER
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
&&	TokenNameAND_AND
isEOLChar	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'$'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
isSet	TokenNameIdentifier
(	TokenNameLPAREN
opts	TokenNameIdentifier
,	TokenNameCOMMA
MULTIPLE_LINES	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
||	TokenNameOR_OR
offset	TokenNameIdentifier
<	TokenNameLESS
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
&&	TokenNameAND_AND
isEOLChar	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
||	TokenNameOR_OR
offset	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
&&	TokenNameAND_AND
isEOLChar	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
offset	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
&&	TokenNameAND_AND
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
CARRIAGE_RETURN	TokenNameIdentifier
&&	TokenNameAND_AND
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
LINE_FEED	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'A'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'Z'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
||	TokenNameOR_OR
offset	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
&&	TokenNameAND_AND
isEOLChar	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
offset	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
&&	TokenNameAND_AND
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
CARRIAGE_RETURN	TokenNameIdentifier
&&	TokenNameAND_AND
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
LINE_FEED	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'z'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'b'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
{	TokenNameLBRACE
int	TokenNameint
after	TokenNameIdentifier
=	TokenNameEQUAL
getWordType	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
after	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WT_IGNORE	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
int	TokenNameint
before	TokenNameIdentifier
=	TokenNameEQUAL
getPreviousWordType	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
after	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
before	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'B'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
go	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
after	TokenNameIdentifier
=	TokenNameEQUAL
getWordType	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
go	TokenNameIdentifier
=	TokenNameEQUAL
after	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WT_IGNORE	TokenNameIdentifier
||	TokenNameOR_OR
after	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
getPreviousWordType	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
go	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
getWordType	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
WT_LETTER	TokenNameIdentifier
||	TokenNameOR_OR
getPreviousWordType	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
WT_OTHER	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
getWordType	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
WT_OTHER	TokenNameIdentifier
||	TokenNameOR_OR
getPreviousWordType	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
WT_LETTER	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
getPreviousWordType	TokenNameIdentifier
(	TokenNameLPAREN
ExpressionTarget	TokenNameIdentifier
target	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
begin	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
end	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
opts	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ret	TokenNameIdentifier
=	TokenNameEQUAL
getWordType	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
begin	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
,	TokenNameCOMMA
--	TokenNameMINUS_MINUS
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
ret	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
WT_IGNORE	TokenNameIdentifier
)	TokenNameRPAREN
ret	TokenNameIdentifier
=	TokenNameEQUAL
getWordType	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
begin	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
,	TokenNameCOMMA
--	TokenNameMINUS_MINUS
offset	TokenNameIdentifier
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
getWordType	TokenNameIdentifier
(	TokenNameLPAREN
ExpressionTarget	TokenNameIdentifier
target	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
begin	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
end	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
opts	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
<	TokenNameLESS
begin	TokenNameIdentifier
||	TokenNameOR_OR
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
end	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
WT_OTHER	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
getWordType0	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
opts	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
matches	TokenNameIdentifier
(	TokenNameLPAREN
CharacterIterator	TokenNameIdentifier
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
Match	TokenNameIdentifier
)	TokenNameRPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
matches	TokenNameIdentifier
(	TokenNameLPAREN
CharacterIterator	TokenNameIdentifier
target	TokenNameIdentifier
,	TokenNameCOMMA
Match	TokenNameIdentifier
match	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
getBeginIndex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
getEndIndex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
prepare	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Context	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Context	TokenNameIdentifier
con	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
.	TokenNameDOT
inuse	TokenNameIdentifier
?	TokenNameQUESTION
new	TokenNamenew
Context	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
numberOfClosures	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
match	TokenNameIdentifier
.	TokenNameDOT
setNumberOfGroups	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
match	TokenNameIdentifier
.	TokenNameDOT
setSource	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
hasBackReferences	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
match	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Match	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
match	TokenNameIdentifier
.	TokenNameDOT
setNumberOfGroups	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
=	TokenNameEQUAL
match	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
matchEnd	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedStringOnly	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
o	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
fixedStringTable	TokenNameIdentifier
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
o	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
o	TokenNameIdentifier
+	TokenNamePLUS
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
o	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
fixedStringTable	TokenNameIdentifier
.	TokenNameDOT
matches	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
limit	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
-	TokenNameMINUS
this	TokenNamethis
.	TokenNameDOT
minlength	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
matchStart	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
CLOSURE	TokenNameIdentifier
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
DOT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
SINGLE_LINE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
boolean	TokenNameboolean
previousIsEOL	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isEOLChar	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
previousIsEOL	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
previousIsEOL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
previousIsEOL	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
firstChar	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
RangeToken	TokenNameIdentifier
range	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
firstChar	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
REUtil	TokenNameIdentifier
.	TokenNameDOT
isHighSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
matchStart	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
con	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
REUtil	TokenNameIdentifier
.	TokenNameDOT
composeFromSurrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
target	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
range	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
matchStart	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
matchStart	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<=	TokenNameLESS_EQUAL
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
con	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
matchEnd	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setBeginning	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
matchStart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
con	TokenNameIdentifier
.	TokenNameDOT
match	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
matchEnd	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
con	TokenNameIdentifier
.	TokenNameDOT
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
String	TokenNameIdentifier
regex	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
options	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
nofparen	TokenNameIdentifier
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tokentree	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
hasBackReferences	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
transient	TokenNametransient
int	TokenNameint
minlength	TokenNameIdentifier
;	TokenNameSEMICOLON
transient	TokenNametransient
Op	TokenNameIdentifier
operations	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
transient	TokenNametransient
int	TokenNameint
numberOfClosures	TokenNameIdentifier
;	TokenNameSEMICOLON
transient	TokenNametransient
Context	TokenNameIdentifier
context	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
transient	TokenNametransient
RangeToken	TokenNameIdentifier
firstChar	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
transient	TokenNametransient
String	TokenNameIdentifier
fixedString	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
transient	TokenNametransient
int	TokenNameint
fixedStringOptions	TokenNameIdentifier
;	TokenNameSEMICOLON
transient	TokenNametransient
BMPattern	TokenNameIdentifier
fixedStringTable	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
transient	TokenNametransient
boolean	TokenNameboolean
fixedStringOnly	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
static	TokenNamestatic
abstract	TokenNameabstract
class	TokenNameclass
ExpressionTarget	TokenNameIdentifier
{	TokenNameLBRACE
abstract	TokenNameabstract
char	TokenNamechar
charAt	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
abstract	TokenNameabstract
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
ignoreCase	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
abstract	TokenNameabstract
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
ignoreCase	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
StringTarget	TokenNameIdentifier
extends	TokenNameextends
ExpressionTarget	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
String	TokenNameIdentifier
target	TokenNameIdentifier
;	TokenNameSEMICOLON
StringTarget	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
void	TokenNamevoid
resetTarget	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
char	TokenNamechar
charAt	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
target	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
ignoreCase	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
limit	TokenNameIdentifier
-	TokenNameMINUS
offset	TokenNameIdentifier
<	TokenNameLESS
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
ignoreCase	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
target	TokenNameIdentifier
.	TokenNameDOT
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
part	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
target	TokenNameIdentifier
.	TokenNameDOT
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
,	TokenNameCOMMA
part	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
ignoreCase	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
limit	TokenNameIdentifier
-	TokenNameMINUS
offset	TokenNameIdentifier
<	TokenNameLESS
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
ignoreCase	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
target	TokenNameIdentifier
.	TokenNameDOT
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
target	TokenNameIdentifier
,	TokenNameCOMMA
offset2	TokenNameIdentifier
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
target	TokenNameIdentifier
.	TokenNameDOT
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
,	TokenNameCOMMA
target	TokenNameIdentifier
,	TokenNameCOMMA
offset2	TokenNameIdentifier
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
CharArrayTarget	TokenNameIdentifier
extends	TokenNameextends
ExpressionTarget	TokenNameIdentifier
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
target	TokenNameIdentifier
;	TokenNameSEMICOLON
CharArrayTarget	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
void	TokenNamevoid
resetTarget	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
char	TokenNamechar
charAt	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
target	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
ignoreCase	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
limit	TokenNameIdentifier
-	TokenNameMINUS
offset	TokenNameIdentifier
<	TokenNameLESS
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
ignoreCase	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
regionMatchesIgnoreCase	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
,	TokenNameCOMMA
limit	TokenNameIdentifier
,	TokenNameCOMMA
part	TokenNameIdentifier
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
,	TokenNameCOMMA
limit	TokenNameIdentifier
,	TokenNameCOMMA
part	TokenNameIdentifier
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
partlen	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
target	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
part	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
regionMatchesIgnoreCase	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
partlen	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
char	TokenNamechar
ch1	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
ch2	TokenNameIdentifier
=	TokenNameEQUAL
part	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ch2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
char	TokenNamechar
uch1	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toUpperCase	TokenNameIdentifier
(	TokenNameLPAREN
ch1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
uch2	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toUpperCase	TokenNameIdentifier
(	TokenNameLPAREN
ch2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
uch1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
uch2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
Character	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
uch1	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
uch2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
ignoreCase	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
limit	TokenNameIdentifier
-	TokenNameMINUS
offset	TokenNameIdentifier
<	TokenNameLESS
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
ignoreCase	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
regionMatchesIgnoreCase	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
,	TokenNameCOMMA
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset2	TokenNameIdentifier
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
,	TokenNameCOMMA
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset2	TokenNameIdentifier
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
offset2	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
partlen	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
target	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
target	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
regionMatchesIgnoreCase	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
offset2	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
partlen	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
char	TokenNamechar
ch1	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
ch2	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ch2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
char	TokenNamechar
uch1	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toUpperCase	TokenNameIdentifier
(	TokenNameLPAREN
ch1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
uch2	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toUpperCase	TokenNameIdentifier
(	TokenNameLPAREN
ch2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
uch1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
uch2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
Character	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
uch1	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
uch2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
CharacterIteratorTarget	TokenNameIdentifier
extends	TokenNameextends
ExpressionTarget	TokenNameIdentifier
{	TokenNameLBRACE
CharacterIterator	TokenNameIdentifier
target	TokenNameIdentifier
;	TokenNameSEMICOLON
CharacterIteratorTarget	TokenNameIdentifier
(	TokenNameLPAREN
CharacterIterator	TokenNameIdentifier
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
void	TokenNamevoid
resetTarget	TokenNameIdentifier
(	TokenNameLPAREN
CharacterIterator	TokenNameIdentifier
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
char	TokenNamechar
charAt	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
target	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
ignoreCase	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
limit	TokenNameIdentifier
-	TokenNameMINUS
offset	TokenNameIdentifier
<	TokenNameLESS
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
ignoreCase	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
regionMatchesIgnoreCase	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
,	TokenNameCOMMA
limit	TokenNameIdentifier
,	TokenNameCOMMA
part	TokenNameIdentifier
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
,	TokenNameCOMMA
limit	TokenNameIdentifier
,	TokenNameCOMMA
part	TokenNameIdentifier
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
partlen	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
target	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
part	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
regionMatchesIgnoreCase	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
partlen	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
char	TokenNamechar
ch1	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
ch2	TokenNameIdentifier
=	TokenNameEQUAL
part	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ch2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
char	TokenNamechar
uch1	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toUpperCase	TokenNameIdentifier
(	TokenNameLPAREN
ch1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
uch2	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toUpperCase	TokenNameIdentifier
(	TokenNameLPAREN
ch2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
uch1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
uch2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
Character	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
uch1	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
uch2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
ignoreCase	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
limit	TokenNameIdentifier
-	TokenNameMINUS
offset	TokenNameIdentifier
<	TokenNameLESS
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
ignoreCase	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
regionMatchesIgnoreCase	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
,	TokenNameCOMMA
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset2	TokenNameIdentifier
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
,	TokenNameCOMMA
limit	TokenNameIdentifier
,	TokenNameCOMMA
offset2	TokenNameIdentifier
,	TokenNameCOMMA
partlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
regionMatches	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
offset2	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
partlen	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
target	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
target	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
regionMatchesIgnoreCase	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
partlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
offset2	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
partlen	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
char	TokenNamechar
ch1	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
ch2	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ch2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
char	TokenNamechar
uch1	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toUpperCase	TokenNameIdentifier
(	TokenNameLPAREN
ch1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
uch2	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toUpperCase	TokenNameIdentifier
(	TokenNameLPAREN
ch2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
uch1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
uch2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
Character	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
uch1	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
uch2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
ClosureContext	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
offsets	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
4	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
currentIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
contains	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
currentIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
currentIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
addOffset	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
currentIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
offsets	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
offsets	TokenNameIdentifier
=	TokenNameEQUAL
expandOffsets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
currentIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
expandOffsets	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
offsets	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
newLen	TokenNameIdentifier
=	TokenNameEQUAL
len	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newOffsets	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
newLen	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
offsets	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newOffsets	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
currentIndex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
newOffsets	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
Context	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
start	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
length	TokenNameIdentifier
;	TokenNameSEMICOLON
Match	TokenNameIdentifier
match	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
inuse	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
ClosureContext	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
closureContexts	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
StringTarget	TokenNameIdentifier
stringTarget	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
CharArrayTarget	TokenNameIdentifier
charArrayTarget	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
CharacterIteratorTarget	TokenNameIdentifier
characterIteratorTarget	TokenNameIdentifier
;	TokenNameSEMICOLON
ExpressionTarget	TokenNameIdentifier
target	TokenNameIdentifier
;	TokenNameSEMICOLON
Context	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
resetCommon	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
nofclosures	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
length	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
limit	TokenNameIdentifier
-	TokenNameMINUS
this	TokenNamethis
.	TokenNameDOT
start	TokenNameIdentifier
;	TokenNameSEMICOLON
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
match	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
closureContexts	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
this	TokenNamethis
.	TokenNameDOT
closureContexts	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
nofclosures	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
closureContexts	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ClosureContext	TokenNameIdentifier
[	TokenNameLBRACKET
nofclosures	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
nofclosures	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
closureContexts	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
closureContexts	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
ClosureContext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
closureContexts	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
void	TokenNamevoid
reset	TokenNameIdentifier
(	TokenNameLPAREN
CharacterIterator	TokenNameIdentifier
target	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
nofclosures	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
characterIteratorTarget	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
characterIteratorTarget	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CharacterIteratorTarget	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
characterIteratorTarget	TokenNameIdentifier
.	TokenNameDOT
resetTarget	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
characterIteratorTarget	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
start	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
limit	TokenNameIdentifier
=	TokenNameEQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
resetCommon	TokenNameIdentifier
(	TokenNameLPAREN
nofclosures	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
reset	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
target	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
nofclosures	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
stringTarget	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
stringTarget	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringTarget	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
stringTarget	TokenNameIdentifier
.	TokenNameDOT
resetTarget	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
stringTarget	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
start	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
limit	TokenNameIdentifier
=	TokenNameEQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
resetCommon	TokenNameIdentifier
(	TokenNameLPAREN
nofclosures	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
reset	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
target	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
nofclosures	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
charArrayTarget	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
charArrayTarget	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CharArrayTarget	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
charArrayTarget	TokenNameIdentifier
.	TokenNameDOT
resetTarget	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
charArrayTarget	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
start	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
limit	TokenNameIdentifier
=	TokenNameEQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
resetCommon	TokenNameIdentifier
(	TokenNameLPAREN
nofclosures	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
setInUse	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
inUse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
inuse	TokenNameIdentifier
=	TokenNameEQUAL
inUse	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
void	TokenNamevoid
prepare	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
Op	TokenNameIdentifier
.	TokenNameDOT
COUNT	TokenNameIdentifier
)	TokenNameRPAREN
Op	TokenNameIdentifier
.	TokenNameDOT
nofinstances	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
compile	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
tokentree	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
Op	TokenNameIdentifier
.	TokenNameDOT
COUNT	TokenNameIdentifier
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"DEBUG: The number of operations: "	TokenNameStringLiteral
+	TokenNamePLUS
Op	TokenNameIdentifier
.	TokenNameDOT
nofinstances	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
minlength	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
tokentree	TokenNameIdentifier
.	TokenNameDOT
getMinLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
firstChar	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
PROHIBIT_HEAD_CHARACTER_OPTIMIZATION	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
RangeToken	TokenNameIdentifier
firstChar	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
fresult	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
tokentree	TokenNameIdentifier
.	TokenNameDOT
analyzeFirstCharacter	TokenNameIdentifier
(	TokenNameLPAREN
firstChar	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fresult	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
FC_TERMINAL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
firstChar	TokenNameIdentifier
.	TokenNameDOT
compactRanges	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
firstChar	TokenNameIdentifier
=	TokenNameEQUAL
firstChar	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"DEBUG: Use the first character optimization: "	TokenNameStringLiteral
+	TokenNamePLUS
firstChar	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
||	TokenNameOR_OR
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
CHAR	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
" *** Only fixed string! *** "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fixedStringOnly	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Op	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
getString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
getData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0x10000	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
=	TokenNameEQUAL
REUtil	TokenNameIdentifier
.	TokenNameDOT
decomposeToSurrogates	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
getData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
ac	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
ac	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
getData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
String	TokenNameIdentifier
(	TokenNameLPAREN
ac	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
fixedStringOptions	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fixedStringTable	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BMPattern	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
,	TokenNameCOMMA
256	TokenNameIntegerLiteral
,	TokenNameCOMMA
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedStringOptions	TokenNameIdentifier
,	TokenNameCOMMA
IGNORE_CASE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
PROHIBIT_FIXED_STRING_OPTIMIZATION	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Token	TokenNameIdentifier
.	TokenNameDOT
FixedStringContainer	TokenNameIdentifier
container	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Token	TokenNameIdentifier
.	TokenNameDOT
FixedStringContainer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
tokentree	TokenNameIdentifier
.	TokenNameDOT
findFixedString	TokenNameIdentifier
(	TokenNameLPAREN
container	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
=	TokenNameEQUAL
container	TokenNameIdentifier
.	TokenNameDOT
token	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
container	TokenNameIdentifier
.	TokenNameDOT
token	TokenNameIdentifier
.	TokenNameDOT
getString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fixedStringOptions	TokenNameIdentifier
=	TokenNameEQUAL
container	TokenNameIdentifier
.	TokenNameDOT
options	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
<	TokenNameLESS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fixedStringTable	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BMPattern	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
,	TokenNameCOMMA
256	TokenNameIntegerLiteral
,	TokenNameCOMMA
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedStringOptions	TokenNameIdentifier
,	TokenNameCOMMA
IGNORE_CASE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"DEBUG: The longest fixed string: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"/"	TokenNameStringLiteral
+	TokenNamePLUS
"/"	TokenNameStringLiteral
+	TokenNamePLUS
REUtil	TokenNameIdentifier
.	TokenNameDOT
createOptionString	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedStringOptions	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"String: "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
REUtil	TokenNameIdentifier
.	TokenNameDOT
dumpString	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
fixedString	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
IGNORE_CASE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
SINGLE_LINE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MULTIPLE_LINES	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
EXTENDED_COMMENT	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
USE_UNICODE_CATEGORY	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
5	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
UNICODE_WORD_BOUNDARY	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
PROHIBIT_HEAD_CHARACTER_OPTIMIZATION	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
7	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
PROHIBIT_FIXED_STRING_OPTIMIZATION	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
XMLSCHEMA_MODE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
9	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
SPECIAL_COMMA	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
isSet	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
options	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
flag	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
options	TokenNameIdentifier
&	TokenNameAND
flag	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
flag	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
RegularExpression	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
regex	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
regex	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
RegularExpression	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
regex	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
options	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
regex	TokenNameIdentifier
,	TokenNameCOMMA
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
RegularExpression	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
regex	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
options	TokenNameIdentifier
,	TokenNameCOMMA
Locale	TokenNameIdentifier
locale	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
regex	TokenNameIdentifier
,	TokenNameCOMMA
options	TokenNameIdentifier
,	TokenNameCOMMA
locale	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
RegularExpression	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
regex	TokenNameIdentifier
,	TokenNameCOMMA
Token	TokenNameIdentifier
tok	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
parens	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
hasBackReferences	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
options	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
=	TokenNameEQUAL
regex	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
tokentree	TokenNameIdentifier
=	TokenNameEQUAL
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
=	TokenNameEQUAL
parens	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
=	TokenNameEQUAL
options	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
hasBackReferences	TokenNameIdentifier
=	TokenNameEQUAL
hasBackReferences	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
newPattern	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
newPattern	TokenNameIdentifier
,	TokenNameCOMMA
Locale	TokenNameIdentifier
.	TokenNameDOT
getDefault	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
newPattern	TokenNameIdentifier
,	TokenNameCOMMA
Locale	TokenNameIdentifier
locale	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
newPattern	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
locale	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
newPattern	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
options	TokenNameIdentifier
,	TokenNameCOMMA
Locale	TokenNameIdentifier
locale	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
=	TokenNameEQUAL
newPattern	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
=	TokenNameEQUAL
options	TokenNameIdentifier
;	TokenNameSEMICOLON
RegexParser	TokenNameIdentifier
rp	TokenNameIdentifier
=	TokenNameEQUAL
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
,	TokenNameCOMMA
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
ParserForXMLSchema	TokenNameIdentifier
(	TokenNameLPAREN
locale	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
RegexParser	TokenNameIdentifier
(	TokenNameLPAREN
locale	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
tokentree	TokenNameIdentifier
=	TokenNameEQUAL
rp	TokenNameIdentifier
.	TokenNameDOT
parse	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
=	TokenNameEQUAL
rp	TokenNameIdentifier
.	TokenNameDOT
parennumber	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
hasBackReferences	TokenNameIdentifier
=	TokenNameEQUAL
rp	TokenNameIdentifier
.	TokenNameDOT
hasBackReferences	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
operations	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
newPattern	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
options	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
newPattern	TokenNameIdentifier
,	TokenNameCOMMA
options	TokenNameIdentifier
,	TokenNameCOMMA
Locale	TokenNameIdentifier
.	TokenNameDOT
getDefault	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
newPattern	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
options	TokenNameIdentifier
,	TokenNameCOMMA
Locale	TokenNameIdentifier
locale	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
setPattern	TokenNameIdentifier
(	TokenNameLPAREN
newPattern	TokenNameIdentifier
,	TokenNameCOMMA
REUtil	TokenNameIdentifier
.	TokenNameDOT
parseOptions	TokenNameIdentifier
(	TokenNameLPAREN
options	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
locale	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getPattern	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
tokentree	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getOptions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
REUtil	TokenNameIdentifier
.	TokenNameDOT
createOptionString	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
obj	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
obj	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
obj	TokenNameIdentifier
instanceof	TokenNameinstanceof
RegularExpression	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
RegularExpression	TokenNameIdentifier
r	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
)	TokenNameRPAREN
obj	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
r	TokenNameIdentifier
.	TokenNameDOT
regex	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
r	TokenNameIdentifier
.	TokenNameDOT
options	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
pattern	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
options	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
pattern	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
options	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
+	TokenNamePLUS
"/"	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
.	TokenNameDOT
getOptions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getNumberOfGroups	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
nofparen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
WT_IGNORE	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
WT_LETTER	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
WT_OTHER	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
getWordType0	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
ch	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
opts	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
opts	TokenNameIdentifier
,	TokenNameCOMMA
UNICODE_WORD_BOUNDARY	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isSet	TokenNameIdentifier
(	TokenNameLPAREN
opts	TokenNameIdentifier
,	TokenNameCOMMA
USE_UNICODE_CATEGORY	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
getRange	TokenNameIdentifier
(	TokenNameLPAREN
"IsWord"	TokenNameStringLiteral
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
.	TokenNameDOT
match	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
WT_LETTER	TokenNameIdentifier
:	TokenNameCOLON
WT_OTHER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
isWordChar	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
WT_LETTER	TokenNameIdentifier
:	TokenNameCOLON
WT_OTHER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
Character	TokenNameIdentifier
.	TokenNameDOT
getType	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
UPPERCASE_LETTER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
LOWERCASE_LETTER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
TITLECASE_LETTER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
MODIFIER_LETTER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
OTHER_LETTER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
LETTER_NUMBER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
DECIMAL_DIGIT_NUMBER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
OTHER_NUMBER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
COMBINING_SPACING_MARK	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
WT_LETTER	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
FORMAT	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
NON_SPACING_MARK	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
ENCLOSING_MARK	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
WT_IGNORE	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
Character	TokenNameIdentifier
.	TokenNameDOT
CONTROL	TokenNameIdentifier
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'\t'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'\n'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
''	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'\f'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'\r'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
WT_OTHER	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
WT_IGNORE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
WT_OTHER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
LINE_FEED	TokenNameIdentifier
=	TokenNameEQUAL
0x000A	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
CARRIAGE_RETURN	TokenNameIdentifier
=	TokenNameEQUAL
0x000D	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
LINE_SEPARATOR	TokenNameIdentifier
=	TokenNameEQUAL
0x2028	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
PARAGRAPH_SEPARATOR	TokenNameIdentifier
=	TokenNameEQUAL
0x2029	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
isEOLChar	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
LINE_FEED	TokenNameIdentifier
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CARRIAGE_RETURN	TokenNameIdentifier
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
LINE_SEPARATOR	TokenNameIdentifier
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
PARAGRAPH_SEPARATOR	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
isWordChar	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'_'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<	TokenNameLESS
'0'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
>	TokenNameGREATER
'z'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<	TokenNameLESS
'A'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'Z'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<	TokenNameLESS
'a'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
matchIgnoreCase	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
chardata	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
chardata	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ch	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
chardata	TokenNameIdentifier
>	TokenNameGREATER
0xffff	TokenNameIntegerLiteral
||	TokenNameOR_OR
ch	TokenNameIdentifier
>	TokenNameGREATER
0xffff	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
char	TokenNamechar
uch1	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toUpperCase	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
chardata	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
uch2	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toUpperCase	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
uch1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
uch2	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
Character	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
uch1	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
uch2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
