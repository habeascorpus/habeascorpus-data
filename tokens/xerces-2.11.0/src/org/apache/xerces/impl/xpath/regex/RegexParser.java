package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
regex	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Locale	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
MissingResourceException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ResourceBundle	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Vector	TokenNameIdentifier
;	TokenNameSEMICOLON
class	TokenNameclass
RegexParser	TokenNameIdentifier
{	TokenNameLBRACE
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_CHAR	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_EOF	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_OR	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_STAR	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_PLUS	TokenNameIdentifier
=	TokenNameEQUAL
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_QUESTION	TokenNameIdentifier
=	TokenNameEQUAL
5	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_LPAREN	TokenNameIdentifier
=	TokenNameEQUAL
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_RPAREN	TokenNameIdentifier
=	TokenNameEQUAL
7	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_DOT	TokenNameIdentifier
=	TokenNameEQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_LBRACKET	TokenNameIdentifier
=	TokenNameEQUAL
9	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_BACKSOLIDUS	TokenNameIdentifier
=	TokenNameEQUAL
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_CARET	TokenNameIdentifier
=	TokenNameEQUAL
11	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_DOLLAR	TokenNameIdentifier
=	TokenNameEQUAL
12	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_LPAREN2	TokenNameIdentifier
=	TokenNameEQUAL
13	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_LOOKAHEAD	TokenNameIdentifier
=	TokenNameEQUAL
14	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_NEGATIVELOOKAHEAD	TokenNameIdentifier
=	TokenNameEQUAL
15	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_LOOKBEHIND	TokenNameIdentifier
=	TokenNameEQUAL
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_NEGATIVELOOKBEHIND	TokenNameIdentifier
=	TokenNameEQUAL
17	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_INDEPENDENT	TokenNameIdentifier
=	TokenNameEQUAL
18	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_SET_OPERATIONS	TokenNameIdentifier
=	TokenNameEQUAL
19	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_POSIX_CHARCLASS_START	TokenNameIdentifier
=	TokenNameEQUAL
20	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_COMMENT	TokenNameIdentifier
=	TokenNameEQUAL
21	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_MODIFIERS	TokenNameIdentifier
=	TokenNameEQUAL
22	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_CONDITION	TokenNameIdentifier
=	TokenNameEQUAL
23	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
T_XMLSCHEMA_CC_SUBTRACTION	TokenNameIdentifier
=	TokenNameEQUAL
24	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
class	TokenNameclass
ReferencePosition	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
refNumber	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
position	TokenNameIdentifier
;	TokenNameSEMICOLON
ReferencePosition	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
n	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
pos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
refNumber	TokenNameIdentifier
=	TokenNameEQUAL
n	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
position	TokenNameIdentifier
=	TokenNameEQUAL
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
String	TokenNameIdentifier
regex	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
regexlen	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
options	TokenNameIdentifier
;	TokenNameSEMICOLON
ResourceBundle	TokenNameIdentifier
resources	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
chardata	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
nexttoken	TokenNameIdentifier
;	TokenNameSEMICOLON
static	TokenNamestatic
protected	TokenNameprotected
final	TokenNamefinal
int	TokenNameint
S_NORMAL	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
protected	TokenNameprotected
final	TokenNamefinal
int	TokenNameint
S_INBRACKETS	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
protected	TokenNameprotected
final	TokenNamefinal
int	TokenNameint
S_INXBRACKETS	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
context	TokenNameIdentifier
=	TokenNameEQUAL
S_NORMAL	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
parenOpened	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
parennumber	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
hasBackReferences	TokenNameIdentifier
;	TokenNameSEMICOLON
Vector	TokenNameIdentifier
references	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
public	TokenNamepublic
RegexParser	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
setLocale	TokenNameIdentifier
(	TokenNameLPAREN
Locale	TokenNameIdentifier
.	TokenNameDOT
getDefault	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
RegexParser	TokenNameIdentifier
(	TokenNameLPAREN
Locale	TokenNameIdentifier
locale	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
setLocale	TokenNameIdentifier
(	TokenNameLPAREN
locale	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setLocale	TokenNameIdentifier
(	TokenNameLPAREN
Locale	TokenNameIdentifier
locale	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
locale	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
resources	TokenNameIdentifier
=	TokenNameEQUAL
ResourceBundle	TokenNameIdentifier
.	TokenNameDOT
getBundle	TokenNameIdentifier
(	TokenNameLPAREN
"org.apache.xerces.impl.xpath.regex.message"	TokenNameStringLiteral
,	TokenNameCOMMA
locale	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
resources	TokenNameIdentifier
=	TokenNameEQUAL
ResourceBundle	TokenNameIdentifier
.	TokenNameDOT
getBundle	TokenNameIdentifier
(	TokenNameLPAREN
"org.apache.xerces.impl.xpath.regex.message"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
MissingResourceException	TokenNameIdentifier
mre	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Installation Problem???  Couldn't load messages: "	TokenNameStringLiteral
+	TokenNamePLUS
mre	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
ParseException	TokenNameIdentifier
ex	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
key	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
loc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
resources	TokenNameIdentifier
.	TokenNameDOT
getString	TokenNameIdentifier
(	TokenNameLPAREN
key	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
loc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
final	TokenNamefinal
boolean	TokenNameboolean
isSet	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
flag	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
&	TokenNameAND
flag	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
flag	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
Token	TokenNameIdentifier
parse	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
regex	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
options	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
options	TokenNameIdentifier
=	TokenNameEQUAL
options	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
setContext	TokenNameIdentifier
(	TokenNameLPAREN
S_NORMAL	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
parennumber	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
parenOpened	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
hasBackReferences	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
=	TokenNameEQUAL
regex	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
EXTENDED_COMMENT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
=	TokenNameEQUAL
REUtil	TokenNameIdentifier
.	TokenNameDOT
stripExtendedComment	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
ret	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.parse.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
references	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
references	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ReferencePosition	TokenNameIdentifier
position	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
ReferencePosition	TokenNameIdentifier
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
references	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
parennumber	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
position	TokenNameIdentifier
.	TokenNameDOT
refNumber	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.parse.2"	TokenNameStringLiteral
,	TokenNameCOMMA
position	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
references	TokenNameIdentifier
.	TokenNameDOT
removeAllElements	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
final	TokenNamefinal
void	TokenNamevoid
setContext	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
con	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
=	TokenNameEQUAL
con	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
nexttoken	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
void	TokenNamevoid
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
nexttoken	TokenNameIdentifier
=	TokenNameEQUAL
T_EOF	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
=	TokenNameEQUAL
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
context	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
S_INBRACKETS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'\\'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_BACKSOLIDUS	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.next.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'-'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'['	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_XMLSCHEMA_CC_SUBTRACTION	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'['	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_POSIX_CHARCLASS_START	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
REUtil	TokenNameIdentifier
.	TokenNameDOT
isHighSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
low	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
REUtil	TokenNameIdentifier
.	TokenNameDOT
isLowSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
low	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
=	TokenNameEQUAL
REUtil	TokenNameIdentifier
.	TokenNameDOT
composeFromSurrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
low	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
nexttoken	TokenNameIdentifier
=	TokenNameEQUAL
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'|'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_OR	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'*'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_STAR	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'+'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_PLUS	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'?'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_QUESTION	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
')'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_RPAREN	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'.'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_DOT	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'['	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_LBRACKET	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'^'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_CARET	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'$'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_DOLLAR	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'('	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_LPAREN	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
'?'	TokenNameCharacterLiteral
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.next.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
':'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_LPAREN2	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'='	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_LOOKAHEAD	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'!'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_NEGATIVELOOKAHEAD	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'['	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_SET_OPERATIONS	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_INDEPENDENT	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.next.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'='	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_LOOKBEHIND	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'!'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_NEGATIVELOOKBEHIND	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.next.3"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'#'	TokenNameCharacterLiteral
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
')'	TokenNameCharacterLiteral
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
')'	TokenNameCharacterLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.next.4"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_COMMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'-'	TokenNameCharacterLiteral
||	TokenNameOR_OR
'a'	TokenNameCharacterLiteral
<=	TokenNameLESS_EQUAL
ch	TokenNameIdentifier
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'z'	TokenNameCharacterLiteral
||	TokenNameOR_OR
'A'	TokenNameCharacterLiteral
<=	TokenNameLESS_EQUAL
ch	TokenNameIdentifier
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'Z'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_MODIFIERS	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'('	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_CONDITION	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.next.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'\\'	TokenNameCharacterLiteral
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_BACKSOLIDUS	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.next.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
T_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
nexttoken	TokenNameIdentifier
=	TokenNameEQUAL
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
parseTerm	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
parent	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
T_OR	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
parent	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
parent	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createUnion	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
parent	TokenNameIdentifier
.	TokenNameDOT
addChild	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
parent	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
tok	TokenNameIdentifier
.	TokenNameDOT
addChild	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
parseTerm	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
parseTerm	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_OR	TokenNameIdentifier
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_RPAREN	TokenNameIdentifier
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_EOF	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
createEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
parseFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
concat	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_OR	TokenNameIdentifier
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
&&	TokenNameAND_AND
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
T_EOF	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
concat	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
concat	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createConcat	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
concat	TokenNameIdentifier
.	TokenNameDOT
addChild	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
concat	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
concat	TokenNameIdentifier
.	TokenNameDOT
addChild	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
parseFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
Token	TokenNameIdentifier
processCaret	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
token_linebeginning	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processDollar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
token_lineend	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processLookahead	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createLook	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
LOOKAHEAD	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processNegativelookahead	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createLook	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKAHEAD	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processLookbehind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createLook	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
LOOKBEHIND	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processNegativelookbehind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createLook	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKBEHIND	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_A	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
token_stringbeginning	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_Z	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
token_stringend2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_z	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
token_stringend	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_b	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
token_wordedge	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_B	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
token_not_wordedge	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_lt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
token_wordbeginning	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_gt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
token_wordend	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processStar	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
tok	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
T_QUESTION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
createNGClosure	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
createClosure	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processPlus	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
tok	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
T_QUESTION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
createConcat	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
,	TokenNameCOMMA
Token	TokenNameIdentifier
.	TokenNameDOT
createNGClosure	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
createConcat	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
,	TokenNameCOMMA
Token	TokenNameIdentifier
.	TokenNameDOT
createClosure	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processQuestion	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
tok	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
par	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createUnion	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
T_QUESTION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
par	TokenNameIdentifier
.	TokenNameDOT
addChild	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
createEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
par	TokenNameIdentifier
.	TokenNameDOT
addChild	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
par	TokenNameIdentifier
.	TokenNameDOT
addChild	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
par	TokenNameIdentifier
.	TokenNameDOT
addChild	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
createEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
par	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
checkQuestion	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
off	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
off	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
off	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'?'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processParen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
p	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
parenOpened	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createParen	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
p	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
parennumber	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processParen2	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createParen	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processCondition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.4"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
refno	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
condition	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
'1'	TokenNameCharacterLiteral
<=	TokenNameLESS_EQUAL
ch	TokenNameIdentifier
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
refno	TokenNameIdentifier
=	TokenNameEQUAL
ch	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
int	TokenNameint
finalRefno	TokenNameIdentifier
=	TokenNameEQUAL
refno	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
parennumber	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
refno	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.parse.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
'0'	TokenNameCharacterLiteral
<=	TokenNameLESS_EQUAL
ch	TokenNameIdentifier
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
refno	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
refno	TokenNameIdentifier
*	TokenNameMULTIPLY
10	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
ch	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
refno	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
parennumber	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
finalRefno	TokenNameIdentifier
=	TokenNameEQUAL
refno	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
hasBackReferences	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
references	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
references	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
references	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
ReferencePosition	TokenNameIdentifier
(	TokenNameLPAREN
finalRefno	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
')'	TokenNameCharacterLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'?'	TokenNameCharacterLiteral
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
condition	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
parseFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
condition	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
LOOKAHEAD	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKAHEAD	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
LOOKBEHIND	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
NEGATIVELOOKBEHIND	TokenNameIdentifier
:	TokenNameCOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
Token	TokenNameIdentifier
.	TokenNameDOT
ANCHOR	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.5"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
yesPattern	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
noPattern	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
yesPattern	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
yesPattern	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.6"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
noPattern	TokenNameIdentifier
=	TokenNameEQUAL
yesPattern	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
yesPattern	TokenNameIdentifier
=	TokenNameEQUAL
yesPattern	TokenNameIdentifier
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
createCondition	TokenNameIdentifier
(	TokenNameLPAREN
refno	TokenNameIdentifier
,	TokenNameCOMMA
condition	TokenNameIdentifier
,	TokenNameCOMMA
yesPattern	TokenNameIdentifier
,	TokenNameCOMMA
noPattern	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processModifiers	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
add	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
mask	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
ch	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
v	TokenNameIdentifier
=	TokenNameEQUAL
REUtil	TokenNameIdentifier
.	TokenNameDOT
getOptionValue	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
v	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
add	TokenNameIdentifier
|=	TokenNameOR_EQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'-'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
v	TokenNameIdentifier
=	TokenNameEQUAL
REUtil	TokenNameIdentifier
.	TokenNameDOT
getOptionValue	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
v	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
mask	TokenNameIdentifier
|=	TokenNameOR_EQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createModifierGroup	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
add	TokenNameIdentifier
,	TokenNameCOMMA
mask	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
')'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createModifierGroup	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
add	TokenNameIdentifier
,	TokenNameCOMMA
mask	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.3"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processIndependent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createLook	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
INDEPENDENT	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
parseRegex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.factor.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_c	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
ch2	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
ch2	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
)	TokenNameRPAREN
&	TokenNameAND
0xffe0	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0x0040	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.atom.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
createChar	TokenNameIdentifier
(	TokenNameLPAREN
ch2	TokenNameIdentifier
-	TokenNameMINUS
0x40	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_C	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.process.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_i	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createChar	TokenNameIdentifier
(	TokenNameLPAREN
'i'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_I	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.process.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_g	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
getGraphemePattern	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBacksolidus_X	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
getCombiningCharacterSequence	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
processBackreference	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
refnum	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
int	TokenNameint
finalRefnum	TokenNameIdentifier
=	TokenNameEQUAL
refnum	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
parennumber	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
refnum	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.parse.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
'0'	TokenNameCharacterLiteral
<=	TokenNameLESS_EQUAL
ch	TokenNameIdentifier
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
refnum	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
refnum	TokenNameIdentifier
*	TokenNameMULTIPLY
10	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
ch	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
refnum	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
parennumber	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
++	TokenNamePLUS_PLUS
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
finalRefnum	TokenNameIdentifier
=	TokenNameEQUAL
refnum	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
=	TokenNameEQUAL
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createBackReference	TokenNameIdentifier
(	TokenNameLPAREN
finalRefnum	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
hasBackReferences	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
references	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
references	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
references	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
ReferencePosition	TokenNameIdentifier
(	TokenNameLPAREN
finalRefnum	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
parseFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
T_CARET	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processCaret	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_DOLLAR	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processDollar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_LOOKAHEAD	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processLookahead	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_NEGATIVELOOKAHEAD	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processNegativelookahead	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_LOOKBEHIND	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processLookbehind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_NEGATIVELOOKBEHIND	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processNegativelookbehind	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_COMMENT	TokenNameIdentifier
:	TokenNameCOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
createEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_BACKSOLIDUS	TokenNameIdentifier
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'A'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_A	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'Z'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_Z	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'z'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_z	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'b'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_b	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'B'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_B	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_lt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_gt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
parseAtom	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
T_STAR	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processStar	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_PLUS	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processPlus	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_QUESTION	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processQuestion	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_CHAR	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'{'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
off	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
min	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
max	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
'0'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
min	TokenNameIdentifier
=	TokenNameEQUAL
ch	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
'0'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
min	TokenNameIdentifier
=	TokenNameEQUAL
min	TokenNameIdentifier
*	TokenNameMULTIPLY
10	TokenNameIntegerLiteral
+	TokenNamePLUS
ch	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
min	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.quantifier.5"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.quantifier.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
max	TokenNameIdentifier
=	TokenNameEQUAL
min	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
','	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
off	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.quantifier.3"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
'0'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
max	TokenNameIdentifier
=	TokenNameEQUAL
ch	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
'0'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
max	TokenNameIdentifier
=	TokenNameEQUAL
max	TokenNameIdentifier
*	TokenNameMULTIPLY
10	TokenNameIntegerLiteral
+	TokenNamePLUS
ch	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
max	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.quantifier.5"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
min	TokenNameIdentifier
>	TokenNameGREATER
max	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.quantifier.4"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
max	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'}'	TokenNameCharacterLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.quantifier.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
checkQuestion	TokenNameIdentifier
(	TokenNameLPAREN
off	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createNGClosure	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createClosure	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
tok	TokenNameIdentifier
.	TokenNameDOT
setMin	TokenNameIdentifier
(	TokenNameLPAREN
min	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
.	TokenNameDOT
setMax	TokenNameIdentifier
(	TokenNameLPAREN
max	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
parseAtom	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
T_LPAREN	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processParen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_LPAREN2	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processParen2	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_CONDITION	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processCondition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_MODIFIERS	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processModifiers	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_INDEPENDENT	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processIndependent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_DOT	TokenNameIdentifier
:	TokenNameCOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
token_dot	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
T_LBRACKET	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
parseCharacterClass	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_SET_OPERATIONS	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
parseSetOperations	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
T_BACKSOLIDUS	TokenNameIdentifier
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'd'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'D'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'w'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'W'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
's'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'S'	TokenNameCharacterLiteral
:	TokenNameCOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
getTokenForShorthand	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'e'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'f'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'n'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'r'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
't'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'u'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'v'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'x'	TokenNameCharacterLiteral
:	TokenNameCOLON
{	TokenNameLBRACE
int	TokenNameint
ch2	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
decodeEscaped	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch2	TokenNameIdentifier
<	TokenNameLESS
0x10000	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createChar	TokenNameIdentifier
(	TokenNameLPAREN
ch2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createString	TokenNameIdentifier
(	TokenNameLPAREN
REUtil	TokenNameIdentifier
.	TokenNameDOT
decomposeToSurrogates	TokenNameIdentifier
(	TokenNameLPAREN
ch2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'c'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_c	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'C'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_C	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'i'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_i	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'I'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_I	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'g'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_g	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'X'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_X	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'1'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'2'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'3'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'4'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'5'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'6'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'7'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'8'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'9'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
processBackreference	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'P'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'p'	TokenNameCharacterLiteral
:	TokenNameCOLON
int	TokenNameint
pstart	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
processBacksolidus_pP	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
tok	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.atom.5"	TokenNameStringLiteral
,	TokenNameCOMMA
pstart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
T_CHAR	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
']'	TokenNameCharacterLiteral
||	TokenNameOR_OR
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'{'	TokenNameCharacterLiteral
||	TokenNameOR_OR
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'}'	TokenNameCharacterLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.atom.4"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
high	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
REUtil	TokenNameIdentifier
.	TokenNameDOT
isHighSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
high	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
T_CHAR	TokenNameIdentifier
&&	TokenNameAND_AND
REUtil	TokenNameIdentifier
.	TokenNameDOT
isLowSurrogate	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sur	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
sur	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
high	TokenNameIdentifier
;	TokenNameSEMICOLON
sur	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createParen	TokenNameIdentifier
(	TokenNameLPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
createString	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
String	TokenNameIdentifier
(	TokenNameLPAREN
sur	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.atom.4"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
RangeToken	TokenNameIdentifier
processBacksolidus_pP	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
c	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'{'	TokenNameCharacterLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.atom.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
positive	TokenNameIdentifier
=	TokenNameEQUAL
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'p'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
int	TokenNameint
namestart	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
nameend	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
'}'	TokenNameCharacterLiteral
,	TokenNameCOMMA
namestart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nameend	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.atom.3"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
pname	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
namestart	TokenNameIdentifier
,	TokenNameCOMMA
nameend	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
=	TokenNameEQUAL
nameend	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
Token	TokenNameIdentifier
.	TokenNameDOT
getRange	TokenNameIdentifier
(	TokenNameLPAREN
pname	TokenNameIdentifier
,	TokenNameCOMMA
positive	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
processCIinCharacterClass	TokenNameIdentifier
(	TokenNameLPAREN
RangeToken	TokenNameIdentifier
tok	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
decodeEscaped	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
RangeToken	TokenNameIdentifier
parseCharacterClass	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
useNrange	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
setContext	TokenNameIdentifier
(	TokenNameLPAREN
S_INBRACKETS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
nrange	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
RangeToken	TokenNameIdentifier
base	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
RangeToken	TokenNameIdentifier
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
T_CHAR	TokenNameIdentifier
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'^'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
nrange	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
useNrange	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createNRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
base	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
base	TokenNameIdentifier
.	TokenNameDOT
addRange	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
Token	TokenNameIdentifier
.	TokenNameDOT
UTF16_MAX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
tok	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
createRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
type	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
firstloop	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
type	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_EOF	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_CHAR	TokenNameIdentifier
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
']'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
firstloop	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
int	TokenNameint
c	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
end	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_BACKSOLIDUS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'd'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'D'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'w'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'W'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
's'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'S'	TokenNameCharacterLiteral
:	TokenNameCOLON
tok	TokenNameIdentifier
.	TokenNameDOT
mergeRanges	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
getTokenForShorthand	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
end	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'i'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'I'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'c'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'C'	TokenNameCharacterLiteral
:	TokenNameCOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
processCIinCharacterClass	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
,	TokenNameCOMMA
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
end	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'p'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'P'	TokenNameCharacterLiteral
:	TokenNameCOLON
int	TokenNameint
pstart	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
RangeToken	TokenNameIdentifier
tok2	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
processBacksolidus_pP	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
tok2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.atom.5"	TokenNameStringLiteral
,	TokenNameCOMMA
pstart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
.	TokenNameDOT
mergeRanges	TokenNameIdentifier
(	TokenNameLPAREN
tok2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
end	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
decodeEscaped	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_POSIX_CHARCLASS_START	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
nameend	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
':'	TokenNameCharacterLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nameend	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.cc.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
positive	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
'^'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
positive	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
String	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
,	TokenNameCOMMA
nameend	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
RangeToken	TokenNameIdentifier
range	TokenNameIdentifier
=	TokenNameEQUAL
Token	TokenNameIdentifier
.	TokenNameDOT
getRange	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
positive	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
XMLSCHEMA_MODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
range	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.cc.3"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
.	TokenNameDOT
mergeRanges	TokenNameIdentifier
(	TokenNameLPAREN
range	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
end	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nameend	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
>=	TokenNameGREATER_EQUAL
this	TokenNamethis
.	TokenNameDOT
regexlen	TokenNameIdentifier
||	TokenNameOR_OR
this	TokenNamethis
.	TokenNameDOT
regex	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
nameend	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
']'	TokenNameCharacterLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.cc.1"	TokenNameStringLiteral
,	TokenNameCOMMA
nameend	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
=	TokenNameEQUAL
nameend	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_XMLSCHEMA_CC_SUBTRACTION	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
firstloop	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nrange	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
nrange	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
useNrange	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
RangeToken	TokenNameIdentifier
)	TokenNameRPAREN
Token	TokenNameIdentifier
.	TokenNameDOT
complementRanges	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
base	TokenNameIdentifier
.	TokenNameDOT
subtractRanges	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
RangeToken	TokenNameIdentifier
range2	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
parseCharacterClass	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
.	TokenNameDOT
subtractRanges	TokenNameIdentifier
(	TokenNameLPAREN
range2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
']'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.cc.5"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'-'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
IGNORE_CASE	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
c	TokenNameIdentifier
>	TokenNameGREATER
0xffff	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
.	TokenNameDOT
addRange	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
,	TokenNameCOMMA
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
addCaseInsensitiveChar	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
,	TokenNameCOMMA
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_XMLSCHEMA_CC_SUBTRACTION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.cc.8"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
type	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
T_EOF	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.cc.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_CHAR	TokenNameIdentifier
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
']'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
IGNORE_CASE	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
c	TokenNameIdentifier
>	TokenNameGREATER
0xffff	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
.	TokenNameDOT
addRange	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
,	TokenNameCOMMA
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
addCaseInsensitiveChar	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
,	TokenNameCOMMA
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
tok	TokenNameIdentifier
.	TokenNameDOT
addRange	TokenNameIdentifier
(	TokenNameLPAREN
'-'	TokenNameCharacterLiteral
,	TokenNameCOMMA
'-'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
rangeend	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_BACKSOLIDUS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
rangeend	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
decodeEscaped	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
>	TokenNameGREATER
rangeend	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.ope.3"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
IGNORE_CASE	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
c	TokenNameIdentifier
>	TokenNameGREATER
0xffff	TokenNameIntegerLiteral
&&	TokenNameAND_AND
rangeend	TokenNameIdentifier
>	TokenNameGREATER
0xffff	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
.	TokenNameDOT
addRange	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
,	TokenNameCOMMA
rangeend	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
addCaseInsensitiveCharRange	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
,	TokenNameCOMMA
c	TokenNameIdentifier
,	TokenNameCOMMA
rangeend	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
SPECIAL_COMMA	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
T_CHAR	TokenNameIdentifier
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
','	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
firstloop	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
T_EOF	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
this	TokenNamethis
.	TokenNameDOT
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.cc.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
useNrange	TokenNameIdentifier
&&	TokenNameAND_AND
nrange	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
base	TokenNameIdentifier
.	TokenNameDOT
subtractRanges	TokenNameIdentifier
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
tok	TokenNameIdentifier
.	TokenNameDOT
sortRanges	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
.	TokenNameDOT
compactRanges	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
setContext	TokenNameIdentifier
(	TokenNameLPAREN
S_NORMAL	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
RangeToken	TokenNameIdentifier
parseSetOperations	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
RangeToken	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
parseCharacterClass	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
type	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
type	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_CHAR	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'-'	TokenNameCharacterLiteral
||	TokenNameOR_OR
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'&'	TokenNameCharacterLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_PLUS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_LBRACKET	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.ope.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
RangeToken	TokenNameIdentifier
t2	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
parseCharacterClass	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
T_PLUS	TokenNameIdentifier
)	TokenNameRPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
mergeRanges	TokenNameIdentifier
(	TokenNameLPAREN
t2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'-'	TokenNameCharacterLiteral
)	TokenNameRPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
subtractRanges	TokenNameIdentifier
(	TokenNameLPAREN
t2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'&'	TokenNameCharacterLiteral
)	TokenNameRPAREN
tok	TokenNameIdentifier
.	TokenNameDOT
intersectRanges	TokenNameIdentifier
(	TokenNameLPAREN
t2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"ASSERT"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.ope.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Token	TokenNameIdentifier
getTokenForShorthand	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Token	TokenNameIdentifier
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'd'	TokenNameCharacterLiteral
:	TokenNameCOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
USE_UNICODE_CATEGORY	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
Token	TokenNameIdentifier
.	TokenNameDOT
getRange	TokenNameIdentifier
(	TokenNameLPAREN
"Nd"	TokenNameStringLiteral
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
:	TokenNameCOLON
Token	TokenNameIdentifier
.	TokenNameDOT
token_0to9	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'D'	TokenNameCharacterLiteral
:	TokenNameCOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
USE_UNICODE_CATEGORY	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
Token	TokenNameIdentifier
.	TokenNameDOT
getRange	TokenNameIdentifier
(	TokenNameLPAREN
"Nd"	TokenNameStringLiteral
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
:	TokenNameCOLON
Token	TokenNameIdentifier
.	TokenNameDOT
token_not_0to9	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'w'	TokenNameCharacterLiteral
:	TokenNameCOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
USE_UNICODE_CATEGORY	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
Token	TokenNameIdentifier
.	TokenNameDOT
getRange	TokenNameIdentifier
(	TokenNameLPAREN
"IsWord"	TokenNameStringLiteral
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
:	TokenNameCOLON
Token	TokenNameIdentifier
.	TokenNameDOT
token_wordchars	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'W'	TokenNameCharacterLiteral
:	TokenNameCOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
USE_UNICODE_CATEGORY	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
Token	TokenNameIdentifier
.	TokenNameDOT
getRange	TokenNameIdentifier
(	TokenNameLPAREN
"IsWord"	TokenNameStringLiteral
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
:	TokenNameCOLON
Token	TokenNameIdentifier
.	TokenNameDOT
token_not_wordchars	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
's'	TokenNameCharacterLiteral
:	TokenNameCOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
USE_UNICODE_CATEGORY	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
Token	TokenNameIdentifier
.	TokenNameDOT
getRange	TokenNameIdentifier
(	TokenNameLPAREN
"IsSpace"	TokenNameStringLiteral
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
:	TokenNameCOLON
Token	TokenNameIdentifier
.	TokenNameDOT
token_spaces	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'S'	TokenNameCharacterLiteral
:	TokenNameCOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
RegularExpression	TokenNameIdentifier
.	TokenNameDOT
USE_UNICODE_CATEGORY	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
Token	TokenNameIdentifier
.	TokenNameDOT
getRange	TokenNameIdentifier
(	TokenNameLPAREN
"IsSpace"	TokenNameStringLiteral
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
:	TokenNameCOLON
Token	TokenNameIdentifier
.	TokenNameDOT
token_not_spaces	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Internal Error: shorthands: \u"	TokenNameStringLiteral
+	TokenNamePLUS
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
16	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
decodeEscaped	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_BACKSOLIDUS	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.next.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
c	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'e'	TokenNameCharacterLiteral
:	TokenNameCOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
0x1b	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'f'	TokenNameCharacterLiteral
:	TokenNameCOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
'\f'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'n'	TokenNameCharacterLiteral
:	TokenNameCOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
'\n'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'r'	TokenNameCharacterLiteral
:	TokenNameCOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
'\r'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
't'	TokenNameCharacterLiteral
:	TokenNameCOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
'\t'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'x'	TokenNameCharacterLiteral
:	TokenNameCOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'{'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
v1	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
uv	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
do	TokenNamedo
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
uv	TokenNameIdentifier
>	TokenNameGREATER
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.2"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
+	TokenNamePLUS
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'}'	TokenNameCharacterLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.3"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
uv	TokenNameIdentifier
>	TokenNameGREATER
Token	TokenNameIdentifier
.	TokenNameDOT
UTF16_MAX	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.4"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
v1	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
uv	TokenNameIdentifier
=	TokenNameEQUAL
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
+	TokenNamePLUS
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'u'	TokenNameCharacterLiteral
:	TokenNameCOLON
int	TokenNameint
v1	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
uv	TokenNameIdentifier
=	TokenNameEQUAL
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
+	TokenNamePLUS
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
+	TokenNamePLUS
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
+	TokenNamePLUS
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'v'	TokenNameCharacterLiteral
:	TokenNameCOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
+	TokenNamePLUS
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
+	TokenNamePLUS
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
+	TokenNamePLUS
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
+	TokenNamePLUS
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
T_CHAR	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
v1	TokenNameIdentifier
=	TokenNameEQUAL
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
chardata	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.1"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
uv	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
+	TokenNamePLUS
v1	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
uv	TokenNameIdentifier
>	TokenNameGREATER
Token	TokenNameIdentifier
.	TokenNameDOT
UTF16_MAX	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descappe.4"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
uv	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'A'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'Z'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'z'	TokenNameCharacterLiteral
:	TokenNameCOLON
throw	TokenNamethrow
ex	TokenNameIdentifier
(	TokenNameLPAREN
"parser.descape.5"	TokenNameStringLiteral
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
}	TokenNameRBRACE
return	TokenNamereturn
c	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
hexChar	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
ch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<	TokenNameLESS
'0'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
>	TokenNameGREATER
'f'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
ch	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<	TokenNameLESS
'A'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'F'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
ch	TokenNameIdentifier
-	TokenNameMINUS
'A'	TokenNameCharacterLiteral
+	TokenNamePLUS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<	TokenNameLESS
'a'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
ch	TokenNameIdentifier
-	TokenNameMINUS
'a'	TokenNameCharacterLiteral
+	TokenNamePLUS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
protected	TokenNameprotected
final	TokenNamefinal
void	TokenNamevoid
addCaseInsensitiveChar	TokenNameIdentifier
(	TokenNameLPAREN
RangeToken	TokenNameIdentifier
tok	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
caseMap	TokenNameIdentifier
=	TokenNameEQUAL
CaseInsensitiveMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
.	TokenNameDOT
addRange	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
,	TokenNameCOMMA
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
caseMap	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
caseMap	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
.	TokenNameDOT
addRange	TokenNameIdentifier
(	TokenNameLPAREN
caseMap	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
caseMap	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
static	TokenNamestatic
protected	TokenNameprotected
final	TokenNamefinal
void	TokenNamevoid
addCaseInsensitiveCharRange	TokenNameIdentifier
(	TokenNameLPAREN
RangeToken	TokenNameIdentifier
tok	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
caseMap	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
r1	TokenNameIdentifier
,	TokenNameCOMMA
r2	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
start	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
r1	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
r2	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
r1	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
;	TokenNameSEMICOLON
r2	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
tok	TokenNameIdentifier
.	TokenNameDOT
addRange	TokenNameIdentifier
(	TokenNameLPAREN
r1	TokenNameIdentifier
,	TokenNameCOMMA
r2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
r1	TokenNameIdentifier
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
r2	TokenNameIdentifier
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
caseMap	TokenNameIdentifier
=	TokenNameEQUAL
CaseInsensitiveMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
caseMap	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
caseMap	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
.	TokenNameDOT
addRange	TokenNameIdentifier
(	TokenNameLPAREN
caseMap	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
caseMap	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
