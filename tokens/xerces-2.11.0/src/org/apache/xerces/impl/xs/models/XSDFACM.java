package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
models	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashMap	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Vector	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dtd	TokenNameIdentifier
.	TokenNameDOT
models	TokenNameIdentifier
.	TokenNameDOT
CMNode	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dtd	TokenNameIdentifier
.	TokenNameDOT
models	TokenNameIdentifier
.	TokenNameDOT
CMStateSet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
SchemaSymbols	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
SubstitutionGroupHandler	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XMLSchemaException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSConstraints	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSElementDecl	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSModelGroupImpl	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSParticleDecl	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSWildcardDecl	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xni	TokenNameIdentifier
.	TokenNameDOT
QName	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
XSDFACM	TokenNameIdentifier
implements	TokenNameimplements
XSCMValidator	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
DEBUG	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
DEBUG_VALIDATE_CONTENT	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
Object	TokenNameIdentifier
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fElemMapType	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fElemMapId	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fElemMapSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
fFinalStateFlags	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
CMStateSet	TokenNameIdentifier
fFollowList	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
CMNode	TokenNameIdentifier
fHeadNode	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fLeafCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
XSCMLeaf	TokenNameIdentifier
fLeafList	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fLeafListType	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
Occurence	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fCountingStates	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
Occurence	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
minOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
maxOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
elemIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Occurence	TokenNameIdentifier
(	TokenNameLPAREN
XSCMRepeatingLeaf	TokenNameIdentifier
leaf	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
elemIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
minOccurs	TokenNameIdentifier
=	TokenNameEQUAL
leaf	TokenNameIdentifier
.	TokenNameDOT
getMinOccurs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
maxOccurs	TokenNameIdentifier
=	TokenNameEQUAL
leaf	TokenNameIdentifier
.	TokenNameDOT
getMaxOccurs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
elemIndex	TokenNameIdentifier
=	TokenNameEQUAL
elemIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"minOccurs="	TokenNameStringLiteral
+	TokenNamePLUS
minOccurs	TokenNameIdentifier
+	TokenNamePLUS
";maxOccurs="	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
maxOccurs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
maxOccurs	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
"unbounded"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
fTransTableSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
fIsCompactedForUPA	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XSDFACM	TokenNameIdentifier
(	TokenNameLPAREN
CMNode	TokenNameIdentifier
syntaxTree	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
leafCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fLeafCount	TokenNameIdentifier
=	TokenNameEQUAL
leafCount	TokenNameIdentifier
;	TokenNameSEMICOLON
fIsCompactedForUPA	TokenNameIdentifier
=	TokenNameEQUAL
syntaxTree	TokenNameIdentifier
.	TokenNameDOT
isCompactedForUPA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DEBUG_VALIDATE_CONTENT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSDFACM	TokenNameIdentifier
.	TokenNameDOT
time	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
buildDFA	TokenNameIdentifier
(	TokenNameLPAREN
syntaxTree	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DEBUG_VALIDATE_CONTENT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSDFACM	TokenNameIdentifier
.	TokenNameDOT
time	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"DFA build: "	TokenNameStringLiteral
+	TokenNamePLUS
XSDFACM	TokenNameIdentifier
.	TokenNameDOT
time	TokenNameIdentifier
+	TokenNamePLUS
"ms"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
long	TokenNamelong
time	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
isFinalState	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
state	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
state	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
false	TokenNamefalse
:	TokenNameCOLON
fFinalStateFlags	TokenNameIdentifier
[	TokenNameLBRACKET
state	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
oneTransition	TokenNameIdentifier
(	TokenNameLPAREN
QName	TokenNameIdentifier
curElem	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
state	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
subGroupHandler	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
curState	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
curState	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSCMValidator	TokenNameIdentifier
.	TokenNameDOT
FIRST_ERROR	TokenNameIdentifier
||	TokenNameOR_OR
curState	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSCMValidator	TokenNameIdentifier
.	TokenNameDOT
SUBSEQUENT_ERROR	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
curState	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSCMValidator	TokenNameIdentifier
.	TokenNameDOT
FIRST_ERROR	TokenNameIdentifier
)	TokenNameRPAREN
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
XSCMValidator	TokenNameIdentifier
.	TokenNameDOT
SUBSEQUENT_ERROR	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
findMatchingDecl	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
,	TokenNameCOMMA
subGroupHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
nextState	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
elemIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
Object	TokenNameIdentifier
matchingDecl	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
elemIndex	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
elemIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
nextState	TokenNameIdentifier
=	TokenNameEQUAL
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nextState	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
fElemMapType	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
matchingDecl	TokenNameIdentifier
=	TokenNameEQUAL
subGroupHandler	TokenNameIdentifier
.	TokenNameDOT
getMatchingElemDecl	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchingDecl	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
.	TokenNameDOT
allowNamespace	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
.	TokenNameDOT
uri	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
matchingDecl	TokenNameIdentifier
=	TokenNameEQUAL
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
elemIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
fElemMapSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
XSCMValidator	TokenNameIdentifier
.	TokenNameDOT
FIRST_ERROR	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
findMatchingDecl	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
,	TokenNameCOMMA
subGroupHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fCountingStates	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
Occurence	TokenNameIdentifier
o	TokenNameIdentifier
=	TokenNameEQUAL
fCountingStates	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
curState	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
nextState	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
state	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
>	TokenNameGREATER
o	TokenNameIdentifier
.	TokenNameDOT
maxOccurs	TokenNameIdentifier
&&	TokenNameAND_AND
o	TokenNameIdentifier
.	TokenNameDOT
maxOccurs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
findMatchingDecl	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
,	TokenNameCOMMA
state	TokenNameIdentifier
,	TokenNameCOMMA
subGroupHandler	TokenNameIdentifier
,	TokenNameCOMMA
elemIndex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
state	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
<	TokenNameLESS
o	TokenNameIdentifier
.	TokenNameDOT
minOccurs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
XSCMValidator	TokenNameIdentifier
.	TokenNameDOT
FIRST_ERROR	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
findMatchingDecl	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
,	TokenNameCOMMA
subGroupHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
o	TokenNameIdentifier
=	TokenNameEQUAL
fCountingStates	TokenNameIdentifier
[	TokenNameLBRACKET
nextState	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
elemIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
o	TokenNameIdentifier
.	TokenNameDOT
elemIndex	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
o	TokenNameIdentifier
=	TokenNameEQUAL
fCountingStates	TokenNameIdentifier
[	TokenNameLBRACKET
nextState	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
elemIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
o	TokenNameIdentifier
.	TokenNameDOT
elemIndex	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
nextState	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
matchingDecl	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Object	TokenNameIdentifier
findMatchingDecl	TokenNameIdentifier
(	TokenNameLPAREN
QName	TokenNameIdentifier
curElem	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
subGroupHandler	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Object	TokenNameIdentifier
matchingDecl	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
elemIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
elemIndex	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
elemIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
fElemMapType	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
matchingDecl	TokenNameIdentifier
=	TokenNameEQUAL
subGroupHandler	TokenNameIdentifier
.	TokenNameDOT
getMatchingElemDecl	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchingDecl	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
matchingDecl	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
.	TokenNameDOT
allowNamespace	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
.	TokenNameDOT
uri	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Object	TokenNameIdentifier
findMatchingDecl	TokenNameIdentifier
(	TokenNameLPAREN
QName	TokenNameIdentifier
curElem	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
state	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
subGroupHandler	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
elemIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
curState	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
nextState	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
Object	TokenNameIdentifier
matchingDecl	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
elemIndex	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
nextState	TokenNameIdentifier
=	TokenNameEQUAL
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nextState	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
fElemMapType	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
matchingDecl	TokenNameIdentifier
=	TokenNameEQUAL
subGroupHandler	TokenNameIdentifier
.	TokenNameDOT
getMatchingElemDecl	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchingDecl	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
.	TokenNameDOT
allowNamespace	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
.	TokenNameDOT
uri	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
matchingDecl	TokenNameIdentifier
=	TokenNameEQUAL
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
elemIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
fElemMapSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
XSCMValidator	TokenNameIdentifier
.	TokenNameDOT
FIRST_ERROR	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
findMatchingDecl	TokenNameIdentifier
(	TokenNameLPAREN
curElem	TokenNameIdentifier
,	TokenNameCOMMA
subGroupHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
nextState	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
Occurence	TokenNameIdentifier
o	TokenNameIdentifier
=	TokenNameEQUAL
fCountingStates	TokenNameIdentifier
[	TokenNameLBRACKET
nextState	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
elemIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
o	TokenNameIdentifier
.	TokenNameDOT
elemIndex	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
matchingDecl	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
startContentModel	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
endContentModel	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
state	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
curState	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fFinalStateFlags	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fCountingStates	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
Occurence	TokenNameIdentifier
o	TokenNameIdentifier
=	TokenNameEQUAL
fCountingStates	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
state	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
<	TokenNameLESS
o	TokenNameIdentifier
.	TokenNameDOT
minOccurs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
buildDFA	TokenNameIdentifier
(	TokenNameLPAREN
CMNode	TokenNameIdentifier
syntaxTree	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
EOCPos	TokenNameIdentifier
=	TokenNameEQUAL
fLeafCount	TokenNameIdentifier
;	TokenNameSEMICOLON
XSCMLeaf	TokenNameIdentifier
nodeEOC	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSCMLeaf	TokenNameIdentifier
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
fLeafCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fHeadNode	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSCMBinOp	TokenNameIdentifier
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
,	TokenNameCOMMA
syntaxTree	TokenNameIdentifier
,	TokenNameCOMMA
nodeEOC	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fLeafList	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSCMLeaf	TokenNameIdentifier
[	TokenNameLBRACKET
fLeafCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fLeafListType	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
fLeafCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
postTreeBuildInit	TokenNameIdentifier
(	TokenNameLPAREN
fHeadNode	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fFollowList	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CMStateSet	TokenNameIdentifier
[	TokenNameLBRACKET
fLeafCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
fLeafCount	TokenNameIdentifier
;	TokenNameSEMICOLON
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
fFollowList	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
CMStateSet	TokenNameIdentifier
(	TokenNameLPAREN
fLeafCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
calcFollowList	TokenNameIdentifier
(	TokenNameLPAREN
fHeadNode	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fElemMap	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
fLeafCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fElemMapType	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
fLeafCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fElemMapId	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
fLeafCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fElemMapSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
Occurence	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
elemOccurenceMap	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
outIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
outIndex	TokenNameIdentifier
<	TokenNameLESS
fLeafCount	TokenNameIdentifier
;	TokenNameSEMICOLON
outIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
outIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
inIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
id	TokenNameIdentifier
=	TokenNameEQUAL
fLeafList	TokenNameIdentifier
[	TokenNameLBRACKET
outIndex	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getParticleId	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
inIndex	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
inIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
id	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
fElemMapId	TokenNameIdentifier
[	TokenNameLBRACKET
inIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
inIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
fElemMapSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSCMLeaf	TokenNameIdentifier
leaf	TokenNameIdentifier
=	TokenNameEQUAL
fLeafList	TokenNameIdentifier
[	TokenNameLBRACKET
outIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
fElemMapSize	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
leaf	TokenNameIdentifier
.	TokenNameDOT
getLeaf	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
leaf	TokenNameIdentifier
instanceof	TokenNameinstanceof
XSCMRepeatingLeaf	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
elemOccurenceMap	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
elemOccurenceMap	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Occurence	TokenNameIdentifier
[	TokenNameLBRACKET
fLeafCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
elemOccurenceMap	TokenNameIdentifier
[	TokenNameLBRACKET
fElemMapSize	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
Occurence	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMRepeatingLeaf	TokenNameIdentifier
)	TokenNameRPAREN
leaf	TokenNameIdentifier
,	TokenNameCOMMA
fElemMapSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fElemMapType	TokenNameIdentifier
[	TokenNameLBRACKET
fElemMapSize	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
fLeafListType	TokenNameIdentifier
[	TokenNameLBRACKET
outIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fElemMapId	TokenNameIdentifier
[	TokenNameLBRACKET
fElemMapSize	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
id	TokenNameIdentifier
;	TokenNameSEMICOLON
fElemMapSize	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fElemMapId	TokenNameIdentifier
[	TokenNameLBRACKET
fElemMapSize	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"interal error in DFA: last element is not EOC."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fElemMapSize	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fLeafSorter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
fLeafCount	TokenNameIdentifier
+	TokenNamePLUS
fElemMapSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
fSortCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
elemIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
elemIndex	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
elemIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
id	TokenNameIdentifier
=	TokenNameEQUAL
fElemMapId	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
leafIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
leafIndex	TokenNameIdentifier
<	TokenNameLESS
fLeafCount	TokenNameIdentifier
;	TokenNameSEMICOLON
leafIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
id	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
fLeafList	TokenNameIdentifier
[	TokenNameLBRACKET
leafIndex	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getParticleId	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
fLeafSorter	TokenNameIdentifier
[	TokenNameLBRACKET
fSortCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
leafIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fLeafSorter	TokenNameIdentifier
[	TokenNameLBRACKET
fSortCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
curArraySize	TokenNameIdentifier
=	TokenNameEQUAL
fLeafCount	TokenNameIdentifier
*	TokenNameMULTIPLY
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
CMStateSet	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
statesToDo	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CMStateSet	TokenNameIdentifier
[	TokenNameLBRACKET
curArraySize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fFinalStateFlags	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
curArraySize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fTransTable	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
curArraySize	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
CMStateSet	TokenNameIdentifier
setT	TokenNameIdentifier
=	TokenNameEQUAL
fHeadNode	TokenNameIdentifier
.	TokenNameDOT
firstPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
unmarkedState	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
curState	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
makeDefStateList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
statesToDo	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
setT	TokenNameIdentifier
;	TokenNameSEMICOLON
curState	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
HashMap	TokenNameIdentifier
stateTable	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
unmarkedState	TokenNameIdentifier
<	TokenNameLESS
curState	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
setT	TokenNameIdentifier
=	TokenNameEQUAL
statesToDo	TokenNameIdentifier
[	TokenNameLBRACKET
unmarkedState	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
transEntry	TokenNameIdentifier
=	TokenNameEQUAL
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
unmarkedState	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fFinalStateFlags	TokenNameIdentifier
[	TokenNameLBRACKET
unmarkedState	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
setT	TokenNameIdentifier
.	TokenNameDOT
getBit	TokenNameIdentifier
(	TokenNameLPAREN
EOCPos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
unmarkedState	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
CMStateSet	TokenNameIdentifier
newSet	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
sorterIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
elemIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
elemIndex	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
elemIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
newSet	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
newSet	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CMStateSet	TokenNameIdentifier
(	TokenNameLPAREN
fLeafCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
newSet	TokenNameIdentifier
.	TokenNameDOT
zeroBits	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
leafIndex	TokenNameIdentifier
=	TokenNameEQUAL
fLeafSorter	TokenNameIdentifier
[	TokenNameLBRACKET
sorterIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
leafIndex	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
setT	TokenNameIdentifier
.	TokenNameDOT
getBit	TokenNameIdentifier
(	TokenNameLPAREN
leafIndex	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
newSet	TokenNameIdentifier
.	TokenNameDOT
union	TokenNameIdentifier
(	TokenNameLPAREN
fFollowList	TokenNameIdentifier
[	TokenNameLBRACKET
leafIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
leafIndex	TokenNameIdentifier
=	TokenNameEQUAL
fLeafSorter	TokenNameIdentifier
[	TokenNameLBRACKET
sorterIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
newSet	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Integer	TokenNameIdentifier
stateObj	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Integer	TokenNameIdentifier
)	TokenNameRPAREN
stateTable	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
newSet	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
stateIndex	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
stateObj	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
curState	TokenNameIdentifier
:	TokenNameCOLON
stateObj	TokenNameIdentifier
.	TokenNameDOT
intValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
stateIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
curState	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
statesToDo	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
newSet	TokenNameIdentifier
;	TokenNameSEMICOLON
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
makeDefStateList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
stateTable	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
newSet	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
Integer	TokenNameIdentifier
(	TokenNameLPAREN
curState	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
curState	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
newSet	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
transEntry	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
stateIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
curState	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
curArraySize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
newSize	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
curArraySize	TokenNameIdentifier
*	TokenNameMULTIPLY
1.5	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
CMStateSet	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newToDo	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CMStateSet	TokenNameIdentifier
[	TokenNameLBRACKET
newSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newFinalFlags	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
newSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newTransTable	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
newSize	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
statesToDo	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newToDo	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
curArraySize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
fFinalStateFlags	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newFinalFlags	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
curArraySize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
fTransTable	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newTransTable	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
curArraySize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
curArraySize	TokenNameIdentifier
=	TokenNameEQUAL
newSize	TokenNameIdentifier
;	TokenNameSEMICOLON
statesToDo	TokenNameIdentifier
=	TokenNameEQUAL
newToDo	TokenNameIdentifier
;	TokenNameSEMICOLON
fFinalStateFlags	TokenNameIdentifier
=	TokenNameEQUAL
newFinalFlags	TokenNameIdentifier
;	TokenNameSEMICOLON
fTransTable	TokenNameIdentifier
=	TokenNameEQUAL
newTransTable	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
elemOccurenceMap	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
fCountingStates	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Occurence	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
curState	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
transitions	TokenNameIdentifier
=	TokenNameEQUAL
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
transitions	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
j	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
transitions	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
fCountingStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
elemOccurenceMap	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
DEBUG_VALIDATE_CONTENT	TokenNameIdentifier
)	TokenNameRPAREN
dumpTree	TokenNameIdentifier
(	TokenNameLPAREN
fHeadNode	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fHeadNode	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fLeafList	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fFollowList	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fLeafListType	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
fElemMapId	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
calcFollowList	TokenNameIdentifier
(	TokenNameLPAREN
CMNode	TokenNameIdentifier
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
calcFollowList	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMBinOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getLeft	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
calcFollowList	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMBinOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getRight	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
calcFollowList	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMBinOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getLeft	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
calcFollowList	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMBinOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getRight	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
CMStateSet	TokenNameIdentifier
last	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMBinOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getLeft	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
lastPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
CMStateSet	TokenNameIdentifier
first	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMBinOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getRight	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
firstPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
fLeafCount	TokenNameIdentifier
;	TokenNameSEMICOLON
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
last	TokenNameIdentifier
.	TokenNameDOT
getBit	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
fFollowList	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
union	TokenNameIdentifier
(	TokenNameLPAREN
first	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ZERO_OR_MORE	TokenNameIdentifier
||	TokenNameOR_OR
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ONE_OR_MORE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
calcFollowList	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMUniOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
CMStateSet	TokenNameIdentifier
first	TokenNameIdentifier
=	TokenNameEQUAL
nodeCur	TokenNameIdentifier
.	TokenNameDOT
firstPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
CMStateSet	TokenNameIdentifier
last	TokenNameIdentifier
=	TokenNameEQUAL
nodeCur	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
fLeafCount	TokenNameIdentifier
;	TokenNameSEMICOLON
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
last	TokenNameIdentifier
.	TokenNameDOT
getBit	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
fFollowList	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
union	TokenNameIdentifier
(	TokenNameLPAREN
first	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ZERO_OR_ONE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
calcFollowList	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMUniOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
dumpTree	TokenNameIdentifier
(	TokenNameLPAREN
CMNode	TokenNameIdentifier
nodeCur	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
level	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
level	TokenNameIdentifier
;	TokenNameSEMICOLON
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"   "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"Choice Node "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"Seq Node "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
isNullable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"Nullable "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"firstPos="	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
firstPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
" lastPos="	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dumpTree	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMBinOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getLeft	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
level	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dumpTree	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMBinOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getRight	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
level	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ZERO_OR_MORE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ONE_OR_MORE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ZERO_OR_ONE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"Rep Node "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
isNullable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"Nullable "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"firstPos="	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
firstPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
" lastPos="	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dumpTree	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMUniOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
level	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"Leaf: (pos="	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMLeaf	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"), "	TokenNameStringLiteral
+	TokenNamePLUS
"(elemIndex="	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMLeaf	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getLeaf	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
") "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
isNullable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
" Nullable "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"firstPos="	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
firstPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
" lastPos="	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
:	TokenNameCOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"Any Node: "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"firstPos="	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
firstPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
" lastPos="	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"ImplementationMessages.VAL_NIICM"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
makeDefStateList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
retArray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
fElemMapSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
retArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
retArray	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
postTreeBuildInit	TokenNameIdentifier
(	TokenNameLPAREN
CMNode	TokenNameIdentifier
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
RuntimeException	TokenNameIdentifier
{	TokenNameLBRACE
nodeCur	TokenNameIdentifier
.	TokenNameDOT
setMaxStates	TokenNameIdentifier
(	TokenNameLPAREN
fLeafCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
XSCMLeaf	TokenNameIdentifier
leaf	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
leaf	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSCMLeaf	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
;	TokenNameSEMICOLON
pos	TokenNameIdentifier
=	TokenNameEQUAL
leaf	TokenNameIdentifier
.	TokenNameDOT
getPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fLeafList	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
leaf	TokenNameIdentifier
;	TokenNameSEMICOLON
fLeafListType	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
postTreeBuildInit	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMBinOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getLeft	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
postTreeBuildInit	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMBinOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getRight	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ZERO_OR_MORE	TokenNameIdentifier
||	TokenNameOR_OR
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ONE_OR_MORE	TokenNameIdentifier
||	TokenNameOR_OR
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ZERO_OR_ONE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
postTreeBuildInit	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSCMUniOp	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getChild	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
nodeCur	TokenNameIdentifier
.	TokenNameDOT
type	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
leaf	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSCMLeaf	TokenNameIdentifier
)	TokenNameRPAREN
nodeCur	TokenNameIdentifier
;	TokenNameSEMICOLON
pos	TokenNameIdentifier
=	TokenNameEQUAL
leaf	TokenNameIdentifier
.	TokenNameDOT
getPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fLeafList	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
leaf	TokenNameIdentifier
;	TokenNameSEMICOLON
fLeafListType	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"ImplementationMessages.VAL_NIICM"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
checkUniqueParticleAttribution	TokenNameIdentifier
(	TokenNameLPAREN
SubstitutionGroupHandler	TokenNameIdentifier
subGroupHandler	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
byte	TokenNamebyte
conflictTable	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
fElemMapSize	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
fElemMapSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fTransTable	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
&&	TokenNameAND_AND
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
k	TokenNameIdentifier
=	TokenNameEQUAL
j	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
k	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
k	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
conflictTable	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
XSConstraints	TokenNameIdentifier
.	TokenNameDOT
overlapUPA	TokenNameIdentifier
(	TokenNameLPAREN
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
subGroupHandler	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fCountingStates	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
Occurence	TokenNameIdentifier
o	TokenNameIdentifier
=	TokenNameEQUAL
fCountingStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
i	TokenNameIdentifier
^	TokenNameXOR
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
i	TokenNameIdentifier
&&	TokenNameAND_AND
o	TokenNameIdentifier
.	TokenNameDOT
minOccurs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
o	TokenNameIdentifier
.	TokenNameDOT
maxOccurs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
conflictTable	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
conflictTable	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
conflictTable	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
conflictTable	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"cos-nonambig"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fElemMapType	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSWildcardDecl	TokenNameIdentifier
wildcard	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
wildcard	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSWildcardDecl	TokenNameIdentifier
.	TokenNameDOT
NSCONSTRAINT_LIST	TokenNameIdentifier
||	TokenNameOR_OR
wildcard	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSWildcardDecl	TokenNameIdentifier
.	TokenNameDOT
NSCONSTRAINT_NOT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Vector	TokenNameIdentifier
whatCanGoHere	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
state	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
curState	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
curState	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
curState	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Occurence	TokenNameIdentifier
o	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
fCountingStates	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
fCountingStates	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
:	TokenNameCOLON
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Vector	TokenNameIdentifier
ret	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
elemIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
elemIndex	TokenNameIdentifier
<	TokenNameLESS
fElemMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
elemIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
nextState	TokenNameIdentifier
=	TokenNameEQUAL
fTransTable	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nextState	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
curState	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
nextState	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
o	TokenNameIdentifier
.	TokenNameDOT
maxOccurs	TokenNameIdentifier
&&	TokenNameAND_AND
o	TokenNameIdentifier
.	TokenNameDOT
maxOccurs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
<	TokenNameLESS
o	TokenNameIdentifier
.	TokenNameDOT
minOccurs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
ret	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
elemIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
occurenceInfo	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
state	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fCountingStates	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
curState	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
curState	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
curState	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Occurence	TokenNameIdentifier
o	TokenNameIdentifier
=	TokenNameEQUAL
fCountingStates	TokenNameIdentifier
[	TokenNameLBRACKET
curState	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
occurenceInfo	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
4	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
occurenceInfo	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
o	TokenNameIdentifier
.	TokenNameDOT
minOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
occurenceInfo	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
o	TokenNameIdentifier
.	TokenNameDOT
maxOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
occurenceInfo	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
state	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
occurenceInfo	TokenNameIdentifier
[	TokenNameLBRACKET
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
o	TokenNameIdentifier
.	TokenNameDOT
elemIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
occurenceInfo	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getTermName	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
termId	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Object	TokenNameIdentifier
term	TokenNameIdentifier
=	TokenNameEQUAL
fElemMap	TokenNameIdentifier
[	TokenNameLBRACKET
termId	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
term	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
term	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isCompactedForUPA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fIsCompactedForUPA	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
