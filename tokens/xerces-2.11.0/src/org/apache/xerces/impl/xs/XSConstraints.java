package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collections	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Comparator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Vector	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
XMLErrorReporter	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
InvalidDatatypeValueException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
ValidatedInfo	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
ValidationContext	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dv	TokenNameIdentifier
.	TokenNameDOT
XSSimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
models	TokenNameIdentifier
.	TokenNameDOT
CMBuilder	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
models	TokenNameIdentifier
.	TokenNameDOT
XSCMValidator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
SimpleLocator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
XSObjectListImpl	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
SymbolHash	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSConstants	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSObjectList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
xs	TokenNameIdentifier
.	TokenNameDOT
XSTypeDefinition	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
XSConstraints	TokenNameIdentifier
{	TokenNameLBRACE
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
OCCURRENCE_UNKNOWN	TokenNameIdentifier
=	TokenNameEQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
XSSimpleType	TokenNameIdentifier
STRING_TYPE	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
)	TokenNameRPAREN
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
SG_SchemaNS	TokenNameIdentifier
.	TokenNameDOT
getGlobalTypeDecl	TokenNameIdentifier
(	TokenNameLPAREN
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
ATTVAL_STRING	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
XSParticleDecl	TokenNameIdentifier
fEmptyParticle	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
XSParticleDecl	TokenNameIdentifier
getEmptySequence	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fEmptyParticle	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
XSModelGroupImpl	TokenNameIdentifier
group	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSModelGroupImpl	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
group	TokenNameIdentifier
.	TokenNameDOT
fCompositor	TokenNameIdentifier
=	TokenNameEQUAL
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
;	TokenNameSEMICOLON
group	TokenNameIdentifier
.	TokenNameDOT
fParticleCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
group	TokenNameIdentifier
.	TokenNameDOT
fParticles	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
group	TokenNameIdentifier
.	TokenNameDOT
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
XSObjectListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
XSParticleDecl	TokenNameIdentifier
particle	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSParticleDecl	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
particle	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
=	TokenNameEQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_MODELGROUP	TokenNameIdentifier
;	TokenNameSEMICOLON
particle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
=	TokenNameEQUAL
group	TokenNameIdentifier
;	TokenNameSEMICOLON
particle	TokenNameIdentifier
.	TokenNameDOT
fAnnotations	TokenNameIdentifier
=	TokenNameEQUAL
XSObjectListImpl	TokenNameIdentifier
.	TokenNameDOT
EMPTY_LIST	TokenNameIdentifier
;	TokenNameSEMICOLON
fEmptyParticle	TokenNameIdentifier
=	TokenNameEQUAL
particle	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fEmptyParticle	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
Comparator	TokenNameIdentifier
ELEMENT_PARTICLE_COMPARATOR	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Comparator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
o1	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
o2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
pDecl1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
o1	TokenNameIdentifier
;	TokenNameSEMICOLON
XSParticleDecl	TokenNameIdentifier
pDecl2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
o2	TokenNameIdentifier
;	TokenNameSEMICOLON
XSElementDecl	TokenNameIdentifier
decl1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
pDecl1	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
;	TokenNameSEMICOLON
XSElementDecl	TokenNameIdentifier
decl2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
pDecl2	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
;	TokenNameSEMICOLON
String	TokenNameIdentifier
namespace1	TokenNameIdentifier
=	TokenNameEQUAL
decl1	TokenNameIdentifier
.	TokenNameDOT
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
namespace2	TokenNameIdentifier
=	TokenNameEQUAL
decl2	TokenNameIdentifier
.	TokenNameDOT
getNamespace	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
name1	TokenNameIdentifier
=	TokenNameEQUAL
decl1	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
name2	TokenNameIdentifier
=	TokenNameEQUAL
decl2	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
sameNamespace	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
namespace1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
namespace2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
namespaceComparison	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
sameNamespace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
namespace1	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
namespace2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
namespaceComparison	TokenNameIdentifier
=	TokenNameEQUAL
namespace1	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
namespace2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
namespaceComparison	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
namespaceComparison	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
namespaceComparison	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
namespaceComparison	TokenNameIdentifier
:	TokenNameCOLON
name1	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
name2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
checkTypeDerivationOk	TokenNameIdentifier
(	TokenNameLPAREN
XSTypeDefinition	TokenNameIdentifier
derived	TokenNameIdentifier
,	TokenNameCOMMA
XSTypeDefinition	TokenNameIdentifier
base	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
block	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
derived	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnyType	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
derived	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
base	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
derived	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnySimpleType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnyType	TokenNameIdentifier
||	TokenNameOR_OR
base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnySimpleType	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
derived	TokenNameIdentifier
.	TokenNameDOT
getTypeCategory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSTypeDefinition	TokenNameIdentifier
.	TokenNameDOT
SIMPLE_TYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
base	TokenNameIdentifier
.	TokenNameDOT
getTypeCategory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSTypeDefinition	TokenNameIdentifier
.	TokenNameDOT
COMPLEX_TYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnyType	TokenNameIdentifier
)	TokenNameRPAREN
base	TokenNameIdentifier
=	TokenNameEQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnySimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
checkSimpleDerivation	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
)	TokenNameRPAREN
derived	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
)	TokenNameRPAREN
base	TokenNameIdentifier
,	TokenNameCOMMA
block	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
checkComplexDerivation	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
derived	TokenNameIdentifier
,	TokenNameCOMMA
base	TokenNameIdentifier
,	TokenNameCOMMA
block	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
checkSimpleDerivationOk	TokenNameIdentifier
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
derived	TokenNameIdentifier
,	TokenNameCOMMA
XSTypeDefinition	TokenNameIdentifier
base	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
block	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
derived	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnySimpleType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnyType	TokenNameIdentifier
||	TokenNameOR_OR
base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnySimpleType	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
base	TokenNameIdentifier
.	TokenNameDOT
getTypeCategory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSTypeDefinition	TokenNameIdentifier
.	TokenNameDOT
COMPLEX_TYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnyType	TokenNameIdentifier
)	TokenNameRPAREN
base	TokenNameIdentifier
=	TokenNameEQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnySimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
checkSimpleDerivation	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
)	TokenNameRPAREN
derived	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
)	TokenNameRPAREN
base	TokenNameIdentifier
,	TokenNameCOMMA
block	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
checkComplexDerivationOk	TokenNameIdentifier
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
derived	TokenNameIdentifier
,	TokenNameCOMMA
XSTypeDefinition	TokenNameIdentifier
base	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
block	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
derived	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnyType	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
derived	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
base	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
checkComplexDerivation	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
derived	TokenNameIdentifier
,	TokenNameCOMMA
base	TokenNameIdentifier
,	TokenNameCOMMA
block	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
checkSimpleDerivation	TokenNameIdentifier
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
derived	TokenNameIdentifier
,	TokenNameCOMMA
XSSimpleType	TokenNameIdentifier
base	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
block	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
derived	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
base	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
block	TokenNameIdentifier
&	TokenNameAND
XSConstants	TokenNameIdentifier
.	TokenNameDOT
DERIVATION_RESTRICTION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
derived	TokenNameIdentifier
.	TokenNameDOT
getBaseType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getFinal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&	TokenNameAND
XSConstants	TokenNameIdentifier
.	TokenNameDOT
DERIVATION_RESTRICTION	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
XSSimpleType	TokenNameIdentifier
directBase	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
)	TokenNameRPAREN
derived	TokenNameIdentifier
.	TokenNameDOT
getBaseType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
directBase	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
base	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
directBase	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnySimpleType	TokenNameIdentifier
&&	TokenNameAND_AND
checkSimpleDerivation	TokenNameIdentifier
(	TokenNameLPAREN
directBase	TokenNameIdentifier
,	TokenNameCOMMA
base	TokenNameIdentifier
,	TokenNameCOMMA
block	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
derived	TokenNameIdentifier
.	TokenNameDOT
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSSimpleType	TokenNameIdentifier
.	TokenNameDOT
VARIETY_LIST	TokenNameIdentifier
||	TokenNameOR_OR
derived	TokenNameIdentifier
.	TokenNameDOT
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSSimpleType	TokenNameIdentifier
.	TokenNameDOT
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnySimpleType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
base	TokenNameIdentifier
.	TokenNameDOT
getVariety	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSSimpleType	TokenNameIdentifier
.	TokenNameDOT
VARIETY_UNION	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSObjectList	TokenNameIdentifier
subUnionMemberDV	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
.	TokenNameDOT
getMemberTypes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
subUnionSize	TokenNameIdentifier
=	TokenNameEQUAL
subUnionMemberDV	TokenNameIdentifier
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
subUnionSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
base	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
)	TokenNameRPAREN
subUnionMemberDV	TokenNameIdentifier
.	TokenNameDOT
item	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
checkSimpleDerivation	TokenNameIdentifier
(	TokenNameLPAREN
derived	TokenNameIdentifier
,	TokenNameCOMMA
base	TokenNameIdentifier
,	TokenNameCOMMA
block	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
checkComplexDerivation	TokenNameIdentifier
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
derived	TokenNameIdentifier
,	TokenNameCOMMA
XSTypeDefinition	TokenNameIdentifier
base	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
block	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
derived	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
base	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
derived	TokenNameIdentifier
.	TokenNameDOT
fDerivedBy	TokenNameIdentifier
&	TokenNameAND
block	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
XSTypeDefinition	TokenNameIdentifier
directBase	TokenNameIdentifier
=	TokenNameEQUAL
derived	TokenNameIdentifier
.	TokenNameDOT
fBaseType	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
directBase	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
base	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
directBase	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnyType	TokenNameIdentifier
||	TokenNameOR_OR
directBase	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnySimpleType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
directBase	TokenNameIdentifier
.	TokenNameDOT
getTypeCategory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSTypeDefinition	TokenNameIdentifier
.	TokenNameDOT
COMPLEX_TYPE	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
checkComplexDerivation	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
directBase	TokenNameIdentifier
,	TokenNameCOMMA
base	TokenNameIdentifier
,	TokenNameCOMMA
block	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
directBase	TokenNameIdentifier
.	TokenNameDOT
getTypeCategory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSTypeDefinition	TokenNameIdentifier
.	TokenNameDOT
SIMPLE_TYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
base	TokenNameIdentifier
.	TokenNameDOT
getTypeCategory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSTypeDefinition	TokenNameIdentifier
.	TokenNameDOT
COMPLEX_TYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
base	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnyType	TokenNameIdentifier
)	TokenNameRPAREN
base	TokenNameIdentifier
=	TokenNameEQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnySimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
checkSimpleDerivation	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
)	TokenNameRPAREN
directBase	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
)	TokenNameRPAREN
base	TokenNameIdentifier
,	TokenNameCOMMA
block	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
Object	TokenNameIdentifier
ElementDefaultValidImmediate	TokenNameIdentifier
(	TokenNameLPAREN
XSTypeDefinition	TokenNameIdentifier
type	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
value	TokenNameIdentifier
,	TokenNameCOMMA
ValidationContext	TokenNameIdentifier
context	TokenNameIdentifier
,	TokenNameCOMMA
ValidatedInfo	TokenNameIdentifier
vinfo	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSSimpleType	TokenNameIdentifier
dv	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
.	TokenNameDOT
getTypeCategory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSTypeDefinition	TokenNameIdentifier
.	TokenNameDOT
SIMPLE_TYPE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dv	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSSimpleType	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
XSComplexTypeDecl	TokenNameIdentifier
ctype	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ctype	TokenNameIdentifier
.	TokenNameDOT
fContentType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSComplexTypeDecl	TokenNameIdentifier
.	TokenNameDOT
CONTENTTYPE_SIMPLE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dv	TokenNameIdentifier
=	TokenNameEQUAL
ctype	TokenNameIdentifier
.	TokenNameDOT
fXSSimpleType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ctype	TokenNameIdentifier
.	TokenNameDOT
fContentType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSComplexTypeDecl	TokenNameIdentifier
.	TokenNameDOT
CONTENTTYPE_MIXED	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
ctype	TokenNameIdentifier
.	TokenNameDOT
getParticle	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
emptiable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
Object	TokenNameIdentifier
actualValue	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dv	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
dv	TokenNameIdentifier
=	TokenNameEQUAL
STRING_TYPE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
actualValue	TokenNameIdentifier
=	TokenNameEQUAL
dv	TokenNameIdentifier
.	TokenNameDOT
validate	TokenNameIdentifier
(	TokenNameLPAREN
value	TokenNameIdentifier
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
vinfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
vinfo	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
actualValue	TokenNameIdentifier
=	TokenNameEQUAL
dv	TokenNameIdentifier
.	TokenNameDOT
validate	TokenNameIdentifier
(	TokenNameLPAREN
vinfo	TokenNameIdentifier
.	TokenNameDOT
stringValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
context	TokenNameIdentifier
,	TokenNameCOMMA
vinfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InvalidDatatypeValueException	TokenNameIdentifier
ide	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
actualValue	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
void	TokenNamevoid
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
XMLErrorReporter	TokenNameIdentifier
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
SimpleLocator	TokenNameIdentifier
loc	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
key	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
args	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
loc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
errorReporter	TokenNameIdentifier
.	TokenNameDOT
reportError	TokenNameIdentifier
(	TokenNameLPAREN
loc	TokenNameIdentifier
,	TokenNameCOMMA
XSMessageFormatter	TokenNameIdentifier
.	TokenNameDOT
SCHEMA_DOMAIN	TokenNameIdentifier
,	TokenNameCOMMA
key	TokenNameIdentifier
,	TokenNameCOMMA
args	TokenNameIdentifier
,	TokenNameCOMMA
XMLErrorReporter	TokenNameIdentifier
.	TokenNameDOT
SEVERITY_ERROR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
errorReporter	TokenNameIdentifier
.	TokenNameDOT
reportError	TokenNameIdentifier
(	TokenNameLPAREN
XSMessageFormatter	TokenNameIdentifier
.	TokenNameDOT
SCHEMA_DOMAIN	TokenNameIdentifier
,	TokenNameCOMMA
key	TokenNameIdentifier
,	TokenNameCOMMA
args	TokenNameIdentifier
,	TokenNameCOMMA
XMLErrorReporter	TokenNameIdentifier
.	TokenNameDOT
SEVERITY_ERROR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
fullSchemaChecking	TokenNameIdentifier
(	TokenNameLPAREN
XSGrammarBucket	TokenNameIdentifier
grammarBucket	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
SGHandler	TokenNameIdentifier
,	TokenNameCOMMA
CMBuilder	TokenNameIdentifier
cmBuilder	TokenNameIdentifier
,	TokenNameCOMMA
XMLErrorReporter	TokenNameIdentifier
errorReporter	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
SchemaGrammar	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
grammars	TokenNameIdentifier
=	TokenNameEQUAL
grammarBucket	TokenNameIdentifier
.	TokenNameDOT
getGrammars	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
grammars	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
SGHandler	TokenNameIdentifier
.	TokenNameDOT
addSubstitutionGroup	TokenNameIdentifier
(	TokenNameLPAREN
grammars	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getSubstitutionGroups	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
XSParticleDecl	TokenNameIdentifier
fakeDerived	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSParticleDecl	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
XSParticleDecl	TokenNameIdentifier
fakeBase	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSParticleDecl	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fakeDerived	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
=	TokenNameEQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_MODELGROUP	TokenNameIdentifier
;	TokenNameSEMICOLON
fakeBase	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
=	TokenNameEQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_MODELGROUP	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
g	TokenNameIdentifier
=	TokenNameEQUAL
grammars	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
g	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
g	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSGroupDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
redefinedGroups	TokenNameIdentifier
=	TokenNameEQUAL
grammars	TokenNameIdentifier
[	TokenNameLBRACKET
g	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getRedefinedGroupDecls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SimpleLocator	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rgLocators	TokenNameIdentifier
=	TokenNameEQUAL
grammars	TokenNameIdentifier
[	TokenNameLBRACKET
g	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getRGLocators	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
redefinedGroups	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
XSGroupDecl	TokenNameIdentifier
derivedGrp	TokenNameIdentifier
=	TokenNameEQUAL
redefinedGroups	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
XSModelGroupImpl	TokenNameIdentifier
derivedMG	TokenNameIdentifier
=	TokenNameEQUAL
derivedGrp	TokenNameIdentifier
.	TokenNameDOT
fModelGroup	TokenNameIdentifier
;	TokenNameSEMICOLON
XSGroupDecl	TokenNameIdentifier
baseGrp	TokenNameIdentifier
=	TokenNameEQUAL
redefinedGroups	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
XSModelGroupImpl	TokenNameIdentifier
baseMG	TokenNameIdentifier
=	TokenNameEQUAL
baseGrp	TokenNameIdentifier
.	TokenNameDOT
fModelGroup	TokenNameIdentifier
;	TokenNameSEMICOLON
fakeDerived	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
=	TokenNameEQUAL
derivedMG	TokenNameIdentifier
;	TokenNameSEMICOLON
fakeBase	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
=	TokenNameEQUAL
baseMG	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
baseMG	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
derivedMG	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
rgLocators	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
"src-redefine.6.2.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
derivedGrp	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
"rcase-Recurse.2"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
derivedMG	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
fakeBase	TokenNameIdentifier
.	TokenNameDOT
emptiable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
rgLocators	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
"src-redefine.6.2.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
derivedGrp	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
"rcase-Recurse.2"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
particleValidRestriction	TokenNameIdentifier
(	TokenNameLPAREN
fakeDerived	TokenNameIdentifier
,	TokenNameCOMMA
SGHandler	TokenNameIdentifier
,	TokenNameCOMMA
fakeBase	TokenNameIdentifier
,	TokenNameCOMMA
SGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
XMLSchemaException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
key	TokenNameIdentifier
=	TokenNameEQUAL
e	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
rgLocators	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
key	TokenNameIdentifier
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
rgLocators	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
"src-redefine.6.2.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
derivedGrp	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
key	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
XSComplexTypeDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
types	TokenNameIdentifier
;	TokenNameSEMICOLON
SimpleLocator	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
ctLocators	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
further	TokenNameIdentifier
,	TokenNameCOMMA
fullChecked	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
keepType	TokenNameIdentifier
;	TokenNameSEMICOLON
SymbolHash	TokenNameIdentifier
elemTable	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SymbolHash	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
grammars	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
j	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
keepType	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fullChecked	TokenNameIdentifier
=	TokenNameEQUAL
grammars	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fFullChecked	TokenNameIdentifier
;	TokenNameSEMICOLON
types	TokenNameIdentifier
=	TokenNameEQUAL
grammars	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getUncheckedComplexTypeDecls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ctLocators	TokenNameIdentifier
=	TokenNameEQUAL
grammars	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getUncheckedCTLocators	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
types	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
fullChecked	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fParticle	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
elemTable	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
checkElementDeclsConsistent	TokenNameIdentifier
(	TokenNameLPAREN
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fParticle	TokenNameIdentifier
,	TokenNameCOMMA
elemTable	TokenNameIdentifier
,	TokenNameCOMMA
SGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
XMLSchemaException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
ctLocators	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fBaseType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fBaseType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SchemaGrammar	TokenNameIdentifier
.	TokenNameDOT
fAnyType	TokenNameIdentifier
&&	TokenNameAND_AND
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fDerivedBy	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
DERIVATION_RESTRICTION	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fBaseType	TokenNameIdentifier
instanceof	TokenNameinstanceof
XSComplexTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
derivedParticle	TokenNameIdentifier
=	TokenNameEQUAL
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fParticle	TokenNameIdentifier
;	TokenNameSEMICOLON
XSParticleDecl	TokenNameIdentifier
baseParticle	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
(	TokenNameLPAREN
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fBaseType	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
fParticle	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
derivedParticle	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
baseParticle	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
!	TokenNameNOT
baseParticle	TokenNameIdentifier
.	TokenNameDOT
emptiable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
ctLocators	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
"derivation-ok-restriction.5.3.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fBaseType	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
baseParticle	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
particleValidRestriction	TokenNameIdentifier
(	TokenNameLPAREN
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fParticle	TokenNameIdentifier
,	TokenNameCOMMA
SGHandler	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
(	TokenNameLPAREN
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fBaseType	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
fParticle	TokenNameIdentifier
,	TokenNameCOMMA
SGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
XMLSchemaException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
ctLocators	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
ctLocators	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
"derivation-ok-restriction.5.4.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
ctLocators	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
"derivation-ok-restriction.5.4.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
XSCMValidator	TokenNameIdentifier
cm	TokenNameIdentifier
=	TokenNameEQUAL
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getContentModel	TokenNameIdentifier
(	TokenNameLPAREN
cmBuilder	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
further	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cm	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
further	TokenNameIdentifier
=	TokenNameEQUAL
cm	TokenNameIdentifier
.	TokenNameDOT
checkUniqueParticleAttribution	TokenNameIdentifier
(	TokenNameLPAREN
SGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
XMLSchemaException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportSchemaError	TokenNameIdentifier
(	TokenNameLPAREN
errorReporter	TokenNameIdentifier
,	TokenNameCOMMA
ctLocators	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
getArgs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
fullChecked	TokenNameIdentifier
&&	TokenNameAND_AND
further	TokenNameIdentifier
)	TokenNameRPAREN
types	TokenNameIdentifier
[	TokenNameLBRACKET
keepType	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
types	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
fullChecked	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
grammars	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
setUncheckedTypeNum	TokenNameIdentifier
(	TokenNameLPAREN
keepType	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
grammars	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fFullChecked	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
checkElementDeclsConsistent	TokenNameIdentifier
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
type	TokenNameIdentifier
,	TokenNameCOMMA
XSParticleDecl	TokenNameIdentifier
particle	TokenNameIdentifier
,	TokenNameCOMMA
SymbolHash	TokenNameIdentifier
elemDeclHash	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
sgHandler	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
pType	TokenNameIdentifier
=	TokenNameEQUAL
particle	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSElementDecl	TokenNameIdentifier
elem	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
(	TokenNameLPAREN
particle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
findElemInTable	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
,	TokenNameCOMMA
elem	TokenNameIdentifier
,	TokenNameCOMMA
elemDeclHash	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
elem	TokenNameIdentifier
.	TokenNameDOT
fScope	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
SCOPE_GLOBAL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSElementDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
subGroup	TokenNameIdentifier
=	TokenNameEQUAL
sgHandler	TokenNameIdentifier
.	TokenNameDOT
getSubstitutionGroup	TokenNameIdentifier
(	TokenNameLPAREN
elem	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
subGroup	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
findElemInTable	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
,	TokenNameCOMMA
subGroup	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
elemDeclHash	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
XSModelGroupImpl	TokenNameIdentifier
group	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
)	TokenNameRPAREN
particle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
group	TokenNameIdentifier
.	TokenNameDOT
fParticleCount	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
checkElementDeclsConsistent	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
,	TokenNameCOMMA
group	TokenNameIdentifier
.	TokenNameDOT
fParticles	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
elemDeclHash	TokenNameIdentifier
,	TokenNameCOMMA
sgHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
findElemInTable	TokenNameIdentifier
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
type	TokenNameIdentifier
,	TokenNameCOMMA
XSElementDecl	TokenNameIdentifier
elem	TokenNameIdentifier
,	TokenNameCOMMA
SymbolHash	TokenNameIdentifier
elemDeclHash	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
String	TokenNameIdentifier
name	TokenNameIdentifier
=	TokenNameEQUAL
elem	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
+	TokenNamePLUS
","	TokenNameStringLiteral
+	TokenNamePLUS
elem	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
;	TokenNameSEMICOLON
XSElementDecl	TokenNameIdentifier
existingElem	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
existingElem	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
(	TokenNameLPAREN
elemDeclHash	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
elemDeclHash	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
elem	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
elem	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
existingElem	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
elem	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
existingElem	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"cos-element-consistent"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
type	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
elem	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
particleValidRestriction	TokenNameIdentifier
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
dParticle	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
XSParticleDecl	TokenNameIdentifier
bParticle	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
particleValidRestriction	TokenNameIdentifier
(	TokenNameLPAREN
dParticle	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bParticle	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
particleValidRestriction	TokenNameIdentifier
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
dParticle	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
XSParticleDecl	TokenNameIdentifier
bParticle	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
bSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
checkWCOccurrence	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
Vector	TokenNameIdentifier
dChildren	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
Vector	TokenNameIdentifier
bChildren	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
dMinEffectiveTotalRange	TokenNameIdentifier
=	TokenNameEQUAL
OCCURRENCE_UNKNOWN	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
dMaxEffectiveTotalRange	TokenNameIdentifier
=	TokenNameEQUAL
OCCURRENCE_UNKNOWN	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
bExpansionHappened	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dParticle	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
bParticle	TokenNameIdentifier
.	TokenNameDOT
emptiable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"cos-particle-restrict.a"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
dParticle	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
bParticle	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"cos-particle-restrict.b"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
short	TokenNameshort
dType	TokenNameIdentifier
=	TokenNameEQUAL
dParticle	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_MODELGROUP	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dType	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
)	TokenNameRPAREN
dParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
fCompositor	TokenNameIdentifier
;	TokenNameSEMICOLON
XSParticleDecl	TokenNameIdentifier
dtmp	TokenNameIdentifier
=	TokenNameEQUAL
getNonUnaryGroup	TokenNameIdentifier
(	TokenNameLPAREN
dParticle	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dtmp	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
dParticle	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dParticle	TokenNameIdentifier
=	TokenNameEQUAL
dtmp	TokenNameIdentifier
;	TokenNameSEMICOLON
dType	TokenNameIdentifier
=	TokenNameEQUAL
dParticle	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_MODELGROUP	TokenNameIdentifier
)	TokenNameRPAREN
dType	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
)	TokenNameRPAREN
dParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
fCompositor	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
dChildren	TokenNameIdentifier
=	TokenNameEQUAL
removePointlessChildren	TokenNameIdentifier
(	TokenNameLPAREN
dParticle	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
dMinOccurs	TokenNameIdentifier
=	TokenNameEQUAL
dParticle	TokenNameIdentifier
.	TokenNameDOT
fMinOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
dMaxOccurs	TokenNameIdentifier
=	TokenNameEQUAL
dParticle	TokenNameIdentifier
.	TokenNameDOT
fMaxOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dSGHandler	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
dType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSElementDecl	TokenNameIdentifier
dElement	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
dParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dElement	TokenNameIdentifier
.	TokenNameDOT
fScope	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
SCOPE_GLOBAL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSElementDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
subGroup	TokenNameIdentifier
=	TokenNameEQUAL
dSGHandler	TokenNameIdentifier
.	TokenNameDOT
getSubstitutionGroup	TokenNameIdentifier
(	TokenNameLPAREN
dElement	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
subGroup	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
dType	TokenNameIdentifier
=	TokenNameEQUAL
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
;	TokenNameSEMICOLON
dMinEffectiveTotalRange	TokenNameIdentifier
=	TokenNameEQUAL
dMinOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
dMaxEffectiveTotalRange	TokenNameIdentifier
=	TokenNameEQUAL
dMaxOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
dChildren	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
subGroup	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
subGroup	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
addElementToParticleVector	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
subGroup	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
addElementToParticleVector	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
dElement	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Collections	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
ELEMENT_PARTICLE_COMPARATOR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dSGHandler	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
short	TokenNameshort
bType	TokenNameIdentifier
=	TokenNameEQUAL
bParticle	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_MODELGROUP	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bType	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
)	TokenNameRPAREN
bParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
fCompositor	TokenNameIdentifier
;	TokenNameSEMICOLON
XSParticleDecl	TokenNameIdentifier
btmp	TokenNameIdentifier
=	TokenNameEQUAL
getNonUnaryGroup	TokenNameIdentifier
(	TokenNameLPAREN
bParticle	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
btmp	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
bParticle	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bParticle	TokenNameIdentifier
=	TokenNameEQUAL
btmp	TokenNameIdentifier
;	TokenNameSEMICOLON
bType	TokenNameIdentifier
=	TokenNameEQUAL
bParticle	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_MODELGROUP	TokenNameIdentifier
)	TokenNameRPAREN
bType	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
)	TokenNameRPAREN
bParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
fCompositor	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bChildren	TokenNameIdentifier
=	TokenNameEQUAL
removePointlessChildren	TokenNameIdentifier
(	TokenNameLPAREN
bParticle	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
bMinOccurs	TokenNameIdentifier
=	TokenNameEQUAL
bParticle	TokenNameIdentifier
.	TokenNameDOT
fMinOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
bMaxOccurs	TokenNameIdentifier
=	TokenNameEQUAL
bParticle	TokenNameIdentifier
.	TokenNameDOT
fMaxOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bSGHandler	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
bType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSElementDecl	TokenNameIdentifier
bElement	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
bParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bElement	TokenNameIdentifier
.	TokenNameDOT
fScope	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
SCOPE_GLOBAL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSElementDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bsubGroup	TokenNameIdentifier
=	TokenNameEQUAL
bSGHandler	TokenNameIdentifier
.	TokenNameDOT
getSubstitutionGroup	TokenNameIdentifier
(	TokenNameLPAREN
bElement	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bsubGroup	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
bType	TokenNameIdentifier
=	TokenNameEQUAL
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
;	TokenNameSEMICOLON
bChildren	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
bsubGroup	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
bsubGroup	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
addElementToParticleVector	TokenNameIdentifier
(	TokenNameLPAREN
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
bsubGroup	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
addElementToParticleVector	TokenNameIdentifier
(	TokenNameLPAREN
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
bElement	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Collections	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
ELEMENT_PARTICLE_COMPARATOR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bSGHandler	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
bExpansionHappened	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
dType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
bType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
checkNameAndTypeOK	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
dParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
,	TokenNameCOMMA
dMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
bParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
checkNSCompat	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
dParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
,	TokenNameCOMMA
dMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
bParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
checkWCOccurrence	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
dChildren	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dChildren	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
dParticle	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkRecurseLax	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_ALL	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
dChildren	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dChildren	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
dParticle	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkRecurse	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"Internal-Error"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"in particleValidRestriction"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
bType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
checkNSSubset	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
dParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
,	TokenNameCOMMA
dMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
bParticle	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_ALL	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"cos-particle-restrict.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"any:choice,sequence,all,elt"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"Internal-Error"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"in particleValidRestriction"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_ALL	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
bType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dMinEffectiveTotalRange	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
OCCURRENCE_UNKNOWN	TokenNameIdentifier
)	TokenNameRPAREN
dMinEffectiveTotalRange	TokenNameIdentifier
=	TokenNameEQUAL
dParticle	TokenNameIdentifier
.	TokenNameDOT
minEffectiveTotalRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dMaxEffectiveTotalRange	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
OCCURRENCE_UNKNOWN	TokenNameIdentifier
)	TokenNameRPAREN
dMaxEffectiveTotalRange	TokenNameIdentifier
=	TokenNameEQUAL
dParticle	TokenNameIdentifier
.	TokenNameDOT
maxEffectiveTotalRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkNSRecurseCheckCardinality	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
dMinEffectiveTotalRange	TokenNameIdentifier
,	TokenNameCOMMA
dMaxEffectiveTotalRange	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bParticle	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
checkWCOccurrence	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_ALL	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
checkRecurse	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
dMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"cos-particle-restrict.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"all:choice,sequence,elt"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"Internal-Error"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"in particleValidRestriction"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
bType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dMinEffectiveTotalRange	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
OCCURRENCE_UNKNOWN	TokenNameIdentifier
)	TokenNameRPAREN
dMinEffectiveTotalRange	TokenNameIdentifier
=	TokenNameEQUAL
dParticle	TokenNameIdentifier
.	TokenNameDOT
minEffectiveTotalRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dMaxEffectiveTotalRange	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
OCCURRENCE_UNKNOWN	TokenNameIdentifier
)	TokenNameRPAREN
dMaxEffectiveTotalRange	TokenNameIdentifier
=	TokenNameEQUAL
dParticle	TokenNameIdentifier
.	TokenNameDOT
maxEffectiveTotalRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkNSRecurseCheckCardinality	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
dMinEffectiveTotalRange	TokenNameIdentifier
,	TokenNameCOMMA
dMaxEffectiveTotalRange	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bParticle	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
checkWCOccurrence	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
checkRecurseLax	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
dMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_ALL	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"cos-particle-restrict.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"choice:all,sequence,elt"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"Internal-Error"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"in particleValidRestriction"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
bType	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dMinEffectiveTotalRange	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
OCCURRENCE_UNKNOWN	TokenNameIdentifier
)	TokenNameRPAREN
dMinEffectiveTotalRange	TokenNameIdentifier
=	TokenNameEQUAL
dParticle	TokenNameIdentifier
.	TokenNameDOT
minEffectiveTotalRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dMaxEffectiveTotalRange	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
OCCURRENCE_UNKNOWN	TokenNameIdentifier
)	TokenNameRPAREN
dMaxEffectiveTotalRange	TokenNameIdentifier
=	TokenNameEQUAL
dParticle	TokenNameIdentifier
.	TokenNameDOT
maxEffectiveTotalRange	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkNSRecurseCheckCardinality	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
dMinEffectiveTotalRange	TokenNameIdentifier
,	TokenNameCOMMA
dMaxEffectiveTotalRange	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bParticle	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
checkWCOccurrence	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_ALL	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
checkRecurseUnordered	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
dMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_SEQUENCE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
checkRecurse	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
dMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSModelGroupImpl	TokenNameIdentifier
.	TokenNameDOT
MODELGROUP_CHOICE	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
int	TokenNameint
min1	TokenNameIdentifier
=	TokenNameEQUAL
dMinOccurs	TokenNameIdentifier
*	TokenNameMULTIPLY
dChildren	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
max1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dMaxOccurs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
dMaxOccurs	TokenNameIdentifier
:	TokenNameCOLON
dMaxOccurs	TokenNameIdentifier
*	TokenNameMULTIPLY
dChildren	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkMapAndSum	TokenNameIdentifier
(	TokenNameLPAREN
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
min1	TokenNameIdentifier
,	TokenNameCOMMA
max1	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
bMinOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bMaxOccurs	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"cos-particle-restrict.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"seq:elt"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"Internal-Error"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
"in particleValidRestriction"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
bExpansionHappened	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
addElementToParticleVector	TokenNameIdentifier
(	TokenNameLPAREN
Vector	TokenNameIdentifier
v	TokenNameIdentifier
,	TokenNameCOMMA
XSElementDecl	TokenNameIdentifier
d	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
p	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XSParticleDecl	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
p	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
=	TokenNameEQUAL
d	TokenNameIdentifier
;	TokenNameSEMICOLON
p	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
=	TokenNameEQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
v	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
XSParticleDecl	TokenNameIdentifier
getNonUnaryGroup	TokenNameIdentifier
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
p	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
||	TokenNameOR_OR
p	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
p	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
fMinOccurs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
p	TokenNameIdentifier
.	TokenNameDOT
fMaxOccurs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
p	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
fParticleCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
getNonUnaryGroup	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
fParticles	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
p	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
Vector	TokenNameIdentifier
removePointlessChildren	TokenNameIdentifier
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
p	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
||	TokenNameOR_OR
p	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
Vector	TokenNameIdentifier
children	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
XSModelGroupImpl	TokenNameIdentifier
group	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
group	TokenNameIdentifier
.	TokenNameDOT
fParticleCount	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
gatherChildren	TokenNameIdentifier
(	TokenNameLPAREN
group	TokenNameIdentifier
.	TokenNameDOT
fCompositor	TokenNameIdentifier
,	TokenNameCOMMA
group	TokenNameIdentifier
.	TokenNameDOT
fParticles	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
children	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
children	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
gatherChildren	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
parentType	TokenNameIdentifier
,	TokenNameCOMMA
XSParticleDecl	TokenNameIdentifier
p	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
children	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
min	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
fMinOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
max	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
fMaxOccurs	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_MODELGROUP	TokenNameIdentifier
)	TokenNameRPAREN
type	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
fCompositor	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_ELEMENT	TokenNameIdentifier
||	TokenNameOR_OR
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSParticleDecl	TokenNameIdentifier
.	TokenNameDOT
PARTICLE_WILDCARD	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
children	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
min	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
max	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
children	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
parentType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSModelGroupImpl	TokenNameIdentifier
group	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSModelGroupImpl	TokenNameIdentifier
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
fValue	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
group	TokenNameIdentifier
.	TokenNameDOT
fParticleCount	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
gatherChildren	TokenNameIdentifier
(	TokenNameLPAREN
type	TokenNameIdentifier
,	TokenNameCOMMA
group	TokenNameIdentifier
.	TokenNameDOT
fParticles	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
children	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
p	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
children	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkNameAndTypeOK	TokenNameIdentifier
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
dElement	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
dMin	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
dMax	TokenNameIdentifier
,	TokenNameCOMMA
XSElementDecl	TokenNameIdentifier
bElement	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
bMin	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
bMax	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dElement	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
bElement	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
||	TokenNameOR_OR
dElement	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
bElement	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NameAndTypeOK.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
dElement	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
dElement	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
,	TokenNameCOMMA
bElement	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
bElement	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
bElement	TokenNameIdentifier
.	TokenNameDOT
getNillable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
dElement	TokenNameIdentifier
.	TokenNameDOT
getNillable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NameAndTypeOK.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
dElement	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
checkOccurrenceRange	TokenNameIdentifier
(	TokenNameLPAREN
dMin	TokenNameIdentifier
,	TokenNameCOMMA
dMax	TokenNameIdentifier
,	TokenNameCOMMA
bMin	TokenNameIdentifier
,	TokenNameCOMMA
bMax	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NameAndTypeOK.3"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
dElement	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
dMin	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
dMax	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
dMax	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
bMin	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
bMax	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
bMax	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
bElement	TokenNameIdentifier
.	TokenNameDOT
getConstraintType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
VC_FIXED	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dElement	TokenNameIdentifier
.	TokenNameDOT
getConstraintType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
VC_FIXED	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NameAndTypeOK.4.a"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
dElement	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
bElement	TokenNameIdentifier
.	TokenNameDOT
fDefault	TokenNameIdentifier
.	TokenNameDOT
stringValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
isSimple	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dElement	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
.	TokenNameDOT
getTypeCategory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
XSTypeDefinition	TokenNameIdentifier
.	TokenNameDOT
SIMPLE_TYPE	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
XSComplexTypeDecl	TokenNameIdentifier
)	TokenNameRPAREN
dElement	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
fContentType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSComplexTypeDecl	TokenNameIdentifier
.	TokenNameDOT
CONTENTTYPE_SIMPLE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
isSimple	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isSimple	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
bElement	TokenNameIdentifier
.	TokenNameDOT
fDefault	TokenNameIdentifier
.	TokenNameDOT
normalizedValue	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
dElement	TokenNameIdentifier
.	TokenNameDOT
fDefault	TokenNameIdentifier
.	TokenNameDOT
normalizedValue	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
isSimple	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
bElement	TokenNameIdentifier
.	TokenNameDOT
fDefault	TokenNameIdentifier
.	TokenNameDOT
actualValue	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
dElement	TokenNameIdentifier
.	TokenNameDOT
fDefault	TokenNameIdentifier
.	TokenNameDOT
actualValue	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NameAndTypeOK.4.b"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
dElement	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
dElement	TokenNameIdentifier
.	TokenNameDOT
fDefault	TokenNameIdentifier
.	TokenNameDOT
stringValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
bElement	TokenNameIdentifier
.	TokenNameDOT
fDefault	TokenNameIdentifier
.	TokenNameDOT
stringValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
checkIDConstraintRestriction	TokenNameIdentifier
(	TokenNameLPAREN
dElement	TokenNameIdentifier
,	TokenNameCOMMA
bElement	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
blockSet1	TokenNameIdentifier
=	TokenNameEQUAL
dElement	TokenNameIdentifier
.	TokenNameDOT
fBlock	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
blockSet2	TokenNameIdentifier
=	TokenNameEQUAL
bElement	TokenNameIdentifier
.	TokenNameDOT
fBlock	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
blockSet1	TokenNameIdentifier
&	TokenNameAND
blockSet2	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
blockSet2	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
blockSet1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
DERIVATION_NONE	TokenNameIdentifier
&&	TokenNameAND_AND
blockSet2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
XSConstants	TokenNameIdentifier
.	TokenNameDOT
DERIVATION_NONE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NameAndTypeOK.6"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
dElement	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
checkTypeDerivationOk	TokenNameIdentifier
(	TokenNameLPAREN
dElement	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
,	TokenNameCOMMA
bElement	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
(	TokenNameLPAREN
XSConstants	TokenNameIdentifier
.	TokenNameDOT
DERIVATION_EXTENSION	TokenNameIdentifier
|	TokenNameOR
XSConstants	TokenNameIdentifier
.	TokenNameDOT
DERIVATION_LIST	TokenNameIdentifier
|	TokenNameOR
XSConstants	TokenNameIdentifier
.	TokenNameDOT
DERIVATION_UNION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NameAndTypeOK.7"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
dElement	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
dElement	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
bElement	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkIDConstraintRestriction	TokenNameIdentifier
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
derivedElemDecl	TokenNameIdentifier
,	TokenNameCOMMA
XSElementDecl	TokenNameIdentifier
baseElemDecl	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
checkOccurrenceRange	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
min1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
min1	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
min2	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
max2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
max1	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
&&	TokenNameAND_AND
max1	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
max2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkNSCompat	TokenNameIdentifier
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
elem	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max1	TokenNameIdentifier
,	TokenNameCOMMA
XSWildcardDecl	TokenNameIdentifier
wildcard	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max2	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
checkWCOccurrence	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
checkWCOccurrence	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
checkOccurrenceRange	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
,	TokenNameCOMMA
max1	TokenNameIdentifier
,	TokenNameCOMMA
min2	TokenNameIdentifier
,	TokenNameCOMMA
max2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NSCompat.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
elem	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min2	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max2	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
wildcard	TokenNameIdentifier
.	TokenNameDOT
allowNamespace	TokenNameIdentifier
(	TokenNameLPAREN
elem	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NSCompat.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
elem	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
,	TokenNameCOMMA
elem	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkNSSubset	TokenNameIdentifier
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
dWildcard	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max1	TokenNameIdentifier
,	TokenNameCOMMA
XSWildcardDecl	TokenNameIdentifier
bWildcard	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max2	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
checkOccurrenceRange	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
,	TokenNameCOMMA
max1	TokenNameIdentifier
,	TokenNameCOMMA
min2	TokenNameIdentifier
,	TokenNameCOMMA
max2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NSSubset.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min2	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max2	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
dWildcard	TokenNameIdentifier
.	TokenNameDOT
isSubsetOf	TokenNameIdentifier
(	TokenNameLPAREN
bWildcard	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NSSubset.1"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
dWildcard	TokenNameIdentifier
.	TokenNameDOT
weakerProcessContents	TokenNameIdentifier
(	TokenNameLPAREN
bWildcard	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NSSubset.3"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
dWildcard	TokenNameIdentifier
.	TokenNameDOT
getProcessContentsAsString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
bWildcard	TokenNameIdentifier
.	TokenNameDOT
getProcessContentsAsString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkNSRecurseCheckCardinality	TokenNameIdentifier
(	TokenNameLPAREN
Vector	TokenNameIdentifier
children	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max1	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
XSParticleDecl	TokenNameIdentifier
wildcard	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max2	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
checkWCOccurrence	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
checkWCOccurrence	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
checkOccurrenceRange	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
,	TokenNameCOMMA
max1	TokenNameIdentifier
,	TokenNameCOMMA
min2	TokenNameIdentifier
,	TokenNameCOMMA
max2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NSRecurseCheckCardinality.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min2	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max2	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
children	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
count	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
children	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
particleValidRestriction	TokenNameIdentifier
(	TokenNameLPAREN
particle1	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
wildcard	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
XMLSchemaException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-NSRecurseCheckCardinality.1"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkRecurse	TokenNameIdentifier
(	TokenNameLPAREN
Vector	TokenNameIdentifier
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max1	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max2	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
checkOccurrenceRange	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
,	TokenNameCOMMA
max1	TokenNameIdentifier
,	TokenNameCOMMA
min2	TokenNameIdentifier
,	TokenNameCOMMA
max2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-Recurse.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min2	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max2	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
count1	TokenNameIdentifier
=	TokenNameEQUAL
dChildren	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
count2	TokenNameIdentifier
=	TokenNameEQUAL
bChildren	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
current	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
label	TokenNameIdentifier
:	TokenNameCOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
count1	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
dChildren	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
current	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
count2	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
bChildren	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
current	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
particleValidRestriction	TokenNameIdentifier
(	TokenNameLPAREN
particle1	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
particle2	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
label	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
XMLSchemaException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
particle2	TokenNameIdentifier
.	TokenNameDOT
emptiable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-Recurse.2"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-Recurse.2"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
current	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
count2	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
bChildren	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
particle2	TokenNameIdentifier
.	TokenNameDOT
emptiable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-Recurse.2"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkRecurseUnordered	TokenNameIdentifier
(	TokenNameLPAREN
Vector	TokenNameIdentifier
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max1	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max2	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
checkOccurrenceRange	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
,	TokenNameCOMMA
max1	TokenNameIdentifier
,	TokenNameCOMMA
min2	TokenNameIdentifier
,	TokenNameCOMMA
max2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-RecurseUnordered.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min2	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max2	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
count1	TokenNameIdentifier
=	TokenNameEQUAL
dChildren	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
count2	TokenNameIdentifier
=	TokenNameEQUAL
bChildren	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
foundIt	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
count2	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
label	TokenNameIdentifier
:	TokenNameCOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
count1	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
dChildren	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
count2	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
bChildren	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
particleValidRestriction	TokenNameIdentifier
(	TokenNameLPAREN
particle1	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
particle2	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
foundIt	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-RecurseUnordered.2"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
foundIt	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
continue	TokenNamecontinue
label	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
XMLSchemaException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-RecurseUnordered.2"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
count2	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
bChildren	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
foundIt	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
&&	TokenNameAND_AND
!	TokenNameNOT
particle2	TokenNameIdentifier
.	TokenNameDOT
emptiable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-RecurseUnordered.2"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkRecurseLax	TokenNameIdentifier
(	TokenNameLPAREN
Vector	TokenNameIdentifier
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max1	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max2	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
checkOccurrenceRange	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
,	TokenNameCOMMA
max1	TokenNameIdentifier
,	TokenNameCOMMA
min2	TokenNameIdentifier
,	TokenNameCOMMA
max2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-RecurseLax.1"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min2	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max2	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
count1	TokenNameIdentifier
=	TokenNameEQUAL
dChildren	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
count2	TokenNameIdentifier
=	TokenNameEQUAL
bChildren	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
current	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
label	TokenNameIdentifier
:	TokenNameCOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
count1	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
dChildren	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
current	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
count2	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
bChildren	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
current	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
particleValidRestriction	TokenNameIdentifier
(	TokenNameLPAREN
particle1	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
particle2	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
current	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
continue	TokenNamecontinue
label	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
XMLSchemaException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-RecurseLax.2"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkMapAndSum	TokenNameIdentifier
(	TokenNameLPAREN
Vector	TokenNameIdentifier
dChildren	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max1	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
bChildren	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
min2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
max2	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLSchemaException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
checkOccurrenceRange	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
,	TokenNameCOMMA
max1	TokenNameIdentifier
,	TokenNameCOMMA
min2	TokenNameIdentifier
,	TokenNameCOMMA
max2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-MapAndSum.2"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
min2	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
max2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SchemaSymbols	TokenNameIdentifier
.	TokenNameDOT
OCCURRENCE_UNBOUNDED	TokenNameIdentifier
?	TokenNameQUESTION
"unbounded"	TokenNameStringLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
max2	TokenNameIdentifier
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
count1	TokenNameIdentifier
=	TokenNameEQUAL
dChildren	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
count2	TokenNameIdentifier
=	TokenNameEQUAL
bChildren	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
label	TokenNameIdentifier
:	TokenNameCOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
count1	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
dChildren	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
count2	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
XSParticleDecl	TokenNameIdentifier
particle2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
XSParticleDecl	TokenNameIdentifier
)	TokenNameRPAREN
bChildren	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
particleValidRestriction	TokenNameIdentifier
(	TokenNameLPAREN
particle1	TokenNameIdentifier
,	TokenNameCOMMA
dSGHandler	TokenNameIdentifier
,	TokenNameCOMMA
particle2	TokenNameIdentifier
,	TokenNameCOMMA
bSGHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
label	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
XMLSchemaException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLSchemaException	TokenNameIdentifier
(	TokenNameLPAREN
"rcase-MapAndSum.1"	TokenNameStringLiteral
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
overlapUPA	TokenNameIdentifier
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
element1	TokenNameIdentifier
,	TokenNameCOMMA
XSElementDecl	TokenNameIdentifier
element2	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
sgHandler	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
element1	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
element2	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
&&	TokenNameAND_AND
element1	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
element2	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
XSElementDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
subGroup	TokenNameIdentifier
=	TokenNameEQUAL
sgHandler	TokenNameIdentifier
.	TokenNameDOT
getSubstitutionGroup	TokenNameIdentifier
(	TokenNameLPAREN
element1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
subGroup	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
subGroup	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
element2	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
&&	TokenNameAND_AND
subGroup	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
element2	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
subGroup	TokenNameIdentifier
=	TokenNameEQUAL
sgHandler	TokenNameIdentifier
.	TokenNameDOT
getSubstitutionGroup	TokenNameIdentifier
(	TokenNameLPAREN
element2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
subGroup	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
subGroup	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
element1	TokenNameIdentifier
.	TokenNameDOT
fName	TokenNameIdentifier
&&	TokenNameAND_AND
subGroup	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
element1	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
overlapUPA	TokenNameIdentifier
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
element	TokenNameIdentifier
,	TokenNameCOMMA
XSWildcardDecl	TokenNameIdentifier
wildcard	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
sgHandler	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
wildcard	TokenNameIdentifier
.	TokenNameDOT
allowNamespace	TokenNameIdentifier
(	TokenNameLPAREN
element	TokenNameIdentifier
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
XSElementDecl	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
subGroup	TokenNameIdentifier
=	TokenNameEQUAL
sgHandler	TokenNameIdentifier
.	TokenNameDOT
getSubstitutionGroup	TokenNameIdentifier
(	TokenNameLPAREN
element	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
subGroup	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
wildcard	TokenNameIdentifier
.	TokenNameDOT
allowNamespace	TokenNameIdentifier
(	TokenNameLPAREN
subGroup	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
fTargetNamespace	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
overlapUPA	TokenNameIdentifier
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
wildcard1	TokenNameIdentifier
,	TokenNameCOMMA
XSWildcardDecl	TokenNameIdentifier
wildcard2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
XSWildcardDecl	TokenNameIdentifier
intersect	TokenNameIdentifier
=	TokenNameEQUAL
wildcard1	TokenNameIdentifier
.	TokenNameDOT
performIntersectionWith	TokenNameIdentifier
(	TokenNameLPAREN
wildcard2	TokenNameIdentifier
,	TokenNameCOMMA
wildcard1	TokenNameIdentifier
.	TokenNameDOT
fProcessContents	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
intersect	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
intersect	TokenNameIdentifier
.	TokenNameDOT
fType	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
XSWildcardDecl	TokenNameIdentifier
.	TokenNameDOT
NSCONSTRAINT_LIST	TokenNameIdentifier
||	TokenNameOR_OR
intersect	TokenNameIdentifier
.	TokenNameDOT
fNamespaceList	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
overlapUPA	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
decl1	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
decl2	TokenNameIdentifier
,	TokenNameCOMMA
SubstitutionGroupHandler	TokenNameIdentifier
sgHandler	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
decl1	TokenNameIdentifier
instanceof	TokenNameinstanceof
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
decl2	TokenNameIdentifier
instanceof	TokenNameinstanceof
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
overlapUPA	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
decl1	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
decl2	TokenNameIdentifier
,	TokenNameCOMMA
sgHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
overlapUPA	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
decl1	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
decl2	TokenNameIdentifier
,	TokenNameCOMMA
sgHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
decl2	TokenNameIdentifier
instanceof	TokenNameinstanceof
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
overlapUPA	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSElementDecl	TokenNameIdentifier
)	TokenNameRPAREN
decl2	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
decl1	TokenNameIdentifier
,	TokenNameCOMMA
sgHandler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
overlapUPA	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
decl1	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
XSWildcardDecl	TokenNameIdentifier
)	TokenNameRPAREN
decl2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
