package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xerces	TokenNameIdentifier
.	TokenNameDOT
impl	TokenNameIdentifier
.	TokenNameDOT
dtd	TokenNameIdentifier
.	TokenNameDOT
models	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
CMStateSet	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
CMStateSet	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
bitCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fBitCount	TokenNameIdentifier
=	TokenNameEQUAL
bitCount	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"ImplementationMessages.VAL_CMSI"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
>	TokenNameGREATER
64	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fByteCount	TokenNameIdentifier
=	TokenNameEQUAL
fBitCount	TokenNameIdentifier
/	TokenNameDIVIDE
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
%	TokenNameREMAINDER
8	TokenNameIntegerLiteral
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
fByteCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
fByteArray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
fByteCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
zeroBits	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuffer	TokenNameIdentifier
strRet	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
strRet	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'{'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
<	TokenNameLESS
fBitCount	TokenNameIdentifier
;	TokenNameSEMICOLON
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
getBit	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
strRet	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
' '	TokenNameCharacterLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
strRet	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" }"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
RuntimeException	TokenNameIdentifier
exToCatch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
return	TokenNamereturn
strRet	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
intersection	TokenNameIdentifier
(	TokenNameLPAREN
CMStateSet	TokenNameIdentifier
setToAnd	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
<	TokenNameLESS
65	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fBits1	TokenNameIdentifier
&=	TokenNameAND_EQUAL
setToAnd	TokenNameIdentifier
.	TokenNameDOT
fBits1	TokenNameIdentifier
;	TokenNameSEMICOLON
fBits2	TokenNameIdentifier
&=	TokenNameAND_EQUAL
setToAnd	TokenNameIdentifier
.	TokenNameDOT
fBits2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
fByteCount	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
setToAnd	TokenNameIdentifier
.	TokenNameDOT
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
boolean	TokenNameboolean
getBit	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
bitToGet	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bitToGet	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
fBitCount	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"ImplementationMessages.VAL_CMSI"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
<	TokenNameLESS
65	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
mask	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
0x1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
(	TokenNameLPAREN
bitToGet	TokenNameIdentifier
%	TokenNameREMAINDER
32	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bitToGet	TokenNameIdentifier
<	TokenNameLESS
32	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
fBits1	TokenNameIdentifier
&	TokenNameAND
mask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
(	TokenNameLPAREN
fBits2	TokenNameIdentifier
&	TokenNameAND
mask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
byte	TokenNamebyte
mask	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
(	TokenNameLPAREN
bitToGet	TokenNameIdentifier
%	TokenNameREMAINDER
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
ofs	TokenNameIdentifier
=	TokenNameEQUAL
bitToGet	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
ofs	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
mask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
boolean	TokenNameboolean
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
<	TokenNameLESS
65	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
fBits1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
fBits2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
fByteCount	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
boolean	TokenNameboolean
isSameSet	TokenNameIdentifier
(	TokenNameLPAREN
CMStateSet	TokenNameIdentifier
setToCompare	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
setToCompare	TokenNameIdentifier
.	TokenNameDOT
fBitCount	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
<	TokenNameLESS
65	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
fBits1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
setToCompare	TokenNameIdentifier
.	TokenNameDOT
fBits1	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
fBits2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
setToCompare	TokenNameIdentifier
.	TokenNameDOT
fBits2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
fByteCount	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
setToCompare	TokenNameIdentifier
.	TokenNameDOT
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
union	TokenNameIdentifier
(	TokenNameLPAREN
CMStateSet	TokenNameIdentifier
setToOr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
<	TokenNameLESS
65	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fBits1	TokenNameIdentifier
|=	TokenNameOR_EQUAL
setToOr	TokenNameIdentifier
.	TokenNameDOT
fBits1	TokenNameIdentifier
;	TokenNameSEMICOLON
fBits2	TokenNameIdentifier
|=	TokenNameOR_EQUAL
setToOr	TokenNameIdentifier
.	TokenNameDOT
fBits2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
fByteCount	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
setToOr	TokenNameIdentifier
.	TokenNameDOT
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
setBit	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
bitToSet	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bitToSet	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
fBitCount	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"ImplementationMessages.VAL_CMSI"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
<	TokenNameLESS
65	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
mask	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
0x1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
(	TokenNameLPAREN
bitToSet	TokenNameIdentifier
%	TokenNameREMAINDER
32	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bitToSet	TokenNameIdentifier
<	TokenNameLESS
32	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fBits1	TokenNameIdentifier
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
mask	TokenNameIdentifier
;	TokenNameSEMICOLON
fBits1	TokenNameIdentifier
|=	TokenNameOR_EQUAL
mask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fBits2	TokenNameIdentifier
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
mask	TokenNameIdentifier
;	TokenNameSEMICOLON
fBits2	TokenNameIdentifier
|=	TokenNameOR_EQUAL
mask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
byte	TokenNamebyte
mask	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
(	TokenNameLPAREN
bitToSet	TokenNameIdentifier
%	TokenNameREMAINDER
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
ofs	TokenNameIdentifier
=	TokenNameEQUAL
bitToSet	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
ofs	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
mask	TokenNameIdentifier
;	TokenNameSEMICOLON
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
ofs	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
mask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
setTo	TokenNameIdentifier
(	TokenNameLPAREN
CMStateSet	TokenNameIdentifier
srcSet	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
srcSet	TokenNameIdentifier
.	TokenNameDOT
fBitCount	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"ImplementationMessages.VAL_CMSI"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
<	TokenNameLESS
65	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fBits1	TokenNameIdentifier
=	TokenNameEQUAL
srcSet	TokenNameIdentifier
.	TokenNameDOT
fBits1	TokenNameIdentifier
;	TokenNameSEMICOLON
fBits2	TokenNameIdentifier
=	TokenNameEQUAL
srcSet	TokenNameIdentifier
.	TokenNameDOT
fBits2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
fByteCount	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
srcSet	TokenNameIdentifier
.	TokenNameDOT
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
zeroBits	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
<	TokenNameLESS
65	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
fBits1	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fBits2	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
fByteCount	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
fBitCount	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
fByteCount	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
fBits1	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
fBits2	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fByteArray	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
o	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
o	TokenNameIdentifier
instanceof	TokenNameinstanceof
CMStateSet	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
return	TokenNamereturn
isSameSet	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
CMStateSet	TokenNameIdentifier
)	TokenNameRPAREN
o	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fBitCount	TokenNameIdentifier
<	TokenNameLESS
65	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fBits1	TokenNameIdentifier
+	TokenNamePLUS
fBits2	TokenNameIdentifier
*	TokenNameMULTIPLY
31	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
fByteCount	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
index	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
hash	TokenNameIdentifier
=	TokenNameEQUAL
fByteArray	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
+	TokenNamePLUS
hash	TokenNameIdentifier
*	TokenNameMULTIPLY
31	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
hash	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
