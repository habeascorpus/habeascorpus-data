package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
anim	TokenNameIdentifier
.	TokenNameDOT
timing	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
anim	TokenNameIdentifier
.	TokenNameDOT
AnimationException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
i18n	TokenNameIdentifier
.	TokenNameDOT
LocalizableSupport	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
parser	TokenNameIdentifier
.	TokenNameDOT
ClockHandler	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
parser	TokenNameIdentifier
.	TokenNameDOT
ClockParser	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
parser	TokenNameIdentifier
.	TokenNameDOT
ParseException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
SMILConstants	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
Element	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
events	TokenNameIdentifier
.	TokenNameDOT
Event	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
events	TokenNameIdentifier
.	TokenNameDOT
EventTarget	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
class	TokenNameclass
TimedElement	TokenNameIdentifier
implements	TokenNameimplements
SMILConstants	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
FILL_REMOVE	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
FILL_FREEZE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
RESTART_ALWAYS	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
RESTART_WHEN_NOT_ACTIVE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
RESTART_NEVER	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
float	TokenNamefloat
INDEFINITE	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
POSITIVE_INFINITY	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
float	TokenNamefloat
UNRESOLVED	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
NaN	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
TimedDocumentRoot	TokenNameIdentifier
root	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
TimeContainer	TokenNameIdentifier
parent	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
TimingSpecifier	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
beginTimes	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
TimingSpecifier	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
endTimes	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
simpleDur	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
durMedia	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
repeatCount	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
repeatDur	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
currentRepeatIteration	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
lastRepeatTime	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
fillMode	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
restartMode	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
min	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
minMedia	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
max	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
maxMedia	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
isActive	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
isFrozen	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
lastSampleTime	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
repeatDuration	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
List	TokenNameIdentifier
beginInstanceTimes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
List	TokenNameIdentifier
endInstanceTimes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
Interval	TokenNameIdentifier
currentInterval	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
lastIntervalEnd	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
Interval	TokenNameIdentifier
previousInterval	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
LinkedList	TokenNameIdentifier
beginDependents	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
LinkedList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
LinkedList	TokenNameIdentifier
endDependents	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
LinkedList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
shouldUpdateCurrentInterval	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
hasParsed	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
Map	TokenNameIdentifier
handledEvents	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
isSampling	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
hasPropagated	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
TimedElement	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
beginTimes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
TimingSpecifier	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
endTimes	TokenNameIdentifier
=	TokenNameEQUAL
beginTimes	TokenNameIdentifier
;	TokenNameSEMICOLON
simpleDur	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
repeatCount	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
repeatDur	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
lastRepeatTime	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
max	TokenNameIdentifier
=	TokenNameEQUAL
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
lastSampleTime	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
lastIntervalEnd	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
NEGATIVE_INFINITY	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
TimedDocumentRoot	TokenNameIdentifier
getRoot	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
root	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
float	TokenNamefloat
getActiveTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
lastSampleTime	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
float	TokenNamefloat
getSimpleTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
lastSampleTime	TokenNameIdentifier
-	TokenNameMINUS
lastRepeatTime	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
addInstanceTime	TokenNameIdentifier
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
time	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
hasPropagated	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
List	TokenNameIdentifier
instanceTimes	TokenNameIdentifier
=	TokenNameEQUAL
isBegin	TokenNameIdentifier
?	TokenNameQUESTION
beginInstanceTimes	TokenNameIdentifier
:	TokenNameCOLON
endInstanceTimes	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
Collections	TokenNameIdentifier
.	TokenNameDOT
binarySearch	TokenNameIdentifier
(	TokenNameLPAREN
instanceTimes	TokenNameIdentifier
,	TokenNameCOMMA
time	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
index	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
instanceTimes	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
,	TokenNameCOMMA
time	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
shouldUpdateCurrentInterval	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
float	TokenNamefloat
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
root	TokenNameIdentifier
.	TokenNameDOT
isSampling	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
isSampling	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
sampleAt	TokenNameIdentifier
(	TokenNameLPAREN
root	TokenNameIdentifier
.	TokenNameDOT
getCurrentTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
root	TokenNameIdentifier
.	TokenNameDOT
isHyperlinking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
POSITIVE_INFINITY	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
hasPropagated	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
root	TokenNameIdentifier
.	TokenNameDOT
currentIntervalWillUpdate	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
removeInstanceTime	TokenNameIdentifier
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
time	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
hasPropagated	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
List	TokenNameIdentifier
instanceTimes	TokenNameIdentifier
=	TokenNameEQUAL
isBegin	TokenNameIdentifier
?	TokenNameQUESTION
beginInstanceTimes	TokenNameIdentifier
:	TokenNameCOLON
endInstanceTimes	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
Collections	TokenNameIdentifier
.	TokenNameDOT
binarySearch	TokenNameIdentifier
(	TokenNameLPAREN
instanceTimes	TokenNameIdentifier
,	TokenNameCOMMA
time	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
InstanceTime	TokenNameIdentifier
it	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
instanceTimes	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
it	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
time	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
instanceTimes	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
it	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
time	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
instanceTimes	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
InstanceTime	TokenNameIdentifier
it	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
instanceTimes	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
it	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
time	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
instanceTimes	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
it	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
time	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
shouldUpdateCurrentInterval	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
float	TokenNamefloat
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
root	TokenNameIdentifier
.	TokenNameDOT
isSampling	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
isSampling	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
sampleAt	TokenNameIdentifier
(	TokenNameLPAREN
root	TokenNameIdentifier
.	TokenNameDOT
getCurrentTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
root	TokenNameIdentifier
.	TokenNameDOT
isHyperlinking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
POSITIVE_INFINITY	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
hasPropagated	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
root	TokenNameIdentifier
.	TokenNameDOT
currentIntervalWillUpdate	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
instanceTimeChanged	TokenNameIdentifier
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
time	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
hasPropagated	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
shouldUpdateCurrentInterval	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
float	TokenNamefloat
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
root	TokenNameIdentifier
.	TokenNameDOT
isSampling	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
isSampling	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
sampleAt	TokenNameIdentifier
(	TokenNameLPAREN
root	TokenNameIdentifier
.	TokenNameDOT
getCurrentTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
root	TokenNameIdentifier
.	TokenNameDOT
isHyperlinking	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ret	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
POSITIVE_INFINITY	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
hasPropagated	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
addDependent	TokenNameIdentifier
(	TokenNameLPAREN
TimingSpecifier	TokenNameIdentifier
dependent	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
forBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
forBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
beginDependents	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
dependent	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
endDependents	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
dependent	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
removeDependent	TokenNameIdentifier
(	TokenNameLPAREN
TimingSpecifier	TokenNameIdentifier
dependent	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
forBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
forBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
beginDependents	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
dependent	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
endDependents	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
dependent	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
float	TokenNamefloat
getSimpleDur	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
durMedia	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getImplicitDur	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
simpleDur	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
repeatCount	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
repeatDur	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
endTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
getImplicitDur	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
simpleDur	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
Float	TokenNameIdentifier
.	TokenNameDOT
isNaN	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
float	TokenNamefloat
getActiveDur	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
B	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
d	TokenNameIdentifier
=	TokenNameEQUAL
getSimpleDur	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
PAD	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
d	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
PAD	TokenNameIdentifier
=	TokenNameEQUAL
minusTime	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
,	TokenNameCOMMA
B	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
repeatDuration	TokenNameIdentifier
=	TokenNameEQUAL
minTime	TokenNameIdentifier
(	TokenNameLPAREN
max	TokenNameIdentifier
,	TokenNameCOMMA
maxTime	TokenNameIdentifier
(	TokenNameLPAREN
min	TokenNameIdentifier
,	TokenNameCOMMA
PAD	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
repeatDuration	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
float	TokenNamefloat
IAD	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
d	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
IAD	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
repeatDur	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
repeatCount	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
IAD	TokenNameIdentifier
=	TokenNameEQUAL
d	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
float	TokenNamefloat
p1	TokenNameIdentifier
=	TokenNameEQUAL
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
repeatCount	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
INDEFINITE	TokenNameIdentifier
:	TokenNameCOLON
multiplyTime	TokenNameIdentifier
(	TokenNameLPAREN
d	TokenNameIdentifier
,	TokenNameCOMMA
repeatCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
p2	TokenNameIdentifier
=	TokenNameEQUAL
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
repeatDur	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
INDEFINITE	TokenNameIdentifier
:	TokenNameCOLON
repeatDur	TokenNameIdentifier
;	TokenNameSEMICOLON
IAD	TokenNameIdentifier
=	TokenNameEQUAL
minTime	TokenNameIdentifier
(	TokenNameLPAREN
minTime	TokenNameIdentifier
(	TokenNameLPAREN
p1	TokenNameIdentifier
,	TokenNameCOMMA
p2	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
INDEFINITE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
end	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
PAD	TokenNameIdentifier
=	TokenNameEQUAL
IAD	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
PAD	TokenNameIdentifier
=	TokenNameEQUAL
minTime	TokenNameIdentifier
(	TokenNameLPAREN
IAD	TokenNameIdentifier
,	TokenNameCOMMA
minusTime	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
,	TokenNameCOMMA
B	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
repeatDuration	TokenNameIdentifier
=	TokenNameEQUAL
IAD	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
minTime	TokenNameIdentifier
(	TokenNameLPAREN
max	TokenNameIdentifier
,	TokenNameCOMMA
maxTime	TokenNameIdentifier
(	TokenNameLPAREN
min	TokenNameIdentifier
,	TokenNameCOMMA
PAD	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
minusTime	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
t1	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
t2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t1	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
t1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
||	TokenNameOR_OR
t2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
t1	TokenNameIdentifier
-	TokenNameMINUS
t2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
multiplyTime	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
t	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
n	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
t	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
t	TokenNameIdentifier
*	TokenNameMULTIPLY
n	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
minTime	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
t1	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
t2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
t1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0.0f	TokenNameFloatingPointLiteral
||	TokenNameOR_OR
t2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0.0f	TokenNameFloatingPointLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
0.0f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
t1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
||	TokenNameOR_OR
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t1	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
t2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
INDEFINITE	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
t2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
t2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
||	TokenNameOR_OR
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
t1	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
INDEFINITE	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t1	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
t1	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
t1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
&&	TokenNameAND_AND
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t2	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t1	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
t2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
t1	TokenNameIdentifier
<	TokenNameLESS
t2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
t1	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
t2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
maxTime	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
t1	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
t2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
t1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
||	TokenNameOR_OR
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t1	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
t2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
INDEFINITE	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
t1	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
t2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
||	TokenNameOR_OR
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
t1	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
INDEFINITE	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t1	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
t2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
t1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
&&	TokenNameAND_AND
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t2	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
t1	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
t2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INDEFINITE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
t1	TokenNameIdentifier
>	TokenNameGREATER
t2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
t1	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
t2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
getImplicitDur	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
notifyNewInterval	TokenNameIdentifier
(	TokenNameLPAREN
Interval	TokenNameIdentifier
interval	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
POSITIVE_INFINITY	TokenNameIdentifier
;	TokenNameSEMICOLON
Iterator	TokenNameIdentifier
i	TokenNameIdentifier
=	TokenNameEQUAL
beginDependents	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
TimingSpecifier	TokenNameIdentifier
ts	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
TimingSpecifier	TokenNameIdentifier
)	TokenNameRPAREN
i	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
t	TokenNameIdentifier
=	TokenNameEQUAL
ts	TokenNameIdentifier
.	TokenNameDOT
newInterval	TokenNameIdentifier
(	TokenNameLPAREN
interval	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
<	TokenNameLESS
dependentMinTime	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
i	TokenNameIdentifier
=	TokenNameEQUAL
endDependents	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
TimingSpecifier	TokenNameIdentifier
ts	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
TimingSpecifier	TokenNameIdentifier
)	TokenNameRPAREN
i	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
t	TokenNameIdentifier
=	TokenNameEQUAL
ts	TokenNameIdentifier
.	TokenNameDOT
newInterval	TokenNameIdentifier
(	TokenNameLPAREN
interval	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
<	TokenNameLESS
dependentMinTime	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
dependentMinTime	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
notifyRemoveInterval	TokenNameIdentifier
(	TokenNameLPAREN
Interval	TokenNameIdentifier
interval	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
POSITIVE_INFINITY	TokenNameIdentifier
;	TokenNameSEMICOLON
Iterator	TokenNameIdentifier
i	TokenNameIdentifier
=	TokenNameEQUAL
beginDependents	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
TimingSpecifier	TokenNameIdentifier
ts	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
TimingSpecifier	TokenNameIdentifier
)	TokenNameRPAREN
i	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
t	TokenNameIdentifier
=	TokenNameEQUAL
ts	TokenNameIdentifier
.	TokenNameDOT
removeInterval	TokenNameIdentifier
(	TokenNameLPAREN
interval	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
<	TokenNameLESS
dependentMinTime	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
i	TokenNameIdentifier
=	TokenNameEQUAL
endDependents	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
TimingSpecifier	TokenNameIdentifier
ts	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
TimingSpecifier	TokenNameIdentifier
)	TokenNameRPAREN
i	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
t	TokenNameIdentifier
=	TokenNameEQUAL
ts	TokenNameIdentifier
.	TokenNameDOT
removeInterval	TokenNameIdentifier
(	TokenNameLPAREN
interval	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
<	TokenNameLESS
dependentMinTime	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
dependentMinTime	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
sampleAt	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
parentSimpleTime	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
hyperlinking	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
isSampling	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
float	TokenNamefloat
time	TokenNameIdentifier
=	TokenNameEQUAL
parentSimpleTime	TokenNameIdentifier
;	TokenNameSEMICOLON
Iterator	TokenNameIdentifier
i	TokenNameIdentifier
=	TokenNameEQUAL
handledEvents	TokenNameIdentifier
.	TokenNameDOT
entrySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Map	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
e	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Map	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
)	TokenNameRPAREN
i	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Event	TokenNameIdentifier
evt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Event	TokenNameIdentifier
)	TokenNameRPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Set	TokenNameIdentifier
ts	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Set	TokenNameIdentifier
)	TokenNameRPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Iterator	TokenNameIdentifier
j	TokenNameIdentifier
=	TokenNameEQUAL
ts	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
hasBegin	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
,	TokenNameCOMMA
hasEnd	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
j	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
(	TokenNameLPAREN
hasBegin	TokenNameIdentifier
&&	TokenNameAND_AND
hasEnd	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
EventLikeTimingSpecifier	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
EventLikeTimingSpecifier	TokenNameIdentifier
)	TokenNameRPAREN
j	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
.	TokenNameDOT
isBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
hasBegin	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
hasEnd	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
boolean	TokenNameboolean
useBegin	TokenNameIdentifier
,	TokenNameCOMMA
useEnd	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hasBegin	TokenNameIdentifier
&&	TokenNameAND_AND
hasEnd	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
useBegin	TokenNameIdentifier
=	TokenNameEQUAL
!	TokenNameNOT
isActive	TokenNameIdentifier
||	TokenNameOR_OR
restartMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RESTART_ALWAYS	TokenNameIdentifier
;	TokenNameSEMICOLON
useEnd	TokenNameIdentifier
=	TokenNameEQUAL
!	TokenNameNOT
useBegin	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
hasBegin	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
!	TokenNameNOT
isActive	TokenNameIdentifier
||	TokenNameOR_OR
restartMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RESTART_ALWAYS	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
useBegin	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
useEnd	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
hasEnd	TokenNameIdentifier
&&	TokenNameAND_AND
isActive	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
useBegin	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
useEnd	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
j	TokenNameIdentifier
=	TokenNameEQUAL
ts	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
j	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
EventLikeTimingSpecifier	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
EventLikeTimingSpecifier	TokenNameIdentifier
)	TokenNameRPAREN
j	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isBegin	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
.	TokenNameDOT
isBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isBegin	TokenNameIdentifier
&&	TokenNameAND_AND
useBegin	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
isBegin	TokenNameIdentifier
&&	TokenNameAND_AND
useEnd	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
t	TokenNameIdentifier
.	TokenNameDOT
resolve	TokenNameIdentifier
(	TokenNameLPAREN
evt	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
shouldUpdateCurrentInterval	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
handledEvents	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentInterval	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
begin	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lastSampleTime	TokenNameIdentifier
<	TokenNameLESS
begin	TokenNameIdentifier
&&	TokenNameAND_AND
time	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
begin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isActive	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
toActive	TokenNameIdentifier
(	TokenNameLPAREN
begin	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
isActive	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
isFrozen	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
lastRepeatTime	TokenNameIdentifier
=	TokenNameEQUAL
begin	TokenNameIdentifier
;	TokenNameSEMICOLON
fireTimeEvent	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_BEGIN_EVENT_NAME	TokenNameIdentifier
,	TokenNameCOMMA
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
boolean	TokenNameboolean
hasEnded	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
time	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentInterval	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
begin	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
time	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
begin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
d	TokenNameIdentifier
=	TokenNameEQUAL
getSimpleDur	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
time	TokenNameIdentifier
-	TokenNameMINUS
lastRepeatTime	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
d	TokenNameIdentifier
&&	TokenNameAND_AND
lastRepeatTime	TokenNameIdentifier
+	TokenNamePLUS
d	TokenNameIdentifier
<	TokenNameLESS
begin	TokenNameIdentifier
+	TokenNamePLUS
repeatDuration	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
lastRepeatTime	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
d	TokenNameIdentifier
;	TokenNameSEMICOLON
currentRepeatIteration	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
fireTimeEvent	TokenNameIdentifier
(	TokenNameLPAREN
root	TokenNameIdentifier
.	TokenNameDOT
getRepeatEventName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
lastRepeatTime	TokenNameIdentifier
,	TokenNameCOMMA
currentRepeatIteration	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
float	TokenNamefloat
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
POSITIVE_INFINITY	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hyperlinking	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
shouldUpdateCurrentInterval	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
shouldUpdateCurrentInterval	TokenNameIdentifier
||	TokenNameOR_OR
hasEnded	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hasEnded	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
previousInterval	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
;	TokenNameSEMICOLON
isActive	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
isFrozen	TokenNameIdentifier
=	TokenNameEQUAL
fillMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
FILL_FREEZE	TokenNameIdentifier
;	TokenNameSEMICOLON
toInactive	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
isFrozen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fireTimeEvent	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_END_EVENT_NAME	TokenNameIdentifier
,	TokenNameCOMMA
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
first	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
previousInterval	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentInterval	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
hyperlinking	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
isActive	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
isFrozen	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
toInactive	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
currentInterval	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
currentInterval	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
hasEnded	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
first	TokenNameIdentifier
||	TokenNameOR_OR
hyperlinking	TokenNameIdentifier
||	TokenNameOR_OR
restartMode	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
RESTART_NEVER	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
beginAfter	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
incl	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
first	TokenNameIdentifier
||	TokenNameOR_OR
hyperlinking	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
beginAfter	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
NEGATIVE_INFINITY	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
beginAfter	TokenNameIdentifier
=	TokenNameEQUAL
previousInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
incl	TokenNameIdentifier
=	TokenNameEQUAL
beginAfter	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
previousInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Interval	TokenNameIdentifier
interval	TokenNameIdentifier
=	TokenNameEQUAL
computeInterval	TokenNameIdentifier
(	TokenNameLPAREN
first	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
beginAfter	TokenNameIdentifier
,	TokenNameCOMMA
incl	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
interval	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
currentInterval	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
float	TokenNamefloat
dmt	TokenNameIdentifier
=	TokenNameEQUAL
selectNewInterval	TokenNameIdentifier
(	TokenNameLPAREN
time	TokenNameIdentifier
,	TokenNameCOMMA
interval	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dmt	TokenNameIdentifier
<	TokenNameLESS
dependentMinTime	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
dmt	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
currentInterval	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
float	TokenNamefloat
currentBegin	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentBegin	TokenNameIdentifier
>	TokenNameGREATER
time	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
beginAfter	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
incl	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
previousInterval	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
beginAfter	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
NEGATIVE_INFINITY	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
beginAfter	TokenNameIdentifier
=	TokenNameEQUAL
previousInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
incl	TokenNameIdentifier
=	TokenNameEQUAL
beginAfter	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
previousInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Interval	TokenNameIdentifier
interval	TokenNameIdentifier
=	TokenNameEQUAL
computeInterval	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
beginAfter	TokenNameIdentifier
,	TokenNameCOMMA
incl	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
dmt	TokenNameIdentifier
=	TokenNameEQUAL
notifyRemoveInterval	TokenNameIdentifier
(	TokenNameLPAREN
currentInterval	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dmt	TokenNameIdentifier
<	TokenNameLESS
dependentMinTime	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
dmt	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
interval	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
currentInterval	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
dmt	TokenNameIdentifier
=	TokenNameEQUAL
selectNewInterval	TokenNameIdentifier
(	TokenNameLPAREN
time	TokenNameIdentifier
,	TokenNameCOMMA
interval	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dmt	TokenNameIdentifier
<	TokenNameLESS
dependentMinTime	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
dmt	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
Interval	TokenNameIdentifier
interval	TokenNameIdentifier
=	TokenNameEQUAL
computeInterval	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
currentBegin	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
newEnd	TokenNameIdentifier
=	TokenNameEQUAL
interval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
newEnd	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
dmt	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
setEnd	TokenNameIdentifier
(	TokenNameLPAREN
newEnd	TokenNameIdentifier
,	TokenNameCOMMA
interval	TokenNameIdentifier
.	TokenNameDOT
getEndInstanceTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dmt	TokenNameIdentifier
<	TokenNameLESS
dependentMinTime	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dependentMinTime	TokenNameIdentifier
=	TokenNameEQUAL
dmt	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
shouldUpdateCurrentInterval	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
hyperlinking	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
hasEnded	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
time	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
float	TokenNamefloat
d	TokenNameIdentifier
=	TokenNameEQUAL
getSimpleDur	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isActive	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
isFrozen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
time	TokenNameIdentifier
-	TokenNameMINUS
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
repeatDuration	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
isFrozen	TokenNameIdentifier
=	TokenNameEQUAL
fillMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
FILL_FREEZE	TokenNameIdentifier
;	TokenNameSEMICOLON
toInactive	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
isFrozen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
sampledAt	TokenNameIdentifier
(	TokenNameLPAREN
time	TokenNameIdentifier
-	TokenNameMINUS
lastRepeatTime	TokenNameIdentifier
,	TokenNameCOMMA
d	TokenNameIdentifier
,	TokenNameCOMMA
currentRepeatIteration	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isFrozen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
t	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
atLast	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isActive	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
t	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
repeatDuration	TokenNameIdentifier
-	TokenNameMINUS
lastRepeatTime	TokenNameIdentifier
;	TokenNameSEMICOLON
atLast	TokenNameIdentifier
=	TokenNameEQUAL
lastRepeatTime	TokenNameIdentifier
+	TokenNamePLUS
d	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
repeatDuration	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
t	TokenNameIdentifier
=	TokenNameEQUAL
previousInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
lastRepeatTime	TokenNameIdentifier
;	TokenNameSEMICOLON
atLast	TokenNameIdentifier
=	TokenNameEQUAL
lastRepeatTime	TokenNameIdentifier
+	TokenNamePLUS
d	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
previousInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
atLast	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
sampledLastValue	TokenNameIdentifier
(	TokenNameLPAREN
currentRepeatIteration	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
sampledAt	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
%	TokenNameREMAINDER
d	TokenNameIdentifier
,	TokenNameCOMMA
d	TokenNameIdentifier
,	TokenNameCOMMA
currentRepeatIteration	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isActive	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
isSampling	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
lastSampleTime	TokenNameIdentifier
=	TokenNameEQUAL
time	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentInterval	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
t	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
time	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
t	TokenNameIdentifier
=	TokenNameEQUAL
isConstantAnimation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
isFrozen	TokenNameIdentifier
?	TokenNameQUESTION
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
time	TokenNameIdentifier
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
dependentMinTime	TokenNameIdentifier
<	TokenNameLESS
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
dependentMinTime	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
dependentMinTime	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
boolean	TokenNameboolean
endHasEventConditions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
endTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
endTimes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
isEventCondition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
selectNewInterval	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
time	TokenNameIdentifier
,	TokenNameCOMMA
Interval	TokenNameIdentifier
interval	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
currentInterval	TokenNameIdentifier
=	TokenNameEQUAL
interval	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
dmt	TokenNameIdentifier
=	TokenNameEQUAL
notifyNewInterval	TokenNameIdentifier
(	TokenNameLPAREN
currentInterval	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
beginEventTime	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
time	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
beginEventTime	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
lastRepeatTime	TokenNameIdentifier
=	TokenNameEQUAL
beginEventTime	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
beginEventTime	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
beginEventTime	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
toActive	TokenNameIdentifier
(	TokenNameLPAREN
beginEventTime	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
isActive	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
isFrozen	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fireTimeEvent	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_BEGIN_EVENT_NAME	TokenNameIdentifier
,	TokenNameCOMMA
beginEventTime	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
d	TokenNameIdentifier
=	TokenNameEQUAL
getSimpleDur	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
end	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
time	TokenNameIdentifier
-	TokenNameMINUS
lastRepeatTime	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
d	TokenNameIdentifier
&&	TokenNameAND_AND
lastRepeatTime	TokenNameIdentifier
+	TokenNamePLUS
d	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
lastRepeatTime	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
d	TokenNameIdentifier
;	TokenNameSEMICOLON
currentRepeatIteration	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
fireTimeEvent	TokenNameIdentifier
(	TokenNameLPAREN
root	TokenNameIdentifier
.	TokenNameDOT
getRepeatEventName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
lastRepeatTime	TokenNameIdentifier
,	TokenNameCOMMA
currentRepeatIteration	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
dmt	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Interval	TokenNameIdentifier
computeInterval	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
first	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
fixedBegin	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
beginAfter	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
incl	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Iterator	TokenNameIdentifier
beginIterator	TokenNameIdentifier
=	TokenNameEQUAL
beginInstanceTimes	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Iterator	TokenNameIdentifier
endIterator	TokenNameIdentifier
=	TokenNameEQUAL
endInstanceTimes	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
parentSimpleDur	TokenNameIdentifier
=	TokenNameEQUAL
parent	TokenNameIdentifier
.	TokenNameDOT
getSimpleDur	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
InstanceTime	TokenNameIdentifier
endInstanceTime	TokenNameIdentifier
=	TokenNameEQUAL
endIterator	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
endIterator	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
firstEnd	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
InstanceTime	TokenNameIdentifier
beginInstanceTime	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
InstanceTime	TokenNameIdentifier
nextBeginInstanceTime	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
tempBegin	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fixedBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tempBegin	TokenNameIdentifier
=	TokenNameEQUAL
beginAfter	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
beginIterator	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
nextBeginInstanceTime	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
beginIterator	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nextBeginInstanceTime	TokenNameIdentifier
.	TokenNameDOT
getTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
tempBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
beginIterator	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
beginInstanceTime	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
beginIterator	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tempBegin	TokenNameIdentifier
=	TokenNameEQUAL
beginInstanceTime	TokenNameIdentifier
.	TokenNameDOT
getTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
incl	TokenNameIdentifier
&&	TokenNameAND_AND
tempBegin	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
beginAfter	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
incl	TokenNameIdentifier
&&	TokenNameAND_AND
tempBegin	TokenNameIdentifier
>	TokenNameGREATER
beginAfter	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
beginIterator	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
nextBeginInstanceTime	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
beginIterator	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
beginInstanceTime	TokenNameIdentifier
.	TokenNameDOT
getTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
nextBeginInstanceTime	TokenNameIdentifier
.	TokenNameDOT
getTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
nextBeginInstanceTime	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
tempBegin	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
parentSimpleDur	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
float	TokenNamefloat
tempEnd	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
endTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
tempEnd	TokenNameIdentifier
=	TokenNameEQUAL
tempBegin	TokenNameIdentifier
+	TokenNamePLUS
getActiveDur	TokenNameIdentifier
(	TokenNameLPAREN
tempBegin	TokenNameIdentifier
,	TokenNameCOMMA
INDEFINITE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
endInstanceTimes	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
tempEnd	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
tempEnd	TokenNameIdentifier
=	TokenNameEQUAL
endInstanceTime	TokenNameIdentifier
.	TokenNameDOT
getTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
first	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
firstEnd	TokenNameIdentifier
&&	TokenNameAND_AND
tempEnd	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
tempBegin	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
first	TokenNameIdentifier
&&	TokenNameAND_AND
currentInterval	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
tempEnd	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
incl	TokenNameIdentifier
&&	TokenNameAND_AND
beginAfter	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
tempEnd	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
incl	TokenNameIdentifier
&&	TokenNameAND_AND
beginAfter	TokenNameIdentifier
>	TokenNameGREATER
tempEnd	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
endIterator	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
endHasEventConditions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
tempEnd	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
endInstanceTime	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
endIterator	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tempEnd	TokenNameIdentifier
=	TokenNameEQUAL
endInstanceTime	TokenNameIdentifier
.	TokenNameDOT
getTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
tempEnd	TokenNameIdentifier
>	TokenNameGREATER
tempBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
firstEnd	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
tempEnd	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
tempBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
endIterator	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
endHasEventConditions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
tempEnd	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
endInstanceTime	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
endIterator	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tempEnd	TokenNameIdentifier
=	TokenNameEQUAL
endInstanceTime	TokenNameIdentifier
.	TokenNameDOT
getTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
float	TokenNamefloat
ad	TokenNameIdentifier
=	TokenNameEQUAL
getActiveDur	TokenNameIdentifier
(	TokenNameLPAREN
tempBegin	TokenNameIdentifier
,	TokenNameCOMMA
tempEnd	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tempEnd	TokenNameIdentifier
=	TokenNameEQUAL
tempBegin	TokenNameIdentifier
+	TokenNamePLUS
ad	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
first	TokenNameIdentifier
||	TokenNameOR_OR
tempEnd	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
tempBegin	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
tempEnd	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
tempEnd	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
restartMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RESTART_ALWAYS	TokenNameIdentifier
&&	TokenNameAND_AND
nextBeginInstanceTime	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
nextBegin	TokenNameIdentifier
=	TokenNameEQUAL
nextBeginInstanceTime	TokenNameIdentifier
.	TokenNameDOT
getTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nextBegin	TokenNameIdentifier
<	TokenNameLESS
tempEnd	TokenNameIdentifier
||	TokenNameOR_OR
isUnresolved	TokenNameIdentifier
(	TokenNameLPAREN
tempEnd	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
tempEnd	TokenNameIdentifier
=	TokenNameEQUAL
nextBegin	TokenNameIdentifier
;	TokenNameSEMICOLON
endInstanceTime	TokenNameIdentifier
=	TokenNameEQUAL
nextBeginInstanceTime	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
Interval	TokenNameIdentifier
i	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Interval	TokenNameIdentifier
(	TokenNameLPAREN
tempBegin	TokenNameIdentifier
,	TokenNameCOMMA
tempEnd	TokenNameIdentifier
,	TokenNameCOMMA
beginInstanceTime	TokenNameIdentifier
,	TokenNameCOMMA
endInstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
i	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fixedBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
beginAfter	TokenNameIdentifier
=	TokenNameEQUAL
tempEnd	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
reset	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
clearCurrentBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Iterator	TokenNameIdentifier
i	TokenNameIdentifier
=	TokenNameEQUAL
beginInstanceTimes	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
InstanceTime	TokenNameIdentifier
it	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
i	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
it	TokenNameIdentifier
.	TokenNameDOT
getClearOnReset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
clearCurrentBegin	TokenNameIdentifier
||	TokenNameOR_OR
currentInterval	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBeginInstanceTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
it	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
i	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
i	TokenNameIdentifier
=	TokenNameEQUAL
endInstanceTimes	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
InstanceTime	TokenNameIdentifier
it	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
i	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
it	TokenNameIdentifier
.	TokenNameDOT
getClearOnReset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
i	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isFrozen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
removeFill	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
currentRepeatIteration	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
lastRepeatTime	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
isActive	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
isFrozen	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
lastSampleTime	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
parseAttributes	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
begin	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
dur	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
end	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
min	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
max	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
repeatCount	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
repeatDur	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
fill	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
restart	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
hasParsed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
parseBegin	TokenNameIdentifier
(	TokenNameLPAREN
begin	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
parseDur	TokenNameIdentifier
(	TokenNameLPAREN
dur	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
parseEnd	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
parseMin	TokenNameIdentifier
(	TokenNameLPAREN
min	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
parseMax	TokenNameIdentifier
(	TokenNameLPAREN
max	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
min	TokenNameIdentifier
>	TokenNameGREATER
this	TokenNamethis
.	TokenNameDOT
max	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
min	TokenNameIdentifier
=	TokenNameEQUAL
0f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
max	TokenNameIdentifier
=	TokenNameEQUAL
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
parseRepeatCount	TokenNameIdentifier
(	TokenNameLPAREN
repeatCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
parseRepeatDur	TokenNameIdentifier
(	TokenNameLPAREN
repeatDur	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
parseFill	TokenNameIdentifier
(	TokenNameLPAREN
fill	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
parseRestart	TokenNameIdentifier
(	TokenNameLPAREN
restart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hasParsed	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
parseBegin	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
begin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
begin	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
begin	TokenNameIdentifier
=	TokenNameEQUAL
SMIL_BEGIN_DEFAULT_VALUE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
beginTimes	TokenNameIdentifier
=	TokenNameEQUAL
TimingSpecifierListProducer	TokenNameIdentifier
.	TokenNameDOT
parseTimingSpecifierList	TokenNameIdentifier
(	TokenNameLPAREN
TimedElement	TokenNameIdentifier
.	TokenNameDOT
this	TokenNamethis
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
begin	TokenNameIdentifier
,	TokenNameCOMMA
root	TokenNameIdentifier
.	TokenNameDOT
useSVG11AccessKeys	TokenNameIdentifier
,	TokenNameCOMMA
root	TokenNameIdentifier
.	TokenNameDOT
useSVG12AccessKeys	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ParseException	TokenNameIdentifier
ex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createException	TokenNameIdentifier
(	TokenNameLPAREN
"attribute.malformed"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
,	TokenNameCOMMA
SMIL_BEGIN_ATTRIBUTE	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
parseDur	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
dur	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dur	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_MEDIA_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
durMedia	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
simpleDur	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
durMedia	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dur	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
dur	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_INDEFINITE_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
simpleDur	TokenNameIdentifier
=	TokenNameEQUAL
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
simpleDur	TokenNameIdentifier
=	TokenNameEQUAL
parseClockValue	TokenNameIdentifier
(	TokenNameLPAREN
dur	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ParseException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createException	TokenNameIdentifier
(	TokenNameLPAREN
"attribute.malformed"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
,	TokenNameCOMMA
SMIL_DUR_ATTRIBUTE	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
simpleDur	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
simpleDur	TokenNameIdentifier
=	TokenNameEQUAL
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
float	TokenNamefloat
parseClockValue	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
s	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
parseOffset	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
ClockParser	TokenNameIdentifier
p	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ClockParser	TokenNameIdentifier
(	TokenNameLPAREN
parseOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
class	TokenNameclass
Handler	TokenNameIdentifier
implements	TokenNameimplements
ClockHandler	TokenNameIdentifier
{	TokenNameLBRACE
protected	TokenNameprotected
float	TokenNamefloat
v	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
void	TokenNamevoid
clockValue	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
newClockValue	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
v	TokenNameIdentifier
=	TokenNameEQUAL
newClockValue	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
Handler	TokenNameIdentifier
h	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Handler	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
p	TokenNameIdentifier
.	TokenNameDOT
setClockHandler	TokenNameIdentifier
(	TokenNameLPAREN
h	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
p	TokenNameIdentifier
.	TokenNameDOT
parse	TokenNameIdentifier
(	TokenNameLPAREN
s	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
h	TokenNameIdentifier
.	TokenNameDOT
v	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
parseEnd	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
endTimes	TokenNameIdentifier
=	TokenNameEQUAL
TimingSpecifierListProducer	TokenNameIdentifier
.	TokenNameDOT
parseTimingSpecifierList	TokenNameIdentifier
(	TokenNameLPAREN
TimedElement	TokenNameIdentifier
.	TokenNameDOT
this	TokenNamethis
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
end	TokenNameIdentifier
,	TokenNameCOMMA
root	TokenNameIdentifier
.	TokenNameDOT
useSVG11AccessKeys	TokenNameIdentifier
,	TokenNameCOMMA
root	TokenNameIdentifier
.	TokenNameDOT
useSVG12AccessKeys	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ParseException	TokenNameIdentifier
ex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createException	TokenNameIdentifier
(	TokenNameLPAREN
"attribute.malformed"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
,	TokenNameCOMMA
SMIL_END_ATTRIBUTE	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
parseMin	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
min	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
min	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_MEDIA_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
min	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
minMedia	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
minMedia	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
min	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
min	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
min	TokenNameIdentifier
=	TokenNameEQUAL
parseClockValue	TokenNameIdentifier
(	TokenNameLPAREN
min	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ParseException	TokenNameIdentifier
ex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
min	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
min	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
min	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
parseMax	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
max	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
max	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_MEDIA_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
max	TokenNameIdentifier
=	TokenNameEQUAL
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
maxMedia	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
maxMedia	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
max	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
max	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_INDEFINITE_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
max	TokenNameIdentifier
=	TokenNameEQUAL
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
max	TokenNameIdentifier
=	TokenNameEQUAL
parseClockValue	TokenNameIdentifier
(	TokenNameLPAREN
max	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ParseException	TokenNameIdentifier
ex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
max	TokenNameIdentifier
=	TokenNameEQUAL
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
max	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
max	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
parseRepeatCount	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
repeatCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
repeatCount	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
repeatCount	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
repeatCount	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_INDEFINITE_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
repeatCount	TokenNameIdentifier
=	TokenNameEQUAL
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
repeatCount	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
parseFloat	TokenNameIdentifier
(	TokenNameLPAREN
repeatCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
repeatCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NumberFormatException	TokenNameIdentifier
ex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createException	TokenNameIdentifier
(	TokenNameLPAREN
"attribute.malformed"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
,	TokenNameCOMMA
SMIL_REPEAT_COUNT_ATTRIBUTE	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
parseRepeatDur	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
repeatDur	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
repeatDur	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
repeatDur	TokenNameIdentifier
=	TokenNameEQUAL
UNRESOLVED	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
repeatDur	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_INDEFINITE_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
repeatDur	TokenNameIdentifier
=	TokenNameEQUAL
INDEFINITE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
repeatDur	TokenNameIdentifier
=	TokenNameEQUAL
parseClockValue	TokenNameIdentifier
(	TokenNameLPAREN
repeatDur	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ParseException	TokenNameIdentifier
ex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createException	TokenNameIdentifier
(	TokenNameLPAREN
"attribute.malformed"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
,	TokenNameCOMMA
SMIL_REPEAT_DUR_ATTRIBUTE	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
parseFill	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
fill	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fill	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
fill	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_REMOVE_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fillMode	TokenNameIdentifier
=	TokenNameEQUAL
FILL_REMOVE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fill	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_FREEZE_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
fillMode	TokenNameIdentifier
=	TokenNameEQUAL
FILL_FREEZE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
createException	TokenNameIdentifier
(	TokenNameLPAREN
"attribute.malformed"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
,	TokenNameCOMMA
SMIL_FILL_ATTRIBUTE	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
parseRestart	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
restart	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
restart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
restart	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_ALWAYS_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
restartMode	TokenNameIdentifier
=	TokenNameEQUAL
RESTART_ALWAYS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
restart	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_WHEN_NOT_ACTIVE_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
restartMode	TokenNameIdentifier
=	TokenNameEQUAL
RESTART_WHEN_NOT_ACTIVE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
restart	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
SMIL_NEVER_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
restartMode	TokenNameIdentifier
=	TokenNameEQUAL
RESTART_NEVER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
createException	TokenNameIdentifier
(	TokenNameLPAREN
"attribute.malformed"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
,	TokenNameCOMMA
SMIL_RESTART_ATTRIBUTE	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
initialize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
beginTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
beginTimes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
initialize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
endTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
endTimes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
initialize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
deinitialize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
beginTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
beginTimes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
deinitialize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
endTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
endTimes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
deinitialize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
beginElement	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
beginElement	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
beginElement	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
t	TokenNameIdentifier
=	TokenNameEQUAL
root	TokenNameIdentifier
.	TokenNameDOT
convertWallclockTime	TokenNameIdentifier
(	TokenNameLPAREN
Calendar	TokenNameIdentifier
.	TokenNameDOT
getInstance	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
InstanceTime	TokenNameIdentifier
it	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
InstanceTime	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
t	TokenNameIdentifier
+	TokenNamePLUS
offset	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addInstanceTime	TokenNameIdentifier
(	TokenNameLPAREN
it	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
endElement	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
endElement	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
endElement	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
t	TokenNameIdentifier
=	TokenNameEQUAL
root	TokenNameIdentifier
.	TokenNameDOT
convertWallclockTime	TokenNameIdentifier
(	TokenNameLPAREN
Calendar	TokenNameIdentifier
.	TokenNameDOT
getInstance	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
InstanceTime	TokenNameIdentifier
it	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
InstanceTime	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
t	TokenNameIdentifier
+	TokenNamePLUS
offset	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addInstanceTime	TokenNameIdentifier
(	TokenNameLPAREN
it	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
float	TokenNamefloat
getLastSampleTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
lastSampleTime	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
float	TokenNamefloat
getCurrentBeginTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
begin	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentInterval	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
(	TokenNameLPAREN
begin	TokenNameIdentifier
=	TokenNameEQUAL
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
lastSampleTime	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
Float	TokenNameIdentifier
.	TokenNameDOT
NaN	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
begin	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
canBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
currentInterval	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
isActive	TokenNameIdentifier
&&	TokenNameAND_AND
restartMode	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
RESTART_NEVER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
canEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
isActive	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
float	TokenNamefloat
getHyperlinkBeginTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isActive	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
currentInterval	TokenNameIdentifier
.	TokenNameDOT
getBegin	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
beginInstanceTimes	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
InstanceTime	TokenNameIdentifier
)	TokenNameRPAREN
beginInstanceTimes	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
Float	TokenNameIdentifier
.	TokenNameDOT
NaN	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
fireTimeEvent	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
eventType	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
time	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
detail	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Calendar	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Calendar	TokenNameIdentifier
)	TokenNameRPAREN
root	TokenNameIdentifier
.	TokenNameDOT
getDocumentBeginTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
t	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
Calendar	TokenNameIdentifier
.	TokenNameDOT
MILLISECOND	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
round	TokenNameIdentifier
(	TokenNameLPAREN
time	TokenNameIdentifier
*	TokenNameMULTIPLY
1e3	TokenNameDoubleLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fireTimeEvent	TokenNameIdentifier
(	TokenNameLPAREN
eventType	TokenNameIdentifier
,	TokenNameCOMMA
t	TokenNameIdentifier
,	TokenNameCOMMA
detail	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
eventOccurred	TokenNameIdentifier
(	TokenNameLPAREN
TimingSpecifier	TokenNameIdentifier
t	TokenNameIdentifier
,	TokenNameCOMMA
Event	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Set	TokenNameIdentifier
ts	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
HashSet	TokenNameIdentifier
)	TokenNameRPAREN
handledEvents	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ts	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
ts	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
handledEvents	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
,	TokenNameCOMMA
ts	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ts	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
root	TokenNameIdentifier
.	TokenNameDOT
currentIntervalWillUpdate	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
abstract	TokenNameabstract
void	TokenNamevoid
fireTimeEvent	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
eventType	TokenNameIdentifier
,	TokenNameCOMMA
Calendar	TokenNameIdentifier
time	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
detail	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
void	TokenNamevoid
toActive	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
begin	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
void	TokenNamevoid
toInactive	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
stillActive	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isFrozen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
void	TokenNamevoid
removeFill	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
void	TokenNamevoid
sampledAt	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
simpleTime	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
simpleDur	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
repeatIteration	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
void	TokenNamevoid
sampledLastValue	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
repeatIteration	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
TimedElement	TokenNameIdentifier
getTimedElementById	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
id	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
EventTarget	TokenNameIdentifier
getEventTargetById	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
id	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
EventTarget	TokenNameIdentifier
getRootEventTarget	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
Element	TokenNameIdentifier
getElement	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
EventTarget	TokenNameIdentifier
getAnimationEventTarget	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
boolean	TokenNameboolean
isBefore	TokenNameIdentifier
(	TokenNameLPAREN
TimedElement	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
boolean	TokenNameboolean
isConstantAnimation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
AnimationException	TokenNameIdentifier
createException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
code	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
params	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Element	TokenNameIdentifier
e	TokenNameIdentifier
=	TokenNameEQUAL
getElement	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
e	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
params	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
e	TokenNameIdentifier
.	TokenNameDOT
getNodeName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
AnimationException	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
,	TokenNameCOMMA
code	TokenNameIdentifier
,	TokenNameCOMMA
params	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
String	TokenNameIdentifier
RESOURCES	TokenNameIdentifier
=	TokenNameEQUAL
"org.apache.batik.anim.resources.Messages"	TokenNameStringLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
LocalizableSupport	TokenNameIdentifier
localizableSupport	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
LocalizableSupport	TokenNameIdentifier
(	TokenNameLPAREN
RESOURCES	TokenNameIdentifier
,	TokenNameCOMMA
TimedElement	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
.	TokenNameDOT
getClassLoader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
setLocale	TokenNameIdentifier
(	TokenNameLPAREN
Locale	TokenNameIdentifier
l	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
localizableSupport	TokenNameIdentifier
.	TokenNameDOT
setLocale	TokenNameIdentifier
(	TokenNameLPAREN
l	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
Locale	TokenNameIdentifier
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
localizableSupport	TokenNameIdentifier
.	TokenNameDOT
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
String	TokenNameIdentifier
formatMessage	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
key	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
args	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MissingResourceException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
localizableSupport	TokenNameIdentifier
.	TokenNameDOT
formatMessage	TokenNameIdentifier
(	TokenNameLPAREN
key	TokenNameIdentifier
,	TokenNameCOMMA
args	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
time	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
Float	TokenNameIdentifier
.	TokenNameDOT
isNaN	TokenNameIdentifier
(	TokenNameLPAREN
time	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"UNRESOLVED"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
time	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
POSITIVE_INFINITY	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"INDEFINITE"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
Float	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
time	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
