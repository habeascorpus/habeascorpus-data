package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
anim	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
geom	TokenNameIdentifier
.	TokenNameDOT
Point2D	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
anim	TokenNameIdentifier
.	TokenNameDOT
timing	TokenNameIdentifier
.	TokenNameDOT
TimedElement	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
anim	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
.	TokenNameDOT
AnimatableAngleValue	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
anim	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
.	TokenNameDOT
AnimatableMotionPointValue	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
anim	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
.	TokenNameDOT
AnimatableValue	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
anim	TokenNameIdentifier
.	TokenNameDOT
AnimatableElement	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
ext	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
geom	TokenNameIdentifier
.	TokenNameDOT
Cubic	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
ext	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
geom	TokenNameIdentifier
.	TokenNameDOT
ExtendedGeneralPath	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
ext	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
geom	TokenNameIdentifier
.	TokenNameDOT
ExtendedPathIterator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
ext	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
geom	TokenNameIdentifier
.	TokenNameDOT
PathLength	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
SMILConstants	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
MotionAnimation	TokenNameIdentifier
extends	TokenNameextends
InterpolatingAnimation	TokenNameIdentifier
{	TokenNameLBRACE
protected	TokenNameprotected
ExtendedGeneralPath	TokenNameIdentifier
path	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
PathLength	TokenNameIdentifier
pathLength	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
[	TokenNameLBRACKET
]	TokenNameRBRACKET
keyPoints	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
rotateAuto	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
rotateAutoReverse	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
float	TokenNamefloat
rotateAngle	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
MotionAnimation	TokenNameIdentifier
(	TokenNameLPAREN
TimedElement	TokenNameIdentifier
timedElement	TokenNameIdentifier
,	TokenNameCOMMA
AnimatableElement	TokenNameIdentifier
animatableElement	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
calcMode	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
[	TokenNameLBRACKET
]	TokenNameRBRACKET
keyTimes	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
[	TokenNameLBRACKET
]	TokenNameRBRACKET
keySplines	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
additive	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
cumulative	TokenNameIdentifier
,	TokenNameCOMMA
AnimatableValue	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
values	TokenNameIdentifier
,	TokenNameCOMMA
AnimatableValue	TokenNameIdentifier
from	TokenNameIdentifier
,	TokenNameCOMMA
AnimatableValue	TokenNameIdentifier
to	TokenNameIdentifier
,	TokenNameCOMMA
AnimatableValue	TokenNameIdentifier
by	TokenNameIdentifier
,	TokenNameCOMMA
ExtendedGeneralPath	TokenNameIdentifier
path	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
[	TokenNameLBRACKET
]	TokenNameRBRACKET
keyPoints	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
rotateAuto	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
rotateAutoReverse	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
rotateAngle	TokenNameIdentifier
,	TokenNameCOMMA
short	TokenNameshort
rotateAngleUnit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
timedElement	TokenNameIdentifier
,	TokenNameCOMMA
animatableElement	TokenNameIdentifier
,	TokenNameCOMMA
calcMode	TokenNameIdentifier
,	TokenNameCOMMA
keyTimes	TokenNameIdentifier
,	TokenNameCOMMA
keySplines	TokenNameIdentifier
,	TokenNameCOMMA
additive	TokenNameIdentifier
,	TokenNameCOMMA
cumulative	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
rotateAuto	TokenNameIdentifier
=	TokenNameEQUAL
rotateAuto	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
rotateAutoReverse	TokenNameIdentifier
=	TokenNameEQUAL
rotateAutoReverse	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
rotateAngle	TokenNameIdentifier
=	TokenNameEQUAL
AnimatableAngleValue	TokenNameIdentifier
.	TokenNameDOT
rad	TokenNameIdentifier
(	TokenNameLPAREN
rotateAngle	TokenNameIdentifier
,	TokenNameCOMMA
rotateAngleUnit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
path	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
path	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ExtendedGeneralPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
values	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
values	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
from	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
AnimatableMotionPointValue	TokenNameIdentifier
fromPt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
AnimatableMotionPointValue	TokenNameIdentifier
)	TokenNameRPAREN
from	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
x	TokenNameIdentifier
=	TokenNameEQUAL
fromPt	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
y	TokenNameIdentifier
=	TokenNameEQUAL
fromPt	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
path	TokenNameIdentifier
.	TokenNameDOT
moveTo	TokenNameIdentifier
(	TokenNameLPAREN
x	TokenNameIdentifier
,	TokenNameCOMMA
y	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
to	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
AnimatableMotionPointValue	TokenNameIdentifier
toPt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
AnimatableMotionPointValue	TokenNameIdentifier
)	TokenNameRPAREN
to	TokenNameIdentifier
;	TokenNameSEMICOLON
path	TokenNameIdentifier
.	TokenNameDOT
lineTo	TokenNameIdentifier
(	TokenNameLPAREN
toPt	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
toPt	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
by	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
AnimatableMotionPointValue	TokenNameIdentifier
byPt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
AnimatableMotionPointValue	TokenNameIdentifier
)	TokenNameRPAREN
by	TokenNameIdentifier
;	TokenNameSEMICOLON
path	TokenNameIdentifier
.	TokenNameDOT
lineTo	TokenNameIdentifier
(	TokenNameLPAREN
x	TokenNameIdentifier
+	TokenNamePLUS
byPt	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
y	TokenNameIdentifier
+	TokenNamePLUS
byPt	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
timedElement	TokenNameIdentifier
.	TokenNameDOT
createException	TokenNameIdentifier
(	TokenNameLPAREN
"values.to.by.path.missing"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
to	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
AnimatableMotionPointValue	TokenNameIdentifier
unPt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
AnimatableMotionPointValue	TokenNameIdentifier
)	TokenNameRPAREN
animatableElement	TokenNameIdentifier
.	TokenNameDOT
getUnderlyingValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
AnimatableMotionPointValue	TokenNameIdentifier
toPt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
AnimatableMotionPointValue	TokenNameIdentifier
)	TokenNameRPAREN
to	TokenNameIdentifier
;	TokenNameSEMICOLON
path	TokenNameIdentifier
.	TokenNameDOT
moveTo	TokenNameIdentifier
(	TokenNameLPAREN
unPt	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
unPt	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
path	TokenNameIdentifier
.	TokenNameDOT
lineTo	TokenNameIdentifier
(	TokenNameLPAREN
toPt	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
toPt	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
cumulative	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
by	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
AnimatableMotionPointValue	TokenNameIdentifier
byPt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
AnimatableMotionPointValue	TokenNameIdentifier
)	TokenNameRPAREN
by	TokenNameIdentifier
;	TokenNameSEMICOLON
path	TokenNameIdentifier
.	TokenNameDOT
moveTo	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
path	TokenNameIdentifier
.	TokenNameDOT
lineTo	TokenNameIdentifier
(	TokenNameLPAREN
byPt	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
byPt	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
additive	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
timedElement	TokenNameIdentifier
.	TokenNameDOT
createException	TokenNameIdentifier
(	TokenNameLPAREN
"values.to.by.path.missing"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
AnimatableMotionPointValue	TokenNameIdentifier
pt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
AnimatableMotionPointValue	TokenNameIdentifier
)	TokenNameRPAREN
values	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
path	TokenNameIdentifier
.	TokenNameDOT
moveTo	TokenNameIdentifier
(	TokenNameLPAREN
pt	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
pt	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
values	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
pt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
AnimatableMotionPointValue	TokenNameIdentifier
)	TokenNameRPAREN
values	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
path	TokenNameIdentifier
.	TokenNameDOT
lineTo	TokenNameIdentifier
(	TokenNameLPAREN
pt	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
pt	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
path	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
;	TokenNameSEMICOLON
pathLength	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
PathLength	TokenNameIdentifier
(	TokenNameLPAREN
path	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
segments	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
ExtendedPathIterator	TokenNameIdentifier
epi	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
getExtendedPathIterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
epi	TokenNameIdentifier
.	TokenNameDOT
isDone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
epi	TokenNameIdentifier
.	TokenNameDOT
currentSegment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
ExtendedPathIterator	TokenNameIdentifier
.	TokenNameDOT
SEG_MOVETO	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
segments	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
epi	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
keyPoints	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
segments	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
keyPoints	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
totalLength	TokenNameIdentifier
=	TokenNameEQUAL
pathLength	TokenNameIdentifier
.	TokenNameDOT
lengthOfPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
keyTimes	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
calcMode	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CALC_MODE_PACED	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
keyTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
timedElement	TokenNameIdentifier
.	TokenNameDOT
createException	TokenNameIdentifier
(	TokenNameLPAREN
"attribute.malformed"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
,	TokenNameCOMMA
SMILConstants	TokenNameIdentifier
.	TokenNameDOT
SMIL_KEY_TIMES_ATTRIBUTE	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
calcMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CALC_MODE_LINEAR	TokenNameIdentifier
||	TokenNameOR_OR
calcMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CALC_MODE_SPLINE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
keyTimes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
float	TokenNamefloat
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
count	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
keyTimes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
i	TokenNameIdentifier
/	TokenNameDIVIDE
(	TokenNameLPAREN
count	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
calcMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CALC_MODE_DISCRETE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
keyTimes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
float	TokenNamefloat
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
count	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
keyTimes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
i	TokenNameIdentifier
/	TokenNameDIVIDE
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
epi	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
getExtendedPathIterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
keyTimes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
float	TokenNamefloat
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
count	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
epi	TokenNameIdentifier
.	TokenNameDOT
currentSegment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
ExtendedPathIterator	TokenNameIdentifier
.	TokenNameDOT
SEG_MOVETO	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
epi	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
keyTimes	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
pathLength	TokenNameIdentifier
.	TokenNameDOT
getLengthAtSegment	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
totalLength	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
epi	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
keyTimes	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
1f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
keyPoints	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
keyPoints	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
this	TokenNamethis
.	TokenNameDOT
keyTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
timedElement	TokenNameIdentifier
.	TokenNameDOT
createException	TokenNameIdentifier
(	TokenNameLPAREN
"attribute.malformed"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
null	TokenNamenull
,	TokenNameCOMMA
SMILConstants	TokenNameIdentifier
.	TokenNameDOT
SMIL_KEY_POINTS_ATTRIBUTE	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
epi	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
getExtendedPathIterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
keyPoints	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
float	TokenNamefloat
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
count	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
epi	TokenNameIdentifier
.	TokenNameDOT
currentSegment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
ExtendedPathIterator	TokenNameIdentifier
.	TokenNameDOT
SEG_MOVETO	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
epi	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
keyPoints	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
pathLength	TokenNameIdentifier
.	TokenNameDOT
getLengthAtSegment	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
totalLength	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
epi	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
keyPoints	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
1f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
keyPoints	TokenNameIdentifier
=	TokenNameEQUAL
keyPoints	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
sampledAtUnitTime	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
unitTime	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
repeatIteration	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
AnimatableValue	TokenNameIdentifier
value	TokenNameIdentifier
,	TokenNameCOMMA
accumulation	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
interpolation	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
unitTime	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
keyTimeIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
keyTimeIndex	TokenNameIdentifier
<	TokenNameLESS
keyTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
unitTime	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
keyTimes	TokenNameIdentifier
[	TokenNameLBRACKET
keyTimeIndex	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
keyTimeIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
keyTimeIndex	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
keyTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
calcMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CALC_MODE_DISCRETE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
keyTimeIndex	TokenNameIdentifier
=	TokenNameEQUAL
keyTimes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
interpolation	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
calcMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CALC_MODE_LINEAR	TokenNameIdentifier
||	TokenNameOR_OR
calcMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CALC_MODE_PACED	TokenNameIdentifier
||	TokenNameOR_OR
calcMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CALC_MODE_SPLINE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
unitTime	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
interpolation	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
interpolation	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
unitTime	TokenNameIdentifier
-	TokenNameMINUS
keyTimes	TokenNameIdentifier
[	TokenNameLBRACKET
keyTimeIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
/	TokenNameDIVIDE
(	TokenNameLPAREN
keyTimes	TokenNameIdentifier
[	TokenNameLBRACKET
keyTimeIndex	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-	TokenNameMINUS
keyTimes	TokenNameIdentifier
[	TokenNameLBRACKET
keyTimeIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
calcMode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CALC_MODE_SPLINE	TokenNameIdentifier
&&	TokenNameAND_AND
unitTime	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
Cubic	TokenNameIdentifier
c	TokenNameIdentifier
=	TokenNameEQUAL
keySplineCubics	TokenNameIdentifier
[	TokenNameLBRACKET
keyTimeIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
float	TokenNamefloat
tolerance	TokenNameIdentifier
=	TokenNameEQUAL
0.001f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
float	TokenNamefloat
min	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
float	TokenNamefloat
max	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
Point2D	TokenNameIdentifier
.	TokenNameDOT
Double	TokenNameIdentifier
p	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
t	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
min	TokenNameIdentifier
+	TokenNamePLUS
max	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
p	TokenNameIdentifier
=	TokenNameEQUAL
c	TokenNameIdentifier
.	TokenNameDOT
eval	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
double	TokenNamedouble
x	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
abs	TokenNameIdentifier
(	TokenNameLPAREN
x	TokenNameIdentifier
-	TokenNameMINUS
interpolation	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
tolerance	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
x	TokenNameIdentifier
<	TokenNameLESS
interpolation	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
min	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
max	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
interpolation	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
float	TokenNamefloat
point	TokenNameIdentifier
=	TokenNameEQUAL
keyPoints	TokenNameIdentifier
[	TokenNameLBRACKET
keyTimeIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
interpolation	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
point	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
interpolation	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
keyPoints	TokenNameIdentifier
[	TokenNameLBRACKET
keyTimeIndex	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-	TokenNameMINUS
keyPoints	TokenNameIdentifier
[	TokenNameLBRACKET
keyTimeIndex	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
point	TokenNameIdentifier
*=	TokenNameMULTIPLY_EQUAL
pathLength	TokenNameIdentifier
.	TokenNameDOT
lengthOfPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Point2D	TokenNameIdentifier
p	TokenNameIdentifier
=	TokenNameEQUAL
pathLength	TokenNameIdentifier
.	TokenNameDOT
pointAtLength	TokenNameIdentifier
(	TokenNameLPAREN
point	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
ang	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
rotateAuto	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ang	TokenNameIdentifier
=	TokenNameEQUAL
pathLength	TokenNameIdentifier
.	TokenNameDOT
angleAtLength	TokenNameIdentifier
(	TokenNameLPAREN
point	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
rotateAutoReverse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ang	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
PI	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ang	TokenNameIdentifier
=	TokenNameEQUAL
rotateAngle	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
value	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AnimatableMotionPointValue	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ang	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
Point2D	TokenNameIdentifier
p	TokenNameIdentifier
=	TokenNameEQUAL
pathLength	TokenNameIdentifier
.	TokenNameDOT
pointAtLength	TokenNameIdentifier
(	TokenNameLPAREN
pathLength	TokenNameIdentifier
.	TokenNameDOT
lengthOfPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
ang	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
rotateAuto	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ang	TokenNameIdentifier
=	TokenNameEQUAL
pathLength	TokenNameIdentifier
.	TokenNameDOT
angleAtLength	TokenNameIdentifier
(	TokenNameLPAREN
pathLength	TokenNameIdentifier
.	TokenNameDOT
lengthOfPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
rotateAutoReverse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ang	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
PI	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ang	TokenNameIdentifier
=	TokenNameEQUAL
rotateAngle	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
value	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AnimatableMotionPointValue	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ang	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
cumulative	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Point2D	TokenNameIdentifier
p	TokenNameIdentifier
=	TokenNameEQUAL
pathLength	TokenNameIdentifier
.	TokenNameDOT
pointAtLength	TokenNameIdentifier
(	TokenNameLPAREN
pathLength	TokenNameIdentifier
.	TokenNameDOT
lengthOfPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
ang	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
rotateAuto	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ang	TokenNameIdentifier
=	TokenNameEQUAL
pathLength	TokenNameIdentifier
.	TokenNameDOT
angleAtLength	TokenNameIdentifier
(	TokenNameLPAREN
pathLength	TokenNameIdentifier
.	TokenNameDOT
lengthOfPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
rotateAutoReverse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ang	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
PI	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ang	TokenNameIdentifier
=	TokenNameEQUAL
rotateAngle	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
accumulation	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AnimatableMotionPointValue	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
p	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
ang	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
accumulation	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
value	TokenNameIdentifier
=	TokenNameEQUAL
value	TokenNameIdentifier
.	TokenNameDOT
interpolate	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
value	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
interpolation	TokenNameIdentifier
,	TokenNameCOMMA
accumulation	TokenNameIdentifier
,	TokenNameCOMMA
repeatIteration	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
value	TokenNameIdentifier
.	TokenNameDOT
hasChanged	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
markDirty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
