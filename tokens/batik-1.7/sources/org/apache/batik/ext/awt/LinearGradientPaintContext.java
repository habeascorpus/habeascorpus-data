package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
ext	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
Color	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
Rectangle	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
RenderingHints	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
geom	TokenNameIdentifier
.	TokenNameDOT
AffineTransform	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
geom	TokenNameIdentifier
.	TokenNameDOT
NoninvertibleTransformException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
geom	TokenNameIdentifier
.	TokenNameDOT
Point2D	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
geom	TokenNameIdentifier
.	TokenNameDOT
Rectangle2D	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
ColorModel	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
class	TokenNameclass
LinearGradientPaintContext	TokenNameIdentifier
extends	TokenNameextends
MultipleGradientPaintContext	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
float	TokenNamefloat
dgdX	TokenNameIdentifier
,	TokenNameCOMMA
dgdY	TokenNameIdentifier
,	TokenNameCOMMA
gc	TokenNameIdentifier
,	TokenNameCOMMA
pixSz	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DEFAULT_IMPL	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
ANTI_ALIAS_IMPL	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
fillMethod	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
LinearGradientPaintContext	TokenNameIdentifier
(	TokenNameLPAREN
ColorModel	TokenNameIdentifier
cm	TokenNameIdentifier
,	TokenNameCOMMA
Rectangle	TokenNameIdentifier
deviceBounds	TokenNameIdentifier
,	TokenNameCOMMA
Rectangle2D	TokenNameIdentifier
userBounds	TokenNameIdentifier
,	TokenNameCOMMA
AffineTransform	TokenNameIdentifier
t	TokenNameIdentifier
,	TokenNameCOMMA
RenderingHints	TokenNameIdentifier
hints	TokenNameIdentifier
,	TokenNameCOMMA
Point2D	TokenNameIdentifier
dStart	TokenNameIdentifier
,	TokenNameCOMMA
Point2D	TokenNameIdentifier
dEnd	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fractions	TokenNameIdentifier
,	TokenNameCOMMA
Color	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
colors	TokenNameIdentifier
,	TokenNameCOMMA
MultipleGradientPaint	TokenNameIdentifier
.	TokenNameDOT
CycleMethodEnum	TokenNameIdentifier
cycleMethod	TokenNameIdentifier
,	TokenNameCOMMA
MultipleGradientPaint	TokenNameIdentifier
.	TokenNameDOT
ColorSpaceEnum	TokenNameIdentifier
colorSpace	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
NoninvertibleTransformException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
cm	TokenNameIdentifier
,	TokenNameCOMMA
deviceBounds	TokenNameIdentifier
,	TokenNameCOMMA
userBounds	TokenNameIdentifier
,	TokenNameCOMMA
t	TokenNameIdentifier
,	TokenNameCOMMA
hints	TokenNameIdentifier
,	TokenNameCOMMA
fractions	TokenNameIdentifier
,	TokenNameCOMMA
colors	TokenNameIdentifier
,	TokenNameCOMMA
cycleMethod	TokenNameIdentifier
,	TokenNameCOMMA
colorSpace	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Point2D	TokenNameIdentifier
.	TokenNameDOT
Float	TokenNameIdentifier
start	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Point2D	TokenNameIdentifier
.	TokenNameDOT
Float	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
dStart	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
dStart	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Point2D	TokenNameIdentifier
.	TokenNameDOT
Float	TokenNameIdentifier
end	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Point2D	TokenNameIdentifier
.	TokenNameDOT
Float	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
dEnd	TokenNameIdentifier
.	TokenNameDOT
getX	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
dEnd	TokenNameIdentifier
.	TokenNameDOT
getY	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
dx	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
.	TokenNameDOT
x	TokenNameIdentifier
-	TokenNameMINUS
start	TokenNameIdentifier
.	TokenNameDOT
x	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
dy	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
.	TokenNameDOT
y	TokenNameIdentifier
-	TokenNameMINUS
start	TokenNameIdentifier
.	TokenNameDOT
y	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
dSq	TokenNameIdentifier
=	TokenNameEQUAL
dx	TokenNameIdentifier
*	TokenNameMULTIPLY
dx	TokenNameIdentifier
+	TokenNamePLUS
dy	TokenNameIdentifier
*	TokenNameMULTIPLY
dy	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
constX	TokenNameIdentifier
=	TokenNameEQUAL
dx	TokenNameIdentifier
/	TokenNameDIVIDE
dSq	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
constY	TokenNameIdentifier
=	TokenNameEQUAL
dy	TokenNameIdentifier
/	TokenNameDIVIDE
dSq	TokenNameIdentifier
;	TokenNameSEMICOLON
dgdX	TokenNameIdentifier
=	TokenNameEQUAL
a00	TokenNameIdentifier
*	TokenNameMULTIPLY
constX	TokenNameIdentifier
+	TokenNamePLUS
a10	TokenNameIdentifier
*	TokenNameMULTIPLY
constY	TokenNameIdentifier
;	TokenNameSEMICOLON
dgdY	TokenNameIdentifier
=	TokenNameEQUAL
a01	TokenNameIdentifier
*	TokenNameMULTIPLY
constX	TokenNameIdentifier
+	TokenNamePLUS
a11	TokenNameIdentifier
*	TokenNameMULTIPLY
constY	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
dgdXAbs	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
abs	TokenNameIdentifier
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
dgdYAbs	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
abs	TokenNameIdentifier
(	TokenNameLPAREN
dgdY	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dgdXAbs	TokenNameIdentifier
>	TokenNameGREATER
dgdYAbs	TokenNameIdentifier
)	TokenNameRPAREN
pixSz	TokenNameIdentifier
=	TokenNameEQUAL
dgdXAbs	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
pixSz	TokenNameIdentifier
=	TokenNameEQUAL
dgdYAbs	TokenNameIdentifier
;	TokenNameSEMICOLON
gc	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
a02	TokenNameIdentifier
-	TokenNameMINUS
start	TokenNameIdentifier
.	TokenNameDOT
x	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
constX	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
a12	TokenNameIdentifier
-	TokenNameMINUS
start	TokenNameIdentifier
.	TokenNameDOT
y	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
constY	TokenNameIdentifier
;	TokenNameSEMICOLON
Object	TokenNameIdentifier
colorRend	TokenNameIdentifier
=	TokenNameEQUAL
hints	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
RenderingHints	TokenNameIdentifier
.	TokenNameDOT
KEY_COLOR_RENDERING	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Object	TokenNameIdentifier
rend	TokenNameIdentifier
=	TokenNameEQUAL
hints	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
RenderingHints	TokenNameIdentifier
.	TokenNameDOT
KEY_RENDERING	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fillMethod	TokenNameIdentifier
=	TokenNameEQUAL
DEFAULT_IMPL	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
cycleMethod	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
MultipleGradientPaint	TokenNameIdentifier
.	TokenNameDOT
REPEAT	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
hasDiscontinuity	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
rend	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RenderingHints	TokenNameIdentifier
.	TokenNameDOT
VALUE_RENDER_QUALITY	TokenNameIdentifier
)	TokenNameRPAREN
fillMethod	TokenNameIdentifier
=	TokenNameEQUAL
ANTI_ALIAS_IMPL	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
colorRend	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RenderingHints	TokenNameIdentifier
.	TokenNameDOT
VALUE_COLOR_RENDER_SPEED	TokenNameIdentifier
)	TokenNameRPAREN
fillMethod	TokenNameIdentifier
=	TokenNameEQUAL
DEFAULT_IMPL	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
colorRend	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RenderingHints	TokenNameIdentifier
.	TokenNameDOT
VALUE_COLOR_RENDER_QUALITY	TokenNameIdentifier
)	TokenNameRPAREN
fillMethod	TokenNameIdentifier
=	TokenNameEQUAL
ANTI_ALIAS_IMPL	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
fillHardNoCycle	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
pixels	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
off	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
adjust	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
x	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
y	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
w	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
h	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
float	TokenNamefloat
initConst	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
x	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
gc	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
g	TokenNameIdentifier
=	TokenNameEQUAL
initConst	TokenNameIdentifier
+	TokenNamePLUS
dgdY	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
rowLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
val	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
g	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
val	TokenNameIdentifier
=	TokenNameEQUAL
gradientUnderflow	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
g	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
val	TokenNameIdentifier
=	TokenNameEQUAL
gradientOverflow	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
gradIdx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
gradIdx	TokenNameIdentifier
<	TokenNameLESS
gradientsLength	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
g	TokenNameIdentifier
<	TokenNameLESS
fractions	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
gradIdx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
float	TokenNamefloat
delta	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
g	TokenNameIdentifier
-	TokenNameMINUS
fractions	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
idx	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
delta	TokenNameIdentifier
*	TokenNameMULTIPLY
GRADIENT_SIZE_INDEX	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
normalizedIntervals	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
+	TokenNamePLUS
0.5f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
val	TokenNameIdentifier
=	TokenNameEQUAL
gradients	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
idx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
rowLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
val	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
gradSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
preGradSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
preVal	TokenNameIdentifier
,	TokenNameCOMMA
postVal	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
gradStepsF	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
preGradStepsF	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
gradStepsF	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
-	TokenNameMINUS
g	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
dgdX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
preGradStepsF	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
ceil	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
-	TokenNameMINUS
g	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
dgdX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
preVal	TokenNameIdentifier
=	TokenNameEQUAL
gradientUnderflow	TokenNameIdentifier
;	TokenNameSEMICOLON
postVal	TokenNameIdentifier
=	TokenNameEQUAL
gradientOverflow	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
gradStepsF	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
-	TokenNameMINUS
g	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
dgdX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
preGradStepsF	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
ceil	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
-	TokenNameMINUS
g	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
dgdX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
preVal	TokenNameIdentifier
=	TokenNameEQUAL
gradientOverflow	TokenNameIdentifier
;	TokenNameSEMICOLON
postVal	TokenNameIdentifier
=	TokenNameEQUAL
gradientUnderflow	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
gradStepsF	TokenNameIdentifier
>	TokenNameGREATER
w	TokenNameIdentifier
)	TokenNameRPAREN
gradSteps	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
gradSteps	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
gradStepsF	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
preGradStepsF	TokenNameIdentifier
>	TokenNameGREATER
w	TokenNameIdentifier
)	TokenNameRPAREN
preGradSteps	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
preGradSteps	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
preGradStepsF	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
gradLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
gradSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
preGradSteps	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
preGradLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
preGradSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
preGradLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
preVal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
preGradSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
gradIdx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
gradIdx	TokenNameIdentifier
<	TokenNameLESS
gradientsLength	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
g	TokenNameIdentifier
<	TokenNameLESS
fractions	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
gradIdx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
gradLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
delta	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
g	TokenNameIdentifier
-	TokenNameMINUS
fractions	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
grad	TokenNameIdentifier
=	TokenNameEQUAL
gradients	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
double	TokenNamedouble
stepsD	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
ceil	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
fractions	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-	TokenNameMINUS
g	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
dgdX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
steps	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
stepsD	TokenNameIdentifier
>	TokenNameGREATER
w	TokenNameIdentifier
)	TokenNameRPAREN
steps	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
steps	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
stepsD	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
subGradLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
steps	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
subGradLimit	TokenNameIdentifier
>	TokenNameGREATER
gradLimit	TokenNameIdentifier
)	TokenNameRPAREN
subGradLimit	TokenNameIdentifier
=	TokenNameEQUAL
gradLimit	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
delta	TokenNameIdentifier
*	TokenNameMULTIPLY
GRADIENT_SIZE_INDEX	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
normalizedIntervals	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
*	TokenNameMULTIPLY
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
16	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
15	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
step	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
GRADIENT_SIZE_INDEX	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
normalizedIntervals	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
*	TokenNameMULTIPLY
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
16	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
subGradLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
grad	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
step	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
stepsD	TokenNameIdentifier
;	TokenNameSEMICOLON
gradIdx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
gradIdx	TokenNameIdentifier
=	TokenNameEQUAL
gradientsLength	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
gradIdx	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
g	TokenNameIdentifier
>	TokenNameGREATER
fractions	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
gradIdx	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
gradLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
delta	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
g	TokenNameIdentifier
-	TokenNameMINUS
fractions	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
grad	TokenNameIdentifier
=	TokenNameEQUAL
gradients	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
double	TokenNamedouble
stepsD	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
ceil	TokenNameIdentifier
(	TokenNameLPAREN
delta	TokenNameIdentifier
/	TokenNameDIVIDE
-	TokenNameMINUS
dgdX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
steps	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
stepsD	TokenNameIdentifier
>	TokenNameGREATER
w	TokenNameIdentifier
)	TokenNameRPAREN
steps	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
steps	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
stepsD	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
subGradLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
steps	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
subGradLimit	TokenNameIdentifier
>	TokenNameGREATER
gradLimit	TokenNameIdentifier
)	TokenNameRPAREN
subGradLimit	TokenNameIdentifier
=	TokenNameEQUAL
gradLimit	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
delta	TokenNameIdentifier
*	TokenNameMULTIPLY
GRADIENT_SIZE_INDEX	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
normalizedIntervals	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
*	TokenNameMULTIPLY
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
16	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
15	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
step	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
GRADIENT_SIZE_INDEX	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
normalizedIntervals	TokenNameIdentifier
[	TokenNameLBRACKET
gradIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
*	TokenNameMULTIPLY
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
16	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
subGradLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
grad	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
step	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
stepsD	TokenNameIdentifier
;	TokenNameSEMICOLON
gradIdx	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
rowLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
postVal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
off	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
adjust	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
fillSimpleNoCycle	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
pixels	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
off	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
adjust	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
x	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
y	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
w	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
h	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
float	TokenNamefloat
initConst	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
x	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
gc	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
float	TokenNamefloat
step	TokenNameIdentifier
=	TokenNameEQUAL
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
fastGradientArraySize	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
fpStep	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
step	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
16	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
grad	TokenNameIdentifier
=	TokenNameEQUAL
gradient	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
g	TokenNameIdentifier
=	TokenNameEQUAL
initConst	TokenNameIdentifier
+	TokenNamePLUS
dgdY	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
g	TokenNameIdentifier
*=	TokenNameMULTIPLY_EQUAL
fastGradientArraySize	TokenNameIdentifier
;	TokenNameSEMICOLON
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
0.5	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
rowLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
check	TokenNameIdentifier
=	TokenNameEQUAL
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
fastGradientArraySize	TokenNameIdentifier
*	TokenNameMULTIPLY
w	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
check	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
check	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
check	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
check	TokenNameIdentifier
<	TokenNameLESS
.3	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
val	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
g	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
val	TokenNameIdentifier
=	TokenNameEQUAL
gradientUnderflow	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
g	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
fastGradientArraySize	TokenNameIdentifier
)	TokenNameRPAREN
val	TokenNameIdentifier
=	TokenNameEQUAL
gradientOverflow	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
val	TokenNameIdentifier
=	TokenNameEQUAL
grad	TokenNameIdentifier
[	TokenNameLBRACKET
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
g	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
rowLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
val	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
gradSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
preGradSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
preVal	TokenNameIdentifier
,	TokenNameCOMMA
postVal	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
gradSteps	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
fastGradientArraySize	TokenNameIdentifier
-	TokenNameMINUS
g	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
step	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
preGradSteps	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
ceil	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
-	TokenNameMINUS
g	TokenNameIdentifier
/	TokenNameDIVIDE
step	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
preVal	TokenNameIdentifier
=	TokenNameEQUAL
gradientUnderflow	TokenNameIdentifier
;	TokenNameSEMICOLON
postVal	TokenNameIdentifier
=	TokenNameEQUAL
gradientOverflow	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
gradSteps	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
-	TokenNameMINUS
g	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
step	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
preGradSteps	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
ceil	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
fastGradientArraySize	TokenNameIdentifier
-	TokenNameMINUS
g	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
step	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
preVal	TokenNameIdentifier
=	TokenNameEQUAL
gradientOverflow	TokenNameIdentifier
;	TokenNameSEMICOLON
postVal	TokenNameIdentifier
=	TokenNameEQUAL
gradientUnderflow	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
gradSteps	TokenNameIdentifier
>	TokenNameGREATER
w	TokenNameIdentifier
)	TokenNameRPAREN
gradSteps	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
gradLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
gradSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
preGradSteps	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
preGradSteps	TokenNameIdentifier
>	TokenNameGREATER
w	TokenNameIdentifier
)	TokenNameRPAREN
preGradSteps	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
preGradLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
preGradSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
preGradLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
preVal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
step	TokenNameIdentifier
*	TokenNameMULTIPLY
preGradSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
fpG	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
g	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
16	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
gradLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
grad	TokenNameIdentifier
[	TokenNameLBRACKET
fpG	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
fpG	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
fpStep	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
rowLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
postVal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
off	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
adjust	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
fillSimpleRepeat	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
pixels	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
off	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
adjust	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
x	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
y	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
w	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
h	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
float	TokenNamefloat
initConst	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
x	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
gc	TokenNameIdentifier
;	TokenNameSEMICOLON
float	TokenNamefloat
step	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
-	TokenNameMINUS
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
dgdX	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
fastGradientArraySize	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
step	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
step	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
fastGradientArraySize	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
grad	TokenNameIdentifier
=	TokenNameEQUAL
gradient	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
g	TokenNameIdentifier
=	TokenNameEQUAL
initConst	TokenNameIdentifier
+	TokenNamePLUS
dgdY	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
g	TokenNameIdentifier
=	TokenNameEQUAL
g	TokenNameIdentifier
-	TokenNameMINUS
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
g	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
g	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
g	TokenNameIdentifier
*=	TokenNameMULTIPLY_EQUAL
fastGradientArraySize	TokenNameIdentifier
;	TokenNameSEMICOLON
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
0.5	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
rowLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
rowLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
g	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
idx	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
fastGradientArraySize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
g	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
fastGradientArraySize	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
fastGradientArraySize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
grad	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
step	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
off	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
adjust	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
fillSimpleReflect	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
pixels	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
off	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
adjust	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
x	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
y	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
w	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
h	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
float	TokenNamefloat
initConst	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
x	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
gc	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
grad	TokenNameIdentifier
=	TokenNameEQUAL
gradient	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
g	TokenNameIdentifier
=	TokenNameEQUAL
initConst	TokenNameIdentifier
+	TokenNamePLUS
dgdY	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
g	TokenNameIdentifier
=	TokenNameEQUAL
g	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
(	TokenNameLPAREN
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
g	TokenNameIdentifier
/	TokenNameDIVIDE
2.0f	TokenNameFloatingPointLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
step	TokenNameIdentifier
=	TokenNameEQUAL
dgdX	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
g	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
g	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
g	TokenNameIdentifier
;	TokenNameSEMICOLON
step	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
step	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
step	TokenNameIdentifier
=	TokenNameEQUAL
step	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
(	TokenNameLPAREN
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
step	TokenNameIdentifier
/	TokenNameDIVIDE
2.0f	TokenNameFloatingPointLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
step	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
step	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2.0	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
reflectMax	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
fastGradientArraySize	TokenNameIdentifier
;	TokenNameSEMICOLON
g	TokenNameIdentifier
*=	TokenNameMULTIPLY_EQUAL
fastGradientArraySize	TokenNameIdentifier
;	TokenNameSEMICOLON
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
0.5	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
step	TokenNameIdentifier
*=	TokenNameMULTIPLY_EQUAL
fastGradientArraySize	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
rowLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
rowLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
g	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
idx	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
reflectMax	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
g	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
reflectMax	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
reflectMax	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
idx	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
fastGradientArraySize	TokenNameIdentifier
)	TokenNameRPAREN
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
grad	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
else	TokenNameelse
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
grad	TokenNameIdentifier
[	TokenNameLBRACKET
reflectMax	TokenNameIdentifier
-	TokenNameMINUS
idx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
step	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
off	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
adjust	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
fillRaster	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
pixels	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
off	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
adjust	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
x	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
y	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
w	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
h	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
float	TokenNamefloat
initConst	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
dgdX	TokenNameIdentifier
*	TokenNameMULTIPLY
x	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
gc	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fillMethod	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ANTI_ALIAS_IMPL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
g	TokenNameIdentifier
=	TokenNameEQUAL
initConst	TokenNameIdentifier
+	TokenNamePLUS
dgdY	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
rowLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
rowLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
indexGradientAntiAlias	TokenNameIdentifier
(	TokenNameLPAREN
g	TokenNameIdentifier
,	TokenNameCOMMA
pixSz	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dgdX	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
off	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
adjust	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isSimpleLookup	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cycleMethod	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
MultipleGradientPaint	TokenNameIdentifier
.	TokenNameDOT
NO_CYCLE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fillHardNoCycle	TokenNameIdentifier
(	TokenNameLPAREN
pixels	TokenNameIdentifier
,	TokenNameCOMMA
off	TokenNameIdentifier
,	TokenNameCOMMA
adjust	TokenNameIdentifier
,	TokenNameCOMMA
x	TokenNameIdentifier
,	TokenNameCOMMA
y	TokenNameIdentifier
,	TokenNameCOMMA
w	TokenNameIdentifier
,	TokenNameCOMMA
h	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
g	TokenNameIdentifier
=	TokenNameEQUAL
initConst	TokenNameIdentifier
+	TokenNamePLUS
dgdY	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
rowLimit	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
off	TokenNameIdentifier
<	TokenNameLESS
rowLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pixels	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
indexIntoGradientsArrays	TokenNameIdentifier
(	TokenNameLPAREN
g	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
g	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dgdX	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
off	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
adjust	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cycleMethod	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
MultipleGradientPaint	TokenNameIdentifier
.	TokenNameDOT
NO_CYCLE	TokenNameIdentifier
)	TokenNameRPAREN
fillSimpleNoCycle	TokenNameIdentifier
(	TokenNameLPAREN
pixels	TokenNameIdentifier
,	TokenNameCOMMA
off	TokenNameIdentifier
,	TokenNameCOMMA
adjust	TokenNameIdentifier
,	TokenNameCOMMA
x	TokenNameIdentifier
,	TokenNameCOMMA
y	TokenNameIdentifier
,	TokenNameCOMMA
w	TokenNameIdentifier
,	TokenNameCOMMA
h	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
cycleMethod	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
MultipleGradientPaint	TokenNameIdentifier
.	TokenNameDOT
REPEAT	TokenNameIdentifier
)	TokenNameRPAREN
fillSimpleRepeat	TokenNameIdentifier
(	TokenNameLPAREN
pixels	TokenNameIdentifier
,	TokenNameCOMMA
off	TokenNameIdentifier
,	TokenNameCOMMA
adjust	TokenNameIdentifier
,	TokenNameCOMMA
x	TokenNameIdentifier
,	TokenNameCOMMA
y	TokenNameIdentifier
,	TokenNameCOMMA
w	TokenNameIdentifier
,	TokenNameCOMMA
h	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
fillSimpleReflect	TokenNameIdentifier
(	TokenNameLPAREN
pixels	TokenNameIdentifier
,	TokenNameCOMMA
off	TokenNameIdentifier
,	TokenNameCOMMA
adjust	TokenNameIdentifier
,	TokenNameCOMMA
x	TokenNameIdentifier
,	TokenNameCOMMA
y	TokenNameIdentifier
,	TokenNameCOMMA
w	TokenNameIdentifier
,	TokenNameCOMMA
h	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
