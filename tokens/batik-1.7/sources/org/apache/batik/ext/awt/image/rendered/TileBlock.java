package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
ext	TokenNameIdentifier
.	TokenNameDOT
awt	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
rendered	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
TileBlock	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
occX	TokenNameIdentifier
,	TokenNameCOMMA
occY	TokenNameIdentifier
,	TokenNameCOMMA
occW	TokenNameIdentifier
,	TokenNameCOMMA
occH	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
xOff	TokenNameIdentifier
,	TokenNameCOMMA
yOff	TokenNameIdentifier
,	TokenNameCOMMA
w	TokenNameIdentifier
,	TokenNameCOMMA
h	TokenNameIdentifier
,	TokenNameCOMMA
benefit	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
occupied	TokenNameIdentifier
;	TokenNameSEMICOLON
TileBlock	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
occX	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
occY	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
occW	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
occH	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
occupied	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
xOff	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
yOff	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
w	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
h	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
occX	TokenNameIdentifier
=	TokenNameEQUAL
occX	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
occY	TokenNameIdentifier
=	TokenNameEQUAL
occY	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
occW	TokenNameIdentifier
=	TokenNameEQUAL
occW	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
occH	TokenNameIdentifier
=	TokenNameEQUAL
occH	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
xOff	TokenNameIdentifier
=	TokenNameEQUAL
xOff	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
yOff	TokenNameIdentifier
=	TokenNameEQUAL
yOff	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
w	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
h	TokenNameIdentifier
=	TokenNameEQUAL
h	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
occupied	TokenNameIdentifier
=	TokenNameEQUAL
occupied	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
y	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
y	TokenNameIdentifier
<	TokenNameLESS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
y	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
x	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
x	TokenNameIdentifier
<	TokenNameLESS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
x	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
occupied	TokenNameIdentifier
[	TokenNameLBRACKET
x	TokenNameIdentifier
+	TokenNamePLUS
xOff	TokenNameIdentifier
+	TokenNamePLUS
occW	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
yOff	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
)	TokenNameRPAREN
benefit	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
ret	TokenNameIdentifier
=	TokenNameEQUAL
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
y	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
y	TokenNameIdentifier
<	TokenNameLESS
occH	TokenNameIdentifier
;	TokenNameSEMICOLON
y	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
x	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
x	TokenNameIdentifier
<	TokenNameLESS
occW	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
x	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
x	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
xOff	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
x	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
xOff	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
y	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
yOff	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
y	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
yOff	TokenNameIdentifier
+	TokenNamePLUS
h	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
ret	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
"+"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
y	TokenNameIdentifier
>	TokenNameGREATER
yOff	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
y	TokenNameIdentifier
<	TokenNameLESS
yOff	TokenNameIdentifier
+	TokenNamePLUS
h	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
ret	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
"|"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
ret	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
" "	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
y	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
yOff	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
x	TokenNameIdentifier
>	TokenNameGREATER
xOff	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
x	TokenNameIdentifier
<	TokenNameLESS
xOff	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
ret	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
"-"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
y	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
yOff	TokenNameIdentifier
+	TokenNamePLUS
h	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
x	TokenNameIdentifier
>	TokenNameGREATER
xOff	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
x	TokenNameIdentifier
<	TokenNameLESS
xOff	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
ret	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
"_"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
ret	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
" "	TokenNameStringLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
x	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
occW	TokenNameIdentifier
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
occupied	TokenNameIdentifier
[	TokenNameLBRACKET
x	TokenNameIdentifier
+	TokenNamePLUS
y	TokenNameIdentifier
*	TokenNameMULTIPLY
occW	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
ret	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
"*"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
ret	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
"."	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ret	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
" "	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
getXLoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
occX	TokenNameIdentifier
+	TokenNamePLUS
xOff	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
getYLoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
occY	TokenNameIdentifier
+	TokenNamePLUS
yOff	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
getWidth	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
w	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
getHeight	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
h	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
getBenefit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
benefit	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
getWork	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
w	TokenNameIdentifier
*	TokenNameMULTIPLY
h	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
int	TokenNameint
getWork	TokenNameIdentifier
(	TokenNameLPAREN
TileBlock	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
blocks	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ret	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
blocks	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
ret	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
blocks	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getWork	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
TileBlock	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getBestSplit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
simplify	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
benefit	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
w	TokenNameIdentifier
*	TokenNameMULTIPLY
h	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
new	TokenNamenew
TileBlock	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
this	TokenNamethis
}	TokenNameRBRACE
;	TokenNameSEMICOLON
return	TokenNamereturn
splitOneGo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
TileBlock	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
splitOneGo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
filled	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
)	TokenNameRPAREN
occupied	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
List	TokenNameIdentifier
items	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
y	TokenNameIdentifier
=	TokenNameEQUAL
yOff	TokenNameIdentifier
;	TokenNameSEMICOLON
y	TokenNameIdentifier
<	TokenNameLESS
yOff	TokenNameIdentifier
+	TokenNamePLUS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
y	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
x	TokenNameIdentifier
=	TokenNameEQUAL
xOff	TokenNameIdentifier
;	TokenNameSEMICOLON
x	TokenNameIdentifier
<	TokenNameLESS
xOff	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
x	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
filled	TokenNameIdentifier
[	TokenNameLBRACKET
x	TokenNameIdentifier
+	TokenNamePLUS
y	TokenNameIdentifier
*	TokenNameMULTIPLY
occW	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
cw	TokenNameIdentifier
=	TokenNameEQUAL
xOff	TokenNameIdentifier
+	TokenNamePLUS
w	TokenNameIdentifier
-	TokenNameMINUS
x	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
cx	TokenNameIdentifier
=	TokenNameEQUAL
x	TokenNameIdentifier
;	TokenNameSEMICOLON
cx	TokenNameIdentifier
<	TokenNameLESS
x	TokenNameIdentifier
+	TokenNamePLUS
cw	TokenNameIdentifier
;	TokenNameSEMICOLON
cx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
filled	TokenNameIdentifier
[	TokenNameLBRACKET
cx	TokenNameIdentifier
+	TokenNamePLUS
y	TokenNameIdentifier
*	TokenNameMULTIPLY
occW	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
cw	TokenNameIdentifier
=	TokenNameEQUAL
cx	TokenNameIdentifier
-	TokenNameMINUS
x	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
filled	TokenNameIdentifier
[	TokenNameLBRACKET
cx	TokenNameIdentifier
+	TokenNamePLUS
y	TokenNameIdentifier
*	TokenNameMULTIPLY
occW	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
cy	TokenNameIdentifier
=	TokenNameEQUAL
y	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
cy	TokenNameIdentifier
<	TokenNameLESS
yOff	TokenNameIdentifier
+	TokenNamePLUS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
cy	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
cx	TokenNameIdentifier
=	TokenNameEQUAL
x	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
cx	TokenNameIdentifier
<	TokenNameLESS
x	TokenNameIdentifier
+	TokenNamePLUS
cw	TokenNameIdentifier
;	TokenNameSEMICOLON
cx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
filled	TokenNameIdentifier
[	TokenNameLBRACKET
cx	TokenNameIdentifier
+	TokenNamePLUS
cy	TokenNameIdentifier
*	TokenNameMULTIPLY
occW	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
x	TokenNameIdentifier
+	TokenNamePLUS
cw	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
cx	TokenNameIdentifier
=	TokenNameEQUAL
x	TokenNameIdentifier
;	TokenNameSEMICOLON
cx	TokenNameIdentifier
<	TokenNameLESS
x	TokenNameIdentifier
+	TokenNamePLUS
cw	TokenNameIdentifier
;	TokenNameSEMICOLON
cx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
filled	TokenNameIdentifier
[	TokenNameLBRACKET
cx	TokenNameIdentifier
+	TokenNamePLUS
cy	TokenNameIdentifier
*	TokenNameMULTIPLY
occW	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
items	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
TileBlock	TokenNameIdentifier
(	TokenNameLPAREN
occX	TokenNameIdentifier
,	TokenNameCOMMA
occY	TokenNameIdentifier
,	TokenNameCOMMA
occW	TokenNameIdentifier
,	TokenNameCOMMA
occH	TokenNameIdentifier
,	TokenNameCOMMA
occupied	TokenNameIdentifier
,	TokenNameCOMMA
x	TokenNameIdentifier
,	TokenNameCOMMA
y	TokenNameIdentifier
,	TokenNameCOMMA
cw	TokenNameIdentifier
,	TokenNameCOMMA
ch	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
x	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
(	TokenNameLPAREN
cw	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
TileBlock	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
ret	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
TileBlock	TokenNameIdentifier
[	TokenNameLBRACKET
items	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
items	TokenNameIdentifier
.	TokenNameDOT
toArray	TokenNameIdentifier
(	TokenNameLPAREN
ret	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
simplify	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
workOccupied	TokenNameIdentifier
=	TokenNameEQUAL
occupied	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
y	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
y	TokenNameIdentifier
<	TokenNameLESS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
y	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
x	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
x	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
x	TokenNameIdentifier
<	TokenNameLESS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
x	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
workOccupied	TokenNameIdentifier
[	TokenNameLBRACKET
x	TokenNameIdentifier
+	TokenNamePLUS
xOff	TokenNameIdentifier
+	TokenNamePLUS
occW	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
yOff	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
x	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
w	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
yOff	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
y	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
h	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
h	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
y	TokenNameIdentifier
=	TokenNameEQUAL
h	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
y	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
y	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
x	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
x	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
x	TokenNameIdentifier
<	TokenNameLESS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
x	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
workOccupied	TokenNameIdentifier
[	TokenNameLBRACKET
x	TokenNameIdentifier
+	TokenNamePLUS
xOff	TokenNameIdentifier
+	TokenNamePLUS
occW	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
yOff	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
x	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
w	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
h	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
x	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
x	TokenNameIdentifier
<	TokenNameLESS
w	TokenNameIdentifier
;	TokenNameSEMICOLON
x	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
y	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
y	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
y	TokenNameIdentifier
<	TokenNameLESS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
y	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
workOccupied	TokenNameIdentifier
[	TokenNameLBRACKET
x	TokenNameIdentifier
+	TokenNamePLUS
xOff	TokenNameIdentifier
+	TokenNamePLUS
occW	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
yOff	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
y	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
h	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
xOff	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
x	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
w	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
x	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
x	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
x	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
y	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
y	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
y	TokenNameIdentifier
<	TokenNameLESS
h	TokenNameIdentifier
;	TokenNameSEMICOLON
y	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
workOccupied	TokenNameIdentifier
[	TokenNameLBRACKET
x	TokenNameIdentifier
+	TokenNamePLUS
xOff	TokenNameIdentifier
+	TokenNamePLUS
occW	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
y	TokenNameIdentifier
+	TokenNamePLUS
yOff	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
y	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
h	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
w	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
