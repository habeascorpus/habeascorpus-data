package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
InputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
Reader	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Locale	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
MissingResourceException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
i18n	TokenNameIdentifier
.	TokenNameDOT
Localizable	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
i18n	TokenNameIdentifier
.	TokenNameDOT
LocalizableSupport	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
NormalizingReader	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
StreamNormalizingReader	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
batik	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
StringNormalizingReader	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
XMLScanner	TokenNameIdentifier
implements	TokenNameimplements
Localizable	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DOCUMENT_START_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
TOP_LEVEL_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
PI_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
XML_DECL_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DOCTYPE_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
START_TAG_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
5	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
CONTENT_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DTD_DECLARATIONS_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
7	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
CDATA_SECTION_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
END_TAG_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
9	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
ATTRIBUTE_VALUE_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
ATTLIST_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
11	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
ELEMENT_DECLARATION_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
12	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
ENTITY_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
13	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
NOTATION_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
14	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
NOTATION_TYPE_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
15	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
ENUMERATION_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
ENTITY_VALUE_CONTEXT	TokenNameIdentifier
=	TokenNameEQUAL
17	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
final	TokenNamefinal
String	TokenNameIdentifier
BUNDLE_CLASSNAME	TokenNameIdentifier
=	TokenNameEQUAL
"org.apache.batik.xml.resources.Messages"	TokenNameStringLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
LocalizableSupport	TokenNameIdentifier
localizableSupport	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
LocalizableSupport	TokenNameIdentifier
(	TokenNameLPAREN
BUNDLE_CLASSNAME	TokenNameIdentifier
,	TokenNameCOMMA
XMLScanner	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
.	TokenNameDOT
getClassLoader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
NormalizingReader	TokenNameIdentifier
reader	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
current	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
type	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
buffer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
1024	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
position	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
start	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
end	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
context	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
depth	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
piEndRead	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
inDTD	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
char	TokenNamechar
attrDelimiter	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
boolean	TokenNameboolean
cdataEndRead	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
XMLScanner	TokenNameIdentifier
(	TokenNameLPAREN
Reader	TokenNameIdentifier
r	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
DOCUMENT_START_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
reader	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StreamNormalizingReader	TokenNameIdentifier
(	TokenNameLPAREN
r	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
current	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
XMLScanner	TokenNameIdentifier
(	TokenNameLPAREN
InputStream	TokenNameIdentifier
is	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
enc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
DOCUMENT_START_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
reader	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StreamNormalizingReader	TokenNameIdentifier
(	TokenNameLPAREN
is	TokenNameIdentifier
,	TokenNameCOMMA
enc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
current	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
XMLScanner	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
s	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
DOCUMENT_START_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
reader	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringNormalizingReader	TokenNameIdentifier
(	TokenNameLPAREN
s	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
current	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setLocale	TokenNameIdentifier
(	TokenNameLPAREN
Locale	TokenNameIdentifier
l	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
localizableSupport	TokenNameIdentifier
.	TokenNameDOT
setLocale	TokenNameIdentifier
(	TokenNameLPAREN
l	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Locale	TokenNameIdentifier
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
localizableSupport	TokenNameIdentifier
.	TokenNameDOT
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
formatMessage	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
key	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
args	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MissingResourceException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
localizableSupport	TokenNameIdentifier
.	TokenNameDOT
formatMessage	TokenNameIdentifier
(	TokenNameLPAREN
key	TokenNameIdentifier
,	TokenNameCOMMA
args	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setDepth	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
depth	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getDepth	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
depth	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setContext	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
c	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getContext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
context	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
type	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getLine	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
reader	TokenNameIdentifier
.	TokenNameDOT
getLine	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getColumn	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
reader	TokenNameIdentifier
.	TokenNameDOT
getColumn	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
buffer	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getStart	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
start	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getEnd	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
end	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
char	TokenNamechar
getStringDelimiter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
attrDelimiter	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getStartOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
SECTION_END	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
-	TokenNameMINUS
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_END	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
-	TokenNameMINUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ENTITY_REFERENCE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PARAMETER_ENTITY_REFERENCE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
START_TAG	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
FIRST_ATTRIBUTE_FRAGMENT	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_START	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
END_TAG	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
CHARACTER_REFERENCE	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
COMMENT	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getEndOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ENTITY_REFERENCE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
CHARACTER_REFERENCE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PARAMETER_ENTITY_REFERENCE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
LAST_ATTRIBUTE_FRAGMENT	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_DATA	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
-	TokenNameMINUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
COMMENT	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
-	TokenNameMINUS
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
case	TokenNamecase
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
CHARACTER_DATA	TokenNameIdentifier
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
cdataEndRead	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
-	TokenNameMINUS
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
clearBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
position	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
position	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
buffer	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
buffer	TokenNameIdentifier
[	TokenNameLBRACKET
position	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
position	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
next	TokenNameIdentifier
(	TokenNameLPAREN
context	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
next	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
ctx	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
start	TokenNameIdentifier
=	TokenNameEQUAL
position	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
ctx	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
DOCUMENT_START_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInDocumentStart	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
TOP_LEVEL_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInTopLevel	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
PI_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInPI	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
START_TAG_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInStartTag	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
ATTRIBUTE_VALUE_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInAttributeValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
CONTENT_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInContent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
END_TAG_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInEndTag	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
CDATA_SECTION_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInCDATASection	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
XML_DECL_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInXMLDecl	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
DOCTYPE_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInDoctype	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
DTD_DECLARATIONS_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInDTDDeclarations	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
ELEMENT_DECLARATION_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInElementDeclaration	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
ATTLIST_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInAttList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
NOTATION_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInNotation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
ENTITY_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
type	TokenNameIdentifier
=	TokenNameEQUAL
nextInEntity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
ENTITY_VALUE_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
nextInEntityValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
NOTATION_TYPE_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
nextInNotationType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
ENUMERATION_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
nextInEnumeration	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected ctx:"	TokenNameStringLiteral
+	TokenNamePLUS
ctx	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
XMLException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
end	TokenNameIdentifier
=	TokenNameEQUAL
position	TokenNameIdentifier
-	TokenNameMINUS
(	TokenNameLPAREN
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
0	TokenNameIntegerLiteral
:	TokenNameCOLON
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
type	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInDocumentStart	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
depth	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
TOP_LEVEL_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
CONTENT_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'?'	TokenNameCharacterLiteral
:	TokenNameCOLON
int	TokenNameint
c1	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameFirstCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
c1	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.pi.target"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
PI_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
c2	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
c2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_START	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
c3	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c3	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
c3	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_START	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
c4	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c4	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
c4	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_START	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
c1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'x'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
c2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'm'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
c3	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'l'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
XML_DECL_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
XML_DECL_START	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
c1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'x'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'X'	TokenNameCharacterLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
c2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'm'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'M'	TokenNameCharacterLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
c3	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'l'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c3	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'L'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"xml.reserved"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_START	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'!'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'-'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readComment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'D'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
DOCTYPE_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"OCTYPE"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
DOCTYPE_START	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.doctype"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
START_TAG_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
depth	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
START_TAG	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
EOF	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
depth	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
nextInContent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInTopLevel	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'?'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
PI_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readPIStart	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'!'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'-'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readComment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'D'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
DOCTYPE_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"OCTYPE"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
DOCTYPE_START	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
START_TAG_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
depth	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
START_TAG	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
EOF	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInPI	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
piEndRead	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
piEndRead	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
depth	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
TOP_LEVEL_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
CONTENT_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_END	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'?'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
'>'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"pi.end.expected"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
inDTD	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
DTD_DECLARATIONS_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
depth	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
TOP_LEVEL_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
CONTENT_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_END	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'?'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'>'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
piEndRead	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_DATA	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInStartTag	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'/'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
'>'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"malformed.tag.end"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
depth	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
TOP_LEVEL_CONTEXT	TokenNameIdentifier
:	TokenNameCOLON
CONTENT_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
EMPTY_ELEMENT_END	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
CONTENT_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
END_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'='	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'"'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ATTRIBUTE_VALUE_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
FIRST_ATTRIBUTE_FRAGMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'\''	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ATTRIBUTE_VALUE_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
FIRST_ATTRIBUTE_FRAGMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInAttributeValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
EOF	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'&'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
readReference	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
loop	TokenNameIdentifier
:	TokenNameCOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
break	TokenNamebreak
loop	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
attrDelimiter	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
loop	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ATTRIBUTE_FRAGMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
inDTD	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
ATTLIST_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
START_TAG_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
LAST_ATTRIBUTE_FRAGMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInContent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
EOF	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readReference	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'?'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
PI_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readPIStart	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'!'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'-'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readComment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'['	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
CDATA_SECTION_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"CDATA["	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
CDATA_START	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
'/'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
END_TAG_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
END_TAG	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
depth	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
START_TAG_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
START_TAG	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
loop	TokenNameIdentifier
:	TokenNameCOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
default	TokenNamedefault
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
break	TokenNamebreak
loop	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
CHARACTER_DATA	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInEndTag	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
depth	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.end.tag"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
depth	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
TOP_LEVEL_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
context	TokenNameIdentifier
=	TokenNameEQUAL
CONTENT_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
END_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInCDATASection	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cdataEndRead	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
cdataEndRead	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
CONTENT_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
SECTION_END	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
']'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
']'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'>'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cdataEndRead	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
CHARACTER_DATA	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInXMLDecl	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'v'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"ersion"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
VERSION_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'e'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"ncoding"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ENCODING_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
's'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"tandalone"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STANDALONE_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'='	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
EQ	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'?'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'>'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"pi.end.expected"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
TOP_LEVEL_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_END	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'"'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
readString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'\''	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
readString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInDoctype	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
TOP_LEVEL_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
END_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'S'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"YSTEM"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
SYSTEM_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'P'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"UBLIC"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PUBLIC_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'"'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
readString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'\''	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
readString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'['	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
DTD_DECLARATIONS_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
inDTD	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
LSQUARE_BRACKET	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInDTDDeclarations	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
']'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
DOCTYPE_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
inDTD	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
RSQUARE_BRACKET	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'%'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readPEReference	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'?'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
PI_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readPIStart	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'!'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'-'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readComment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'E'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'L'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ELEMENT_DECLARATION_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"EMENT"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ELEMENT_DECLARATION_START	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'N'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ENTITY_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"TITY"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ENTITY_START	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
'A'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ATTLIST_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"TTLIST"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ATTLIST_START	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'N'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
NOTATION_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"OTATION"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NOTATION_START	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
readString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
attrDelimiter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
readComment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
'-'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"malformed.comment"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
c	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
c	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
c	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
c	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'-'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
c	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
c	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'-'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
c	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'>'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"malformed.comment"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
COMMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
s	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
type	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
ntype	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
s	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
s	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ntype	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
ntype	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
type	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
readName	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
type	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameFirstCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.name"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
type	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
readPIStart	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
c1	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameFirstCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"malformed.pi.target"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
c2	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
c2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_START	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
c3	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c3	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
c3	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_START	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
c4	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c4	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
c4	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_START	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
c1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'x'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'X'	TokenNameCharacterLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
c2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'm'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'M'	TokenNameCharacterLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
c3	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'l'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c3	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'L'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"xml.reserved"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PI_START	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInElementDeclaration	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
DTD_DECLARATIONS_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
END_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'%'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
t	TokenNameIdentifier
=	TokenNameEQUAL
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PARAMETER_ENTITY_REFERENCE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
';'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"malformed.parameter.entity"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
t	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'E'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"MPTY"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
EMPTY_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'A'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"NY"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ANY_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'?'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
QUESTION	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'+'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PLUS	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'*'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STAR	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'('	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
LEFT_BRACE	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
')'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
RIGHT_BRACE	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'|'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PIPE	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
','	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
COMMA	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'#'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"PCDATA"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PCDATA_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInAttList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
DTD_DECLARATIONS_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
type	TokenNameIdentifier
=	TokenNameEQUAL
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
END_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'%'	TokenNameCharacterLiteral
:	TokenNameCOLON
int	TokenNameint
t	TokenNameIdentifier
=	TokenNameEQUAL
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PARAMETER_ENTITY_REFERENCE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
';'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"malformed.parameter.entity"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
t	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'C'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"DATA"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
CDATA_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'I'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'D'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ID_IDENTIFIER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'R'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'E'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'F'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
IDREF_IDENTIFIER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'S'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
IDREFS_IDENTIFIER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
type	TokenNameIdentifier
=	TokenNameEQUAL
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'N'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
default	TokenNamedefault
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'O'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
NOTATION_TYPE_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"TATION"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NOTATION_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'M'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'T'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'O'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'K'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'E'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'N'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NMTOKEN_IDENTIFIER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'S'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NMTOKENS_IDENTIFIER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
'E'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'N'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'T'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'I'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'T'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
type	TokenNameIdentifier
=	TokenNameEQUAL
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'Y'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ENTITY_IDENTIFIER	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'I'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'E'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'S'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ENTITIES_IDENTIFIER	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'"'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'"'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'&'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'"'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'&'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ATTRIBUTE_VALUE_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
FIRST_ATTRIBUTE_FRAGMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'\''	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'\''	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'&'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'\''	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'&'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ATTRIBUTE_VALUE_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
FIRST_ATTRIBUTE_FRAGMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
'#'	TokenNameCharacterLiteral
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'R'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"EQUIRED"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
REQUIRED_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'I'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"MPLIED"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
IMPLIED_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'F'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"IXED"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
FIXED_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
'('	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ENUMERATION_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
LEFT_BRACE	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInNotation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
DTD_DECLARATIONS_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
END_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'%'	TokenNameCharacterLiteral
:	TokenNameCOLON
int	TokenNameint
t	TokenNameIdentifier
=	TokenNameEQUAL
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PARAMETER_ENTITY_REFERENCE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
';'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"malformed.parameter.entity"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
t	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'S'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"YSTEM"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
SYSTEM_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'P'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"UBLIC"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PUBLIC_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'"'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
readString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'\''	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
readString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInEntity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
DTD_DECLARATIONS_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
END_CHAR	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'%'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PERCENT	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'S'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"YSTEM"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
SYSTEM_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'P'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"UBLIC"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PUBLIC_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'N'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readIdentifier	TokenNameIdentifier
(	TokenNameLPAREN
"DATA"	TokenNameStringLiteral
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NDATA_IDENTIFIER	TokenNameIdentifier
,	TokenNameCOMMA
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'"'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'"'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'&'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'"'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'&'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'%'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ENTITY_VALUE_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
FIRST_ATTRIBUTE_FRAGMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
attrDelimiter	TokenNameIdentifier
=	TokenNameEQUAL
'\''	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'\''	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'&'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'\''	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'&'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.character"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'%'	TokenNameCharacterLiteral
:	TokenNameCOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ENTITY_VALUE_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
FIRST_ATTRIBUTE_FRAGMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInEntityValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'&'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
readReference	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'%'	TokenNameCharacterLiteral
:	TokenNameCOLON
int	TokenNameint
t	TokenNameIdentifier
=	TokenNameEQUAL
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PARAMETER_ENTITY_REFERENCE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
';'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.parameter.entity"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
t	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
attrDelimiter	TokenNameIdentifier
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'&'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'%'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'"'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ENTITY_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
STRING	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
FIRST_ATTRIBUTE_FRAGMENT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInNotationType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'|'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PIPE	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'('	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
LEFT_BRACE	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
')'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ATTLIST_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
RIGHT_BRACE	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextInEnumeration	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0x9	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xA	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0xD	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x20	TokenNameIntegerLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLSpace	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
S	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'|'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PIPE	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
')'	TokenNameCharacterLiteral
:	TokenNameCOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
context	TokenNameIdentifier
=	TokenNameEQUAL
ATTLIST_CONTEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
RIGHT_BRACE	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
readNmtoken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
readReference	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'#'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'x'	TokenNameCharacterLiteral
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
current	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'0'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
current	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'a'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'f'	TokenNameCharacterLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
current	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'A'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'F'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
do	TokenNamedo
{	TokenNameLBRACE
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
'0'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
current	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
';'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"character.reference"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
CHARACTER_REFERENCE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
t	TokenNameIdentifier
=	TokenNameEQUAL
readName	TokenNameIdentifier
(	TokenNameLPAREN
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
ENTITY_REFERENCE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
';'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"character.reference"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
readPEReference	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameFirstCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.parameter.entity"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
do	TokenNamedo
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
';'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid.parameter.entity"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
PARAMETER_ENTITY_REFERENCE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
readNmtoken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
XMLException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected.eof"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
XMLUtilities	TokenNameIdentifier
.	TokenNameDOT
isXMLNameCharacter	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
LexicalUnits	TokenNameIdentifier
.	TokenNameDOT
NMTOKEN	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
nextChar	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
current	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
current	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
position	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
buffer	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
t	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
+	TokenNamePLUS
position	TokenNameIdentifier
+	TokenNamePLUS
position	TokenNameIdentifier
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
buffer	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
t	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
position	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
buffer	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
buffer	TokenNameIdentifier
[	TokenNameLBRACKET
position	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
current	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
XMLException	TokenNameIdentifier
createXMLException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
message	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
m	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
m	TokenNameIdentifier
=	TokenNameEQUAL
formatMessage	TokenNameIdentifier
(	TokenNameLPAREN
message	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
new	TokenNamenew
Integer	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
getLine	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
Integer	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
getColumn	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
MissingResourceException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m	TokenNameIdentifier
=	TokenNameEQUAL
message	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
XMLException	TokenNameIdentifier
(	TokenNameLPAREN
m	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
