package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xalan	TokenNameIdentifier
.	TokenNameDOT
xsltc	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xalan	TokenNameIdentifier
.	TokenNameDOT
xsltc	TokenNameIdentifier
.	TokenNameDOT
runtime	TokenNameIdentifier
.	TokenNameDOT
BasisLibrary	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
dtm	TokenNameIdentifier
.	TokenNameDOT
DTMAxisIterator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
dtm	TokenNameIdentifier
.	TokenNameDOT
ref	TokenNameIdentifier
.	TokenNameDOT
DTMAxisIteratorBase	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
class	TokenNameclass
SortingIterator	TokenNameIdentifier
extends	TokenNameextends
DTMAxisIteratorBase	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
INIT_DATA_SIZE	TokenNameIdentifier
=	TokenNameEQUAL
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
DTMAxisIterator	TokenNameIdentifier
_source	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
NodeSortRecordFactory	TokenNameIdentifier
_factory	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
NodeSortRecord	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
_data	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
_free	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
_current	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
SortingIterator	TokenNameIdentifier
(	TokenNameLPAREN
DTMAxisIterator	TokenNameIdentifier
source	TokenNameIdentifier
,	TokenNameCOMMA
NodeSortRecordFactory	TokenNameIdentifier
factory	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
_source	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
;	TokenNameSEMICOLON
_factory	TokenNameIdentifier
=	TokenNameEQUAL
factory	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_current	TokenNameIdentifier
<	TokenNameLESS
_free	TokenNameIdentifier
?	TokenNameQUESTION
_data	TokenNameIdentifier
[	TokenNameLBRACKET
_current	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
.	TokenNameDOT
getNode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
END	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
DTMAxisIterator	TokenNameIdentifier
setStartNode	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
node	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
_source	TokenNameIdentifier
.	TokenNameDOT
setStartNode	TokenNameIdentifier
(	TokenNameLPAREN
_startNode	TokenNameIdentifier
=	TokenNameEQUAL
node	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_data	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
NodeSortRecord	TokenNameIdentifier
[	TokenNameLBRACKET
INIT_DATA_SIZE	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
_free	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
node	TokenNameIdentifier
=	TokenNameEQUAL
_source	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
END	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
addRecord	TokenNameIdentifier
(	TokenNameLPAREN
_factory	TokenNameIdentifier
.	TokenNameDOT
makeNodeSortRecord	TokenNameIdentifier
(	TokenNameLPAREN
node	TokenNameIdentifier
,	TokenNameCOMMA
_free	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
quicksort	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
_free	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_current	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_current	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
_current	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getLast	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_free	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setMark	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_source	TokenNameIdentifier
.	TokenNameDOT
setMark	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_markedNode	TokenNameIdentifier
=	TokenNameEQUAL
_current	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
gotoMark	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_source	TokenNameIdentifier
.	TokenNameDOT
gotoMark	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_current	TokenNameIdentifier
=	TokenNameEQUAL
_markedNode	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
DTMAxisIterator	TokenNameIdentifier
cloneIterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
final	TokenNamefinal
SortingIterator	TokenNameIdentifier
clone	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
SortingIterator	TokenNameIdentifier
)	TokenNameRPAREN
super	TokenNamesuper
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
_source	TokenNameIdentifier
=	TokenNameEQUAL
_source	TokenNameIdentifier
.	TokenNameDOT
cloneIterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
_factory	TokenNameIdentifier
=	TokenNameEQUAL
_factory	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
_data	TokenNameIdentifier
=	TokenNameEQUAL
_data	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
_free	TokenNameIdentifier
=	TokenNameEQUAL
_free	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
_current	TokenNameIdentifier
=	TokenNameEQUAL
_current	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
setRestartable	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
clone	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
CloneNotSupportedException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
BasisLibrary	TokenNameIdentifier
.	TokenNameDOT
runTimeError	TokenNameIdentifier
(	TokenNameLPAREN
BasisLibrary	TokenNameIdentifier
.	TokenNameDOT
ITERATOR_CLONE_ERR	TokenNameIdentifier
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
addRecord	TokenNameIdentifier
(	TokenNameLPAREN
NodeSortRecord	TokenNameIdentifier
record	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
_free	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
_data	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
NodeSortRecord	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newArray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
NodeSortRecord	TokenNameIdentifier
[	TokenNameLBRACKET
_data	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
*	TokenNameMULTIPLY
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
_data	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newArray	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
_free	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_data	TokenNameIdentifier
=	TokenNameEQUAL
newArray	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
_data	TokenNameIdentifier
[	TokenNameLBRACKET
_free	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
record	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
quicksort	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
p	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
r	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
p	TokenNameIdentifier
<	TokenNameLESS
r	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
q	TokenNameIdentifier
=	TokenNameEQUAL
partition	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
,	TokenNameCOMMA
r	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
quicksort	TokenNameIdentifier
(	TokenNameLPAREN
p	TokenNameIdentifier
,	TokenNameCOMMA
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
p	TokenNameIdentifier
=	TokenNameEQUAL
q	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
partition	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
p	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
r	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
NodeSortRecord	TokenNameIdentifier
x	TokenNameIdentifier
=	TokenNameEQUAL
_data	TokenNameIdentifier
[	TokenNameLBRACKET
(	TokenNameLPAREN
p	TokenNameIdentifier
+	TokenNamePLUS
r	TokenNameIdentifier
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
r	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
x	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
_data	TokenNameIdentifier
[	TokenNameLBRACKET
--	TokenNameMINUS_MINUS
j	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
x	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
_data	TokenNameIdentifier
[	TokenNameLBRACKET
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
j	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
NodeSortRecord	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
_data	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
_data	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
_data	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
_data	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
