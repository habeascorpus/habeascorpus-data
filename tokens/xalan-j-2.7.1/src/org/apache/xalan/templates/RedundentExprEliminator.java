package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xalan	TokenNameIdentifier
.	TokenNameDOT
templates	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Vector	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xalan	TokenNameIdentifier
.	TokenNameDOT
res	TokenNameIdentifier
.	TokenNameDOT
XSLMessages	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xalan	TokenNameIdentifier
.	TokenNameDOT
res	TokenNameIdentifier
.	TokenNameDOT
XSLTErrorResources	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
.	TokenNameDOT
QName	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
.	TokenNameDOT
WrappedRuntimeException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
Expression	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
ExpressionNode	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
ExpressionOwner	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
XPath	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
axes	TokenNameIdentifier
.	TokenNameDOT
AxesWalker	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
axes	TokenNameIdentifier
.	TokenNameDOT
FilterExprIteratorSimple	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
axes	TokenNameIdentifier
.	TokenNameDOT
FilterExprWalker	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
axes	TokenNameIdentifier
.	TokenNameDOT
LocPathIterator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
axes	TokenNameIdentifier
.	TokenNameDOT
SelfIteratorNoPredicate	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
axes	TokenNameIdentifier
.	TokenNameDOT
WalkerFactory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
axes	TokenNameIdentifier
.	TokenNameDOT
WalkingIterator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
Variable	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
operations	TokenNameIdentifier
.	TokenNameDOT
VariableSafeAbsRef	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
RedundentExprEliminator	TokenNameIdentifier
extends	TokenNameextends
XSLTVisitor	TokenNameIdentifier
{	TokenNameLBRACE
Vector	TokenNameIdentifier
m_paths	TokenNameIdentifier
;	TokenNameSEMICOLON
Vector	TokenNameIdentifier
m_absPaths	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
m_isSameContext	TokenNameIdentifier
;	TokenNameSEMICOLON
AbsPathChecker	TokenNameIdentifier
m_absPathChecker	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AbsPathChecker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
int	TokenNameint
m_uniquePseudoVarID	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
String	TokenNameIdentifier
PSUEDOVARNAMESPACE	TokenNameIdentifier
=	TokenNameEQUAL
Constants	TokenNameIdentifier
.	TokenNameDOT
S_VENDORURL	TokenNameIdentifier
+	TokenNamePLUS
"/xalan/psuedovar"	TokenNameStringLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
DEBUG	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
DIAGNOSE_NUM_PATHS_REDUCED	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
DIAGNOSE_MULTISTEPLIST	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
VarNameCollector	TokenNameIdentifier
m_varNameCollector	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
VarNameCollector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
RedundentExprEliminator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
m_isSameContext	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
m_absPaths	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_paths	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
eleminateRedundentLocals	TokenNameIdentifier
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
psuedoVarRecipient	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
eleminateRedundent	TokenNameIdentifier
(	TokenNameLPAREN
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
m_paths	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
eleminateRedundentGlobals	TokenNameIdentifier
(	TokenNameLPAREN
StylesheetRoot	TokenNameIdentifier
stylesheet	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
eleminateRedundent	TokenNameIdentifier
(	TokenNameLPAREN
stylesheet	TokenNameIdentifier
,	TokenNameCOMMA
m_absPaths	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
eleminateRedundent	TokenNameIdentifier
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
paths	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
n	TokenNameIdentifier
=	TokenNameEQUAL
paths	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
numPathsEliminated	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
numUniquePathsEliminated	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
n	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ExpressionOwner	TokenNameIdentifier
owner	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
ExpressionOwner	TokenNameIdentifier
)	TokenNameRPAREN
paths	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
owner	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
found	TokenNameIdentifier
=	TokenNameEQUAL
findAndEliminateRedundant	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
i	TokenNameIdentifier
,	TokenNameCOMMA
owner	TokenNameIdentifier
,	TokenNameCOMMA
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
paths	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
found	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
numUniquePathsEliminated	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
numPathsEliminated	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
found	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
eleminateSharedPartialPaths	TokenNameIdentifier
(	TokenNameLPAREN
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
paths	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DIAGNOSE_NUM_PATHS_REDUCED	TokenNameIdentifier
)	TokenNameRPAREN
diagnoseNumPaths	TokenNameIdentifier
(	TokenNameLPAREN
paths	TokenNameIdentifier
,	TokenNameCOMMA
numPathsEliminated	TokenNameIdentifier
,	TokenNameCOMMA
numUniquePathsEliminated	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
eleminateSharedPartialPaths	TokenNameIdentifier
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
paths	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
MultistepExprHolder	TokenNameIdentifier
list	TokenNameIdentifier
=	TokenNameEQUAL
createMultistepExprList	TokenNameIdentifier
(	TokenNameLPAREN
paths	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
list	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
DIAGNOSE_MULTISTEPLIST	TokenNameIdentifier
)	TokenNameRPAREN
list	TokenNameIdentifier
.	TokenNameDOT
diagnose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isGlobal	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
paths	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
m_absPaths	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
longestStepsCount	TokenNameIdentifier
=	TokenNameEQUAL
list	TokenNameIdentifier
.	TokenNameDOT
m_stepCount	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
longestStepsCount	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
MultistepExprHolder	TokenNameIdentifier
next	TokenNameIdentifier
=	TokenNameEQUAL
list	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
next	TokenNameIdentifier
.	TokenNameDOT
m_stepCount	TokenNameIdentifier
<	TokenNameLESS
i	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
list	TokenNameIdentifier
=	TokenNameEQUAL
matchAndEliminatePartialPaths	TokenNameIdentifier
(	TokenNameLPAREN
next	TokenNameIdentifier
,	TokenNameCOMMA
list	TokenNameIdentifier
,	TokenNameCOMMA
isGlobal	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
,	TokenNameCOMMA
psuedoVarRecipient	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
MultistepExprHolder	TokenNameIdentifier
matchAndEliminatePartialPaths	TokenNameIdentifier
(	TokenNameLPAREN
MultistepExprHolder	TokenNameIdentifier
testee	TokenNameIdentifier
,	TokenNameCOMMA
MultistepExprHolder	TokenNameIdentifier
head	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isGlobal	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
lengthToTest	TokenNameIdentifier
,	TokenNameCOMMA
ElemTemplateElement	TokenNameIdentifier
varScope	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
testee	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
head	TokenNameIdentifier
;	TokenNameSEMICOLON
WalkingIterator	TokenNameIdentifier
iter1	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
WalkingIterator	TokenNameIdentifier
)	TokenNameRPAREN
testee	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
partialIsVariable	TokenNameIdentifier
(	TokenNameLPAREN
testee	TokenNameIdentifier
,	TokenNameCOMMA
lengthToTest	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
head	TokenNameIdentifier
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
matchedPaths	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
matchedPathsTail	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
meh	TokenNameIdentifier
=	TokenNameEQUAL
head	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
meh	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
meh	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
testee	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
meh	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
WalkingIterator	TokenNameIdentifier
iter2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
WalkingIterator	TokenNameIdentifier
)	TokenNameRPAREN
meh	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
stepsEqual	TokenNameIdentifier
(	TokenNameLPAREN
iter1	TokenNameIdentifier
,	TokenNameCOMMA
iter2	TokenNameIdentifier
,	TokenNameCOMMA
lengthToTest	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
matchedPaths	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
matchedPaths	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
MultistepExprHolder	TokenNameIdentifier
)	TokenNameRPAREN
testee	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
testee	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
CloneNotSupportedException	TokenNameIdentifier
cnse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
matchedPathsTail	TokenNameIdentifier
=	TokenNameEQUAL
matchedPaths	TokenNameIdentifier
;	TokenNameSEMICOLON
matchedPathsTail	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
matchedPathsTail	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
MultistepExprHolder	TokenNameIdentifier
)	TokenNameRPAREN
meh	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
meh	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
CloneNotSupportedException	TokenNameIdentifier
cnse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
matchedPathsTail	TokenNameIdentifier
=	TokenNameEQUAL
matchedPathsTail	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
matchedPathsTail	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
meh	TokenNameIdentifier
=	TokenNameEQUAL
meh	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
matchCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
matchedPaths	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemTemplateElement	TokenNameIdentifier
root	TokenNameIdentifier
=	TokenNameEQUAL
isGlobal	TokenNameIdentifier
?	TokenNameQUESTION
varScope	TokenNameIdentifier
:	TokenNameCOLON
findCommonAncestor	TokenNameIdentifier
(	TokenNameLPAREN
matchedPaths	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
WalkingIterator	TokenNameIdentifier
sharedIter	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
WalkingIterator	TokenNameIdentifier
)	TokenNameRPAREN
matchedPaths	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
WalkingIterator	TokenNameIdentifier
newIter	TokenNameIdentifier
=	TokenNameEQUAL
createIteratorFromSteps	TokenNameIdentifier
(	TokenNameLPAREN
sharedIter	TokenNameIdentifier
,	TokenNameCOMMA
lengthToTest	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ElemVariable	TokenNameIdentifier
var	TokenNameIdentifier
=	TokenNameEQUAL
createPseudoVarDecl	TokenNameIdentifier
(	TokenNameLPAREN
root	TokenNameIdentifier
,	TokenNameCOMMA
newIter	TokenNameIdentifier
,	TokenNameCOMMA
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DIAGNOSE_MULTISTEPLIST	TokenNameIdentifier
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"Created var: "	TokenNameStringLiteral
+	TokenNamePLUS
var	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
isGlobal	TokenNameIdentifier
?	TokenNameQUESTION
"(Global)"	TokenNameStringLiteral
:	TokenNameCOLON
""	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
matchedPaths	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ExpressionOwner	TokenNameIdentifier
owner	TokenNameIdentifier
=	TokenNameEQUAL
matchedPaths	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
;	TokenNameSEMICOLON
WalkingIterator	TokenNameIdentifier
iter	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
WalkingIterator	TokenNameIdentifier
)	TokenNameRPAREN
owner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DIAGNOSE_MULTISTEPLIST	TokenNameIdentifier
)	TokenNameRPAREN
diagnoseLineNumber	TokenNameIdentifier
(	TokenNameLPAREN
iter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
LocPathIterator	TokenNameIdentifier
newIter2	TokenNameIdentifier
=	TokenNameEQUAL
changePartToRef	TokenNameIdentifier
(	TokenNameLPAREN
var	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
iter	TokenNameIdentifier
,	TokenNameCOMMA
lengthToTest	TokenNameIdentifier
,	TokenNameCOMMA
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
owner	TokenNameIdentifier
.	TokenNameDOT
setExpression	TokenNameIdentifier
(	TokenNameLPAREN
newIter2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
matchedPaths	TokenNameIdentifier
=	TokenNameEQUAL
matchedPaths	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
DIAGNOSE_MULTISTEPLIST	TokenNameIdentifier
)	TokenNameRPAREN
diagnoseMultistepList	TokenNameIdentifier
(	TokenNameLPAREN
matchCount	TokenNameIdentifier
,	TokenNameCOMMA
lengthToTest	TokenNameIdentifier
,	TokenNameCOMMA
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
head	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
partialIsVariable	TokenNameIdentifier
(	TokenNameLPAREN
MultistepExprHolder	TokenNameIdentifier
testee	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
lengthToTest	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
lengthToTest	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
WalkingIterator	TokenNameIdentifier
wi	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
WalkingIterator	TokenNameIdentifier
)	TokenNameRPAREN
testee	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
wi	TokenNameIdentifier
.	TokenNameDOT
getFirstWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
instanceof	TokenNameinstanceof
FilterExprWalker	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
diagnoseLineNumber	TokenNameIdentifier
(	TokenNameLPAREN
Expression	TokenNameIdentifier
expr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemTemplateElement	TokenNameIdentifier
e	TokenNameIdentifier
=	TokenNameEQUAL
getElemFromExpression	TokenNameIdentifier
(	TokenNameLPAREN
expr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"   "	TokenNameStringLiteral
+	TokenNamePLUS
e	TokenNameIdentifier
.	TokenNameDOT
getSystemId	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" Line "	TokenNameStringLiteral
+	TokenNamePLUS
e	TokenNameIdentifier
.	TokenNameDOT
getLineNumber	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
ElemTemplateElement	TokenNameIdentifier
findCommonAncestor	TokenNameIdentifier
(	TokenNameLPAREN
MultistepExprHolder	TokenNameIdentifier
head	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
numExprs	TokenNameIdentifier
=	TokenNameEQUAL
head	TokenNameIdentifier
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ElemTemplateElement	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
elems	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ElemTemplateElement	TokenNameIdentifier
[	TokenNameLBRACKET
numExprs	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
ancestorCounts	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
numExprs	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
next	TokenNameIdentifier
=	TokenNameEQUAL
head	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
shortestAncestorCount	TokenNameIdentifier
=	TokenNameEQUAL
10000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numExprs	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemTemplateElement	TokenNameIdentifier
elem	TokenNameIdentifier
=	TokenNameEQUAL
getElemFromExpression	TokenNameIdentifier
(	TokenNameLPAREN
next	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
elems	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
elem	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
numAncestors	TokenNameIdentifier
=	TokenNameEQUAL
countAncestors	TokenNameIdentifier
(	TokenNameLPAREN
elem	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ancestorCounts	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
numAncestors	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numAncestors	TokenNameIdentifier
<	TokenNameLESS
shortestAncestorCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
shortestAncestorCount	TokenNameIdentifier
=	TokenNameEQUAL
numAncestors	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numExprs	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ancestorCounts	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
>	TokenNameGREATER
shortestAncestorCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
numStepCorrection	TokenNameIdentifier
=	TokenNameEQUAL
ancestorCounts	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
-	TokenNameMINUS
shortestAncestorCount	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
numStepCorrection	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
elems	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
elems	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getParentElem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
ElemTemplateElement	TokenNameIdentifier
first	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
shortestAncestorCount	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
areEqual	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
first	TokenNameIdentifier
=	TokenNameEQUAL
elems	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numExprs	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
first	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
elems	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
areEqual	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
areEqual	TokenNameIdentifier
&&	TokenNameAND_AND
isNotSameAsOwner	TokenNameIdentifier
(	TokenNameLPAREN
head	TokenNameIdentifier
,	TokenNameCOMMA
first	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
first	TokenNameIdentifier
.	TokenNameDOT
canAcceptVariables	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
DIAGNOSE_MULTISTEPLIST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
first	TokenNameIdentifier
.	TokenNameDOT
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
" at   "	TokenNameStringLiteral
+	TokenNamePLUS
first	TokenNameIdentifier
.	TokenNameDOT
getSystemId	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" Line "	TokenNameStringLiteral
+	TokenNamePLUS
first	TokenNameIdentifier
.	TokenNameDOT
getLineNumber	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
first	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numExprs	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
elems	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
elems	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
getParentElem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
assertion	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
"Could not find common ancestor!!!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
boolean	TokenNameboolean
isNotSameAsOwner	TokenNameIdentifier
(	TokenNameLPAREN
MultistepExprHolder	TokenNameIdentifier
head	TokenNameIdentifier
,	TokenNameCOMMA
ElemTemplateElement	TokenNameIdentifier
ete	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
MultistepExprHolder	TokenNameIdentifier
next	TokenNameIdentifier
=	TokenNameEQUAL
head	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemTemplateElement	TokenNameIdentifier
elemOwner	TokenNameIdentifier
=	TokenNameEQUAL
getElemFromExpression	TokenNameIdentifier
(	TokenNameLPAREN
next	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
elemOwner	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ete	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
countAncestors	TokenNameIdentifier
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
elem	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
elem	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
elem	TokenNameIdentifier
=	TokenNameEQUAL
elem	TokenNameIdentifier
.	TokenNameDOT
getParentElem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
diagnoseMultistepList	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
matchCount	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
lengthToTest	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
matchCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"Found multistep matches: "	TokenNameStringLiteral
+	TokenNamePLUS
matchCount	TokenNameIdentifier
+	TokenNamePLUS
", "	TokenNameStringLiteral
+	TokenNamePLUS
lengthToTest	TokenNameIdentifier
+	TokenNamePLUS
" length"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
" (global)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
LocPathIterator	TokenNameIdentifier
changePartToRef	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
QName	TokenNameIdentifier
uniquePseudoVarName	TokenNameIdentifier
,	TokenNameCOMMA
WalkingIterator	TokenNameIdentifier
wi	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
numSteps	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
boolean	TokenNameboolean
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Variable	TokenNameIdentifier
var	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Variable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
var	TokenNameIdentifier
.	TokenNameDOT
setQName	TokenNameIdentifier
(	TokenNameLPAREN
uniquePseudoVarName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
var	TokenNameIdentifier
.	TokenNameDOT
setIsGlobal	TokenNameIdentifier
(	TokenNameLPAREN
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemTemplateElement	TokenNameIdentifier
elem	TokenNameIdentifier
=	TokenNameEQUAL
getElemFromExpression	TokenNameIdentifier
(	TokenNameLPAREN
wi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
StylesheetRoot	TokenNameIdentifier
root	TokenNameIdentifier
=	TokenNameEQUAL
elem	TokenNameIdentifier
.	TokenNameDOT
getStylesheetRoot	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Vector	TokenNameIdentifier
vars	TokenNameIdentifier
=	TokenNameEQUAL
root	TokenNameIdentifier
.	TokenNameDOT
getVariablesAndParamsComposed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
var	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
vars	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
AxesWalker	TokenNameIdentifier
walker	TokenNameIdentifier
=	TokenNameEQUAL
wi	TokenNameIdentifier
.	TokenNameDOT
getFirstWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
assertion	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
walker	TokenNameIdentifier
,	TokenNameCOMMA
"Walker should not be null!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
walker	TokenNameIdentifier
=	TokenNameEQUAL
walker	TokenNameIdentifier
.	TokenNameDOT
getNextWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
walker	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
FilterExprWalker	TokenNameIdentifier
few	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FilterExprWalker	TokenNameIdentifier
(	TokenNameLPAREN
wi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
few	TokenNameIdentifier
.	TokenNameDOT
setInnerExpression	TokenNameIdentifier
(	TokenNameLPAREN
var	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
few	TokenNameIdentifier
.	TokenNameDOT
exprSetParent	TokenNameIdentifier
(	TokenNameLPAREN
wi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
few	TokenNameIdentifier
.	TokenNameDOT
setNextWalker	TokenNameIdentifier
(	TokenNameLPAREN
walker	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
walker	TokenNameIdentifier
.	TokenNameDOT
setPrevWalker	TokenNameIdentifier
(	TokenNameLPAREN
few	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
wi	TokenNameIdentifier
.	TokenNameDOT
setFirstWalker	TokenNameIdentifier
(	TokenNameLPAREN
few	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
wi	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
FilterExprIteratorSimple	TokenNameIdentifier
feis	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FilterExprIteratorSimple	TokenNameIdentifier
(	TokenNameLPAREN
var	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
feis	TokenNameIdentifier
.	TokenNameDOT
exprSetParent	TokenNameIdentifier
(	TokenNameLPAREN
wi	TokenNameIdentifier
.	TokenNameDOT
exprGetParent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
feis	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
WalkingIterator	TokenNameIdentifier
createIteratorFromSteps	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
WalkingIterator	TokenNameIdentifier
wi	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
numSteps	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
WalkingIterator	TokenNameIdentifier
newIter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
WalkingIterator	TokenNameIdentifier
(	TokenNameLPAREN
wi	TokenNameIdentifier
.	TokenNameDOT
getPrefixResolver	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
AxesWalker	TokenNameIdentifier
walker	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
AxesWalker	TokenNameIdentifier
)	TokenNameRPAREN
wi	TokenNameIdentifier
.	TokenNameDOT
getFirstWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
newIter	TokenNameIdentifier
.	TokenNameDOT
setFirstWalker	TokenNameIdentifier
(	TokenNameLPAREN
walker	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
walker	TokenNameIdentifier
.	TokenNameDOT
setLocPathIterator	TokenNameIdentifier
(	TokenNameLPAREN
newIter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numSteps	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
AxesWalker	TokenNameIdentifier
next	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
AxesWalker	TokenNameIdentifier
)	TokenNameRPAREN
walker	TokenNameIdentifier
.	TokenNameDOT
getNextWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
walker	TokenNameIdentifier
.	TokenNameDOT
setNextWalker	TokenNameIdentifier
(	TokenNameLPAREN
next	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
next	TokenNameIdentifier
.	TokenNameDOT
setLocPathIterator	TokenNameIdentifier
(	TokenNameLPAREN
newIter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
walker	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
walker	TokenNameIdentifier
.	TokenNameDOT
setNextWalker	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
CloneNotSupportedException	TokenNameIdentifier
cnse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
WrappedRuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
cnse	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
newIter	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
boolean	TokenNameboolean
stepsEqual	TokenNameIdentifier
(	TokenNameLPAREN
WalkingIterator	TokenNameIdentifier
iter1	TokenNameIdentifier
,	TokenNameCOMMA
WalkingIterator	TokenNameIdentifier
iter2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
numSteps	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
AxesWalker	TokenNameIdentifier
aw1	TokenNameIdentifier
=	TokenNameEQUAL
iter1	TokenNameIdentifier
.	TokenNameDOT
getFirstWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
AxesWalker	TokenNameIdentifier
aw2	TokenNameIdentifier
=	TokenNameEQUAL
iter2	TokenNameIdentifier
.	TokenNameDOT
getFirstWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
numSteps	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
aw1	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
aw2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
aw1	TokenNameIdentifier
.	TokenNameDOT
deepEquals	TokenNameIdentifier
(	TokenNameLPAREN
aw2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
aw1	TokenNameIdentifier
=	TokenNameEQUAL
aw1	TokenNameIdentifier
.	TokenNameDOT
getNextWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
aw2	TokenNameIdentifier
=	TokenNameEQUAL
aw2	TokenNameIdentifier
.	TokenNameDOT
getNextWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assertion	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
aw1	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
aw2	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
"Total match is incorrect!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
MultistepExprHolder	TokenNameIdentifier
createMultistepExprList	TokenNameIdentifier
(	TokenNameLPAREN
Vector	TokenNameIdentifier
paths	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
MultistepExprHolder	TokenNameIdentifier
first	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
n	TokenNameIdentifier
=	TokenNameEQUAL
paths	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
n	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ExpressionOwner	TokenNameIdentifier
eo	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
ExpressionOwner	TokenNameIdentifier
)	TokenNameRPAREN
paths	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
eo	TokenNameIdentifier
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
LocPathIterator	TokenNameIdentifier
lpi	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
LocPathIterator	TokenNameIdentifier
)	TokenNameRPAREN
eo	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
numPaths	TokenNameIdentifier
=	TokenNameEQUAL
countSteps	TokenNameIdentifier
(	TokenNameLPAREN
lpi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numPaths	TokenNameIdentifier
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
first	TokenNameIdentifier
)	TokenNameRPAREN
first	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MultistepExprHolder	TokenNameIdentifier
(	TokenNameLPAREN
eo	TokenNameIdentifier
,	TokenNameCOMMA
numPaths	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
first	TokenNameIdentifier
=	TokenNameEQUAL
first	TokenNameIdentifier
.	TokenNameDOT
addInSortedOrder	TokenNameIdentifier
(	TokenNameLPAREN
eo	TokenNameIdentifier
,	TokenNameCOMMA
numPaths	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
first	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
first	TokenNameIdentifier
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
<=	TokenNameLESS_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
first	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
findAndEliminateRedundant	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
firstOccuranceIndex	TokenNameIdentifier
,	TokenNameCOMMA
ExpressionOwner	TokenNameIdentifier
firstOccuranceOwner	TokenNameIdentifier
,	TokenNameCOMMA
ElemTemplateElement	TokenNameIdentifier
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
paths	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
DOMException	TokenNameIdentifier
{	TokenNameLBRACE
MultistepExprHolder	TokenNameIdentifier
head	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
tail	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
numPathsFound	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
n	TokenNameIdentifier
=	TokenNameEQUAL
paths	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Expression	TokenNameIdentifier
expr1	TokenNameIdentifier
=	TokenNameEQUAL
firstOccuranceOwner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
assertIsLocPathIterator	TokenNameIdentifier
(	TokenNameLPAREN
expr1	TokenNameIdentifier
,	TokenNameCOMMA
firstOccuranceOwner	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isGlobal	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
paths	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
m_absPaths	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
LocPathIterator	TokenNameIdentifier
lpi	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
LocPathIterator	TokenNameIdentifier
)	TokenNameRPAREN
expr1	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
stepCount	TokenNameIdentifier
=	TokenNameEQUAL
countSteps	TokenNameIdentifier
(	TokenNameLPAREN
lpi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
n	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ExpressionOwner	TokenNameIdentifier
owner2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
ExpressionOwner	TokenNameIdentifier
)	TokenNameRPAREN
paths	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
owner2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Expression	TokenNameIdentifier
expr2	TokenNameIdentifier
=	TokenNameEQUAL
owner2	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isEqual	TokenNameIdentifier
=	TokenNameEQUAL
expr2	TokenNameIdentifier
.	TokenNameDOT
deepEquals	TokenNameIdentifier
(	TokenNameLPAREN
lpi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isEqual	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
LocPathIterator	TokenNameIdentifier
lpi2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
LocPathIterator	TokenNameIdentifier
)	TokenNameRPAREN
expr2	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
head	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
head	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MultistepExprHolder	TokenNameIdentifier
(	TokenNameLPAREN
firstOccuranceOwner	TokenNameIdentifier
,	TokenNameCOMMA
stepCount	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tail	TokenNameIdentifier
=	TokenNameEQUAL
head	TokenNameIdentifier
;	TokenNameSEMICOLON
numPathsFound	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
tail	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MultistepExprHolder	TokenNameIdentifier
(	TokenNameLPAREN
owner2	TokenNameIdentifier
,	TokenNameCOMMA
stepCount	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tail	TokenNameIdentifier
=	TokenNameEQUAL
tail	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
paths	TokenNameIdentifier
.	TokenNameDOT
setElementAt	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
numPathsFound	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
numPathsFound	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
head	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MultistepExprHolder	TokenNameIdentifier
(	TokenNameLPAREN
firstOccuranceOwner	TokenNameIdentifier
,	TokenNameCOMMA
stepCount	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
numPathsFound	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
head	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemTemplateElement	TokenNameIdentifier
root	TokenNameIdentifier
=	TokenNameEQUAL
isGlobal	TokenNameIdentifier
?	TokenNameQUESTION
psuedoVarRecipient	TokenNameIdentifier
:	TokenNameCOLON
findCommonAncestor	TokenNameIdentifier
(	TokenNameLPAREN
head	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
LocPathIterator	TokenNameIdentifier
sharedIter	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
LocPathIterator	TokenNameIdentifier
)	TokenNameRPAREN
head	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ElemVariable	TokenNameIdentifier
var	TokenNameIdentifier
=	TokenNameEQUAL
createPseudoVarDecl	TokenNameIdentifier
(	TokenNameLPAREN
root	TokenNameIdentifier
,	TokenNameCOMMA
sharedIter	TokenNameIdentifier
,	TokenNameCOMMA
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DIAGNOSE_MULTISTEPLIST	TokenNameIdentifier
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"Created var: "	TokenNameStringLiteral
+	TokenNamePLUS
var	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
isGlobal	TokenNameIdentifier
?	TokenNameQUESTION
"(Global)"	TokenNameStringLiteral
:	TokenNameCOLON
""	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
QName	TokenNameIdentifier
uniquePseudoVarName	TokenNameIdentifier
=	TokenNameEQUAL
var	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
head	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ExpressionOwner	TokenNameIdentifier
owner	TokenNameIdentifier
=	TokenNameEQUAL
head	TokenNameIdentifier
.	TokenNameDOT
m_exprOwner	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DIAGNOSE_MULTISTEPLIST	TokenNameIdentifier
)	TokenNameRPAREN
diagnoseLineNumber	TokenNameIdentifier
(	TokenNameLPAREN
owner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
changeToVarRef	TokenNameIdentifier
(	TokenNameLPAREN
uniquePseudoVarName	TokenNameIdentifier
,	TokenNameCOMMA
owner	TokenNameIdentifier
,	TokenNameCOMMA
paths	TokenNameIdentifier
,	TokenNameCOMMA
root	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
head	TokenNameIdentifier
=	TokenNameEQUAL
head	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
paths	TokenNameIdentifier
.	TokenNameDOT
setElementAt	TokenNameIdentifier
(	TokenNameLPAREN
var	TokenNameIdentifier
.	TokenNameDOT
getSelect	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
firstOccuranceIndex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
numPathsFound	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
oldFindAndEliminateRedundant	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
firstOccuranceIndex	TokenNameIdentifier
,	TokenNameCOMMA
ExpressionOwner	TokenNameIdentifier
firstOccuranceOwner	TokenNameIdentifier
,	TokenNameCOMMA
ElemTemplateElement	TokenNameIdentifier
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
paths	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
DOMException	TokenNameIdentifier
{	TokenNameLBRACE
QName	TokenNameIdentifier
uniquePseudoVarName	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
foundFirst	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
int	TokenNameint
numPathsFound	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
n	TokenNameIdentifier
=	TokenNameEQUAL
paths	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Expression	TokenNameIdentifier
expr1	TokenNameIdentifier
=	TokenNameEQUAL
firstOccuranceOwner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
assertIsLocPathIterator	TokenNameIdentifier
(	TokenNameLPAREN
expr1	TokenNameIdentifier
,	TokenNameCOMMA
firstOccuranceOwner	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isGlobal	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
paths	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
m_absPaths	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
LocPathIterator	TokenNameIdentifier
lpi	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
LocPathIterator	TokenNameIdentifier
)	TokenNameRPAREN
expr1	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
n	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ExpressionOwner	TokenNameIdentifier
owner2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
ExpressionOwner	TokenNameIdentifier
)	TokenNameRPAREN
paths	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
owner2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Expression	TokenNameIdentifier
expr2	TokenNameIdentifier
=	TokenNameEQUAL
owner2	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isEqual	TokenNameIdentifier
=	TokenNameEQUAL
expr2	TokenNameIdentifier
.	TokenNameDOT
deepEquals	TokenNameIdentifier
(	TokenNameLPAREN
lpi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isEqual	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
LocPathIterator	TokenNameIdentifier
lpi2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
LocPathIterator	TokenNameIdentifier
)	TokenNameRPAREN
expr2	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
foundFirst	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
foundFirst	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
ElemVariable	TokenNameIdentifier
var	TokenNameIdentifier
=	TokenNameEQUAL
createPseudoVarDecl	TokenNameIdentifier
(	TokenNameLPAREN
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
lpi	TokenNameIdentifier
,	TokenNameCOMMA
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
var	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
uniquePseudoVarName	TokenNameIdentifier
=	TokenNameEQUAL
var	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
changeToVarRef	TokenNameIdentifier
(	TokenNameLPAREN
uniquePseudoVarName	TokenNameIdentifier
,	TokenNameCOMMA
firstOccuranceOwner	TokenNameIdentifier
,	TokenNameCOMMA
paths	TokenNameIdentifier
,	TokenNameCOMMA
psuedoVarRecipient	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
paths	TokenNameIdentifier
.	TokenNameDOT
setElementAt	TokenNameIdentifier
(	TokenNameLPAREN
var	TokenNameIdentifier
.	TokenNameDOT
getSelect	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
firstOccuranceIndex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
numPathsFound	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
changeToVarRef	TokenNameIdentifier
(	TokenNameLPAREN
uniquePseudoVarName	TokenNameIdentifier
,	TokenNameCOMMA
owner2	TokenNameIdentifier
,	TokenNameCOMMA
paths	TokenNameIdentifier
,	TokenNameCOMMA
psuedoVarRecipient	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
paths	TokenNameIdentifier
.	TokenNameDOT
setElementAt	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
numPathsFound	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
numPathsFound	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
paths	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
m_absPaths	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemVariable	TokenNameIdentifier
var	TokenNameIdentifier
=	TokenNameEQUAL
createPseudoVarDecl	TokenNameIdentifier
(	TokenNameLPAREN
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
lpi	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
var	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
uniquePseudoVarName	TokenNameIdentifier
=	TokenNameEQUAL
var	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
changeToVarRef	TokenNameIdentifier
(	TokenNameLPAREN
uniquePseudoVarName	TokenNameIdentifier
,	TokenNameCOMMA
firstOccuranceOwner	TokenNameIdentifier
,	TokenNameCOMMA
paths	TokenNameIdentifier
,	TokenNameCOMMA
psuedoVarRecipient	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
paths	TokenNameIdentifier
.	TokenNameDOT
setElementAt	TokenNameIdentifier
(	TokenNameLPAREN
var	TokenNameIdentifier
.	TokenNameDOT
getSelect	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
firstOccuranceIndex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
numPathsFound	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
numPathsFound	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
countSteps	TokenNameIdentifier
(	TokenNameLPAREN
LocPathIterator	TokenNameIdentifier
lpi	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
lpi	TokenNameIdentifier
instanceof	TokenNameinstanceof
WalkingIterator	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
WalkingIterator	TokenNameIdentifier
wi	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
WalkingIterator	TokenNameIdentifier
)	TokenNameRPAREN
lpi	TokenNameIdentifier
;	TokenNameSEMICOLON
AxesWalker	TokenNameIdentifier
aw	TokenNameIdentifier
=	TokenNameEQUAL
wi	TokenNameIdentifier
.	TokenNameDOT
getFirstWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
aw	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
aw	TokenNameIdentifier
=	TokenNameEQUAL
aw	TokenNameIdentifier
.	TokenNameDOT
getNextWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
return	TokenNamereturn
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
changeToVarRef	TokenNameIdentifier
(	TokenNameLPAREN
QName	TokenNameIdentifier
varName	TokenNameIdentifier
,	TokenNameCOMMA
ExpressionOwner	TokenNameIdentifier
owner	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
paths	TokenNameIdentifier
,	TokenNameCOMMA
ElemTemplateElement	TokenNameIdentifier
psuedoVarRecipient	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Variable	TokenNameIdentifier
varRef	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
paths	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
m_absPaths	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
new	TokenNamenew
VariableSafeAbsRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
Variable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
varRef	TokenNameIdentifier
.	TokenNameDOT
setQName	TokenNameIdentifier
(	TokenNameLPAREN
varName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
paths	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
m_absPaths	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
StylesheetRoot	TokenNameIdentifier
root	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
StylesheetRoot	TokenNameIdentifier
)	TokenNameRPAREN
psuedoVarRecipient	TokenNameIdentifier
;	TokenNameSEMICOLON
Vector	TokenNameIdentifier
globalVars	TokenNameIdentifier
=	TokenNameEQUAL
root	TokenNameIdentifier
.	TokenNameDOT
getVariablesAndParamsComposed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
varRef	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
globalVars	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
varRef	TokenNameIdentifier
.	TokenNameDOT
setIsGlobal	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
owner	TokenNameIdentifier
.	TokenNameDOT
setExpression	TokenNameIdentifier
(	TokenNameLPAREN
varRef	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
static	TokenNamestatic
int	TokenNameint
getPseudoVarID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
m_uniquePseudoVarID	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
ElemVariable	TokenNameIdentifier
createPseudoVarDecl	TokenNameIdentifier
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
LocPathIterator	TokenNameIdentifier
lpi	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
DOMException	TokenNameIdentifier
{	TokenNameLBRACE
QName	TokenNameIdentifier
uniquePseudoVarName	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
QName	TokenNameIdentifier
(	TokenNameLPAREN
PSUEDOVARNAMESPACE	TokenNameIdentifier
,	TokenNameCOMMA
"#"	TokenNameStringLiteral
+	TokenNamePLUS
getPseudoVarID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isGlobal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
createGlobalPseudoVarDecl	TokenNameIdentifier
(	TokenNameLPAREN
uniquePseudoVarName	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
StylesheetRoot	TokenNameIdentifier
)	TokenNameRPAREN
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
lpi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
return	TokenNamereturn
createLocalPseudoVarDecl	TokenNameIdentifier
(	TokenNameLPAREN
uniquePseudoVarName	TokenNameIdentifier
,	TokenNameCOMMA
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
lpi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
ElemVariable	TokenNameIdentifier
createGlobalPseudoVarDecl	TokenNameIdentifier
(	TokenNameLPAREN
QName	TokenNameIdentifier
uniquePseudoVarName	TokenNameIdentifier
,	TokenNameCOMMA
StylesheetRoot	TokenNameIdentifier
stylesheetRoot	TokenNameIdentifier
,	TokenNameCOMMA
LocPathIterator	TokenNameIdentifier
lpi	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
DOMException	TokenNameIdentifier
{	TokenNameLBRACE
ElemVariable	TokenNameIdentifier
psuedoVar	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ElemVariable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
psuedoVar	TokenNameIdentifier
.	TokenNameDOT
setIsTopLevel	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
XPath	TokenNameIdentifier
xpath	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XPath	TokenNameIdentifier
(	TokenNameLPAREN
lpi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
psuedoVar	TokenNameIdentifier
.	TokenNameDOT
setSelect	TokenNameIdentifier
(	TokenNameLPAREN
xpath	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
psuedoVar	TokenNameIdentifier
.	TokenNameDOT
setName	TokenNameIdentifier
(	TokenNameLPAREN
uniquePseudoVarName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Vector	TokenNameIdentifier
globalVars	TokenNameIdentifier
=	TokenNameEQUAL
stylesheetRoot	TokenNameIdentifier
.	TokenNameDOT
getVariablesAndParamsComposed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
psuedoVar	TokenNameIdentifier
.	TokenNameDOT
setIndex	TokenNameIdentifier
(	TokenNameLPAREN
globalVars	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
globalVars	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
psuedoVar	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
psuedoVar	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
ElemVariable	TokenNameIdentifier
createLocalPseudoVarDecl	TokenNameIdentifier
(	TokenNameLPAREN
QName	TokenNameIdentifier
uniquePseudoVarName	TokenNameIdentifier
,	TokenNameCOMMA
ElemTemplateElement	TokenNameIdentifier
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
LocPathIterator	TokenNameIdentifier
lpi	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
DOMException	TokenNameIdentifier
{	TokenNameLBRACE
ElemVariable	TokenNameIdentifier
psuedoVar	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ElemVariablePsuedo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
XPath	TokenNameIdentifier
xpath	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
XPath	TokenNameIdentifier
(	TokenNameLPAREN
lpi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
psuedoVar	TokenNameIdentifier
.	TokenNameDOT
setSelect	TokenNameIdentifier
(	TokenNameLPAREN
xpath	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
psuedoVar	TokenNameIdentifier
.	TokenNameDOT
setName	TokenNameIdentifier
(	TokenNameLPAREN
uniquePseudoVarName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ElemVariable	TokenNameIdentifier
var	TokenNameIdentifier
=	TokenNameEQUAL
addVarDeclToElem	TokenNameIdentifier
(	TokenNameLPAREN
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
lpi	TokenNameIdentifier
,	TokenNameCOMMA
psuedoVar	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
lpi	TokenNameIdentifier
.	TokenNameDOT
exprSetParent	TokenNameIdentifier
(	TokenNameLPAREN
var	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
var	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
ElemVariable	TokenNameIdentifier
addVarDeclToElem	TokenNameIdentifier
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
psuedoVarRecipient	TokenNameIdentifier
,	TokenNameCOMMA
LocPathIterator	TokenNameIdentifier
lpi	TokenNameIdentifier
,	TokenNameCOMMA
ElemVariable	TokenNameIdentifier
psuedoVar	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
w3c	TokenNameIdentifier
.	TokenNameDOT
dom	TokenNameIdentifier
.	TokenNameDOT
DOMException	TokenNameIdentifier
{	TokenNameLBRACE
ElemTemplateElement	TokenNameIdentifier
ete	TokenNameIdentifier
=	TokenNameEQUAL
psuedoVarRecipient	TokenNameIdentifier
.	TokenNameDOT
getFirstChildElem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
lpi	TokenNameIdentifier
.	TokenNameDOT
callVisitors	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
m_varNameCollector	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_varNameCollector	TokenNameIdentifier
.	TokenNameDOT
getVarCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemTemplateElement	TokenNameIdentifier
baseElem	TokenNameIdentifier
=	TokenNameEQUAL
getElemFromExpression	TokenNameIdentifier
(	TokenNameLPAREN
lpi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ElemVariable	TokenNameIdentifier
varElem	TokenNameIdentifier
=	TokenNameEQUAL
getPrevVariableElem	TokenNameIdentifier
(	TokenNameLPAREN
baseElem	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
varElem	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_varNameCollector	TokenNameIdentifier
.	TokenNameDOT
doesOccur	TokenNameIdentifier
(	TokenNameLPAREN
varElem	TokenNameIdentifier
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
psuedoVarRecipient	TokenNameIdentifier
=	TokenNameEQUAL
varElem	TokenNameIdentifier
.	TokenNameDOT
getParentElem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ete	TokenNameIdentifier
=	TokenNameEQUAL
varElem	TokenNameIdentifier
.	TokenNameDOT
getNextSiblingElem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
varElem	TokenNameIdentifier
=	TokenNameEQUAL
getPrevVariableElem	TokenNameIdentifier
(	TokenNameLPAREN
varElem	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
ete	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_PARAMVARIABLE	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ete	TokenNameIdentifier
.	TokenNameDOT
getXSLToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isParam	TokenNameIdentifier
(	TokenNameLPAREN
lpi	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
ete	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ete	TokenNameIdentifier
=	TokenNameEQUAL
ete	TokenNameIdentifier
.	TokenNameDOT
getNextSiblingElem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
ete	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_PARAMVARIABLE	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
ete	TokenNameIdentifier
.	TokenNameDOT
getXSLToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
psuedoVarRecipient	TokenNameIdentifier
.	TokenNameDOT
insertBefore	TokenNameIdentifier
(	TokenNameLPAREN
psuedoVar	TokenNameIdentifier
,	TokenNameCOMMA
ete	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_varNameCollector	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
psuedoVar	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
boolean	TokenNameboolean
isParam	TokenNameIdentifier
(	TokenNameLPAREN
ExpressionNode	TokenNameIdentifier
expr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
expr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
expr	TokenNameIdentifier
instanceof	TokenNameinstanceof
ElemTemplateElement	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
expr	TokenNameIdentifier
=	TokenNameEQUAL
expr	TokenNameIdentifier
.	TokenNameDOT
exprGetParent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
expr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemTemplateElement	TokenNameIdentifier
ete	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
)	TokenNameRPAREN
expr	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
ete	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
ete	TokenNameIdentifier
.	TokenNameDOT
getXSLToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_PARAMVARIABLE	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
case	TokenNamecase
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_TEMPLATE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_STYLESHEET	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ete	TokenNameIdentifier
=	TokenNameEQUAL
ete	TokenNameIdentifier
.	TokenNameDOT
getParentElem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
ElemVariable	TokenNameIdentifier
getPrevVariableElem	TokenNameIdentifier
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
elem	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
(	TokenNameLPAREN
elem	TokenNameIdentifier
=	TokenNameEQUAL
getPrevElementWithinContext	TokenNameIdentifier
(	TokenNameLPAREN
elem	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
elem	TokenNameIdentifier
.	TokenNameDOT
getXSLToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_VARIABLE	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
type	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_PARAMVARIABLE	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
type	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
ElemVariable	TokenNameIdentifier
)	TokenNameRPAREN
elem	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
ElemTemplateElement	TokenNameIdentifier
getPrevElementWithinContext	TokenNameIdentifier
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
elem	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemTemplateElement	TokenNameIdentifier
prev	TokenNameIdentifier
=	TokenNameEQUAL
elem	TokenNameIdentifier
.	TokenNameDOT
getPreviousSiblingElem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
prev	TokenNameIdentifier
)	TokenNameRPAREN
prev	TokenNameIdentifier
=	TokenNameEQUAL
elem	TokenNameIdentifier
.	TokenNameDOT
getParentElem	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
prev	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
prev	TokenNameIdentifier
.	TokenNameDOT
getXSLToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_FOREACH	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
type	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_TEMPLATE	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
type	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_STYLESHEET	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
type	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
prev	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
prev	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
ElemTemplateElement	TokenNameIdentifier
getElemFromExpression	TokenNameIdentifier
(	TokenNameLPAREN
Expression	TokenNameIdentifier
expr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ExpressionNode	TokenNameIdentifier
parent	TokenNameIdentifier
=	TokenNameEQUAL
expr	TokenNameIdentifier
.	TokenNameDOT
exprGetParent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
parent	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
parent	TokenNameIdentifier
instanceof	TokenNameinstanceof
ElemTemplateElement	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
)	TokenNameRPAREN
parent	TokenNameIdentifier
;	TokenNameSEMICOLON
parent	TokenNameIdentifier
=	TokenNameEQUAL
parent	TokenNameIdentifier
.	TokenNameDOT
exprGetParent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
XSLMessages	TokenNameIdentifier
.	TokenNameDOT
createMessage	TokenNameIdentifier
(	TokenNameLPAREN
XSLTErrorResources	TokenNameIdentifier
.	TokenNameDOT
ER_ASSERT_NO_TEMPLATE_PARENT	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isAbsolute	TokenNameIdentifier
(	TokenNameLPAREN
LocPathIterator	TokenNameIdentifier
path	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
analysis	TokenNameIdentifier
=	TokenNameEQUAL
path	TokenNameIdentifier
.	TokenNameDOT
getAnalysisBits	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isAbs	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
WalkerFactory	TokenNameIdentifier
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
analysis	TokenNameIdentifier
,	TokenNameCOMMA
WalkerFactory	TokenNameIdentifier
.	TokenNameDOT
BIT_ROOT	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
WalkerFactory	TokenNameIdentifier
.	TokenNameDOT
isSet	TokenNameIdentifier
(	TokenNameLPAREN
analysis	TokenNameIdentifier
,	TokenNameCOMMA
WalkerFactory	TokenNameIdentifier
.	TokenNameDOT
BIT_ANY_DESCENDANT_FROM_ROOT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isAbs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
isAbs	TokenNameIdentifier
=	TokenNameEQUAL
m_absPathChecker	TokenNameIdentifier
.	TokenNameDOT
checkAbsolute	TokenNameIdentifier
(	TokenNameLPAREN
path	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
isAbs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
visitLocationPath	TokenNameIdentifier
(	TokenNameLPAREN
ExpressionOwner	TokenNameIdentifier
owner	TokenNameIdentifier
,	TokenNameCOMMA
LocPathIterator	TokenNameIdentifier
path	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
path	TokenNameIdentifier
instanceof	TokenNameinstanceof
SelfIteratorNoPredicate	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
path	TokenNameIdentifier
instanceof	TokenNameinstanceof
WalkingIterator	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
WalkingIterator	TokenNameIdentifier
wi	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
WalkingIterator	TokenNameIdentifier
)	TokenNameRPAREN
path	TokenNameIdentifier
;	TokenNameSEMICOLON
AxesWalker	TokenNameIdentifier
aw	TokenNameIdentifier
=	TokenNameEQUAL
wi	TokenNameIdentifier
.	TokenNameDOT
getFirstWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
aw	TokenNameIdentifier
instanceof	TokenNameinstanceof
FilterExprWalker	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
aw	TokenNameIdentifier
.	TokenNameDOT
getNextWalker	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
FilterExprWalker	TokenNameIdentifier
few	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
FilterExprWalker	TokenNameIdentifier
)	TokenNameRPAREN
aw	TokenNameIdentifier
;	TokenNameSEMICOLON
Expression	TokenNameIdentifier
exp	TokenNameIdentifier
=	TokenNameEQUAL
few	TokenNameIdentifier
.	TokenNameDOT
getInnerExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
exp	TokenNameIdentifier
instanceof	TokenNameinstanceof
Variable	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isAbsolute	TokenNameIdentifier
(	TokenNameLPAREN
path	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
m_absPaths	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
validateNewAddition	TokenNameIdentifier
(	TokenNameLPAREN
m_absPaths	TokenNameIdentifier
,	TokenNameCOMMA
owner	TokenNameIdentifier
,	TokenNameCOMMA
path	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_absPaths	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
owner	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
m_isSameContext	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
m_paths	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
DEBUG	TokenNameIdentifier
)	TokenNameRPAREN
validateNewAddition	TokenNameIdentifier
(	TokenNameLPAREN
m_paths	TokenNameIdentifier
,	TokenNameCOMMA
owner	TokenNameIdentifier
,	TokenNameCOMMA
path	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_paths	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
owner	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
visitPredicate	TokenNameIdentifier
(	TokenNameLPAREN
ExpressionOwner	TokenNameIdentifier
owner	TokenNameIdentifier
,	TokenNameCOMMA
Expression	TokenNameIdentifier
pred	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
savedIsSame	TokenNameIdentifier
=	TokenNameEQUAL
m_isSameContext	TokenNameIdentifier
;	TokenNameSEMICOLON
m_isSameContext	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
pred	TokenNameIdentifier
.	TokenNameDOT
callVisitors	TokenNameIdentifier
(	TokenNameLPAREN
owner	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_isSameContext	TokenNameIdentifier
=	TokenNameEQUAL
savedIsSame	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
visitTopLevelInstruction	TokenNameIdentifier
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
elem	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
elem	TokenNameIdentifier
.	TokenNameDOT
getXSLToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_TEMPLATE	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
visitInstruction	TokenNameIdentifier
(	TokenNameLPAREN
elem	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
visitInstruction	TokenNameIdentifier
(	TokenNameLPAREN
ElemTemplateElement	TokenNameIdentifier
elem	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
type	TokenNameIdentifier
=	TokenNameEQUAL
elem	TokenNameIdentifier
.	TokenNameDOT
getXSLToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
type	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_CALLTEMPLATE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_TEMPLATE	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_FOREACH	TokenNameIdentifier
:	TokenNameCOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
type	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_FOREACH	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ElemForEach	TokenNameIdentifier
efe	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
ElemForEach	TokenNameIdentifier
)	TokenNameRPAREN
elem	TokenNameIdentifier
;	TokenNameSEMICOLON
Expression	TokenNameIdentifier
select	TokenNameIdentifier
=	TokenNameEQUAL
efe	TokenNameIdentifier
.	TokenNameDOT
getSelect	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
select	TokenNameIdentifier
.	TokenNameDOT
callVisitors	TokenNameIdentifier
(	TokenNameLPAREN
efe	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Vector	TokenNameIdentifier
savedPaths	TokenNameIdentifier
=	TokenNameEQUAL
m_paths	TokenNameIdentifier
;	TokenNameSEMICOLON
m_paths	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Vector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
elem	TokenNameIdentifier
.	TokenNameDOT
callChildVisitors	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
eleminateRedundentLocals	TokenNameIdentifier
(	TokenNameLPAREN
elem	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_paths	TokenNameIdentifier
=	TokenNameEQUAL
savedPaths	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_NUMBER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
Constants	TokenNameIdentifier
.	TokenNameDOT
ELEMNAME_SORT	TokenNameIdentifier
:	TokenNameCOLON
boolean	TokenNameboolean
savedIsSame	TokenNameIdentifier
=	TokenNameEQUAL
m_isSameContext	TokenNameIdentifier
;	TokenNameSEMICOLON
m_isSameContext	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
elem	TokenNameIdentifier
.	TokenNameDOT
callChildVisitors	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_isSameContext	TokenNameIdentifier
=	TokenNameEQUAL
savedIsSame	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
diagnoseNumPaths	TokenNameIdentifier
(	TokenNameLPAREN
Vector	TokenNameIdentifier
paths	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
numPathsEliminated	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
numUniquePathsEliminated	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
numPathsEliminated	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
paths	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
m_paths	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"Eliminated "	TokenNameStringLiteral
+	TokenNamePLUS
numPathsEliminated	TokenNameIdentifier
+	TokenNamePLUS
" total paths!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"Consolodated "	TokenNameStringLiteral
+	TokenNamePLUS
numUniquePathsEliminated	TokenNameIdentifier
+	TokenNamePLUS
" redundent paths!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"Eliminated "	TokenNameStringLiteral
+	TokenNamePLUS
numPathsEliminated	TokenNameIdentifier
+	TokenNamePLUS
" total global paths!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"Consolodated "	TokenNameStringLiteral
+	TokenNamePLUS
numUniquePathsEliminated	TokenNameIdentifier
+	TokenNamePLUS
" redundent global paths!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
void	TokenNamevoid
assertIsLocPathIterator	TokenNameIdentifier
(	TokenNameLPAREN
Expression	TokenNameIdentifier
expr1	TokenNameIdentifier
,	TokenNameCOMMA
ExpressionOwner	TokenNameIdentifier
eo	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
RuntimeException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
expr1	TokenNameIdentifier
instanceof	TokenNameinstanceof
LocPathIterator	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
errMsg	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
expr1	TokenNameIdentifier
instanceof	TokenNameinstanceof
Variable	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
errMsg	TokenNameIdentifier
=	TokenNameEQUAL
"Programmer's assertion: expr1 not an iterator: "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
Variable	TokenNameIdentifier
)	TokenNameRPAREN
expr1	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getQName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
errMsg	TokenNameIdentifier
=	TokenNameEQUAL
"Programmer's assertion: expr1 not an iterator: "	TokenNameStringLiteral
+	TokenNamePLUS
expr1	TokenNameIdentifier
.	TokenNameDOT
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
errMsg	TokenNameIdentifier
+	TokenNamePLUS
", "	TokenNameStringLiteral
+	TokenNamePLUS
eo	TokenNameIdentifier
.	TokenNameDOT
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" "	TokenNameStringLiteral
+	TokenNamePLUS
expr1	TokenNameIdentifier
.	TokenNameDOT
exprGetParent	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
validateNewAddition	TokenNameIdentifier
(	TokenNameLPAREN
Vector	TokenNameIdentifier
paths	TokenNameIdentifier
,	TokenNameCOMMA
ExpressionOwner	TokenNameIdentifier
owner	TokenNameIdentifier
,	TokenNameCOMMA
LocPathIterator	TokenNameIdentifier
path	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
RuntimeException	TokenNameIdentifier
{	TokenNameLBRACE
assertion	TokenNameIdentifier
(	TokenNameLPAREN
owner	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
path	TokenNameIdentifier
,	TokenNameCOMMA
"owner.getExpression() != path!!!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
n	TokenNameIdentifier
=	TokenNameEQUAL
paths	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
n	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
ExpressionOwner	TokenNameIdentifier
ew	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
ExpressionOwner	TokenNameIdentifier
)	TokenNameRPAREN
paths	TokenNameIdentifier
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assertion	TokenNameIdentifier
(	TokenNameLPAREN
ew	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
owner	TokenNameIdentifier
,	TokenNameCOMMA
"duplicate owner on the list!!!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assertion	TokenNameIdentifier
(	TokenNameLPAREN
ew	TokenNameIdentifier
.	TokenNameDOT
getExpression	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
path	TokenNameIdentifier
,	TokenNameCOMMA
"duplicate expression on the list!!!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
static	TokenNamestatic
void	TokenNamevoid
assertion	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
b	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
msg	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
XSLMessages	TokenNameIdentifier
.	TokenNameDOT
createMessage	TokenNameIdentifier
(	TokenNameLPAREN
XSLTErrorResources	TokenNameIdentifier
.	TokenNameDOT
ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
msg	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
class	TokenNameclass
MultistepExprHolder	TokenNameIdentifier
implements	TokenNameimplements
Cloneable	TokenNameIdentifier
{	TokenNameLBRACE
ExpressionOwner	TokenNameIdentifier
m_exprOwner	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
m_stepCount	TokenNameIdentifier
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Object	TokenNameIdentifier
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CloneNotSupportedException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
super	TokenNamesuper
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
MultistepExprHolder	TokenNameIdentifier
(	TokenNameLPAREN
ExpressionOwner	TokenNameIdentifier
exprOwner	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
stepCount	TokenNameIdentifier
,	TokenNameCOMMA
MultistepExprHolder	TokenNameIdentifier
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_exprOwner	TokenNameIdentifier
=	TokenNameEQUAL
exprOwner	TokenNameIdentifier
;	TokenNameSEMICOLON
assertion	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
m_exprOwner	TokenNameIdentifier
,	TokenNameCOMMA
"exprOwner can not be null!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_stepCount	TokenNameIdentifier
=	TokenNameEQUAL
stepCount	TokenNameIdentifier
;	TokenNameSEMICOLON
m_next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
MultistepExprHolder	TokenNameIdentifier
addInSortedOrder	TokenNameIdentifier
(	TokenNameLPAREN
ExpressionOwner	TokenNameIdentifier
exprOwner	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
stepCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
MultistepExprHolder	TokenNameIdentifier
first	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
next	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
prev	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
stepCount	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
next	TokenNameIdentifier
.	TokenNameDOT
m_stepCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
MultistepExprHolder	TokenNameIdentifier
newholder	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MultistepExprHolder	TokenNameIdentifier
(	TokenNameLPAREN
exprOwner	TokenNameIdentifier
,	TokenNameCOMMA
stepCount	TokenNameIdentifier
,	TokenNameCOMMA
next	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
prev	TokenNameIdentifier
)	TokenNameRPAREN
first	TokenNameIdentifier
=	TokenNameEQUAL
newholder	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
prev	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
=	TokenNameEQUAL
newholder	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
first	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
prev	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
prev	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MultistepExprHolder	TokenNameIdentifier
(	TokenNameLPAREN
exprOwner	TokenNameIdentifier
,	TokenNameCOMMA
stepCount	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
first	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
MultistepExprHolder	TokenNameIdentifier
unlink	TokenNameIdentifier
(	TokenNameLPAREN
MultistepExprHolder	TokenNameIdentifier
itemToRemove	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
MultistepExprHolder	TokenNameIdentifier
first	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
next	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
prev	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
next	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
itemToRemove	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
prev	TokenNameIdentifier
)	TokenNameRPAREN
first	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
prev	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
next	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
return	TokenNamereturn
first	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
prev	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assertion	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
"unlink failed!!!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
next	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
diagnose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"Found multistep iterators: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
.	TokenNameDOT
getLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"  "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
MultistepExprHolder	TokenNameIdentifier
next	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
""	TokenNameStringLiteral
+	TokenNamePLUS
next	TokenNameIdentifier
.	TokenNameDOT
m_stepCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
.	TokenNameDOT
m_next	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
next	TokenNameIdentifier
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
", "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
