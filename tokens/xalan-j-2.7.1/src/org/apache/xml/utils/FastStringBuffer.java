package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
FastStringBuffer	TokenNameIdentifier
{	TokenNameLBRACE
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DEBUG_FORCE_INIT_BITS	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
DEBUG_FORCE_FIXED_CHUNKSIZE	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
SUPPRESS_LEADING_WS	TokenNameIdentifier
=	TokenNameEQUAL
0x01	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
SUPPRESS_TRAILING_WS	TokenNameIdentifier
=	TokenNameEQUAL
0x02	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
SUPPRESS_BOTH	TokenNameIdentifier
=	TokenNameEQUAL
SUPPRESS_LEADING_WS	TokenNameIdentifier
|	TokenNameOR
SUPPRESS_TRAILING_WS	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
CARRY_WS	TokenNameIdentifier
=	TokenNameEQUAL
0x04	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
m_chunkBits	TokenNameIdentifier
=	TokenNameEQUAL
15	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
m_maxChunkBits	TokenNameIdentifier
=	TokenNameEQUAL
15	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
m_rebundleBits	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
m_array	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
m_lastChunk	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
FastStringBuffer	TokenNameIdentifier
m_innerFSB	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
public	TokenNamepublic
FastStringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
initChunkBits	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
maxChunkBits	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
rebundleBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
DEBUG_FORCE_INIT_BITS	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
initChunkBits	TokenNameIdentifier
=	TokenNameEQUAL
DEBUG_FORCE_INIT_BITS	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
DEBUG_FORCE_FIXED_CHUNKSIZE	TokenNameIdentifier
)	TokenNameRPAREN
maxChunkBits	TokenNameIdentifier
=	TokenNameEQUAL
initChunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
m_array	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
initChunkBits	TokenNameIdentifier
>	TokenNameGREATER
maxChunkBits	TokenNameIdentifier
)	TokenNameRPAREN
initChunkBits	TokenNameIdentifier
=	TokenNameEQUAL
maxChunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
m_chunkBits	TokenNameIdentifier
=	TokenNameEQUAL
initChunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
m_maxChunkBits	TokenNameIdentifier
=	TokenNameEQUAL
maxChunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
m_rebundleBits	TokenNameIdentifier
=	TokenNameEQUAL
rebundleBits	TokenNameIdentifier
;	TokenNameSEMICOLON
m_chunkSize	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
(	TokenNameLPAREN
initChunkBits	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_chunkMask	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
m_chunkSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
FastStringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
initChunkBits	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
maxChunkBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
initChunkBits	TokenNameIdentifier
,	TokenNameCOMMA
maxChunkBits	TokenNameIdentifier
,	TokenNameCOMMA
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
FastStringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
initChunkBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
initChunkBits	TokenNameIdentifier
,	TokenNameCOMMA
15	TokenNameIntegerLiteral
,	TokenNameCOMMA
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
FastStringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
10	TokenNameIntegerLiteral
,	TokenNameCOMMA
15	TokenNameIntegerLiteral
,	TokenNameCOMMA
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
int	TokenNameint
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
m_chunkBits	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
m_firstFree	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
int	TokenNameint
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
m_chunkBits	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
m_firstFree	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
m_lastChunk	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
FastStringBuffer	TokenNameIdentifier
innermost	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
innermost	TokenNameIdentifier
.	TokenNameDOT
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
innermost	TokenNameIdentifier
=	TokenNameEQUAL
innermost	TokenNameIdentifier
.	TokenNameDOT
m_innerFSB	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_chunkBits	TokenNameIdentifier
=	TokenNameEQUAL
innermost	TokenNameIdentifier
.	TokenNameDOT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
m_chunkSize	TokenNameIdentifier
=	TokenNameEQUAL
innermost	TokenNameIdentifier
.	TokenNameDOT
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
m_chunkMask	TokenNameIdentifier
=	TokenNameEQUAL
innermost	TokenNameIdentifier
.	TokenNameDOT
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
m_innerFSB	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
m_array	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
m_chunkSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
setLength	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
l	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_lastChunk	TokenNameIdentifier
=	TokenNameEQUAL
l	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_innerFSB	TokenNameIdentifier
.	TokenNameDOT
setLength	TokenNameIdentifier
(	TokenNameLPAREN
l	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
l	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_firstFree	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_lastChunk	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
--	TokenNameMINUS_MINUS
m_lastChunk	TokenNameIdentifier
;	TokenNameSEMICOLON
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
void	TokenNamevoid
setLength	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
l	TokenNameIdentifier
,	TokenNameCOMMA
FastStringBuffer	TokenNameIdentifier
rootFSB	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_lastChunk	TokenNameIdentifier
=	TokenNameEQUAL
l	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
m_innerFSB	TokenNameIdentifier
.	TokenNameDOT
setLength	TokenNameIdentifier
(	TokenNameLPAREN
l	TokenNameIdentifier
,	TokenNameCOMMA
rootFSB	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
rootFSB	TokenNameIdentifier
.	TokenNameDOT
m_chunkBits	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
rootFSB	TokenNameIdentifier
.	TokenNameDOT
m_maxChunkBits	TokenNameIdentifier
=	TokenNameEQUAL
m_maxChunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
rootFSB	TokenNameIdentifier
.	TokenNameDOT
m_rebundleBits	TokenNameIdentifier
=	TokenNameEQUAL
m_rebundleBits	TokenNameIdentifier
;	TokenNameSEMICOLON
rootFSB	TokenNameIdentifier
.	TokenNameDOT
m_chunkSize	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
rootFSB	TokenNameIdentifier
.	TokenNameDOT
m_chunkMask	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
rootFSB	TokenNameIdentifier
.	TokenNameDOT
m_array	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
;	TokenNameSEMICOLON
rootFSB	TokenNameIdentifier
.	TokenNameDOT
m_innerFSB	TokenNameIdentifier
=	TokenNameEQUAL
m_innerFSB	TokenNameIdentifier
;	TokenNameSEMICOLON
rootFSB	TokenNameIdentifier
.	TokenNameDOT
m_lastChunk	TokenNameIdentifier
=	TokenNameEQUAL
m_lastChunk	TokenNameIdentifier
;	TokenNameSEMICOLON
rootFSB	TokenNameIdentifier
.	TokenNameDOT
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
l	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
length	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
m_chunkBits	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
m_firstFree	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
getString	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
StringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
length	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
append	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
value	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
chunk	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_firstFree	TokenNameIdentifier
<	TokenNameLESS
m_chunkSize	TokenNameIdentifier
)	TokenNameRPAREN
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newarray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newarray	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_array	TokenNameIdentifier
=	TokenNameEQUAL
newarray	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
++	TokenNamePLUS_PLUS
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
chunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
m_rebundleBits	TokenNameIdentifier
&&	TokenNameAND_AND
m_chunkBits	TokenNameIdentifier
<	TokenNameLESS
m_maxChunkBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_innerFSB	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FastStringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
m_chunkSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
[	TokenNameLBRACKET
m_firstFree	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
value	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
append	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
value	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
value	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
strlen	TokenNameIdentifier
=	TokenNameEQUAL
value	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
strlen	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
copyfrom	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
available	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
m_firstFree	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
strlen	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
available	TokenNameIdentifier
>	TokenNameGREATER
strlen	TokenNameIdentifier
)	TokenNameRPAREN
available	TokenNameIdentifier
=	TokenNameEQUAL
strlen	TokenNameIdentifier
;	TokenNameSEMICOLON
value	TokenNameIdentifier
.	TokenNameDOT
getChars	TokenNameIdentifier
(	TokenNameLPAREN
copyfrom	TokenNameIdentifier
,	TokenNameCOMMA
copyfrom	TokenNameIdentifier
+	TokenNamePLUS
available	TokenNameIdentifier
,	TokenNameCOMMA
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
m_firstFree	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
strlen	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
copyfrom	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
strlen	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newarray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newarray	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_array	TokenNameIdentifier
=	TokenNameEQUAL
newarray	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
++	TokenNamePLUS_PLUS
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
chunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
m_rebundleBits	TokenNameIdentifier
&&	TokenNameAND_AND
m_chunkBits	TokenNameIdentifier
<	TokenNameLESS
m_maxChunkBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_innerFSB	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FastStringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
m_chunkSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
available	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
m_firstFree	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
append	TokenNameIdentifier
(	TokenNameLPAREN
StringBuffer	TokenNameIdentifier
value	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
value	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
strlen	TokenNameIdentifier
=	TokenNameEQUAL
value	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
strlen	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
copyfrom	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
available	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
m_firstFree	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
strlen	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
available	TokenNameIdentifier
>	TokenNameGREATER
strlen	TokenNameIdentifier
)	TokenNameRPAREN
available	TokenNameIdentifier
=	TokenNameEQUAL
strlen	TokenNameIdentifier
;	TokenNameSEMICOLON
value	TokenNameIdentifier
.	TokenNameDOT
getChars	TokenNameIdentifier
(	TokenNameLPAREN
copyfrom	TokenNameIdentifier
,	TokenNameCOMMA
copyfrom	TokenNameIdentifier
+	TokenNamePLUS
available	TokenNameIdentifier
,	TokenNameCOMMA
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
m_firstFree	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
strlen	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
copyfrom	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
strlen	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newarray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newarray	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_array	TokenNameIdentifier
=	TokenNameEQUAL
newarray	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
++	TokenNamePLUS_PLUS
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
chunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
m_rebundleBits	TokenNameIdentifier
&&	TokenNameAND_AND
m_chunkBits	TokenNameIdentifier
<	TokenNameLESS
m_maxChunkBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_innerFSB	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FastStringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
m_chunkSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
available	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
m_firstFree	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
append	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
chars	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
strlen	TokenNameIdentifier
=	TokenNameEQUAL
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
strlen	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
copyfrom	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
available	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
m_firstFree	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
strlen	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
available	TokenNameIdentifier
>	TokenNameGREATER
strlen	TokenNameIdentifier
)	TokenNameRPAREN
available	TokenNameIdentifier
=	TokenNameEQUAL
strlen	TokenNameIdentifier
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
chars	TokenNameIdentifier
,	TokenNameCOMMA
copyfrom	TokenNameIdentifier
,	TokenNameCOMMA
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
m_firstFree	TokenNameIdentifier
,	TokenNameCOMMA
available	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
strlen	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
copyfrom	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
strlen	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newarray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newarray	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_array	TokenNameIdentifier
=	TokenNameEQUAL
newarray	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
++	TokenNamePLUS_PLUS
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
chunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
m_rebundleBits	TokenNameIdentifier
&&	TokenNameAND_AND
m_chunkBits	TokenNameIdentifier
<	TokenNameLESS
m_maxChunkBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_innerFSB	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FastStringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
m_chunkSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
available	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
m_firstFree	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
append	TokenNameIdentifier
(	TokenNameLPAREN
FastStringBuffer	TokenNameIdentifier
value	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
value	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
strlen	TokenNameIdentifier
=	TokenNameEQUAL
value	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
strlen	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
copyfrom	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
available	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
m_firstFree	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
strlen	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
available	TokenNameIdentifier
>	TokenNameGREATER
strlen	TokenNameIdentifier
)	TokenNameRPAREN
available	TokenNameIdentifier
=	TokenNameEQUAL
strlen	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
sourcechunk	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
copyfrom	TokenNameIdentifier
+	TokenNamePLUS
value	TokenNameIdentifier
.	TokenNameDOT
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
value	TokenNameIdentifier
.	TokenNameDOT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
sourcecolumn	TokenNameIdentifier
=	TokenNameEQUAL
copyfrom	TokenNameIdentifier
&	TokenNameAND
value	TokenNameIdentifier
.	TokenNameDOT
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
runlength	TokenNameIdentifier
=	TokenNameEQUAL
value	TokenNameIdentifier
.	TokenNameDOT
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
sourcecolumn	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
runlength	TokenNameIdentifier
>	TokenNameGREATER
available	TokenNameIdentifier
)	TokenNameRPAREN
runlength	TokenNameIdentifier
=	TokenNameEQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
value	TokenNameIdentifier
.	TokenNameDOT
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
sourcechunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
sourcecolumn	TokenNameIdentifier
,	TokenNameCOMMA
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
m_firstFree	TokenNameIdentifier
,	TokenNameCOMMA
runlength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
runlength	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
available	TokenNameIdentifier
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
value	TokenNameIdentifier
.	TokenNameDOT
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
sourcechunk	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
m_firstFree	TokenNameIdentifier
+	TokenNamePLUS
runlength	TokenNameIdentifier
,	TokenNameCOMMA
available	TokenNameIdentifier
-	TokenNameMINUS
runlength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
strlen	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
copyfrom	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
strlen	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newarray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newarray	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_array	TokenNameIdentifier
=	TokenNameEQUAL
newarray	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
++	TokenNamePLUS_PLUS
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
chunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_lastChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
m_rebundleBits	TokenNameIdentifier
&&	TokenNameAND_AND
m_chunkBits	TokenNameIdentifier
<	TokenNameLESS
m_maxChunkBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_innerFSB	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FastStringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
chunk	TokenNameIdentifier
=	TokenNameEQUAL
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
m_lastChunk	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
m_chunkSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
available	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
m_firstFree	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
available	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isWhitespace	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
sourcechunk	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
sourcecolumn	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
available	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
sourcecolumn	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
chunkOK	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
length	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
runlength	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
length	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
available	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
length	TokenNameIdentifier
:	TokenNameCOLON
available	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
sourcechunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
chunkOK	TokenNameIdentifier
=	TokenNameEQUAL
m_innerFSB	TokenNameIdentifier
.	TokenNameDOT
isWhitespace	TokenNameIdentifier
(	TokenNameLPAREN
sourcecolumn	TokenNameIdentifier
,	TokenNameCOMMA
runlength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
chunkOK	TokenNameIdentifier
=	TokenNameEQUAL
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
.	TokenNameDOT
XMLCharacterRecognizer	TokenNameIdentifier
.	TokenNameDOT
isWhiteSpace	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
sourcechunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
sourcecolumn	TokenNameIdentifier
,	TokenNameCOMMA
runlength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
chunkOK	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
length	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
runlength	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
sourcechunk	TokenNameIdentifier
;	TokenNameSEMICOLON
sourcecolumn	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
available	TokenNameIdentifier
=	TokenNameEQUAL
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getString	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
startColumn	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
startChunk	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startColumn	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
<	TokenNameLESS
m_chunkMask	TokenNameIdentifier
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getOneChunkString	TokenNameIdentifier
(	TokenNameLPAREN
startChunk	TokenNameIdentifier
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
getString	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
StringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
length	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
startChunk	TokenNameIdentifier
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
String	TokenNameIdentifier
getOneChunkString	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
startChunk	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
String	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
startChunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
StringBuffer	TokenNameIdentifier
getString	TokenNameIdentifier
(	TokenNameLPAREN
StringBuffer	TokenNameIdentifier
sb	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getString	TokenNameIdentifier
(	TokenNameLPAREN
sb	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
StringBuffer	TokenNameIdentifier
getString	TokenNameIdentifier
(	TokenNameLPAREN
StringBuffer	TokenNameIdentifier
sb	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
startChunk	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
stop	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
startChunk	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
m_chunkBits	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
startColumn	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
stopChunk	TokenNameIdentifier
=	TokenNameEQUAL
stop	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
stopColumn	TokenNameIdentifier
=	TokenNameEQUAL
stop	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
startChunk	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
stopChunk	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
m_innerFSB	TokenNameIdentifier
.	TokenNameDOT
getString	TokenNameIdentifier
(	TokenNameLPAREN
sb	TokenNameIdentifier
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
startColumn	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
stopChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
m_innerFSB	TokenNameIdentifier
.	TokenNameDOT
getString	TokenNameIdentifier
(	TokenNameLPAREN
sb	TokenNameIdentifier
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
stopColumn	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
stopColumn	TokenNameIdentifier
>	TokenNameGREATER
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
stopChunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
stopColumn	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
sb	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
char	TokenNamechar
charAt	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
pos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
startChunk	TokenNameIdentifier
=	TokenNameEQUAL
pos	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
m_innerFSB	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
pos	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
startChunk	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
pos	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
sendSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
ContentHandler	TokenNameIdentifier
ch	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
SAXException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
startChunk	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
startColumn	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startColumn	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
<	TokenNameLESS
m_chunkMask	TokenNameIdentifier
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
.	TokenNameDOT
characters	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
startChunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
stop	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
stopChunk	TokenNameIdentifier
=	TokenNameEQUAL
stop	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
stopColumn	TokenNameIdentifier
=	TokenNameEQUAL
stop	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
startChunk	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
stopChunk	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
m_innerFSB	TokenNameIdentifier
.	TokenNameDOT
sendSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
ch	TokenNameIdentifier
.	TokenNameDOT
characters	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
startColumn	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
stopChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
m_innerFSB	TokenNameIdentifier
.	TokenNameDOT
sendSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
stopColumn	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
stopColumn	TokenNameIdentifier
>	TokenNameGREATER
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
.	TokenNameDOT
characters	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
stopChunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
stopColumn	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
sendNormalizedSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
ContentHandler	TokenNameIdentifier
ch	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
SAXException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
stateForNextChunk	TokenNameIdentifier
=	TokenNameEQUAL
SUPPRESS_LEADING_WS	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
stop	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
startChunk	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
startColumn	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
stopChunk	TokenNameIdentifier
=	TokenNameEQUAL
stop	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
stopColumn	TokenNameIdentifier
=	TokenNameEQUAL
stop	TokenNameIdentifier
&	TokenNameAND
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
startChunk	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
stopChunk	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
stateForNextChunk	TokenNameIdentifier
=	TokenNameEQUAL
m_innerFSB	TokenNameIdentifier
.	TokenNameDOT
sendNormalizedSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
stateForNextChunk	TokenNameIdentifier
=	TokenNameEQUAL
sendNormalizedSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
ch	TokenNameIdentifier
,	TokenNameCOMMA
stateForNextChunk	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
startColumn	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
stopChunk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
m_innerFSB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
stateForNextChunk	TokenNameIdentifier
=	TokenNameEQUAL
m_innerFSB	TokenNameIdentifier
.	TokenNameDOT
sendNormalizedSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
stopColumn	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
stopColumn	TokenNameIdentifier
>	TokenNameGREATER
startColumn	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
stateForNextChunk	TokenNameIdentifier
=	TokenNameEQUAL
sendNormalizedSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
m_array	TokenNameIdentifier
[	TokenNameLBRACKET
stopChunk	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
stopColumn	TokenNameIdentifier
-	TokenNameMINUS
startColumn	TokenNameIdentifier
,	TokenNameCOMMA
ch	TokenNameIdentifier
,	TokenNameCOMMA
stateForNextChunk	TokenNameIdentifier
|	TokenNameOR
SUPPRESS_TRAILING_WS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
stateForNextChunk	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
SINGLE_SPACE	TokenNameIdentifier
=	TokenNameEQUAL
{	TokenNameLBRACE
' '	TokenNameCharacterLiteral
}	TokenNameRBRACE
;	TokenNameSEMICOLON
static	TokenNamestatic
int	TokenNameint
sendNormalizedSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
ch	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
,	TokenNameCOMMA
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
ContentHandler	TokenNameIdentifier
handler	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
edgeTreatmentFlags	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
SAXException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
processingLeadingWhitespace	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
edgeTreatmentFlags	TokenNameIdentifier
&	TokenNameAND
SUPPRESS_LEADING_WS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
seenWhitespace	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
edgeTreatmentFlags	TokenNameIdentifier
&	TokenNameAND
CARRY_WS	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
currPos	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
limit	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
processingLeadingWhitespace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
currPos	TokenNameIdentifier
<	TokenNameLESS
limit	TokenNameIdentifier
&&	TokenNameAND_AND
XMLCharacterRecognizer	TokenNameIdentifier
.	TokenNameDOT
isWhiteSpace	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
[	TokenNameLBRACKET
currPos	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
currPos	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
currPos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
edgeTreatmentFlags	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
currPos	TokenNameIdentifier
<	TokenNameLESS
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
startNonWhitespace	TokenNameIdentifier
=	TokenNameEQUAL
currPos	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
currPos	TokenNameIdentifier
<	TokenNameLESS
limit	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
XMLCharacterRecognizer	TokenNameIdentifier
.	TokenNameDOT
isWhiteSpace	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
[	TokenNameLBRACKET
currPos	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
currPos	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
startNonWhitespace	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
currPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
seenWhitespace	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handler	TokenNameIdentifier
.	TokenNameDOT
characters	TokenNameIdentifier
(	TokenNameLPAREN
SINGLE_SPACE	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
seenWhitespace	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
handler	TokenNameIdentifier
.	TokenNameDOT
characters	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
startNonWhitespace	TokenNameIdentifier
,	TokenNameCOMMA
currPos	TokenNameIdentifier
-	TokenNameMINUS
startNonWhitespace	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
startWhitespace	TokenNameIdentifier
=	TokenNameEQUAL
currPos	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
currPos	TokenNameIdentifier
<	TokenNameLESS
limit	TokenNameIdentifier
&&	TokenNameAND_AND
XMLCharacterRecognizer	TokenNameIdentifier
.	TokenNameDOT
isWhiteSpace	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
[	TokenNameLBRACKET
currPos	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
currPos	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
startWhitespace	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
currPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
seenWhitespace	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
seenWhitespace	TokenNameIdentifier
?	TokenNameQUESTION
CARRY_WS	TokenNameIdentifier
:	TokenNameCOLON
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
edgeTreatmentFlags	TokenNameIdentifier
&	TokenNameAND
SUPPRESS_TRAILING_WS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
sendNormalizedSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
ch	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
,	TokenNameCOMMA
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
ContentHandler	TokenNameIdentifier
handler	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
SAXException	TokenNameIdentifier
{	TokenNameLBRACE
sendNormalizedSAXcharacters	TokenNameIdentifier
(	TokenNameLPAREN
ch	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
,	TokenNameCOMMA
handler	TokenNameIdentifier
,	TokenNameCOMMA
SUPPRESS_BOTH	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
sendSAXComment	TokenNameIdentifier
(	TokenNameLPAREN
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
ext	TokenNameIdentifier
.	TokenNameDOT
LexicalHandler	TokenNameIdentifier
ch	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
org	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
sax	TokenNameIdentifier
.	TokenNameDOT
SAXException	TokenNameIdentifier
{	TokenNameLBRACE
String	TokenNameIdentifier
comment	TokenNameIdentifier
=	TokenNameEQUAL
getString	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
.	TokenNameDOT
comment	TokenNameIdentifier
(	TokenNameLPAREN
comment	TokenNameIdentifier
.	TokenNameDOT
toCharArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
getChars	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
srcBegin	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
srcEnd	TokenNameIdentifier
,	TokenNameCOMMA
char	TokenNamechar
dst	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
,	TokenNameCOMMA
int	TokenNameint
dstBegin	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
private	TokenNameprivate
FastStringBuffer	TokenNameIdentifier
(	TokenNameLPAREN
FastStringBuffer	TokenNameIdentifier
source	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_chunkBits	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
m_chunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
m_maxChunkBits	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
m_maxChunkBits	TokenNameIdentifier
;	TokenNameSEMICOLON
m_rebundleBits	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
m_rebundleBits	TokenNameIdentifier
;	TokenNameSEMICOLON
m_chunkSize	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
m_chunkMask	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
m_chunkMask	TokenNameIdentifier
;	TokenNameSEMICOLON
m_array	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
m_array	TokenNameIdentifier
;	TokenNameSEMICOLON
m_innerFSB	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
m_innerFSB	TokenNameIdentifier
;	TokenNameSEMICOLON
m_lastChunk	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
m_lastChunk	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
m_chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
source	TokenNameIdentifier
.	TokenNameDOT
m_array	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
source	TokenNameIdentifier
.	TokenNameDOT
m_innerFSB	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
source	TokenNameIdentifier
.	TokenNameDOT
m_lastChunk	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
source	TokenNameIdentifier
.	TokenNameDOT
m_firstFree	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
source	TokenNameIdentifier
.	TokenNameDOT
m_chunkBits	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
m_rebundleBits	TokenNameIdentifier
;	TokenNameSEMICOLON
source	TokenNameIdentifier
.	TokenNameDOT
m_chunkSize	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
(	TokenNameLPAREN
source	TokenNameIdentifier
.	TokenNameDOT
m_chunkBits	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
source	TokenNameIdentifier
.	TokenNameDOT
m_chunkMask	TokenNameIdentifier
=	TokenNameEQUAL
source	TokenNameIdentifier
.	TokenNameDOT
m_chunkSize	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
