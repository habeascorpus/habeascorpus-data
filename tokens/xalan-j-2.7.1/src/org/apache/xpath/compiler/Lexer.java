package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
compiler	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Vector	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
utils	TokenNameIdentifier
.	TokenNameDOT
PrefixResolver	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
xpath	TokenNameIdentifier
.	TokenNameDOT
res	TokenNameIdentifier
.	TokenNameDOT
XPATHErrorResources	TokenNameIdentifier
;	TokenNameSEMICOLON
class	TokenNameclass
Lexer	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
Compiler	TokenNameIdentifier
m_compiler	TokenNameIdentifier
;	TokenNameSEMICOLON
PrefixResolver	TokenNameIdentifier
m_namespaceContext	TokenNameIdentifier
;	TokenNameSEMICOLON
XPathParser	TokenNameIdentifier
m_processor	TokenNameIdentifier
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
TARGETEXTRA	TokenNameIdentifier
=	TokenNameEQUAL
10000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
m_patternMap	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
100	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
m_patternMapSize	TokenNameIdentifier
;	TokenNameSEMICOLON
Lexer	TokenNameIdentifier
(	TokenNameLPAREN
Compiler	TokenNameIdentifier
compiler	TokenNameIdentifier
,	TokenNameCOMMA
PrefixResolver	TokenNameIdentifier
resolver	TokenNameIdentifier
,	TokenNameCOMMA
XPathParser	TokenNameIdentifier
xpathProcessor	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_compiler	TokenNameIdentifier
=	TokenNameEQUAL
compiler	TokenNameIdentifier
;	TokenNameSEMICOLON
m_namespaceContext	TokenNameIdentifier
=	TokenNameEQUAL
resolver	TokenNameIdentifier
;	TokenNameSEMICOLON
m_processor	TokenNameIdentifier
=	TokenNameEQUAL
xpathProcessor	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
tokenize	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
pat	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
javax	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
transform	TokenNameIdentifier
.	TokenNameDOT
TransformerException	TokenNameIdentifier
{	TokenNameLBRACE
tokenize	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
tokenize	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
pat	TokenNameIdentifier
,	TokenNameCOMMA
Vector	TokenNameIdentifier
targetStrings	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
javax	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
transform	TokenNameIdentifier
.	TokenNameDOT
TransformerException	TokenNameIdentifier
{	TokenNameLBRACE
m_compiler	TokenNameIdentifier
.	TokenNameDOT
m_currentPattern	TokenNameIdentifier
=	TokenNameEQUAL
pat	TokenNameIdentifier
;	TokenNameSEMICOLON
m_patternMapSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
initTokQueueSize	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
<	TokenNameLESS
OpMap	TokenNameIdentifier
.	TokenNameDOT
MAXTOKENQUEUESIZE	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
pat	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
OpMap	TokenNameIdentifier
.	TokenNameDOT
MAXTOKENQUEUESIZE	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
5	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
m_compiler	TokenNameIdentifier
.	TokenNameDOT
m_opMap	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
OpMapVector	TokenNameIdentifier
(	TokenNameLPAREN
initTokQueueSize	TokenNameIdentifier
,	TokenNameCOMMA
OpMap	TokenNameIdentifier
.	TokenNameDOT
BLOCKTOKENQUEUESIZE	TokenNameIdentifier
*	TokenNameMULTIPLY
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
OpMap	TokenNameIdentifier
.	TokenNameDOT
MAPINDEX_LENGTH	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
nChars	TokenNameIdentifier
=	TokenNameEQUAL
pat	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
startSubstring	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
posOfNSSep	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isStartOfPat	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isAttrName	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
isNum	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
int	TokenNameint
nesting	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
nChars	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
c	TokenNameIdentifier
=	TokenNameEQUAL
pat	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'\"'	TokenNameCharacterLiteral
:	TokenNameCOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
isNum	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
isStartOfPat	TokenNameIdentifier
=	TokenNameEQUAL
mapPatternElemPos	TokenNameIdentifier
(	TokenNameLPAREN
nesting	TokenNameIdentifier
,	TokenNameCOMMA
isStartOfPat	TokenNameIdentifier
,	TokenNameCOMMA
isAttrName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
isAttrName	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
!=	TokenNameNOT_EQUAL
posOfNSSep	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
posOfNSSep	TokenNameIdentifier
=	TokenNameEQUAL
mapNSTokens	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
,	TokenNameCOMMA
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
posOfNSSep	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
startSubstring	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
nChars	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
c	TokenNameIdentifier
=	TokenNameEQUAL
pat	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
'\"'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'\"'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
i	TokenNameIdentifier
<	TokenNameLESS
nChars	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
startSubstring	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_processor	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
(	TokenNameLPAREN
XPATHErrorResources	TokenNameIdentifier
.	TokenNameDOT
ER_EXPECTED_DOUBLE_QUOTE	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'\''	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
isNum	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
isStartOfPat	TokenNameIdentifier
=	TokenNameEQUAL
mapPatternElemPos	TokenNameIdentifier
(	TokenNameLPAREN
nesting	TokenNameIdentifier
,	TokenNameCOMMA
isStartOfPat	TokenNameIdentifier
,	TokenNameCOMMA
isAttrName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
isAttrName	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
!=	TokenNameNOT_EQUAL
posOfNSSep	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
posOfNSSep	TokenNameIdentifier
=	TokenNameEQUAL
mapNSTokens	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
,	TokenNameCOMMA
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
posOfNSSep	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
startSubstring	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
nChars	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
c	TokenNameIdentifier
=	TokenNameEQUAL
pat	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
'\''	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'\''	TokenNameCharacterLiteral
&&	TokenNameAND_AND
i	TokenNameIdentifier
<	TokenNameLESS
nChars	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
startSubstring	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_processor	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
(	TokenNameLPAREN
XPATHErrorResources	TokenNameIdentifier
.	TokenNameDOT
ER_EXPECTED_SINGLE_QUOTE	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
0x0A	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
0x0D	TokenNameIntegerLiteral
:	TokenNameCOLON
case	TokenNamecase
' '	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'\t'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
isNum	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
isStartOfPat	TokenNameIdentifier
=	TokenNameEQUAL
mapPatternElemPos	TokenNameIdentifier
(	TokenNameLPAREN
nesting	TokenNameIdentifier
,	TokenNameCOMMA
isStartOfPat	TokenNameIdentifier
,	TokenNameCOMMA
isAttrName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
isAttrName	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
!=	TokenNameNOT_EQUAL
posOfNSSep	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
posOfNSSep	TokenNameIdentifier
=	TokenNameEQUAL
mapNSTokens	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
,	TokenNameCOMMA
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
posOfNSSep	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
startSubstring	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
'@'	TokenNameCharacterLiteral
:	TokenNameCOLON
isAttrName	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
case	TokenNamecase
'-'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
'-'	TokenNameCharacterLiteral
==	TokenNameEQUAL_EQUAL
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
isNum	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
isNum	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
case	TokenNamecase
'('	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'['	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
')'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
']'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'|'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'/'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'*'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'+'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'='	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
','	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'\\'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'^'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'!'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'$'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'<'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
'>'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
isNum	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
isStartOfPat	TokenNameIdentifier
=	TokenNameEQUAL
mapPatternElemPos	TokenNameIdentifier
(	TokenNameLPAREN
nesting	TokenNameIdentifier
,	TokenNameCOMMA
isStartOfPat	TokenNameIdentifier
,	TokenNameCOMMA
isAttrName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
isAttrName	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
!=	TokenNameNOT_EQUAL
posOfNSSep	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
posOfNSSep	TokenNameIdentifier
=	TokenNameEQUAL
mapNSTokens	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
,	TokenNameCOMMA
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
posOfNSSep	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
startSubstring	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
'/'	TokenNameCharacterLiteral
==	TokenNameEQUAL_EQUAL
c	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
isStartOfPat	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
isStartOfPat	TokenNameIdentifier
=	TokenNameEQUAL
mapPatternElemPos	TokenNameIdentifier
(	TokenNameLPAREN
nesting	TokenNameIdentifier
,	TokenNameCOMMA
isStartOfPat	TokenNameIdentifier
,	TokenNameCOMMA
isAttrName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
'*'	TokenNameCharacterLiteral
==	TokenNameEQUAL_EQUAL
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
isStartOfPat	TokenNameIdentifier
=	TokenNameEQUAL
mapPatternElemPos	TokenNameIdentifier
(	TokenNameLPAREN
nesting	TokenNameIdentifier
,	TokenNameCOMMA
isStartOfPat	TokenNameIdentifier
,	TokenNameCOMMA
isAttrName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
isAttrName	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
nesting	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
'|'	TokenNameCharacterLiteral
==	TokenNameEQUAL_EQUAL
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
targetStrings	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
recordTokenString	TokenNameIdentifier
(	TokenNameLPAREN
targetStrings	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
isStartOfPat	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
')'	TokenNameCharacterLiteral
==	TokenNameEQUAL_EQUAL
c	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
']'	TokenNameCharacterLiteral
==	TokenNameEQUAL_EQUAL
c	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
nesting	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
'('	TokenNameCharacterLiteral
==	TokenNameEQUAL_EQUAL
c	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
'['	TokenNameCharacterLiteral
==	TokenNameEQUAL_EQUAL
c	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
nesting	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
':'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
posOfNSSep	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
(	TokenNameLPAREN
i	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
<	TokenNameLESS
(	TokenNameLPAREN
i	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
isNum	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
isAttrName	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
startSubstring	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
posOfNSSep	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
posOfNSSep	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
default	TokenNamedefault
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
startSubstring	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
startSubstring	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
isNum	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
isDigit	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
isNum	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
isNum	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
isDigit	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
isNum	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
isStartOfPat	TokenNameIdentifier
=	TokenNameEQUAL
mapPatternElemPos	TokenNameIdentifier
(	TokenNameLPAREN
nesting	TokenNameIdentifier
,	TokenNameCOMMA
isStartOfPat	TokenNameIdentifier
,	TokenNameCOMMA
isAttrName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
!=	TokenNameNOT_EQUAL
posOfNSSep	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
(	TokenNameLPAREN
m_namespaceContext	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
m_namespaceContext	TokenNameIdentifier
.	TokenNameDOT
handlesNullPrefixes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
posOfNSSep	TokenNameIdentifier
=	TokenNameEQUAL
mapNSTokens	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
,	TokenNameCOMMA
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
posOfNSSep	TokenNameIdentifier
,	TokenNameCOMMA
nChars	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
nChars	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
m_compiler	TokenNameIdentifier
.	TokenNameDOT
getTokenQueueSize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
m_processor	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
(	TokenNameLPAREN
XPATHErrorResources	TokenNameIdentifier
.	TokenNameDOT
ER_EMPTY_EXPRESSION	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
targetStrings	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
recordTokenString	TokenNameIdentifier
(	TokenNameLPAREN
targetStrings	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_processor	TokenNameIdentifier
.	TokenNameDOT
m_queueMark	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
mapPatternElemPos	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
nesting	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isStart	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isAttrName	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
nesting	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_patternMapSize	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
m_patternMap	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
patternMap	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
m_patternMap	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
m_patternMap	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
m_patternMap	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
m_patternMapSize	TokenNameIdentifier
+	TokenNamePLUS
100	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
patternMap	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
m_patternMap	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isStart	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_patternMap	TokenNameIdentifier
[	TokenNameLBRACKET
m_patternMapSize	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-=	TokenNameMINUS_EQUAL
TARGETEXTRA	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
m_patternMap	TokenNameIdentifier
[	TokenNameLBRACKET
m_patternMapSize	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
m_compiler	TokenNameIdentifier
.	TokenNameDOT
getTokenQueueSize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
(	TokenNameLPAREN
isAttrName	TokenNameIdentifier
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
TARGETEXTRA	TokenNameIdentifier
;	TokenNameSEMICOLON
m_patternMapSize	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
isStart	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
isStart	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
getTokenQueuePosFromMap	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
m_patternMap	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
pos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
TARGETEXTRA	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
(	TokenNameLPAREN
pos	TokenNameIdentifier
-	TokenNameMINUS
TARGETEXTRA	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
void	TokenNamevoid
resetTokenMark	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
mark	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
qsz	TokenNameIdentifier
=	TokenNameEQUAL
m_compiler	TokenNameIdentifier
.	TokenNameDOT
getTokenQueueSize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_processor	TokenNameIdentifier
.	TokenNameDOT
m_queueMark	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
mark	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
(	TokenNameLPAREN
(	TokenNameLPAREN
mark	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
qsz	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
mark	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
mark	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_processor	TokenNameIdentifier
.	TokenNameDOT
m_queueMark	TokenNameIdentifier
<	TokenNameLESS
qsz	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_processor	TokenNameIdentifier
.	TokenNameDOT
m_token	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
String	TokenNameIdentifier
)	TokenNameRPAREN
m_compiler	TokenNameIdentifier
.	TokenNameDOT
getTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
m_processor	TokenNameIdentifier
.	TokenNameDOT
m_queueMark	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
m_processor	TokenNameIdentifier
.	TokenNameDOT
m_tokenChar	TokenNameIdentifier
=	TokenNameEQUAL
m_processor	TokenNameIdentifier
.	TokenNameDOT
m_token	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_processor	TokenNameIdentifier
.	TokenNameDOT
m_token	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
m_processor	TokenNameIdentifier
.	TokenNameDOT
m_tokenChar	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
getKeywordToken	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
key	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
Integer	TokenNameIdentifier
itok	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Integer	TokenNameIdentifier
)	TokenNameRPAREN
Keywords	TokenNameIdentifier
.	TokenNameDOT
getKeyWord	TokenNameIdentifier
(	TokenNameLPAREN
key	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
itok	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
itok	TokenNameIdentifier
.	TokenNameDOT
intValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NullPointerException	TokenNameIdentifier
npe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ClassCastException	TokenNameIdentifier
cce	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tok	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
tok	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
recordTokenString	TokenNameIdentifier
(	TokenNameLPAREN
Vector	TokenNameIdentifier
targetStrings	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
tokPos	TokenNameIdentifier
=	TokenNameEQUAL
getTokenQueuePosFromMap	TokenNameIdentifier
(	TokenNameLPAREN
m_patternMapSize	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
resetTokenMark	TokenNameIdentifier
(	TokenNameLPAREN
tokPos	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m_processor	TokenNameIdentifier
.	TokenNameDOT
lookahead	TokenNameIdentifier
(	TokenNameLPAREN
'('	TokenNameCharacterLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
tok	TokenNameIdentifier
=	TokenNameEQUAL
getKeywordToken	TokenNameIdentifier
(	TokenNameLPAREN
m_processor	TokenNameIdentifier
.	TokenNameDOT
m_token	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
tok	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
OpCodes	TokenNameIdentifier
.	TokenNameDOT
NODETYPE_COMMENT	TokenNameIdentifier
:	TokenNameCOLON
targetStrings	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
PsuedoNames	TokenNameIdentifier
.	TokenNameDOT
PSEUDONAME_COMMENT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
OpCodes	TokenNameIdentifier
.	TokenNameDOT
NODETYPE_TEXT	TokenNameIdentifier
:	TokenNameCOLON
targetStrings	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
PsuedoNames	TokenNameIdentifier
.	TokenNameDOT
PSEUDONAME_TEXT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
OpCodes	TokenNameIdentifier
.	TokenNameDOT
NODETYPE_NODE	TokenNameIdentifier
:	TokenNameCOLON
targetStrings	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
PsuedoNames	TokenNameIdentifier
.	TokenNameDOT
PSEUDONAME_ANY	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
OpCodes	TokenNameIdentifier
.	TokenNameDOT
NODETYPE_ROOT	TokenNameIdentifier
:	TokenNameCOLON
targetStrings	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
PsuedoNames	TokenNameIdentifier
.	TokenNameDOT
PSEUDONAME_ROOT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
OpCodes	TokenNameIdentifier
.	TokenNameDOT
NODETYPE_ANYELEMENT	TokenNameIdentifier
:	TokenNameCOLON
targetStrings	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
PsuedoNames	TokenNameIdentifier
.	TokenNameDOT
PSEUDONAME_ANY	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
OpCodes	TokenNameIdentifier
.	TokenNameDOT
NODETYPE_PI	TokenNameIdentifier
:	TokenNameCOLON
targetStrings	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
PsuedoNames	TokenNameIdentifier
.	TokenNameDOT
PSEUDONAME_ANY	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
targetStrings	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
PsuedoNames	TokenNameIdentifier
.	TokenNameDOT
PSEUDONAME_ANY	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
m_processor	TokenNameIdentifier
.	TokenNameDOT
tokenIs	TokenNameIdentifier
(	TokenNameLPAREN
'@'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
tokPos	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
resetTokenMark	TokenNameIdentifier
(	TokenNameLPAREN
tokPos	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
m_processor	TokenNameIdentifier
.	TokenNameDOT
lookahead	TokenNameIdentifier
(	TokenNameLPAREN
':'	TokenNameCharacterLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
tokPos	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
targetStrings	TokenNameIdentifier
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
m_compiler	TokenNameIdentifier
.	TokenNameDOT
getTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
elementAt	TokenNameIdentifier
(	TokenNameLPAREN
tokPos	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
void	TokenNamevoid
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
s	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
m_compiler	TokenNameIdentifier
.	TokenNameDOT
getTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
addElement	TokenNameIdentifier
(	TokenNameLPAREN
s	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
mapNSTokens	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
pat	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
posOfNSSep	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
posOfScan	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
javax	TokenNameIdentifier
.	TokenNameDOT
xml	TokenNameIdentifier
.	TokenNameDOT
transform	TokenNameIdentifier
.	TokenNameDOT
TransformerException	TokenNameIdentifier
{	TokenNameLBRACE
String	TokenNameIdentifier
prefix	TokenNameIdentifier
=	TokenNameEQUAL
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
posOfNSSep	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
prefix	TokenNameIdentifier
=	TokenNameEQUAL
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
startSubstring	TokenNameIdentifier
,	TokenNameCOMMA
posOfNSSep	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
String	TokenNameIdentifier
uName	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
m_namespaceContext	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
prefix	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
"*"	TokenNameStringLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
prefix	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
"xmlns"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
prefix	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
uName	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
PrefixResolver	TokenNameIdentifier
)	TokenNameRPAREN
m_namespaceContext	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getNamespaceForPrefix	TokenNameIdentifier
(	TokenNameLPAREN
prefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
{	TokenNameLBRACE
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
":"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
s	TokenNameIdentifier
=	TokenNameEQUAL
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
posOfNSSep	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
posOfScan	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
s	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
s	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
uName	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
PrefixResolver	TokenNameIdentifier
)	TokenNameRPAREN
m_namespaceContext	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getNamespaceForPrefix	TokenNameIdentifier
(	TokenNameLPAREN
prefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ClassCastException	TokenNameIdentifier
cce	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
uName	TokenNameIdentifier
=	TokenNameEQUAL
m_namespaceContext	TokenNameIdentifier
.	TokenNameDOT
getNamespaceForPrefix	TokenNameIdentifier
(	TokenNameLPAREN
prefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
uName	TokenNameIdentifier
=	TokenNameEQUAL
prefix	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
null	TokenNamenull
!=	TokenNameNOT_EQUAL
uName	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
uName	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
uName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
":"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
s	TokenNameIdentifier
=	TokenNameEQUAL
pat	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
posOfNSSep	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
posOfScan	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
s	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
addToTokenQueue	TokenNameIdentifier
(	TokenNameLPAREN
s	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
m_processor	TokenNameIdentifier
.	TokenNameDOT
errorForDOM3	TokenNameIdentifier
(	TokenNameLPAREN
XPATHErrorResources	TokenNameIdentifier
.	TokenNameDOT
ER_PREFIX_MUST_RESOLVE	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
prefix	TokenNameIdentifier
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
