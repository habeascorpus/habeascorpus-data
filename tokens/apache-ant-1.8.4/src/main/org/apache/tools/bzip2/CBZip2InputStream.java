package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
tools	TokenNameIdentifier
.	TokenNameDOT
bzip2	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
InputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
CBZip2InputStream	TokenNameIdentifier
extends	TokenNameextends
InputStream	TokenNameIdentifier
implements	TokenNameimplements
BZip2Constants	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
reportCRCError	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
err	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"BZip2 CRC error"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
makeMaps	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
inUse	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
inUse	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
seqToUnseq	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
seqToUnseq	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
nInUseShadow	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
256	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
inUse	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
seqToUnseq	TokenNameIdentifier
[	TokenNameLBRACKET
nInUseShadow	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
i	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
nInUse	TokenNameIdentifier
=	TokenNameEQUAL
nInUseShadow	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
last	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
origPtr	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
blockSize100k	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
blockRandomised	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
bsBuff	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
bsLive	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
CRC	TokenNameIdentifier
crc	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CRC	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
nInUse	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
InputStream	TokenNameIdentifier
in	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
currentChar	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
EOF	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
START_BLOCK_STATE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
RAND_PART_A_STATE	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
RAND_PART_B_STATE	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
RAND_PART_C_STATE	TokenNameIdentifier
=	TokenNameEQUAL
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
NO_RAND_PART_A_STATE	TokenNameIdentifier
=	TokenNameEQUAL
5	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
NO_RAND_PART_B_STATE	TokenNameIdentifier
=	TokenNameEQUAL
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
NO_RAND_PART_C_STATE	TokenNameIdentifier
=	TokenNameEQUAL
7	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
currentState	TokenNameIdentifier
=	TokenNameEQUAL
START_BLOCK_STATE	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
storedBlockCRC	TokenNameIdentifier
,	TokenNameCOMMA
storedCombinedCRC	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
computedBlockCRC	TokenNameIdentifier
,	TokenNameCOMMA
computedCombinedCRC	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
su_count	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
su_ch2	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
su_chPrev	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
su_i2	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
su_j2	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
su_rNToGo	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
su_rTPos	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
su_tPos	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
char	TokenNamechar
su_z	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
CBZip2InputStream	TokenNameIdentifier
.	TokenNameDOT
Data	TokenNameIdentifier
data	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
CBZip2InputStream	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
InputStream	TokenNameIdentifier
in	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
;	TokenNameSEMICOLON
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
read0	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"stream closed"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
read	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
dest	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
offs	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
len	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
offs	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IndexOutOfBoundsException	TokenNameIdentifier
(	TokenNameLPAREN
"offs("	TokenNameStringLiteral
+	TokenNamePLUS
offs	TokenNameIdentifier
+	TokenNamePLUS
") < 0."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
len	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IndexOutOfBoundsException	TokenNameIdentifier
(	TokenNameLPAREN
"len("	TokenNameStringLiteral
+	TokenNamePLUS
len	TokenNameIdentifier
+	TokenNamePLUS
") < 0."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
offs	TokenNameIdentifier
+	TokenNamePLUS
len	TokenNameIdentifier
>	TokenNameGREATER
dest	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IndexOutOfBoundsException	TokenNameIdentifier
(	TokenNameLPAREN
"offs("	TokenNameStringLiteral
+	TokenNamePLUS
offs	TokenNameIdentifier
+	TokenNamePLUS
") + len("	TokenNameStringLiteral
+	TokenNamePLUS
len	TokenNameIdentifier
+	TokenNamePLUS
") > dest.length("	TokenNameStringLiteral
+	TokenNamePLUS
dest	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
+	TokenNamePLUS
")."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"stream closed"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
hi	TokenNameIdentifier
=	TokenNameEQUAL
offs	TokenNameIdentifier
+	TokenNamePLUS
len	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
destOffs	TokenNameIdentifier
=	TokenNameEQUAL
offs	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
b	TokenNameIdentifier
;	TokenNameSEMICOLON
(	TokenNameLPAREN
destOffs	TokenNameIdentifier
<	TokenNameLESS
hi	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
b	TokenNameIdentifier
=	TokenNameEQUAL
read0	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
dest	TokenNameIdentifier
[	TokenNameLBRACKET
destOffs	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
b	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
destOffs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
offs	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
(	TokenNameLPAREN
destOffs	TokenNameIdentifier
-	TokenNameMINUS
offs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
read0	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
retChar	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
currentChar	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
EOF	TokenNameIdentifier
:	TokenNameCOLON
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
case	TokenNamecase
START_BLOCK_STATE	TokenNameIdentifier
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
RAND_PART_A_STATE	TokenNameIdentifier
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
RAND_PART_B_STATE	TokenNameIdentifier
:	TokenNameCOLON
setupRandPartB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
RAND_PART_C_STATE	TokenNameIdentifier
:	TokenNameCOLON
setupRandPartC	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
NO_RAND_PART_A_STATE	TokenNameIdentifier
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
case	TokenNamecase
NO_RAND_PART_B_STATE	TokenNameIdentifier
:	TokenNameCOLON
setupNoRandPartB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
NO_RAND_PART_C_STATE	TokenNameIdentifier
:	TokenNameCOLON
setupNoRandPartC	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
retChar	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
null	TokenNamenull
==	TokenNameEQUAL_EQUAL
in	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"No InputStream"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
in	TokenNameIdentifier
.	TokenNameDOT
available	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"Empty InputStream"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
magic2	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
magic2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
'h'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"Stream is not BZip2 formatted: expected 'h'"	TokenNameStringLiteral
+	TokenNamePLUS
" as first byte but got '"	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
magic2	TokenNameIdentifier
+	TokenNamePLUS
"'"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
blockSize	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
blockSize	TokenNameIdentifier
<	TokenNameLESS
'1'	TokenNameCharacterLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
blockSize	TokenNameIdentifier
>	TokenNameGREATER
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"Stream is not BZip2 formatted: illegal "	TokenNameStringLiteral
+	TokenNamePLUS
"blocksize "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
blockSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
blockSize100k	TokenNameIdentifier
=	TokenNameEQUAL
blockSize	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
initBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setupBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
initBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
char	TokenNamechar
magic0	TokenNameIdentifier
=	TokenNameEQUAL
bsGetUByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
magic1	TokenNameIdentifier
=	TokenNameEQUAL
bsGetUByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
magic2	TokenNameIdentifier
=	TokenNameEQUAL
bsGetUByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
magic3	TokenNameIdentifier
=	TokenNameEQUAL
bsGetUByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
magic4	TokenNameIdentifier
=	TokenNameEQUAL
bsGetUByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
magic5	TokenNameIdentifier
=	TokenNameEQUAL
bsGetUByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
magic0	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x17	TokenNameIntegerLiteral
&&	TokenNameAND_AND
magic1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x72	TokenNameIntegerLiteral
&&	TokenNameAND_AND
magic2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x45	TokenNameIntegerLiteral
&&	TokenNameAND_AND
magic3	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x38	TokenNameIntegerLiteral
&&	TokenNameAND_AND
magic4	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x50	TokenNameIntegerLiteral
&&	TokenNameAND_AND
magic5	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0x90	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
complete	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
magic0	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x31	TokenNameIntegerLiteral
||	TokenNameOR_OR
magic1	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x41	TokenNameIntegerLiteral
||	TokenNameOR_OR
magic2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x59	TokenNameIntegerLiteral
||	TokenNameOR_OR
magic3	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x26	TokenNameIntegerLiteral
||	TokenNameOR_OR
magic4	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x53	TokenNameIntegerLiteral
||	TokenNameOR_OR
magic5	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0x59	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
EOF	TokenNameIdentifier
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"bad block header"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
storedBlockCRC	TokenNameIdentifier
=	TokenNameEQUAL
bsGetInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
blockRandomised	TokenNameIdentifier
=	TokenNameEQUAL
bsR	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Data	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
blockSize100k	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
getAndMoveToFrontDecode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
crc	TokenNameIdentifier
.	TokenNameDOT
initialiseCRC	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
START_BLOCK_STATE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
endBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
computedBlockCRC	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
crc	TokenNameIdentifier
.	TokenNameDOT
getFinalCRC	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
storedBlockCRC	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
this	TokenNamethis
.	TokenNameDOT
computedBlockCRC	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
computedCombinedCRC	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
storedCombinedCRC	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
storedCombinedCRC	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
31	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
computedCombinedCRC	TokenNameIdentifier
^=	TokenNameXOR_EQUAL
this	TokenNamethis
.	TokenNameDOT
storedBlockCRC	TokenNameIdentifier
;	TokenNameSEMICOLON
reportCRCError	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
computedCombinedCRC	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
computedCombinedCRC	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
computedCombinedCRC	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
31	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
computedCombinedCRC	TokenNameIdentifier
^=	TokenNameXOR_EQUAL
this	TokenNamethis
.	TokenNameDOT
computedBlockCRC	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
complete	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
storedCombinedCRC	TokenNameIdentifier
=	TokenNameEQUAL
bsGetInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
EOF	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
storedCombinedCRC	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
this	TokenNamethis
.	TokenNameDOT
computedCombinedCRC	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
reportCRCError	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
InputStream	TokenNameIdentifier
inShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
inShadow	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
inShadow	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
System	TokenNameIdentifier
.	TokenNameDOT
in	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
inShadow	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
bsR	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
int	TokenNameint
n	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
bsLiveShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bsLive	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bsBuff	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
<	TokenNameLESS
n	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
InputStream	TokenNameIdentifier
inShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
;	TokenNameSEMICOLON
do	TokenNamedo
{	TokenNameLBRACE
int	TokenNameint
thech	TokenNameIdentifier
=	TokenNameEQUAL
inShadow	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
thech	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected end of stream"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
thech	TokenNameIdentifier
;	TokenNameSEMICOLON
bsLiveShadow	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
<	TokenNameLESS
n	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
bsBuff	TokenNameIdentifier
=	TokenNameEQUAL
bsBuffShadow	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
bsLive	TokenNameIdentifier
=	TokenNameEQUAL
bsLiveShadow	TokenNameIdentifier
-	TokenNameMINUS
n	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
-	TokenNameMINUS
n	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&	TokenNameAND
(	TokenNameLPAREN
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
n	TokenNameIdentifier
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
bsGetBit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
bsLiveShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bsLive	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bsBuff	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
<	TokenNameLESS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
thech	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
thech	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected end of stream"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
thech	TokenNameIdentifier
;	TokenNameSEMICOLON
bsLiveShadow	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
bsBuff	TokenNameIdentifier
=	TokenNameEQUAL
bsBuffShadow	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
bsLive	TokenNameIdentifier
=	TokenNameEQUAL
bsLiveShadow	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
&	TokenNameAND
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
char	TokenNamechar
bsGetUByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
bsR	TokenNameIdentifier
(	TokenNameLPAREN
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
bsGetInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
bsR	TokenNameIdentifier
(	TokenNameLPAREN
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
bsR	TokenNameIdentifier
(	TokenNameLPAREN
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
bsR	TokenNameIdentifier
(	TokenNameLPAREN
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
bsR	TokenNameIdentifier
(	TokenNameLPAREN
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
hbCreateDecodeTables	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
limit	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
base	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
perm	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
length	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
minLen	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
maxLen	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
alphaSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
minLen	TokenNameIdentifier
,	TokenNameCOMMA
pp	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
maxLen	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
alphaSize	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
length	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
perm	TokenNameIdentifier
[	TokenNameLBRACKET
pp	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
j	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
MAX_CODE_LEN	TokenNameIdentifier
;	TokenNameSEMICOLON
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
base	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
limit	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
alphaSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
base	TokenNameIdentifier
[	TokenNameLBRACKET
length	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
b	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
MAX_CODE_LEN	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
base	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
base	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
b	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
minLen	TokenNameIdentifier
,	TokenNameCOMMA
vec	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
b	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
maxLen	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
nb	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
vec	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
nb	TokenNameIdentifier
-	TokenNameMINUS
b	TokenNameIdentifier
;	TokenNameSEMICOLON
b	TokenNameIdentifier
=	TokenNameEQUAL
nb	TokenNameIdentifier
;	TokenNameSEMICOLON
limit	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
vec	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
vec	TokenNameIdentifier
<<=	TokenNameLEFT_SHIFT_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
minLen	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
maxLen	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
base	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
limit	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
-	TokenNameMINUS
base	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
recvDecodingTables	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
Data	TokenNameIdentifier
dataShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
inUse	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
inUse	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
pos	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
recvDecodingTables_pos	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
selector	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
selector	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
selectorMtf	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
selectorMtf	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
inUse16	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bsGetBit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
inUse16	TokenNameIdentifier
|=	TokenNameOR_EQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
i	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
256	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
inUse	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
inUse16	TokenNameIdentifier
&	TokenNameAND
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
i16	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bsGetBit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
inUse	TokenNameIdentifier
[	TokenNameLBRACKET
i16	TokenNameIdentifier
+	TokenNamePLUS
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
makeMaps	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
alphaSize	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
nInUse	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
nGroups	TokenNameIdentifier
=	TokenNameEQUAL
bsR	TokenNameIdentifier
(	TokenNameLPAREN
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
nSelectors	TokenNameIdentifier
=	TokenNameEQUAL
bsR	TokenNameIdentifier
(	TokenNameLPAREN
15	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
nSelectors	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
bsGetBit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
selectorMtf	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
j	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
v	TokenNameIdentifier
=	TokenNameEQUAL
nGroups	TokenNameIdentifier
;	TokenNameSEMICOLON
--	TokenNameMINUS_MINUS
v	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
pos	TokenNameIdentifier
[	TokenNameLBRACKET
v	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
v	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
nSelectors	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
v	TokenNameIdentifier
=	TokenNameEQUAL
selectorMtf	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
tmp	TokenNameIdentifier
=	TokenNameEQUAL
pos	TokenNameIdentifier
[	TokenNameLBRACKET
v	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
v	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
pos	TokenNameIdentifier
[	TokenNameLBRACKET
v	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
pos	TokenNameIdentifier
[	TokenNameLBRACKET
v	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
v	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pos	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
tmp	TokenNameIdentifier
;	TokenNameSEMICOLON
selector	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
tmp	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
len	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
temp_charArray2d	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
t	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
t	TokenNameIdentifier
<	TokenNameLESS
nGroups	TokenNameIdentifier
;	TokenNameSEMICOLON
t	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
curr	TokenNameIdentifier
=	TokenNameEQUAL
bsR	TokenNameIdentifier
(	TokenNameLPAREN
5	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
len_t	TokenNameIdentifier
=	TokenNameEQUAL
len	TokenNameIdentifier
[	TokenNameLBRACKET
t	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
alphaSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
bsGetBit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
curr	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
bsGetBit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
len_t	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
curr	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
createHuffmanDecodingTables	TokenNameIdentifier
(	TokenNameLPAREN
alphaSize	TokenNameIdentifier
,	TokenNameCOMMA
nGroups	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
createHuffmanDecodingTables	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
int	TokenNameint
alphaSize	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
nGroups	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Data	TokenNameIdentifier
dataShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
len	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
temp_charArray2d	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
minLens	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
minLens	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
limit	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
base	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
base	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
perm	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
perm	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
t	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
t	TokenNameIdentifier
<	TokenNameLESS
nGroups	TokenNameIdentifier
;	TokenNameSEMICOLON
t	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
minLen	TokenNameIdentifier
=	TokenNameEQUAL
32	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
maxLen	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
len_t	TokenNameIdentifier
=	TokenNameEQUAL
len	TokenNameIdentifier
[	TokenNameLBRACKET
t	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
alphaSize	TokenNameIdentifier
;	TokenNameSEMICOLON
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
char	TokenNamechar
lent	TokenNameIdentifier
=	TokenNameEQUAL
len_t	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lent	TokenNameIdentifier
>	TokenNameGREATER
maxLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
maxLen	TokenNameIdentifier
=	TokenNameEQUAL
lent	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
lent	TokenNameIdentifier
<	TokenNameLESS
minLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
minLen	TokenNameIdentifier
=	TokenNameEQUAL
lent	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
hbCreateDecodeTables	TokenNameIdentifier
(	TokenNameLPAREN
limit	TokenNameIdentifier
[	TokenNameLBRACKET
t	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
base	TokenNameIdentifier
[	TokenNameLBRACKET
t	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
perm	TokenNameIdentifier
[	TokenNameLBRACKET
t	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
len	TokenNameIdentifier
[	TokenNameLBRACKET
t	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
minLen	TokenNameIdentifier
,	TokenNameCOMMA
maxLen	TokenNameIdentifier
,	TokenNameCOMMA
alphaSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
minLens	TokenNameIdentifier
[	TokenNameLBRACKET
t	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
minLen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
getAndMoveToFrontDecode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
origPtr	TokenNameIdentifier
=	TokenNameEQUAL
bsR	TokenNameIdentifier
(	TokenNameLPAREN
24	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
recvDecodingTables	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
InputStream	TokenNameIdentifier
inShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
Data	TokenNameIdentifier
dataShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
ll8	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
ll8	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
unzftab	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
unzftab	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
selector	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
selector	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
seqToUnseq	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
seqToUnseq	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
yy	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
getAndMoveToFrontDecode_yy	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
minLens	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
minLens	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
limit	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
base	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
base	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
perm	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
perm	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
limitLast	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
blockSize100k	TokenNameIdentifier
*	TokenNameMULTIPLY
100000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
256	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
yy	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
i	TokenNameIdentifier
;	TokenNameSEMICOLON
unzftab	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
groupNo	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
groupPos	TokenNameIdentifier
=	TokenNameEQUAL
G_SIZE	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
eob	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
nInUse	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
nextSym	TokenNameIdentifier
=	TokenNameEQUAL
getAndMoveToFrontDecode0	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bsBuff	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
bsLiveShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bsLive	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
lastShadow	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
zt	TokenNameIdentifier
=	TokenNameEQUAL
selector	TokenNameIdentifier
[	TokenNameLBRACKET
groupNo	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
base_zt	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
limit_zt	TokenNameIdentifier
=	TokenNameEQUAL
limit	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
perm_zt	TokenNameIdentifier
=	TokenNameEQUAL
perm	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
minLens_zt	TokenNameIdentifier
=	TokenNameEQUAL
minLens	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
nextSym	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
eob	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
nextSym	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RUNA	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
nextSym	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RUNB	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
s	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
n	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
true	TokenNametrue
;	TokenNameSEMICOLON
n	TokenNameIdentifier
<<=	TokenNameLEFT_SHIFT_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nextSym	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RUNA	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
s	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
n	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
nextSym	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RUNB	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
s	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
n	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
groupPos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
groupPos	TokenNameIdentifier
=	TokenNameEQUAL
G_SIZE	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
zt	TokenNameIdentifier
=	TokenNameEQUAL
selector	TokenNameIdentifier
[	TokenNameLBRACKET
++	TokenNamePLUS_PLUS
groupNo	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
base_zt	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
limit_zt	TokenNameIdentifier
=	TokenNameEQUAL
limit	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
perm_zt	TokenNameIdentifier
=	TokenNameEQUAL
perm	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
minLens_zt	TokenNameIdentifier
=	TokenNameEQUAL
minLens	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
groupPos	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
zn	TokenNameIdentifier
=	TokenNameEQUAL
minLens_zt	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
<	TokenNameLESS
zn	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
thech	TokenNameIdentifier
=	TokenNameEQUAL
inShadow	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
thech	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
thech	TokenNameIdentifier
;	TokenNameSEMICOLON
bsLiveShadow	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected end of stream"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
zvec	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
-	TokenNameMINUS
zn	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&	TokenNameAND
(	TokenNameLPAREN
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
zn	TokenNameIdentifier
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bsLiveShadow	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
zn	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
zvec	TokenNameIdentifier
>	TokenNameGREATER
limit_zt	TokenNameIdentifier
[	TokenNameLBRACKET
zn	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
zn	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
<	TokenNameLESS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
thech	TokenNameIdentifier
=	TokenNameEQUAL
inShadow	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
thech	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
thech	TokenNameIdentifier
;	TokenNameSEMICOLON
bsLiveShadow	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected end of stream"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
bsLiveShadow	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
zvec	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
zvec	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
bsLiveShadow	TokenNameIdentifier
)	TokenNameRPAREN
&	TokenNameAND
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextSym	TokenNameIdentifier
=	TokenNameEQUAL
perm_zt	TokenNameIdentifier
[	TokenNameLBRACKET
zvec	TokenNameIdentifier
-	TokenNameMINUS
base_zt	TokenNameIdentifier
[	TokenNameLBRACKET
zn	TokenNameIdentifier
]	TokenNameRBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
byte	TokenNamebyte
ch	TokenNameIdentifier
=	TokenNameEQUAL
seqToUnseq	TokenNameIdentifier
[	TokenNameLBRACKET
yy	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
unzftab	TokenNameIdentifier
[	TokenNameLBRACKET
ch	TokenNameIdentifier
&	TokenNameAND
0xff	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+=	TokenNamePLUS_EQUAL
s	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
s	TokenNameIdentifier
--	TokenNameMINUS_MINUS
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
ll8	TokenNameIdentifier
[	TokenNameLBRACKET
++	TokenNamePLUS_PLUS
lastShadow	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
lastShadow	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
limitLast	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"block overrun"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
lastShadow	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
limitLast	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"block overrun"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
char	TokenNamechar
tmp	TokenNameIdentifier
=	TokenNameEQUAL
yy	TokenNameIdentifier
[	TokenNameLBRACKET
nextSym	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
unzftab	TokenNameIdentifier
[	TokenNameLBRACKET
seqToUnseq	TokenNameIdentifier
[	TokenNameLBRACKET
tmp	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
]	TokenNameRBRACKET
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
ll8	TokenNameIdentifier
[	TokenNameLBRACKET
lastShadow	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
seqToUnseq	TokenNameIdentifier
[	TokenNameLBRACKET
tmp	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nextSym	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
16	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
nextSym	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
yy	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
yy	TokenNameIdentifier
[	TokenNameLBRACKET
--	TokenNameMINUS_MINUS
j	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
yy	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
yy	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
nextSym	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
yy	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
tmp	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
groupPos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
groupPos	TokenNameIdentifier
=	TokenNameEQUAL
G_SIZE	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
zt	TokenNameIdentifier
=	TokenNameEQUAL
selector	TokenNameIdentifier
[	TokenNameLBRACKET
++	TokenNamePLUS_PLUS
groupNo	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
base_zt	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
limit_zt	TokenNameIdentifier
=	TokenNameEQUAL
limit	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
perm_zt	TokenNameIdentifier
=	TokenNameEQUAL
perm	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
minLens_zt	TokenNameIdentifier
=	TokenNameEQUAL
minLens	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
groupPos	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
zn	TokenNameIdentifier
=	TokenNameEQUAL
minLens_zt	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
<	TokenNameLESS
zn	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
thech	TokenNameIdentifier
=	TokenNameEQUAL
inShadow	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
thech	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
thech	TokenNameIdentifier
;	TokenNameSEMICOLON
bsLiveShadow	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected end of stream"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
zvec	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
-	TokenNameMINUS
zn	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&	TokenNameAND
(	TokenNameLPAREN
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
zn	TokenNameIdentifier
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bsLiveShadow	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
zn	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
zvec	TokenNameIdentifier
>	TokenNameGREATER
limit_zt	TokenNameIdentifier
[	TokenNameLBRACKET
zn	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
zn	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
<	TokenNameLESS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
thech	TokenNameIdentifier
=	TokenNameEQUAL
inShadow	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
thech	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
thech	TokenNameIdentifier
;	TokenNameSEMICOLON
bsLiveShadow	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected end of stream"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
bsLiveShadow	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
zvec	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
zvec	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
bsLiveShadow	TokenNameIdentifier
)	TokenNameRPAREN
&	TokenNameAND
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nextSym	TokenNameIdentifier
=	TokenNameEQUAL
perm_zt	TokenNameIdentifier
[	TokenNameLBRACKET
zvec	TokenNameIdentifier
-	TokenNameMINUS
base_zt	TokenNameIdentifier
[	TokenNameLBRACKET
zn	TokenNameIdentifier
]	TokenNameRBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
last	TokenNameIdentifier
=	TokenNameEQUAL
lastShadow	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
bsLive	TokenNameIdentifier
=	TokenNameEQUAL
bsLiveShadow	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
bsBuff	TokenNameIdentifier
=	TokenNameEQUAL
bsBuffShadow	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
getAndMoveToFrontDecode0	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
int	TokenNameint
groupNo	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
InputStream	TokenNameIdentifier
inShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
in	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
Data	TokenNameIdentifier
dataShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
zt	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
selector	TokenNameIdentifier
[	TokenNameLBRACKET
groupNo	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
limit_zt	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
zn	TokenNameIdentifier
=	TokenNameEQUAL
dataShadow	TokenNameIdentifier
.	TokenNameDOT
minLens	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
zvec	TokenNameIdentifier
=	TokenNameEQUAL
bsR	TokenNameIdentifier
(	TokenNameLPAREN
zn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
bsLiveShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bsLive	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bsBuff	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
zvec	TokenNameIdentifier
>	TokenNameGREATER
limit_zt	TokenNameIdentifier
[	TokenNameLBRACKET
zn	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
zn	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
bsLiveShadow	TokenNameIdentifier
<	TokenNameLESS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
thech	TokenNameIdentifier
=	TokenNameEQUAL
inShadow	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
thech	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
bsBuffShadow	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
thech	TokenNameIdentifier
;	TokenNameSEMICOLON
bsLiveShadow	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"unexpected end of stream"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
bsLiveShadow	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
zvec	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
zvec	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
bsBuffShadow	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
bsLiveShadow	TokenNameIdentifier
)	TokenNameRPAREN
&	TokenNameAND
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
bsLive	TokenNameIdentifier
=	TokenNameEQUAL
bsLiveShadow	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
bsBuff	TokenNameIdentifier
=	TokenNameEQUAL
bsBuffShadow	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
dataShadow	TokenNameIdentifier
.	TokenNameDOT
perm	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
zvec	TokenNameIdentifier
-	TokenNameMINUS
dataShadow	TokenNameIdentifier
.	TokenNameDOT
base	TokenNameIdentifier
[	TokenNameLBRACKET
zt	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
zn	TokenNameIdentifier
]	TokenNameRBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setupBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
cftab	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
cftab	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
tt	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
initTT	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
last	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
ll8	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
ll8	TokenNameIdentifier
;	TokenNameSEMICOLON
cftab	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
unzftab	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
cftab	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
256	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
c	TokenNameIdentifier
=	TokenNameEQUAL
cftab	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
256	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
c	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
cftab	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
cftab	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
c	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
lastShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
last	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
lastShadow	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
tt	TokenNameIdentifier
[	TokenNameLBRACKET
cftab	TokenNameIdentifier
[	TokenNameLBRACKET
ll8	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
]	TokenNameRBRACKET
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
origPtr	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
origPtr	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
tt	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"stream corrupted"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
=	TokenNameEQUAL
tt	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
origPtr	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_i2	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_ch2	TokenNameIdentifier
=	TokenNameEQUAL
256	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
blockRandomised	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_rNToGo	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_rTPos	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
setupRandPartA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
setupNoRandPartA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setupRandPartA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_i2	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
this	TokenNamethis
.	TokenNameDOT
last	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_chPrev	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
su_ch2	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
su_ch2Shadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
ll8	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
tt	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_rNToGo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_rNToGo	TokenNameIdentifier
=	TokenNameEQUAL
BZip2Constants	TokenNameIdentifier
.	TokenNameDOT
rNums	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
su_rTPos	TokenNameIdentifier
]	TokenNameRBRACKET
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
this	TokenNamethis
.	TokenNameDOT
su_rTPos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
512	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_rTPos	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_rNToGo	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
su_ch2	TokenNameIdentifier
=	TokenNameEQUAL
su_ch2Shadow	TokenNameIdentifier
^=	TokenNameXOR_EQUAL
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_rNToGo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_i2	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
currentChar	TokenNameIdentifier
=	TokenNameEQUAL
su_ch2Shadow	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
RAND_PART_B_STATE	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
crc	TokenNameIdentifier
.	TokenNameDOT
updateCRC	TokenNameIdentifier
(	TokenNameLPAREN
su_ch2Shadow	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
endBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
initBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setupBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setupNoRandPartA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_i2	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
this	TokenNamethis
.	TokenNameDOT
last	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_chPrev	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
su_ch2	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
su_ch2Shadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
ll8	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_ch2	TokenNameIdentifier
=	TokenNameEQUAL
su_ch2Shadow	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
tt	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_i2	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
currentChar	TokenNameIdentifier
=	TokenNameEQUAL
su_ch2Shadow	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
NO_RAND_PART_B_STATE	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
crc	TokenNameIdentifier
.	TokenNameDOT
updateCRC	TokenNameIdentifier
(	TokenNameLPAREN
su_ch2Shadow	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
NO_RAND_PART_A_STATE	TokenNameIdentifier
;	TokenNameSEMICOLON
endBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
initBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setupBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setupRandPartB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_ch2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
this	TokenNamethis
.	TokenNameDOT
su_chPrev	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
RAND_PART_A_STATE	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_count	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
setupRandPartA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
this	TokenNamethis
.	TokenNameDOT
su_count	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_z	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
ll8	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
tt	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_rNToGo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_rNToGo	TokenNameIdentifier
=	TokenNameEQUAL
BZip2Constants	TokenNameIdentifier
.	TokenNameDOT
rNums	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
su_rTPos	TokenNameIdentifier
]	TokenNameRBRACKET
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
this	TokenNamethis
.	TokenNameDOT
su_rTPos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
512	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_rTPos	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_rNToGo	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
su_j2	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
RAND_PART_C_STATE	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_rNToGo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_z	TokenNameIdentifier
^=	TokenNameXOR_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
setupRandPartC	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
RAND_PART_A_STATE	TokenNameIdentifier
;	TokenNameSEMICOLON
setupRandPartA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setupRandPartC	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_j2	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
su_z	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
currentChar	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
su_ch2	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
crc	TokenNameIdentifier
.	TokenNameDOT
updateCRC	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_ch2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_j2	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
RAND_PART_A_STATE	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_i2	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
setupRandPartA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setupNoRandPartB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_ch2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
this	TokenNamethis
.	TokenNameDOT
su_chPrev	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_count	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
setupNoRandPartA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
this	TokenNamethis
.	TokenNameDOT
su_count	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_z	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
ll8	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
data	TokenNameIdentifier
.	TokenNameDOT
tt	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
su_tPos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_j2	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
setupNoRandPartC	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
setupNoRandPartA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setupNoRandPartC	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
su_j2	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
su_z	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
su_ch2Shadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
su_ch2	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
currentChar	TokenNameIdentifier
=	TokenNameEQUAL
su_ch2Shadow	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
crc	TokenNameIdentifier
.	TokenNameDOT
updateCRC	TokenNameIdentifier
(	TokenNameLPAREN
su_ch2Shadow	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_j2	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
currentState	TokenNameIdentifier
=	TokenNameEQUAL
NO_RAND_PART_C_STATE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
su_i2	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
su_count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
setupNoRandPartA	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
Data	TokenNameIdentifier
extends	TokenNameextends
Object	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
inUse	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
256	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
seqToUnseq	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
256	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
selector	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
MAX_SELECTORS	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
selectorMtf	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
MAX_SELECTORS	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
unzftab	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
256	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
limit	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
N_GROUPS	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
MAX_ALPHA_SIZE	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
base	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
N_GROUPS	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
MAX_ALPHA_SIZE	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
perm	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
N_GROUPS	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
MAX_ALPHA_SIZE	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
minLens	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
N_GROUPS	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
cftab	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
257	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getAndMoveToFrontDecode_yy	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
256	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
temp_charArray2d	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
N_GROUPS	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
MAX_ALPHA_SIZE	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
recvDecodingTables_pos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
N_GROUPS	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
tt	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
ll8	TokenNameIdentifier
;	TokenNameSEMICOLON
Data	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
blockSize100k	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
ll8	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
blockSize100k	TokenNameIdentifier
*	TokenNameMULTIPLY
BZip2Constants	TokenNameIdentifier
.	TokenNameDOT
baseBlockSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
initTT	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
ttShadow	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
tt	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
ttShadow	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
ttShadow	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
length	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
tt	TokenNameIdentifier
=	TokenNameEQUAL
ttShadow	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
ttShadow	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
