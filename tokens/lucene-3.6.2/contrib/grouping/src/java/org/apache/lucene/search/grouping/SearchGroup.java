package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
grouping	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
FieldComparator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
Sort	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
SortField	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
GROUP_VALUE_TYPE	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
public	TokenNamepublic
GROUP_VALUE_TYPE	TokenNameIdentifier
groupValue	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sortValues	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
"SearchGroup(groupValue="	TokenNameStringLiteral
+	TokenNamePLUS
groupValue	TokenNameIdentifier
+	TokenNamePLUS
" sortValues="	TokenNameStringLiteral
+	TokenNamePLUS
Arrays	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
sortValues	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
o	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
==	TokenNameEQUAL_EQUAL
o	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
o	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
o	TokenNameIdentifier
.	TokenNameDOT
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
SearchGroup	TokenNameIdentifier
that	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
SearchGroup	TokenNameIdentifier
)	TokenNameRPAREN
o	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
groupValue	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
groupValue	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
groupValue	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
that	TokenNameIdentifier
.	TokenNameDOT
groupValue	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
groupValue	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
groupValue	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
ShardIter	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
public	TokenNamepublic
final	TokenNamefinal
Iterator	TokenNameIdentifier
<	TokenNameLESS
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
iter	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
int	TokenNameint
shardIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
ShardIter	TokenNameIdentifier
(	TokenNameLPAREN
Collection	TokenNameIdentifier
<	TokenNameLESS
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
shard	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
shardIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
shardIndex	TokenNameIdentifier
=	TokenNameEQUAL
shardIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
iter	TokenNameIdentifier
=	TokenNameEQUAL
shard	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
group	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
group	TokenNameIdentifier
.	TokenNameDOT
sortValues	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"group.sortValues is null; you must pass fillFields=true to the first pass collector"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
group	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"ShardIter(shard="	TokenNameStringLiteral
+	TokenNamePLUS
shardIndex	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
public	TokenNamepublic
final	TokenNamefinal
T	TokenNameIdentifier
groupValue	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
topValues	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
ShardIter	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
shards	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
ShardIter	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
minShardIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
processed	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
inQueue	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
MergedGroup	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
groupValue	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
groupValue	TokenNameIdentifier
=	TokenNameEQUAL
groupValue	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
neverEquals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
_other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
_other	TokenNameIdentifier
instanceof	TokenNameinstanceof
MergedGroup	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
MergedGroup	TokenNameIdentifier
other	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
MergedGroup	TokenNameIdentifier
)	TokenNameRPAREN
_other	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
groupValue	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
other	TokenNameIdentifier
.	TokenNameDOT
groupValue	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
assert	TokenNameassert
!	TokenNameNOT
groupValue	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
groupValue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
_other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
neverEquals	TokenNameIdentifier
(	TokenNameLPAREN
_other	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
_other	TokenNameIdentifier
instanceof	TokenNameinstanceof
MergedGroup	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
MergedGroup	TokenNameIdentifier
other	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
MergedGroup	TokenNameIdentifier
)	TokenNameRPAREN
_other	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
groupValue	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
other	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
groupValue	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
groupValue	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
groupValue	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
GroupComparator	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
implements	TokenNameimplements
Comparator	TokenNameIdentifier
<	TokenNameLESS
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
{	TokenNameLBRACE
public	TokenNamepublic
final	TokenNamefinal
FieldComparator	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>	TokenNameGREATER
[	TokenNameLBRACKET
]	TokenNameRBRACKET
comparators	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
reversed	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
{	TokenNameLBRACE
"unchecked"	TokenNameStringLiteral
,	TokenNameCOMMA
"rawtypes"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
public	TokenNamepublic
GroupComparator	TokenNameIdentifier
(	TokenNameLPAREN
Sort	TokenNameIdentifier
groupSort	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
SortField	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sortFields	TokenNameIdentifier
=	TokenNameEQUAL
groupSort	TokenNameIdentifier
.	TokenNameDOT
getSort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
comparators	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FieldComparator	TokenNameIdentifier
[	TokenNameLBRACKET
sortFields	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
reversed	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
sortFields	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
compIDX	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
compIDX	TokenNameIdentifier
<	TokenNameLESS
sortFields	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
compIDX	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SortField	TokenNameIdentifier
sortField	TokenNameIdentifier
=	TokenNameEQUAL
sortFields	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
comparators	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
sortField	TokenNameIdentifier
.	TokenNameDOT
getComparator	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
compIDX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reversed	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
sortField	TokenNameIdentifier
.	TokenNameDOT
getReverse	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
{	TokenNameLBRACE
"rawtypes"	TokenNameStringLiteral
,	TokenNameCOMMA
"unchecked"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
public	TokenNamepublic
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
group	TokenNameIdentifier
,	TokenNameCOMMA
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
group	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
groupValues	TokenNameIdentifier
=	TokenNameEQUAL
group	TokenNameIdentifier
.	TokenNameDOT
topValues	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
otherValues	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
topValues	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
compIDX	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
compIDX	TokenNameIdentifier
<	TokenNameLESS
comparators	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
compIDX	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
c	TokenNameIdentifier
=	TokenNameEQUAL
reversed	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
*	TokenNameMULTIPLY
(	TokenNameLPAREN
(	TokenNameLPAREN
FieldComparator	TokenNameIdentifier
)	TokenNameRPAREN
comparators	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
.	TokenNameDOT
compareValues	TokenNameIdentifier
(	TokenNameLPAREN
groupValues	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
otherValues	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
c	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
assert	TokenNameassert
group	TokenNameIdentifier
.	TokenNameDOT
minShardIndex	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
other	TokenNameIdentifier
.	TokenNameDOT
minShardIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
group	TokenNameIdentifier
.	TokenNameDOT
minShardIndex	TokenNameIdentifier
-	TokenNameMINUS
other	TokenNameIdentifier
.	TokenNameDOT
minShardIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
GroupMerger	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
GroupComparator	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
groupComp	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
SortedSet	TokenNameIdentifier
<	TokenNameLESS
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
queue	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
Map	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
,	TokenNameCOMMA
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
groupsSeen	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
GroupMerger	TokenNameIdentifier
(	TokenNameLPAREN
Sort	TokenNameIdentifier
groupSort	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
groupComp	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
GroupComparator	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
groupSort	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queue	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
TreeSet	TokenNameIdentifier
<	TokenNameLESS
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
groupComp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
groupsSeen	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
,	TokenNameCOMMA
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
"unchecked"	TokenNameStringLiteral
)	TokenNameRPAREN
private	TokenNameprivate
void	TokenNamevoid
updateNextGroup	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
topN	TokenNameIdentifier
,	TokenNameCOMMA
ShardIter	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
shard	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
shard	TokenNameIdentifier
.	TokenNameDOT
iter	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
group	TokenNameIdentifier
=	TokenNameEQUAL
shard	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
mergedGroup	TokenNameIdentifier
=	TokenNameEQUAL
groupsSeen	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
group	TokenNameIdentifier
.	TokenNameDOT
groupValue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
isNew	TokenNameIdentifier
=	TokenNameEQUAL
mergedGroup	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isNew	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
mergedGroup	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
group	TokenNameIdentifier
.	TokenNameDOT
groupValue	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
minShardIndex	TokenNameIdentifier
=	TokenNameEQUAL
shard	TokenNameIdentifier
.	TokenNameDOT
shardIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
group	TokenNameIdentifier
.	TokenNameDOT
sortValues	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
topValues	TokenNameIdentifier
=	TokenNameEQUAL
group	TokenNameIdentifier
.	TokenNameDOT
sortValues	TokenNameIdentifier
;	TokenNameSEMICOLON
groupsSeen	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
group	TokenNameIdentifier
.	TokenNameDOT
groupValue	TokenNameIdentifier
,	TokenNameCOMMA
mergedGroup	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
inQueue	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
queue	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
mergedGroup	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
processed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
boolean	TokenNameboolean
competes	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
compIDX	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
compIDX	TokenNameIdentifier
<	TokenNameLESS
groupComp	TokenNameIdentifier
.	TokenNameDOT
comparators	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
compIDX	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
cmp	TokenNameIdentifier
=	TokenNameEQUAL
groupComp	TokenNameIdentifier
.	TokenNameDOT
reversed	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
*	TokenNameMULTIPLY
(	TokenNameLPAREN
(	TokenNameLPAREN
FieldComparator	TokenNameIdentifier
)	TokenNameRPAREN
groupComp	TokenNameIdentifier
.	TokenNameDOT
comparators	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
.	TokenNameDOT
compareValues	TokenNameIdentifier
(	TokenNameLPAREN
group	TokenNameIdentifier
.	TokenNameDOT
sortValues	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
topValues	TokenNameIdentifier
[	TokenNameLBRACKET
compIDX	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cmp	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
competes	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
cmp	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
compIDX	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
groupComp	TokenNameIdentifier
.	TokenNameDOT
comparators	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
shard	TokenNameIdentifier
.	TokenNameDOT
shardIndex	TokenNameIdentifier
<	TokenNameLESS
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
minShardIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
competes	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
competes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
inQueue	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
queue	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
mergedGroup	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
topValues	TokenNameIdentifier
=	TokenNameEQUAL
group	TokenNameIdentifier
.	TokenNameDOT
sortValues	TokenNameIdentifier
;	TokenNameSEMICOLON
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
minShardIndex	TokenNameIdentifier
=	TokenNameEQUAL
shard	TokenNameIdentifier
.	TokenNameDOT
shardIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
queue	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
mergedGroup	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
inQueue	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
mergedGroup	TokenNameIdentifier
.	TokenNameDOT
shards	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
shard	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
queue	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
topN	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
group	TokenNameIdentifier
=	TokenNameEQUAL
queue	TokenNameIdentifier
.	TokenNameDOT
last	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queue	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
group	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
group	TokenNameIdentifier
.	TokenNameDOT
inQueue	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
Collection	TokenNameIdentifier
<	TokenNameLESS
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
merge	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Collection	TokenNameIdentifier
<	TokenNameLESS
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
shards	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
topN	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
maxQueueSize	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
+	TokenNamePLUS
topN	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
shardIDX	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
shardIDX	TokenNameIdentifier
<	TokenNameLESS
shards	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
shardIDX	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Collection	TokenNameIdentifier
<	TokenNameLESS
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
shard	TokenNameIdentifier
=	TokenNameEQUAL
shards	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
shardIDX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
shard	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
updateNextGroup	TokenNameIdentifier
(	TokenNameLPAREN
maxQueueSize	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
ShardIter	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
shard	TokenNameIdentifier
,	TokenNameCOMMA
shardIDX	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
newTopGroups	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
queue	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
MergedGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
group	TokenNameIdentifier
=	TokenNameEQUAL
queue	TokenNameIdentifier
.	TokenNameDOT
first	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queue	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
group	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
group	TokenNameIdentifier
.	TokenNameDOT
processed	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
>=	TokenNameGREATER_EQUAL
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
newGroup	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
newGroup	TokenNameIdentifier
.	TokenNameDOT
groupValue	TokenNameIdentifier
=	TokenNameEQUAL
group	TokenNameIdentifier
.	TokenNameDOT
groupValue	TokenNameIdentifier
;	TokenNameSEMICOLON
newGroup	TokenNameIdentifier
.	TokenNameDOT
sortValues	TokenNameIdentifier
=	TokenNameEQUAL
group	TokenNameIdentifier
.	TokenNameDOT
topValues	TokenNameIdentifier
;	TokenNameSEMICOLON
newTopGroups	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
newGroup	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
newTopGroups	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
topN	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
ShardIter	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
shardIter	TokenNameIdentifier
:	TokenNameCOLON
group	TokenNameIdentifier
.	TokenNameDOT
shards	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
updateNextGroup	TokenNameIdentifier
(	TokenNameLPAREN
maxQueueSize	TokenNameIdentifier
,	TokenNameCOMMA
shardIter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
newTopGroups	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
newTopGroups	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
Collection	TokenNameIdentifier
<	TokenNameLESS
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
merge	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
Collection	TokenNameIdentifier
<	TokenNameLESS
SearchGroup	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
topGroups	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
topN	TokenNameIdentifier
,	TokenNameCOMMA
Sort	TokenNameIdentifier
groupSort	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
topGroups	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
GroupMerger	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
groupSort	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
merge	TokenNameIdentifier
(	TokenNameLPAREN
topGroups	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
topN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
