package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
en	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
EnglishMinimalStemmer	TokenNameIdentifier
{	TokenNameLBRACE
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
"fallthrough"	TokenNameStringLiteral
)	TokenNameRPAREN
public	TokenNamepublic
int	TokenNameint
stem	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
s	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
,	TokenNameCOMMA
int	TokenNameint
len	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
len	TokenNameIdentifier
<	TokenNameLESS
3	TokenNameIntegerLiteral
||	TokenNameOR_OR
s	TokenNameIdentifier
[	TokenNameLBRACKET
len	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
's'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
len	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
s	TokenNameIdentifier
[	TokenNameLBRACKET
len	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
'u'	TokenNameCharacterLiteral
:	TokenNameCOLON
case	TokenNamecase
's'	TokenNameCharacterLiteral
:	TokenNameCOLON
return	TokenNamereturn
len	TokenNameIdentifier
;	TokenNameSEMICOLON
case	TokenNamecase
'e'	TokenNameCharacterLiteral
:	TokenNameCOLON
if	TokenNameif
(	TokenNameLPAREN
len	TokenNameIdentifier
>	TokenNameGREATER
3	TokenNameIntegerLiteral
&&	TokenNameAND_AND
s	TokenNameIdentifier
[	TokenNameLBRACKET
len	TokenNameIdentifier
-	TokenNameMINUS
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
'i'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
s	TokenNameIdentifier
[	TokenNameLBRACKET
len	TokenNameIdentifier
-	TokenNameMINUS
4	TokenNameIntegerLiteral
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
'a'	TokenNameCharacterLiteral
&&	TokenNameAND_AND
s	TokenNameIdentifier
[	TokenNameLBRACKET
len	TokenNameIdentifier
-	TokenNameMINUS
4	TokenNameIntegerLiteral
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
'e'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
s	TokenNameIdentifier
[	TokenNameLBRACKET
len	TokenNameIdentifier
-	TokenNameMINUS
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
'y'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
len	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
s	TokenNameIdentifier
[	TokenNameLBRACKET
len	TokenNameIdentifier
-	TokenNameMINUS
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
'i'	TokenNameCharacterLiteral
||	TokenNameOR_OR
s	TokenNameIdentifier
[	TokenNameLBRACKET
len	TokenNameIdentifier
-	TokenNameMINUS
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
'a'	TokenNameCharacterLiteral
||	TokenNameOR_OR
s	TokenNameIdentifier
[	TokenNameLBRACKET
len	TokenNameIdentifier
-	TokenNameMINUS
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
'o'	TokenNameCharacterLiteral
||	TokenNameOR_OR
s	TokenNameIdentifier
[	TokenNameLBRACKET
len	TokenNameIdentifier
-	TokenNameMINUS
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
'e'	TokenNameCharacterLiteral
)	TokenNameRPAREN
return	TokenNamereturn
len	TokenNameIdentifier
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
return	TokenNamereturn
len	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
