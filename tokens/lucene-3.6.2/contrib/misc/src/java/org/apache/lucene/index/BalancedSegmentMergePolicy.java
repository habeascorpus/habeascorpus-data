package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collections	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Map	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
SerialMergeScheduler	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
TieredMergePolicy	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
class	TokenNameclass
BalancedSegmentMergePolicy	TokenNameIdentifier
extends	TokenNameextends
LogByteSizeMergePolicy	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DEFAULT_NUM_LARGE_SEGMENTS	TokenNameIdentifier
=	TokenNameEQUAL
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
_partialExpunge	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
_numLargeSegments	TokenNameIdentifier
=	TokenNameEQUAL
DEFAULT_NUM_LARGE_SEGMENTS	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
_maxSmallSegments	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
LogMergePolicy	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_MERGE_FACTOR	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
_maxSegments	TokenNameIdentifier
=	TokenNameEQUAL
_numLargeSegments	TokenNameIdentifier
+	TokenNamePLUS
_maxSmallSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
BalancedSegmentMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setMergePolicyParams	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicyParams	TokenNameIdentifier
params	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
params	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
setPartialExpunge	TokenNameIdentifier
(	TokenNameLPAREN
params	TokenNameIdentifier
.	TokenNameDOT
_doPartialExpunge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setNumLargeSegments	TokenNameIdentifier
(	TokenNameLPAREN
params	TokenNameIdentifier
.	TokenNameDOT
_numLargeSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setMaxSmallSegments	TokenNameIdentifier
(	TokenNameLPAREN
params	TokenNameIdentifier
.	TokenNameDOT
_maxSmallSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setPartialExpunge	TokenNameIdentifier
(	TokenNameLPAREN
params	TokenNameIdentifier
.	TokenNameDOT
_doPartialExpunge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
params	TokenNameIdentifier
.	TokenNameDOT
_mergeFactor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
params	TokenNameIdentifier
.	TokenNameDOT
_useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setMaxMergeDocs	TokenNameIdentifier
(	TokenNameLPAREN
params	TokenNameIdentifier
.	TokenNameDOT
_maxMergeDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
long	TokenNamelong
size	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
long	TokenNamelong
byteSize	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
delRatio	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
0.0f	TokenNameFloatingPointLiteral
:	TokenNameCOLON
(	TokenNameLPAREN
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
info	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
/	TokenNameDIVIDE
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
byteSize	TokenNameIdentifier
:	TokenNameCOLON
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
1.0f	TokenNameFloatingPointLiteral
-	TokenNameMINUS
delRatio	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
byteSize	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPartialExpunge	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
doPartialExpunge	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
_partialExpunge	TokenNameIdentifier
=	TokenNameEQUAL
doPartialExpunge	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getPartialExpunge	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_partialExpunge	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setNumLargeSegments	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
numLargeSegments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
numLargeSegments	TokenNameIdentifier
<	TokenNameLESS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"numLargeSegments cannot be less than 2"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
_numLargeSegments	TokenNameIdentifier
=	TokenNameEQUAL
numLargeSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
_maxSegments	TokenNameIdentifier
=	TokenNameEQUAL
_numLargeSegments	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
getMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getNumLargeSegments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_numLargeSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setMaxSmallSegments	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxSmallSegments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
maxSmallSegments	TokenNameIdentifier
<	TokenNameLESS
getMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"maxSmallSegments cannot be less than mergeFactor"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
_maxSmallSegments	TokenNameIdentifier
=	TokenNameEQUAL
maxSmallSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
_maxSegments	TokenNameIdentifier
=	TokenNameEQUAL
_numLargeSegments	TokenNameIdentifier
+	TokenNamePLUS
_maxSmallSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getMaxSmallSegments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_maxSmallSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
mergeFactor	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
.	TokenNameDOT
setMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
mergeFactor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
_maxSmallSegments	TokenNameIdentifier
<	TokenNameLESS
getMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_maxSmallSegments	TokenNameIdentifier
=	TokenNameEQUAL
getMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_maxSegments	TokenNameIdentifier
=	TokenNameEQUAL
_numLargeSegments	TokenNameIdentifier
+	TokenNamePLUS
_maxSmallSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
MergeSpecification	TokenNameIdentifier
findForcedMerges	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
maxNumSegments	TokenNameIdentifier
,	TokenNameCOMMA
Map	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
>	TokenNameGREATER
segmentsToMerge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
maxNumSegments	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isMerged	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
,	TokenNameCOMMA
maxNumSegments	TokenNameIdentifier
,	TokenNameCOMMA
segmentsToMerge	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
last	TokenNameIdentifier
=	TokenNameEQUAL
infos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
last	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
last	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segmentsToMerge	TokenNameIdentifier
.	TokenNameDOT
containsKey	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
last	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
last	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
maxNumSegments	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
last	TokenNameIdentifier
>	TokenNameGREATER
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
isMerged	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
spec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergeSpecification	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
asList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
subList	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
last	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
last	TokenNameIdentifier
>	TokenNameGREATER
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
spec	TokenNameIdentifier
=	TokenNameEQUAL
findBalancedMerges	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
,	TokenNameCOMMA
last	TokenNameIdentifier
,	TokenNameCOMMA
maxNumSegments	TokenNameIdentifier
,	TokenNameCOMMA
_partialExpunge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
MergeSpecification	TokenNameIdentifier
findBalancedMerges	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
infoLen	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
maxNumSegments	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
partialExpunge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoLen	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergeSpecification	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
variance	TokenNameIdentifier
=	TokenNameEQUAL
createVarianceTable	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
,	TokenNameCOMMA
infoLen	TokenNameIdentifier
,	TokenNameCOMMA
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
maxMergeSegments	TokenNameIdentifier
=	TokenNameEQUAL
infoLen	TokenNameIdentifier
-	TokenNameMINUS
maxNumSegments	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sumVariance	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
double	TokenNamedouble
[	TokenNameLBRACKET
maxMergeSegments	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
backLink	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
maxNumSegments	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
maxMergeSegments	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
maxMergeSegments	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
sumVariance	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
variance	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
backLink	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
maxNumSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
maxMergeSegments	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
j	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
double	TokenNamedouble
minV	TokenNameIdentifier
=	TokenNameEQUAL
Double	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
minK	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
k	TokenNameIdentifier
=	TokenNameEQUAL
j	TokenNameIdentifier
;	TokenNameSEMICOLON
k	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
k	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
double	TokenNamedouble
v	TokenNameIdentifier
=	TokenNameEQUAL
sumVariance	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
+	TokenNamePLUS
variance	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
k	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
j	TokenNameIdentifier
-	TokenNameMINUS
k	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
v	TokenNameIdentifier
<	TokenNameLESS
minV	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
minV	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
minK	TokenNameIdentifier
=	TokenNameEQUAL
k	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
sumVariance	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
minV	TokenNameIdentifier
;	TokenNameSEMICOLON
backLink	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
minK	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
mergeEnd	TokenNameIdentifier
=	TokenNameEQUAL
infoLen	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
prev	TokenNameIdentifier
=	TokenNameEQUAL
maxMergeSegments	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
expungeCandidate	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
maxDelCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
maxNumSegments	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
prev	TokenNameIdentifier
=	TokenNameEQUAL
backLink	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
prev	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
mergeStart	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
+	TokenNamePLUS
prev	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
mergeEnd	TokenNameIdentifier
-	TokenNameMINUS
mergeStart	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
asList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
subList	TokenNameIdentifier
(	TokenNameLPAREN
mergeStart	TokenNameIdentifier
,	TokenNameCOMMA
mergeEnd	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
partialExpunge	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
mergeStart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
delCount	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
delCount	TokenNameIdentifier
>	TokenNameGREATER
maxDelCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
expungeCandidate	TokenNameIdentifier
=	TokenNameEQUAL
mergeStart	TokenNameIdentifier
;	TokenNameSEMICOLON
maxDelCount	TokenNameIdentifier
=	TokenNameEQUAL
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
mergeEnd	TokenNameIdentifier
=	TokenNameEQUAL
mergeStart	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
partialExpunge	TokenNameIdentifier
&&	TokenNameAND_AND
maxDelCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
Collections	TokenNameIdentifier
.	TokenNameDOT
singletonList	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
expungeCandidate	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
createVarianceTable	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
last	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
maxMergeSegments	TokenNameIdentifier
=	TokenNameEQUAL
last	TokenNameIdentifier
-	TokenNameMINUS
maxNumSegments	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
variance	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
double	TokenNamedouble
[	TokenNameLBRACKET
last	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
maxMergeSegments	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
long	TokenNamelong
optSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sizeArr	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
long	TokenNamelong
[	TokenNameLBRACKET
last	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
sizeArr	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
sizeArr	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
optSize	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
sizeArr	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
optSize	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
optSize	TokenNameIdentifier
/	TokenNameDIVIDE
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
last	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
size	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
maxMergeSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
j	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
last	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
size	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
sizeArr	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
+	TokenNamePLUS
j	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
double	TokenNamedouble
residual	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
size	TokenNameIdentifier
/	TokenNameDIVIDE
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
optSize	TokenNameIdentifier
)	TokenNameRPAREN
-	TokenNameMINUS
1.0d	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
variance	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
residual	TokenNameIdentifier
*	TokenNameMULTIPLY
residual	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
variance	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
Double	TokenNameIdentifier
.	TokenNameDOT
NaN	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
variance	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
MergeSpecification	TokenNameIdentifier
findForcedDeletesMerges	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
numSegs	TokenNameIdentifier
=	TokenNameEQUAL
infos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
numLargeSegs	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
numSegs	TokenNameIdentifier
<	TokenNameLESS
_numLargeSegments	TokenNameIdentifier
?	TokenNameQUESTION
numSegs	TokenNameIdentifier
:	TokenNameCOLON
_numLargeSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numLargeSegs	TokenNameIdentifier
<	TokenNameLESS
numSegs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentInfos	TokenNameIdentifier
smallSegments	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
smallSegments	TokenNameIdentifier
.	TokenNameDOT
rollbackSegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
asList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
subList	TokenNameIdentifier
(	TokenNameLPAREN
numLargeSegs	TokenNameIdentifier
,	TokenNameCOMMA
numSegs	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
spec	TokenNameIdentifier
=	TokenNameEQUAL
super	TokenNamesuper
.	TokenNameDOT
findForcedDeletesMerges	TokenNameIdentifier
(	TokenNameLPAREN
smallSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
spec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergeSpecification	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numLargeSegs	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
Collections	TokenNameIdentifier
.	TokenNameDOT
singletonList	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
MergeSpecification	TokenNameIdentifier
findMerges	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
numSegs	TokenNameIdentifier
=	TokenNameEQUAL
infos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
numLargeSegs	TokenNameIdentifier
=	TokenNameEQUAL
_numLargeSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numSegs	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
numLargeSegs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
long	TokenNamelong
totalLargeSegSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
totalSmallSegSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numLargeSegs	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
info	TokenNameIdentifier
=	TokenNameEQUAL
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
totalLargeSegSize	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
numLargeSegs	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numSegs	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
info	TokenNameIdentifier
=	TokenNameEQUAL
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
totalSmallSegSize	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
long	TokenNamelong
targetSegSize	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
totalLargeSegSize	TokenNameIdentifier
/	TokenNameDIVIDE
(	TokenNameLPAREN
numLargeSegs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
targetSegSize	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
totalSmallSegSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
totalSmallSegSize	TokenNameIdentifier
<	TokenNameLESS
targetSegSize	TokenNameIdentifier
*	TokenNameMULTIPLY
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
=	TokenNameEQUAL
findBalancedMerges	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
,	TokenNameCOMMA
numLargeSegs	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
numLargeSegs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
_partialExpunge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
spec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergeSpecification	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
asList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
subList	TokenNameIdentifier
(	TokenNameLPAREN
numLargeSegs	TokenNameIdentifier
,	TokenNameCOMMA
numSegs	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
findBalancedMerges	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
,	TokenNameCOMMA
numSegs	TokenNameIdentifier
,	TokenNameCOMMA
numLargeSegs	TokenNameIdentifier
,	TokenNameCOMMA
_partialExpunge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
_maxSegments	TokenNameIdentifier
<	TokenNameLESS
numSegs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergeSpecification	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
startSeg	TokenNameIdentifier
=	TokenNameEQUAL
numLargeSegs	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
sizeThreshold	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
targetSegSize	TokenNameIdentifier
/	TokenNameDIVIDE
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
startSeg	TokenNameIdentifier
<	TokenNameLESS
numSegs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
info	TokenNameIdentifier
=	TokenNameEQUAL
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
startSeg	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
size	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
sizeThreshold	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
startSeg	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
asList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
subList	TokenNameIdentifier
(	TokenNameLPAREN
startSeg	TokenNameIdentifier
,	TokenNameCOMMA
numSegs	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
SegmentInfos	TokenNameIdentifier
smallSegments	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
smallSegments	TokenNameIdentifier
.	TokenNameDOT
rollbackSegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
asList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
subList	TokenNameIdentifier
(	TokenNameLPAREN
numLargeSegs	TokenNameIdentifier
,	TokenNameCOMMA
numSegs	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
=	TokenNameEQUAL
super	TokenNamesuper
.	TokenNameDOT
findMerges	TokenNameIdentifier
(	TokenNameLPAREN
smallSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
_partialExpunge	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
OneMerge	TokenNameIdentifier
expunge	TokenNameIdentifier
=	TokenNameEQUAL
findOneSegmentToExpunge	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
,	TokenNameCOMMA
numLargeSegs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
expunge	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
spec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergeSpecification	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
expunge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
OneMerge	TokenNameIdentifier
findOneSegmentToExpunge	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
expungeCandidate	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
maxDelCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
maxNumSegments	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
delCount	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
delCount	TokenNameIdentifier
>	TokenNameGREATER
maxDelCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
expungeCandidate	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
maxDelCount	TokenNameIdentifier
=	TokenNameEQUAL
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
maxDelCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
Collections	TokenNameIdentifier
.	TokenNameDOT
singletonList	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
expungeCandidate	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
MergePolicyParams	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
int	TokenNameint
_numLargeSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
_maxSmallSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
_doPartialExpunge	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
_mergeFactor	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
_useCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
_maxMergeDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
MergePolicyParams	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
_useCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
_doPartialExpunge	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
_numLargeSegments	TokenNameIdentifier
=	TokenNameEQUAL
DEFAULT_NUM_LARGE_SEGMENTS	TokenNameIdentifier
;	TokenNameSEMICOLON
_maxSmallSegments	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
LogMergePolicy	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_MERGE_FACTOR	TokenNameIdentifier
;	TokenNameSEMICOLON
_maxSmallSegments	TokenNameIdentifier
=	TokenNameEQUAL
_numLargeSegments	TokenNameIdentifier
+	TokenNamePLUS
_maxSmallSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
_mergeFactor	TokenNameIdentifier
=	TokenNameEQUAL
LogMergePolicy	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_MERGE_FACTOR	TokenNameIdentifier
;	TokenNameSEMICOLON
_maxMergeDocs	TokenNameIdentifier
=	TokenNameEQUAL
LogMergePolicy	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_MAX_MERGE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setNumLargeSegments	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
numLargeSegments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
_numLargeSegments	TokenNameIdentifier
=	TokenNameEQUAL
numLargeSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getNumLargeSegments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_numLargeSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setMaxSmallSegments	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxSmallSegments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
_maxSmallSegments	TokenNameIdentifier
=	TokenNameEQUAL
maxSmallSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getMaxSmallSegments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_maxSmallSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPartialExpunge	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
doPartialExpunge	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
_doPartialExpunge	TokenNameIdentifier
=	TokenNameEQUAL
doPartialExpunge	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getPartialExpunge	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_doPartialExpunge	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
mergeFactor	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
_mergeFactor	TokenNameIdentifier
=	TokenNameEQUAL
mergeFactor	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_mergeFactor	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setMaxMergeDocs	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxMergeDocs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
_maxMergeDocs	TokenNameIdentifier
=	TokenNameEQUAL
maxMergeDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getMaxMergeDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_maxMergeDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
_useCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
useCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
_useCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
