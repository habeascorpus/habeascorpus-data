package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
facet	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
sampling	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Arrays	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
logging	TokenNameIdentifier
.	TokenNameDOT
Level	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
logging	TokenNameIdentifier
.	TokenNameDOT
Logger	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
PriorityQueue	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
facet	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
ScoredDocIDs	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
facet	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
ScoredDocIDsIterator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
facet	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ScoredDocIdsUtils	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
RepeatableSampler	TokenNameIdentifier
extends	TokenNameextends
Sampler	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
Logger	TokenNameIdentifier
logger	TokenNameIdentifier
=	TokenNameEQUAL
Logger	TokenNameIdentifier
.	TokenNameDOT
getLogger	TokenNameIdentifier
(	TokenNameLPAREN
RepeatableSampler	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
RepeatableSampler	TokenNameIdentifier
(	TokenNameLPAREN
SamplingParams	TokenNameIdentifier
params	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
params	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
SampleResult	TokenNameIdentifier
createSample	TokenNameIdentifier
(	TokenNameLPAREN
ScoredDocIDs	TokenNameIdentifier
docids	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
actualSize	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
sampleSetSize	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sampleSet	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
sampleSet	TokenNameIdentifier
=	TokenNameEQUAL
repeatableSample	TokenNameIdentifier
(	TokenNameLPAREN
docids	TokenNameIdentifier
,	TokenNameCOMMA
actualSize	TokenNameIdentifier
,	TokenNameCOMMA
sampleSetSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
logger	TokenNameIdentifier
.	TokenNameDOT
isLoggable	TokenNameIdentifier
(	TokenNameLPAREN
Level	TokenNameIdentifier
.	TokenNameDOT
WARNING	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
logger	TokenNameIdentifier
.	TokenNameDOT
log	TokenNameIdentifier
(	TokenNameLPAREN
Level	TokenNameIdentifier
.	TokenNameDOT
WARNING	TokenNameIdentifier
,	TokenNameCOMMA
"sampling failed: "	TokenNameStringLiteral
+	TokenNamePLUS
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" - falling back to no sampling!"	TokenNameStringLiteral
,	TokenNameCOMMA
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
SampleResult	TokenNameIdentifier
(	TokenNameLPAREN
docids	TokenNameIdentifier
,	TokenNameCOMMA
1d	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ScoredDocIDs	TokenNameIdentifier
sampled	TokenNameIdentifier
=	TokenNameEQUAL
ScoredDocIdsUtils	TokenNameIdentifier
.	TokenNameDOT
createScoredDocIDsSubset	TokenNameIdentifier
(	TokenNameLPAREN
docids	TokenNameIdentifier
,	TokenNameCOMMA
sampleSet	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
logger	TokenNameIdentifier
.	TokenNameDOT
isLoggable	TokenNameIdentifier
(	TokenNameLPAREN
Level	TokenNameIdentifier
.	TokenNameDOT
FINEST	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
logger	TokenNameIdentifier
.	TokenNameDOT
finest	TokenNameIdentifier
(	TokenNameLPAREN
"******************** "	TokenNameStringLiteral
+	TokenNamePLUS
sampled	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
SampleResult	TokenNameIdentifier
(	TokenNameLPAREN
sampled	TokenNameIdentifier
,	TokenNameCOMMA
sampled	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
/	TokenNameDIVIDE
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
docids	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
repeatableSample	TokenNameIdentifier
(	TokenNameLPAREN
ScoredDocIDs	TokenNameIdentifier
collection	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
collectionSize	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
sampleSize	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
repeatableSample	TokenNameIdentifier
(	TokenNameLPAREN
collection	TokenNameIdentifier
,	TokenNameCOMMA
collectionSize	TokenNameIdentifier
,	TokenNameCOMMA
sampleSize	TokenNameIdentifier
,	TokenNameCOMMA
Algorithm	TokenNameIdentifier
.	TokenNameDOT
HASHING	TokenNameIdentifier
,	TokenNameCOMMA
Sorted	TokenNameIdentifier
.	TokenNameDOT
NO	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
repeatableSample	TokenNameIdentifier
(	TokenNameLPAREN
ScoredDocIDs	TokenNameIdentifier
collection	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
collectionSize	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
sampleSize	TokenNameIdentifier
,	TokenNameCOMMA
Algorithm	TokenNameIdentifier
algorithm	TokenNameIdentifier
,	TokenNameCOMMA
Sorted	TokenNameIdentifier
sorted	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
collection	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"docIdSet is null"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
sampleSize	TokenNameIdentifier
<	TokenNameLESS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"sampleSize < 1 ("	TokenNameStringLiteral
+	TokenNamePLUS
sampleSize	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
collectionSize	TokenNameIdentifier
<	TokenNameLESS
sampleSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"collectionSize ("	TokenNameStringLiteral
+	TokenNamePLUS
collectionSize	TokenNameIdentifier
+	TokenNamePLUS
") less than sampleSize ("	TokenNameStringLiteral
+	TokenNamePLUS
sampleSize	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sample	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
sampleSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
times	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
long	TokenNamelong
[	TokenNameLBRACKET
4	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
algorithm	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Algorithm	TokenNameIdentifier
.	TokenNameDOT
TRAVERSAL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
sample1	TokenNameIdentifier
(	TokenNameLPAREN
collection	TokenNameIdentifier
,	TokenNameCOMMA
collectionSize	TokenNameIdentifier
,	TokenNameCOMMA
sample	TokenNameIdentifier
,	TokenNameCOMMA
times	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
algorithm	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Algorithm	TokenNameIdentifier
.	TokenNameDOT
HASHING	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
sample2	TokenNameIdentifier
(	TokenNameLPAREN
collection	TokenNameIdentifier
,	TokenNameCOMMA
collectionSize	TokenNameIdentifier
,	TokenNameCOMMA
sample	TokenNameIdentifier
,	TokenNameCOMMA
times	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Invalid algorithm selection"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
sorted	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Sorted	TokenNameIdentifier
.	TokenNameDOT
YES	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Arrays	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
sample	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
returnTimings	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
times	TokenNameIdentifier
[	TokenNameLBRACKET
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
logger	TokenNameIdentifier
.	TokenNameDOT
isLoggable	TokenNameIdentifier
(	TokenNameLPAREN
Level	TokenNameIdentifier
.	TokenNameDOT
FINEST	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
logger	TokenNameIdentifier
.	TokenNameDOT
finest	TokenNameIdentifier
(	TokenNameLPAREN
"Times: "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
times	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-	TokenNameMINUS
times	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
+	TokenNamePLUS
"ms, "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
times	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-	TokenNameMINUS
times	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
+	TokenNamePLUS
"ms, "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
times	TokenNameIdentifier
[	TokenNameLBRACKET
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-	TokenNameMINUS
times	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
+	TokenNamePLUS
"ms"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
sample	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
sample1	TokenNameIdentifier
(	TokenNameLPAREN
ScoredDocIDs	TokenNameIdentifier
collection	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
collectionSize	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sample	TokenNameIdentifier
,	TokenNameCOMMA
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
times	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ScoredDocIDsIterator	TokenNameIdentifier
it	TokenNameIdentifier
=	TokenNameEQUAL
collection	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
returnTimings	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
times	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
sampleSize	TokenNameIdentifier
=	TokenNameEQUAL
sample	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
prime	TokenNameIdentifier
=	TokenNameEQUAL
findGoodStepSize	TokenNameIdentifier
(	TokenNameLPAREN
collectionSize	TokenNameIdentifier
,	TokenNameCOMMA
sampleSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
mod	TokenNameIdentifier
=	TokenNameEQUAL
prime	TokenNameIdentifier
%	TokenNameREMAINDER
collectionSize	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
returnTimings	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
times	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
sampleCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
sampleCount	TokenNameIdentifier
<	TokenNameLESS
sampleSize	TokenNameIdentifier
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
mod	TokenNameIdentifier
<	TokenNameLESS
collectionSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
mod	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
index	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
it	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
index	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
+	TokenNamePLUS
mod	TokenNameIdentifier
-	TokenNameMINUS
collectionSize	TokenNameIdentifier
;	TokenNameSEMICOLON
it	TokenNameIdentifier
=	TokenNameEQUAL
collection	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
index	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
it	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
sample	TokenNameIdentifier
[	TokenNameLBRACKET
sampleCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
it	TokenNameIdentifier
.	TokenNameDOT
getDocID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
returnTimings	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
times	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
int	TokenNameint
findGoodStepSize	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
collectionSize	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
sampleSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
sqrt	TokenNameIdentifier
(	TokenNameLPAREN
collectionSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
sampleSize	TokenNameIdentifier
<	TokenNameLESS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
i	TokenNameIdentifier
=	TokenNameEQUAL
collectionSize	TokenNameIdentifier
/	TokenNameDIVIDE
sampleSize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
do	TokenNamedo
{	TokenNameLBRACE
i	TokenNameIdentifier
=	TokenNameEQUAL
findNextPrimeAfter	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
collectionSize	TokenNameIdentifier
%	TokenNameREMAINDER
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
i	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
int	TokenNameint
findNextPrimeAfter	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
n	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
n	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
(	TokenNameLPAREN
n	TokenNameIdentifier
%	TokenNameREMAINDER
2	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
foundFactor	TokenNameIdentifier
:	TokenNameCOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
n	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
sri	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
sqrt	TokenNameIdentifier
(	TokenNameLPAREN
n	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
primeIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
primeIndex	TokenNameIdentifier
<	TokenNameLESS
N_PRIMES	TokenNameIdentifier
;	TokenNameSEMICOLON
primeIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
p	TokenNameIdentifier
=	TokenNameEQUAL
primes	TokenNameIdentifier
[	TokenNameLBRACKET
primeIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
>	TokenNameGREATER
sri	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
n	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
n	TokenNameIdentifier
%	TokenNameREMAINDER
p	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
foundFactor	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
p	TokenNameIdentifier
=	TokenNameEQUAL
primes	TokenNameIdentifier
[	TokenNameLBRACKET
N_PRIMES	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
p	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
>	TokenNameGREATER
sri	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
n	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
n	TokenNameIdentifier
%	TokenNameREMAINDER
p	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
foundFactor	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
N_PRIMES	TokenNameIdentifier
=	TokenNameEQUAL
4000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
primes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
N_PRIMES	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
static	TokenNamestatic
{	TokenNameLBRACE
primes	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
count	TokenNameIdentifier
<	TokenNameLESS
N_PRIMES	TokenNameIdentifier
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
primes	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
findNextPrimeAfter	TokenNameIdentifier
(	TokenNameLPAREN
primes	TokenNameIdentifier
[	TokenNameLBRACKET
count	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
sample2	TokenNameIdentifier
(	TokenNameLPAREN
ScoredDocIDs	TokenNameIdentifier
collection	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
collectionSize	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sample	TokenNameIdentifier
,	TokenNameCOMMA
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
times	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
returnTimings	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
times	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
sampleSize	TokenNameIdentifier
=	TokenNameEQUAL
sample	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
IntPriorityQueue	TokenNameIdentifier
pq	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IntPriorityQueue	TokenNameIdentifier
(	TokenNameLPAREN
sampleSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ScoredDocIDsIterator	TokenNameIdentifier
it	TokenNameIdentifier
=	TokenNameEQUAL
collection	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
it	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
pq	TokenNameIdentifier
.	TokenNameDOT
insertWithReuse	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
it	TokenNameIdentifier
.	TokenNameDOT
getDocID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
*	TokenNameMULTIPLY
PHI_32	TokenNameIdentifier
)	TokenNameRPAREN
&	TokenNameAND
0x7FFFFFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
returnTimings	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
times	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
heap	TokenNameIdentifier
=	TokenNameEQUAL
pq	TokenNameIdentifier
.	TokenNameDOT
getHeap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
si	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
si	TokenNameIdentifier
<	TokenNameLESS
sampleSize	TokenNameIdentifier
;	TokenNameSEMICOLON
si	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
sample	TokenNameIdentifier
[	TokenNameLBRACKET
si	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
IntPriorityQueue	TokenNameIdentifier
.	TokenNameDOT
MI	TokenNameIdentifier
)	TokenNameRPAREN
(	TokenNameLPAREN
heap	TokenNameIdentifier
[	TokenNameLBRACKET
si	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
value	TokenNameIdentifier
*	TokenNameMULTIPLY
PHI_32I	TokenNameIdentifier
)	TokenNameRPAREN
&	TokenNameAND
0x7FFFFFFF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
returnTimings	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
times	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
IntPriorityQueue	TokenNameIdentifier
extends	TokenNameextends
PriorityQueue	TokenNameIdentifier
<	TokenNameLESS
Object	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
public	TokenNamepublic
IntPriorityQueue	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
size	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
initialize	TokenNameIdentifier
(	TokenNameLPAREN
size	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
insertWithReuse	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
intval	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
mi	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
mi	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MI	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
mi	TokenNameIdentifier
.	TokenNameDOT
value	TokenNameIdentifier
=	TokenNameEQUAL
intval	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
mi	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
MI	TokenNameIdentifier
)	TokenNameRPAREN
this	TokenNamethis
.	TokenNameDOT
insertWithOverflow	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
mi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getHeap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getHeapArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
lessThan	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
o1	TokenNameIdentifier
,	TokenNameCOMMA
Object	TokenNameIdentifier
o2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
MI	TokenNameIdentifier
)	TokenNameRPAREN
o1	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
value	TokenNameIdentifier
<	TokenNameLESS
(	TokenNameLPAREN
(	TokenNameLPAREN
MI	TokenNameIdentifier
)	TokenNameRPAREN
o2	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
value	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
MI	TokenNameIdentifier
{	TokenNameLBRACE
MI	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
value	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
MI	TokenNameIdentifier
mi	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
enum	TokenNameenum
Algorithm	TokenNameIdentifier
{	TokenNameLBRACE
TRAVERSAL	TokenNameIdentifier
,	TokenNameCOMMA
HASHING	TokenNameIdentifier
}	TokenNameRBRACE
private	TokenNameprivate
enum	TokenNameenum
Sorted	TokenNameIdentifier
{	TokenNameLBRACE
YES	TokenNameIdentifier
,	TokenNameCOMMA
NO	TokenNameIdentifier
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
PHI_32	TokenNameIdentifier
=	TokenNameEQUAL
2654435769L	TokenNameLongLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
PHI_32I	TokenNameIdentifier
=	TokenNameEQUAL
340573321L	TokenNameLongLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
returnTimings	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
