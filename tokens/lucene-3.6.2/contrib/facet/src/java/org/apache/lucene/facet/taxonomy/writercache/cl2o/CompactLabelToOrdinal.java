package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
facet	TokenNameIdentifier
.	TokenNameDOT
taxonomy	TokenNameIdentifier
.	TokenNameDOT
writercache	TokenNameIdentifier
.	TokenNameDOT
cl2o	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
BufferedInputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
BufferedOutputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
DataInputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
DataOutputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
File	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
FileInputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
FileOutputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Iterator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
facet	TokenNameIdentifier
.	TokenNameDOT
taxonomy	TokenNameIdentifier
.	TokenNameDOT
CategoryPath	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
CompactLabelToOrdinal	TokenNameIdentifier
extends	TokenNameextends
LabelToOrdinal	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
float	TokenNamefloat
DefaultLoadFactor	TokenNameIdentifier
=	TokenNameEQUAL
0.15f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
char	TokenNamechar
TerminatorChar	TokenNameIdentifier
=	TokenNameEQUAL
0xffff	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
Collision	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
5	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
HashArray	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
hashArrays	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
CollisionMap	TokenNameIdentifier
collisionMap	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
CharBlockArray	TokenNameIdentifier
labelRepository	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
capacity	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
threshold	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
float	TokenNamefloat
loadFactor	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
sizeOfMap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
CompactLabelToOrdinal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
CompactLabelToOrdinal	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
initialCapacity	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
loadFactor	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
numHashArrays	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashArray	TokenNameIdentifier
[	TokenNameLBRACKET
numHashArrays	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
capacity	TokenNameIdentifier
=	TokenNameEQUAL
determineCapacity	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
pow	TokenNameIdentifier
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
,	TokenNameCOMMA
numHashArrays	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
initialCapacity	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CollisionMap	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
counter	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
loadFactor	TokenNameIdentifier
=	TokenNameEQUAL
loadFactor	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
threshold	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
loadFactor	TokenNameIdentifier
*	TokenNameMULTIPLY
this	TokenNamethis
.	TokenNameDOT
capacity	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
int	TokenNameint
determineCapacity	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
minCapacity	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
initialCapacity	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
capacity	TokenNameIdentifier
=	TokenNameEQUAL
minCapacity	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
capacity	TokenNameIdentifier
<	TokenNameLESS
initialCapacity	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
capacity	TokenNameIdentifier
<<=	TokenNameLEFT_SHIFT_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
capacity	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
labelRepository	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CharBlockArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
new	TokenNamenew
CategoryPath	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
serializeAppendTo	TokenNameIdentifier
(	TokenNameLPAREN
labelRepository	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
int	TokenNameint
c	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
capacity	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
HashArray	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
c	TokenNameIdentifier
/=	TokenNameDIVIDE_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
addLabel	TokenNameIdentifier
(	TokenNameLPAREN
CategoryPath	TokenNameIdentifier
label	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
ordinal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
this	TokenNamethis
.	TokenNameDOT
threshold	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
grow	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
CompactLabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
stringHashCode	TokenNameIdentifier
(	TokenNameLPAREN
label	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
addLabel	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
label	TokenNameIdentifier
,	TokenNameCOMMA
hash	TokenNameIdentifier
,	TokenNameCOMMA
ordinal	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
prevVal	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
.	TokenNameDOT
addLabel	TokenNameIdentifier
(	TokenNameLPAREN
label	TokenNameIdentifier
,	TokenNameCOMMA
hash	TokenNameIdentifier
,	TokenNameCOMMA
ordinal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
prevVal	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
ordinal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Label already exists: "	TokenNameStringLiteral
+	TokenNamePLUS
label	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
'/'	TokenNameCharacterLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
" prev ordinal "	TokenNameStringLiteral
+	TokenNamePLUS
prevVal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
addLabel	TokenNameIdentifier
(	TokenNameLPAREN
CategoryPath	TokenNameIdentifier
label	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
prefixLen	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
ordinal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
this	TokenNamethis
.	TokenNameDOT
threshold	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
grow	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
CompactLabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
stringHashCode	TokenNameIdentifier
(	TokenNameLPAREN
label	TokenNameIdentifier
,	TokenNameCOMMA
prefixLen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
addLabel	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
label	TokenNameIdentifier
,	TokenNameCOMMA
prefixLen	TokenNameIdentifier
,	TokenNameCOMMA
hash	TokenNameIdentifier
,	TokenNameCOMMA
ordinal	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
prevVal	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
.	TokenNameDOT
addLabel	TokenNameIdentifier
(	TokenNameLPAREN
label	TokenNameIdentifier
,	TokenNameCOMMA
prefixLen	TokenNameIdentifier
,	TokenNameCOMMA
hash	TokenNameIdentifier
,	TokenNameCOMMA
ordinal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
prevVal	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
ordinal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Label already exists: "	TokenNameStringLiteral
+	TokenNamePLUS
label	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
'/'	TokenNameCharacterLiteral
,	TokenNameCOMMA
prefixLen	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" prev ordinal "	TokenNameStringLiteral
+	TokenNamePLUS
prevVal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
getOrdinal	TokenNameIdentifier
(	TokenNameLPAREN
CategoryPath	TokenNameIdentifier
label	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
InvalidOrdinal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
CompactLabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
stringHashCode	TokenNameIdentifier
(	TokenNameLPAREN
label	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ord	TokenNameIdentifier
=	TokenNameEQUAL
getOrdinal	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
label	TokenNameIdentifier
,	TokenNameCOMMA
hash	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ord	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
Collision	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
ord	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
label	TokenNameIdentifier
,	TokenNameCOMMA
hash	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
getOrdinal	TokenNameIdentifier
(	TokenNameLPAREN
CategoryPath	TokenNameIdentifier
label	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
prefixLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
InvalidOrdinal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
CompactLabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
stringHashCode	TokenNameIdentifier
(	TokenNameLPAREN
label	TokenNameIdentifier
,	TokenNameCOMMA
prefixLen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ord	TokenNameIdentifier
=	TokenNameEQUAL
getOrdinal	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
label	TokenNameIdentifier
,	TokenNameCOMMA
prefixLen	TokenNameIdentifier
,	TokenNameCOMMA
hash	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ord	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
Collision	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
ord	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
label	TokenNameIdentifier
,	TokenNameCOMMA
prefixLen	TokenNameIdentifier
,	TokenNameCOMMA
hash	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
grow	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
HashArray	TokenNameIdentifier
temp	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
capacity	TokenNameIdentifier
*=	TokenNameMULTIPLY_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
HashArray	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
capacity	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sourceOffsetArray	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
offsets	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sourceCidsArray	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
cids	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
k	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
k	TokenNameIdentifier
<	TokenNameLESS
sourceOffsetArray	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
k	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
i	TokenNameIdentifier
&&	TokenNameAND_AND
sourceOffsetArray	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
targetOffsetArray	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
offsets	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
targetCidsArray	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
cids	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
newIndex	TokenNameIdentifier
=	TokenNameEQUAL
indexFor	TokenNameIdentifier
(	TokenNameLPAREN
stringHashCode	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
,	TokenNameCOMMA
sourceOffsetArray	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
,	TokenNameCOMMA
targetOffsetArray	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
targetOffsetArray	TokenNameIdentifier
[	TokenNameLBRACKET
newIndex	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
targetOffsetArray	TokenNameIdentifier
[	TokenNameLBRACKET
newIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
sourceOffsetArray	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
targetCidsArray	TokenNameIdentifier
[	TokenNameLBRACKET
newIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
sourceCidsArray	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
sourceOffsetArray	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
temp	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
offset	TokenNameIdentifier
=	TokenNameEQUAL
temp	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
stringHashCode	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addLabelOffset	TokenNameIdentifier
(	TokenNameLPAREN
hash	TokenNameIdentifier
,	TokenNameCOMMA
temp	TokenNameIdentifier
.	TokenNameDOT
cids	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
CollisionMap	TokenNameIdentifier
oldCollisionMap	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CollisionMap	TokenNameIdentifier
(	TokenNameLPAREN
oldCollisionMap	TokenNameIdentifier
.	TokenNameDOT
capacity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
threshold	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
capacity	TokenNameIdentifier
*	TokenNameMULTIPLY
this	TokenNamethis
.	TokenNameDOT
loadFactor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Iterator	TokenNameIdentifier
<	TokenNameLESS
CollisionMap	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
>	TokenNameGREATER
it	TokenNameIdentifier
=	TokenNameEQUAL
oldCollisionMap	TokenNameIdentifier
.	TokenNameDOT
entryIterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
it	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
CollisionMap	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
e	TokenNameIdentifier
=	TokenNameEQUAL
it	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addLabelOffset	TokenNameIdentifier
(	TokenNameLPAREN
stringHashCode	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
cid	TokenNameIdentifier
,	TokenNameCOMMA
e	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
addLabel	TokenNameIdentifier
(	TokenNameLPAREN
HashArray	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
CategoryPath	TokenNameIdentifier
label	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hash	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
ordinal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
CompactLabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
indexFor	TokenNameIdentifier
(	TokenNameLPAREN
hash	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
offset	TokenNameIdentifier
=	TokenNameEQUAL
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
label	TokenNameIdentifier
.	TokenNameDOT
serializeAppendTo	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
a	TokenNameIdentifier
.	TokenNameDOT
cids	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
ordinal	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
addLabel	TokenNameIdentifier
(	TokenNameLPAREN
HashArray	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
CategoryPath	TokenNameIdentifier
label	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
prefixLen	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hash	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
ordinal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
CompactLabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
indexFor	TokenNameIdentifier
(	TokenNameLPAREN
hash	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
offset	TokenNameIdentifier
=	TokenNameEQUAL
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
label	TokenNameIdentifier
.	TokenNameDOT
serializeAppendTo	TokenNameIdentifier
(	TokenNameLPAREN
prefixLen	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
a	TokenNameIdentifier
.	TokenNameDOT
cids	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
ordinal	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
addLabelOffset	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
hash	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
cid	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
knownOffset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
addLabelOffsetToHashArray	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
hash	TokenNameIdentifier
,	TokenNameCOMMA
cid	TokenNameIdentifier
,	TokenNameCOMMA
knownOffset	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
.	TokenNameDOT
addLabelOffset	TokenNameIdentifier
(	TokenNameLPAREN
hash	TokenNameIdentifier
,	TokenNameCOMMA
knownOffset	TokenNameIdentifier
,	TokenNameCOMMA
cid	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
this	TokenNamethis
.	TokenNameDOT
threshold	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
grow	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
addLabelOffsetToHashArray	TokenNameIdentifier
(	TokenNameLPAREN
HashArray	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hash	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
ordinal	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
knownOffset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
CompactLabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
indexFor	TokenNameIdentifier
(	TokenNameLPAREN
hash	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
offset	TokenNameIdentifier
=	TokenNameEQUAL
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
knownOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
a	TokenNameIdentifier
.	TokenNameDOT
cids	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
ordinal	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
getOrdinal	TokenNameIdentifier
(	TokenNameLPAREN
HashArray	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
CategoryPath	TokenNameIdentifier
label	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hash	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
InvalidOrdinal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
CompactLabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
indexFor	TokenNameIdentifier
(	TokenNameLPAREN
hash	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
offset	TokenNameIdentifier
=	TokenNameEQUAL
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
InvalidOrdinal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
label	TokenNameIdentifier
.	TokenNameDOT
equalsToSerialized	TokenNameIdentifier
(	TokenNameLPAREN
labelRepository	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
a	TokenNameIdentifier
.	TokenNameDOT
cids	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
Collision	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
getOrdinal	TokenNameIdentifier
(	TokenNameLPAREN
HashArray	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
CategoryPath	TokenNameIdentifier
label	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
prefixLen	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hash	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
InvalidOrdinal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
index	TokenNameIdentifier
=	TokenNameEQUAL
CompactLabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
indexFor	TokenNameIdentifier
(	TokenNameLPAREN
hash	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
offset	TokenNameIdentifier
=	TokenNameEQUAL
a	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
LabelToOrdinal	TokenNameIdentifier
.	TokenNameDOT
InvalidOrdinal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
label	TokenNameIdentifier
.	TokenNameDOT
equalsToSerialized	TokenNameIdentifier
(	TokenNameLPAREN
prefixLen	TokenNameIdentifier
,	TokenNameCOMMA
labelRepository	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
a	TokenNameIdentifier
.	TokenNameDOT
cids	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
Collision	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
int	TokenNameint
indexFor	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
h	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
h	TokenNameIdentifier
&	TokenNameAND
(	TokenNameLPAREN
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
int	TokenNameint
stringHashCode	TokenNameIdentifier
(	TokenNameLPAREN
CategoryPath	TokenNameIdentifier
label	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
label	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
^	TokenNameXOR
(	TokenNameLPAREN
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
20	TokenNameIntegerLiteral
)	TokenNameRPAREN
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
7	TokenNameIntegerLiteral
)	TokenNameRPAREN
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
hash	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
int	TokenNameint
stringHashCode	TokenNameIdentifier
(	TokenNameLPAREN
CategoryPath	TokenNameIdentifier
label	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
prefixLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
label	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
prefixLen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
^	TokenNameXOR
(	TokenNameLPAREN
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
20	TokenNameIntegerLiteral
)	TokenNameRPAREN
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
7	TokenNameIntegerLiteral
)	TokenNameRPAREN
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
hash	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
int	TokenNameint
stringHashCode	TokenNameIdentifier
(	TokenNameLPAREN
CharBlockArray	TokenNameIdentifier
labelRepository	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
CategoryPath	TokenNameIdentifier
.	TokenNameDOT
hashCodeOfSerialized	TokenNameIdentifier
(	TokenNameLPAREN
labelRepository	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
^	TokenNameXOR
(	TokenNameLPAREN
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
20	TokenNameIntegerLiteral
)	TokenNameRPAREN
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
7	TokenNameIntegerLiteral
)	TokenNameRPAREN
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
hash	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
getMemoryUsage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
memoryUsage	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
HashArray	TokenNameIdentifier
ha	TokenNameIdentifier
:	TokenNameCOLON
this	TokenNamethis
.	TokenNameDOT
hashArrays	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
memoryUsage	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
(	TokenNameLPAREN
ha	TokenNameIdentifier
.	TokenNameDOT
capacity	TokenNameIdentifier
*	TokenNameMULTIPLY
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
blockSize	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
.	TokenNameDOT
blockSize	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
actualBlockSize	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
blockSize	TokenNameIdentifier
*	TokenNameMULTIPLY
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
memoryUsage	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
.	TokenNameDOT
blocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
*	TokenNameMULTIPLY
actualBlockSize	TokenNameIdentifier
;	TokenNameSEMICOLON
memoryUsage	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
memoryUsage	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
this	TokenNamethis
.	TokenNameDOT
collisionMap	TokenNameIdentifier
.	TokenNameDOT
getMemoryUsage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
memoryUsage	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
CompactLabelToOrdinal	TokenNameIdentifier
open	TokenNameIdentifier
(	TokenNameLPAREN
File	TokenNameIdentifier
file	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
loadFactor	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
numHashArrays	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
CompactLabelToOrdinal	TokenNameIdentifier
l2o	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CompactLabelToOrdinal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
l2o	TokenNameIdentifier
.	TokenNameDOT
loadFactor	TokenNameIdentifier
=	TokenNameEQUAL
loadFactor	TokenNameIdentifier
;	TokenNameSEMICOLON
l2o	TokenNameIdentifier
.	TokenNameDOT
hashArrays	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashArray	TokenNameIdentifier
[	TokenNameLBRACKET
numHashArrays	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
DataInputStream	TokenNameIdentifier
dis	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
dis	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
DataInputStream	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
BufferedInputStream	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
FileInputStream	TokenNameIdentifier
(	TokenNameLPAREN
file	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
l2o	TokenNameIdentifier
.	TokenNameDOT
counter	TokenNameIdentifier
=	TokenNameEQUAL
dis	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
l2o	TokenNameIdentifier
.	TokenNameDOT
capacity	TokenNameIdentifier
=	TokenNameEQUAL
determineCapacity	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
pow	TokenNameIdentifier
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
,	TokenNameCOMMA
l2o	TokenNameIdentifier
.	TokenNameDOT
hashArrays	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
l2o	TokenNameIdentifier
.	TokenNameDOT
counter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
l2o	TokenNameIdentifier
.	TokenNameDOT
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
l2o	TokenNameIdentifier
.	TokenNameDOT
labelRepository	TokenNameIdentifier
=	TokenNameEQUAL
CharBlockArray	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
dis	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
l2o	TokenNameIdentifier
.	TokenNameDOT
collisionMap	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CollisionMap	TokenNameIdentifier
(	TokenNameLPAREN
l2o	TokenNameIdentifier
.	TokenNameDOT
labelRepository	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
cid	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
offset	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
lastStartOffset	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
offset	TokenNameIdentifier
<	TokenNameLESS
l2o	TokenNameIdentifier
.	TokenNameDOT
labelRepository	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
ncomponents	TokenNameIdentifier
=	TokenNameEQUAL
l2o	TokenNameIdentifier
.	TokenNameDOT
labelRepository	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
ncomponents	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ncomponents	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
usedchars	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
ncomponents	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
usedchars	TokenNameIdentifier
=	TokenNameEQUAL
l2o	TokenNameIdentifier
.	TokenNameDOT
labelRepository	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
*	TokenNameMULTIPLY
31	TokenNameIntegerLiteral
+	TokenNamePLUS
usedchars	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
usedchars	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
*	TokenNameMULTIPLY
31	TokenNameIntegerLiteral
+	TokenNamePLUS
l2o	TokenNameIdentifier
.	TokenNameDOT
labelRepository	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
^	TokenNameXOR
(	TokenNameLPAREN
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
20	TokenNameIntegerLiteral
)	TokenNameRPAREN
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
hash	TokenNameIdentifier
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
7	TokenNameIntegerLiteral
)	TokenNameRPAREN
^	TokenNameXOR
(	TokenNameLPAREN
hash	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
l2o	TokenNameIdentifier
.	TokenNameDOT
addLabelOffset	TokenNameIdentifier
(	TokenNameLPAREN
hash	TokenNameIdentifier
,	TokenNameCOMMA
cid	TokenNameIdentifier
,	TokenNameCOMMA
lastStartOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cid	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
lastStartOffset	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ClassNotFoundException	TokenNameIdentifier
cnfe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"Invalid file format. Cannot deserialize."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dis	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
dis	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
l2o	TokenNameIdentifier
.	TokenNameDOT
threshold	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
l2o	TokenNameIdentifier
.	TokenNameDOT
loadFactor	TokenNameIdentifier
*	TokenNameMULTIPLY
l2o	TokenNameIdentifier
.	TokenNameDOT
capacity	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
l2o	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
flush	TokenNameIdentifier
(	TokenNameLPAREN
File	TokenNameIdentifier
file	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
FileOutputStream	TokenNameIdentifier
fos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FileOutputStream	TokenNameIdentifier
(	TokenNameLPAREN
file	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
BufferedOutputStream	TokenNameIdentifier
os	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BufferedOutputStream	TokenNameIdentifier
(	TokenNameLPAREN
fos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
DataOutputStream	TokenNameIdentifier
dos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
DataOutputStream	TokenNameIdentifier
(	TokenNameLPAREN
os	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dos	TokenNameIdentifier
.	TokenNameDOT
writeInt	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
counter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
labelRepository	TokenNameIdentifier
.	TokenNameDOT
flush	TokenNameIdentifier
(	TokenNameLPAREN
dos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dos	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
fos	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
HashArray	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
offsets	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
cids	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
capacity	TokenNameIdentifier
;	TokenNameSEMICOLON
HashArray	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
c	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
capacity	TokenNameIdentifier
=	TokenNameEQUAL
c	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offsets	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
capacity	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
cids	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
this	TokenNamethis
.	TokenNameDOT
capacity	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
