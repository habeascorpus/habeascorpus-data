package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
.	TokenNameDOT
surround	TokenNameIdentifier
.	TokenNameDOT
parser	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
StringReader	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
TokenStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
.	TokenNameDOT
surround	TokenNameIdentifier
.	TokenNameDOT
query	TokenNameIdentifier
.	TokenNameDOT
SrndQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
.	TokenNameDOT
surround	TokenNameIdentifier
.	TokenNameDOT
query	TokenNameIdentifier
.	TokenNameDOT
FieldsQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
.	TokenNameDOT
surround	TokenNameIdentifier
.	TokenNameDOT
query	TokenNameIdentifier
.	TokenNameDOT
OrQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
.	TokenNameDOT
surround	TokenNameIdentifier
.	TokenNameDOT
query	TokenNameIdentifier
.	TokenNameDOT
AndQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
.	TokenNameDOT
surround	TokenNameIdentifier
.	TokenNameDOT
query	TokenNameIdentifier
.	TokenNameDOT
NotQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
.	TokenNameDOT
surround	TokenNameIdentifier
.	TokenNameDOT
query	TokenNameIdentifier
.	TokenNameDOT
DistanceQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
.	TokenNameDOT
surround	TokenNameIdentifier
.	TokenNameDOT
query	TokenNameIdentifier
.	TokenNameDOT
SrndTermQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
.	TokenNameDOT
surround	TokenNameIdentifier
.	TokenNameDOT
query	TokenNameIdentifier
.	TokenNameDOT
SrndPrefixQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
.	TokenNameDOT
surround	TokenNameIdentifier
.	TokenNameDOT
query	TokenNameIdentifier
.	TokenNameDOT
SrndTruncQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
QueryParser	TokenNameIdentifier
implements	TokenNameimplements
QueryParserConstants	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
minimumPrefixLength	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
minimumCharsInTrunc	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
truncationErrorMessage	TokenNameIdentifier
=	TokenNameEQUAL
"Too unrestrictive truncation: "	TokenNameStringLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
boostErrorMessage	TokenNameIdentifier
=	TokenNameEQUAL
"Cannot handle boost value: "	TokenNameStringLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
truncator	TokenNameIdentifier
=	TokenNameEQUAL
'*'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
anyChar	TokenNameIdentifier
=	TokenNameEQUAL
'?'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
quote	TokenNameIdentifier
=	TokenNameEQUAL
'\"'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
fieldOperator	TokenNameIdentifier
=	TokenNameEQUAL
':'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
comma	TokenNameIdentifier
=	TokenNameEQUAL
','	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
carat	TokenNameIdentifier
=	TokenNameEQUAL
'^'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
parse	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
query	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
QueryParser	TokenNameIdentifier
parser	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
QueryParser	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
parser	TokenNameIdentifier
.	TokenNameDOT
parse2	TokenNameIdentifier
(	TokenNameLPAREN
query	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
QueryParser	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
new	TokenNamenew
FastCharStream	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
StringReader	TokenNameIdentifier
(	TokenNameLPAREN
""	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
parse2	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
query	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
ReInit	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
FastCharStream	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
StringReader	TokenNameIdentifier
(	TokenNameLPAREN
query	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
TopSrndQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
TokenMgrError	TokenNameIdentifier
tme	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
tme	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
SrndQuery	TokenNameIdentifier
getFieldsQuery	TokenNameIdentifier
(	TokenNameLPAREN
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
,	TokenNameCOMMA
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
fieldNames	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
FieldsQuery	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
fieldNames	TokenNameIdentifier
,	TokenNameCOMMA
fieldOperator	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
SrndQuery	TokenNameIdentifier
getOrQuery	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
infix	TokenNameIdentifier
,	TokenNameCOMMA
Token	TokenNameIdentifier
orToken	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
OrQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
infix	TokenNameIdentifier
,	TokenNameCOMMA
orToken	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
SrndQuery	TokenNameIdentifier
getAndQuery	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
infix	TokenNameIdentifier
,	TokenNameCOMMA
Token	TokenNameIdentifier
andToken	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
AndQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
infix	TokenNameIdentifier
,	TokenNameCOMMA
andToken	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
SrndQuery	TokenNameIdentifier
getNotQuery	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
,	TokenNameCOMMA
Token	TokenNameIdentifier
notToken	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
NotQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
notToken	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
static	TokenNamestatic
int	TokenNameint
getOpDistance	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
distanceOp	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
distanceOp	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
Integer	TokenNameIdentifier
.	TokenNameDOT
parseInt	TokenNameIdentifier
(	TokenNameLPAREN
distanceOp	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
distanceOp	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
static	TokenNamestatic
void	TokenNamevoid
checkDistanceSubQueries	TokenNameIdentifier
(	TokenNameLPAREN
DistanceQuery	TokenNameIdentifier
distq	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
opName	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
String	TokenNameIdentifier
m	TokenNameIdentifier
=	TokenNameEQUAL
distq	TokenNameIdentifier
.	TokenNameDOT
distanceSubQueryNotAllowed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
m	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
"Operator "	TokenNameStringLiteral
+	TokenNamePLUS
opName	TokenNameIdentifier
+	TokenNamePLUS
": "	TokenNameStringLiteral
+	TokenNamePLUS
m	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
SrndQuery	TokenNameIdentifier
getDistanceQuery	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
infix	TokenNameIdentifier
,	TokenNameCOMMA
Token	TokenNameIdentifier
dToken	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
ordered	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
DistanceQuery	TokenNameIdentifier
dq	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
DistanceQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
infix	TokenNameIdentifier
,	TokenNameCOMMA
getOpDistance	TokenNameIdentifier
(	TokenNameLPAREN
dToken	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
dToken	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
,	TokenNameCOMMA
ordered	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkDistanceSubQueries	TokenNameIdentifier
(	TokenNameLPAREN
dq	TokenNameIdentifier
,	TokenNameCOMMA
dToken	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
dq	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
SrndQuery	TokenNameIdentifier
getTermQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
term	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
quoted	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
SrndTermQuery	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
,	TokenNameCOMMA
quoted	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
boolean	TokenNameboolean
allowedSuffix	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
suffixed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
suffixed	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
minimumPrefixLength	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
SrndQuery	TokenNameIdentifier
getPrefixQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
prefix	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
quoted	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
SrndPrefixQuery	TokenNameIdentifier
(	TokenNameLPAREN
prefix	TokenNameIdentifier
,	TokenNameCOMMA
quoted	TokenNameIdentifier
,	TokenNameCOMMA
truncator	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
boolean	TokenNameboolean
allowedTruncation	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
truncated	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
nrNormalChars	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
truncated	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
c	TokenNameIdentifier
=	TokenNameEQUAL
truncated	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
c	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
truncator	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
c	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
anyChar	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
nrNormalChars	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
nrNormalChars	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
minimumCharsInTrunc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
SrndQuery	TokenNameIdentifier
getTruncQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
truncated	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
SrndTruncQuery	TokenNameIdentifier
(	TokenNameLPAREN
truncated	TokenNameIdentifier
,	TokenNameCOMMA
truncator	TokenNameIdentifier
,	TokenNameCOMMA
anyChar	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
TopSrndQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
FieldsQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
q	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
FieldsQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
fieldNames	TokenNameIdentifier
;	TokenNameSEMICOLON
fieldNames	TokenNameIdentifier
=	TokenNameEQUAL
OptionalFields	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
OrQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
fieldNames	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
q	TokenNameIdentifier
:	TokenNameCOLON
getFieldsQuery	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
fieldNames	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
OptionalFields	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Token	TokenNameIdentifier
fieldName	TokenNameIdentifier
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
fieldNames	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
label_1	TokenNameIdentifier
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_2_1	TokenNameIdentifier
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
label_1	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fieldName	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
TERM	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
COLON	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fieldNames	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
fieldNames	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fieldNames	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
fieldName	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
fieldNames	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
OrQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
oprt	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
AndQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
label_2	TokenNameIdentifier
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
OR	TokenNameIdentifier
:	TokenNameCOLON
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
label_2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
oprt	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
OR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
queries	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
queries	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
q	TokenNameIdentifier
=	TokenNameEQUAL
AndQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
queries	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
q	TokenNameIdentifier
:	TokenNameCOLON
getOrQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
oprt	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
AndQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
oprt	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
NotQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
label_3	TokenNameIdentifier
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
AND	TokenNameIdentifier
:	TokenNameCOLON
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
label_3	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
oprt	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
AND	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
queries	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
queries	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
q	TokenNameIdentifier
=	TokenNameEQUAL
NotQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
queries	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
q	TokenNameIdentifier
:	TokenNameCOLON
getAndQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
oprt	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
NotQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
oprt	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
NQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
label_4	TokenNameIdentifier
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
NOT	TokenNameIdentifier
:	TokenNameCOLON
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
label_4	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
oprt	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
NOT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
queries	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
queries	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
q	TokenNameIdentifier
=	TokenNameEQUAL
NQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
queries	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
q	TokenNameIdentifier
:	TokenNameCOLON
getNotQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
oprt	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
NQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
dt	TokenNameIdentifier
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
WQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
label_5	TokenNameIdentifier
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
N	TokenNameIdentifier
:	TokenNameCOLON
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
label_5	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
dt	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
N	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
WQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
getDistanceQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
dt	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
q	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
WQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
wt	TokenNameIdentifier
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
PrimaryQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
label_6	TokenNameIdentifier
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
W	TokenNameIdentifier
:	TokenNameCOLON
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
4	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
label_6	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
wt	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
W	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
PrimaryQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
getDistanceQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
wt	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
q	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
PrimaryQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
LPAREN	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
LPAREN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
FieldsQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
OR	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
AND	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
W	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
N	TokenNameIdentifier
:	TokenNameCOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
PrefixOperatorQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
TRUNCQUOTED	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
QUOTED	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
SUFFIXTERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
TRUNCTERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
TERM	TokenNameIdentifier
:	TokenNameCOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
SimpleTerm	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
5	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
OptionalWeights	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
q	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
PrefixOperatorQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Token	TokenNameIdentifier
oprt	TokenNameIdentifier
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
OR	TokenNameIdentifier
:	TokenNameCOLON
oprt	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
OR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
=	TokenNameEQUAL
FieldsQueryList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
getOrQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
oprt	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
AND	TokenNameIdentifier
:	TokenNameCOLON
oprt	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
AND	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
=	TokenNameEQUAL
FieldsQueryList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
getAndQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
oprt	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
N	TokenNameIdentifier
:	TokenNameCOLON
oprt	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
N	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
=	TokenNameEQUAL
FieldsQueryList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
getDistanceQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
oprt	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
W	TokenNameIdentifier
:	TokenNameCOLON
oprt	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
W	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
=	TokenNameEQUAL
FieldsQueryList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
getDistanceQuery	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
oprt	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
6	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
List	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
FieldsQueryList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
queries	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SrndQuery	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
LPAREN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
FieldsQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
label_7	TokenNameIdentifier
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
COMMA	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
FieldsQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
queries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
COMMA	TokenNameIdentifier
:	TokenNameCOLON
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
7	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
label_7	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
queries	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
SrndQuery	TokenNameIdentifier
SimpleTerm	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Token	TokenNameIdentifier
term	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
TERM	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
TERM	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
getTermQuery	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
QUOTED	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
QUOTED	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
getTermQuery	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
SUFFIXTERM	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
SUFFIXTERM	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
allowedSuffix	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
truncationErrorMessage	TokenNameIdentifier
+	TokenNamePLUS
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
getPrefixQuery	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
TRUNCTERM	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
TRUNCTERM	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
allowedTruncation	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
truncationErrorMessage	TokenNameIdentifier
+	TokenNamePLUS
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
getTruncQuery	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
TRUNCQUOTED	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
TRUNCQUOTED	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
<	TokenNameLESS
minimumPrefixLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
truncationErrorMessage	TokenNameIdentifier
+	TokenNamePLUS
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
getPrefixQuery	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
8	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
void	TokenNamevoid
OptionalWeights	TokenNameIdentifier
(	TokenNameLPAREN
SrndQuery	TokenNameIdentifier
q	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Token	TokenNameIdentifier
weight	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
label_8	TokenNameIdentifier
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
CARAT	TokenNameIdentifier
:	TokenNameCOLON
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
9	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
label_8	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
CARAT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
weight	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
NUMBER	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
f	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
f	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
valueOf	TokenNameIdentifier
(	TokenNameLPAREN
weight	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
floatValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
floatExc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
boostErrorMessage	TokenNameIdentifier
+	TokenNamePLUS
weight	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
+	TokenNamePLUS
" ("	TokenNameStringLiteral
+	TokenNamePLUS
floatExc	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
f	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
boostErrorMessage	TokenNameIdentifier
+	TokenNamePLUS
weight	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
q	TokenNameIdentifier
.	TokenNameDOT
setWeight	TokenNameIdentifier
(	TokenNameLPAREN
f	TokenNameIdentifier
*	TokenNameMULTIPLY
q	TokenNameIdentifier
.	TokenNameDOT
getWeight	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
jj_2_1	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
xla	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_la	TokenNameIdentifier
=	TokenNameEQUAL
xla	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_lastpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
!	TokenNameNOT
jj_3_1	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
LookaheadSuccess	TokenNameIdentifier
ls	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
jj_save	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
xla	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
jj_3_1	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_scan_token	TokenNameIdentifier
(	TokenNameLPAREN
TERM	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_scan_token	TokenNameIdentifier
(	TokenNameLPAREN
COLON	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
QueryParserTokenManager	TokenNameIdentifier
token_source	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Token	TokenNameIdentifier
token	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Token	TokenNameIdentifier
jj_nt	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_ntk	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Token	TokenNameIdentifier
jj_scanpos	TokenNameIdentifier
,	TokenNameCOMMA
jj_lastpos	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_la	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_la1	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
10	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_la1_0	TokenNameIdentifier
;	TokenNameSEMICOLON
static	TokenNamestatic
{	TokenNameLBRACE
jj_la1_init_0	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
jj_la1_init_0	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_la1_0	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
0x100	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x200	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x400	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x1000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x800	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x7c3b00	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x1b00	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x8000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x7c0000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x20000	TokenNameIntegerLiteral
,	TokenNameCOMMA
}	TokenNameRBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
private	TokenNameprivate
JJCalls	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_2_rtns	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
jj_rescan	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_gc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
QueryParser	TokenNameIdentifier
(	TokenNameLPAREN
CharStream	TokenNameIdentifier
stream	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
token_source	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
QueryParserTokenManager	TokenNameIdentifier
(	TokenNameLPAREN
stream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
token	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_gen	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_2_rtns	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
ReInit	TokenNameIdentifier
(	TokenNameLPAREN
CharStream	TokenNameIdentifier
stream	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
token_source	TokenNameIdentifier
.	TokenNameDOT
ReInit	TokenNameIdentifier
(	TokenNameLPAREN
stream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
token	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_gen	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_2_rtns	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
QueryParser	TokenNameIdentifier
(	TokenNameLPAREN
QueryParserTokenManager	TokenNameIdentifier
tm	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
token_source	TokenNameIdentifier
=	TokenNameEQUAL
tm	TokenNameIdentifier
;	TokenNameSEMICOLON
token	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_gen	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_2_rtns	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
ReInit	TokenNameIdentifier
(	TokenNameLPAREN
QueryParserTokenManager	TokenNameIdentifier
tm	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
token_source	TokenNameIdentifier
=	TokenNameEQUAL
tm	TokenNameIdentifier
;	TokenNameSEMICOLON
token	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_gen	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_2_rtns	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Token	TokenNameIdentifier
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
kind	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Token	TokenNameIdentifier
oldToken	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
oldToken	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
next	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
token	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
token	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
token_source	TokenNameIdentifier
.	TokenNameDOT
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
token	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
kind	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_gen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
jj_gc	TokenNameIdentifier
>	TokenNameGREATER
100	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_gc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_2_rtns	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
JJCalls	TokenNameIdentifier
c	TokenNameIdentifier
=	TokenNameEQUAL
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
c	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
<	TokenNameLESS
jj_gen	TokenNameIdentifier
)	TokenNameRPAREN
c	TokenNameIdentifier
.	TokenNameDOT
first	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
c	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
token	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
token	TokenNameIdentifier
=	TokenNameEQUAL
oldToken	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_kind	TokenNameIdentifier
=	TokenNameEQUAL
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
throw	TokenNamethrow
generateParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
class	TokenNameclass
LookaheadSuccess	TokenNameIdentifier
extends	TokenNameextends
java	TokenNameIdentifier
.	TokenNameDOT
lang	TokenNameIdentifier
.	TokenNameDOT
Error	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
final	TokenNamefinal
private	TokenNameprivate
LookaheadSuccess	TokenNameIdentifier
jj_ls	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
LookaheadSuccess	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
jj_scan_token	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
kind	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_scanpos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
jj_lastpos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_la	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_scanpos	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_lastpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
token_source	TokenNameIdentifier
.	TokenNameDOT
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
jj_lastpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_rescan	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
tok	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
tok	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
jj_scanpos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
tok	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
tok	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
jj_add_error_token	TokenNameIdentifier
(	TokenNameLPAREN
kind	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_scanpos	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
kind	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_la	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
jj_scanpos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
jj_lastpos	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
jj_ls	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
Token	TokenNameIdentifier
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
token	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
token	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
token_source	TokenNameIdentifier
.	TokenNameDOT
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_gen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
return	TokenNamereturn
token	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
Token	TokenNameIdentifier
getToken	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Token	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
index	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
t	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
t	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
token_source	TokenNameIdentifier
.	TokenNameDOT
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_nt	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
token_source	TokenNameIdentifier
.	TokenNameDOT
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
kind	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
jj_nt	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
<	TokenNameLESS
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
jj_expentries	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
<	TokenNameLESS
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_expentry	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_kind	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_lasttokens	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
100	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_endpos	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
void	TokenNamevoid
jj_add_error_token	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
kind	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
pos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
100	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
jj_endpos	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_lasttokens	TokenNameIdentifier
[	TokenNameLBRACKET
jj_endpos	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
jj_endpos	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_expentry	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
jj_endpos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_endpos	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_expentry	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_lasttokens	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
jj_entries_loop	TokenNameIdentifier
:	TokenNameCOLON
for	TokenNamefor
(	TokenNameLPAREN
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Iterator	TokenNameIdentifier
it	TokenNameIdentifier
=	TokenNameEQUAL
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
it	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
oldentry	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
)	TokenNameRPAREN
(	TokenNameLPAREN
it	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
oldentry	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
jj_expentry	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_expentry	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
oldentry	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
jj_expentry	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
jj_entries_loop	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
jj_expentry	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
jj_entries_loop	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
jj_lasttokens	TokenNameIdentifier
[	TokenNameLBRACKET
(	TokenNameLPAREN
jj_endpos	TokenNameIdentifier
=	TokenNameEQUAL
pos	TokenNameIdentifier
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
ParseException	TokenNameIdentifier
generateParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
la1tokens	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
24	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_kind	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
la1tokens	TokenNameIdentifier
[	TokenNameLBRACKET
jj_kind	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
jj_kind	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
jj_gen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
32	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_la1_0	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
la1tokens	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
24	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
la1tokens	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_expentry	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
jj_expentry	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
jj_expentry	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
jj_endpos	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_rescan_token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_add_error_token	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
exptokseq	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
exptokseq	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
token	TokenNameIdentifier
,	TokenNameCOMMA
exptokseq	TokenNameIdentifier
,	TokenNameCOMMA
tokenImage	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
void	TokenNamevoid
enable_tracing	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
void	TokenNamevoid
disable_tracing	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
jj_rescan_token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_rescan	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
JJCalls	TokenNameIdentifier
p	TokenNameIdentifier
=	TokenNameEQUAL
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
do	TokenNamedo
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
>	TokenNameGREATER
jj_gen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_la	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
arg	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_lastpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
first	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0	TokenNameIntegerLiteral
:	TokenNameCOLON
jj_3_1	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
p	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
p	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
LookaheadSuccess	TokenNameIdentifier
ls	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
jj_rescan	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
jj_save	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
xla	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
JJCalls	TokenNameIdentifier
p	TokenNameIdentifier
=	TokenNameEQUAL
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
>	TokenNameGREATER
jj_gen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
p	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
p	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
p	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
+	TokenNamePLUS
xla	TokenNameIdentifier
-	TokenNameMINUS
jj_la	TokenNameIdentifier
;	TokenNameSEMICOLON
p	TokenNameIdentifier
.	TokenNameDOT
first	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
;	TokenNameSEMICOLON
p	TokenNameIdentifier
.	TokenNameDOT
arg	TokenNameIdentifier
=	TokenNameEQUAL
xla	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
JJCalls	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
gen	TokenNameIdentifier
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
first	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
arg	TokenNameIdentifier
;	TokenNameSEMICOLON
JJCalls	TokenNameIdentifier
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
