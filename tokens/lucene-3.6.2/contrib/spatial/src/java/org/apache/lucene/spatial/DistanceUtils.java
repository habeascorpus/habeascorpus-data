package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
spatial	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
spatial	TokenNameIdentifier
.	TokenNameDOT
geometry	TokenNameIdentifier
.	TokenNameDOT
DistanceUnits	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
spatial	TokenNameIdentifier
.	TokenNameDOT
geometry	TokenNameIdentifier
.	TokenNameDOT
FloatLatLng	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
spatial	TokenNameIdentifier
.	TokenNameDOT
geometry	TokenNameIdentifier
.	TokenNameDOT
LatLng	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
spatial	TokenNameIdentifier
.	TokenNameDOT
geometry	TokenNameIdentifier
.	TokenNameDOT
shape	TokenNameIdentifier
.	TokenNameDOT
LLRect	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
spatial	TokenNameIdentifier
.	TokenNameDOT
geometry	TokenNameIdentifier
.	TokenNameDOT
shape	TokenNameIdentifier
.	TokenNameDOT
Rectangle	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
spatial	TokenNameIdentifier
.	TokenNameDOT
tier	TokenNameIdentifier
.	TokenNameDOT
InvalidGeoException	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
class	TokenNameclass
DistanceUtils	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
DEGREES_TO_RADIANS	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
PI	TokenNameIdentifier
/	TokenNameDIVIDE
180.0	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
RADIANS_TO_DEGREES	TokenNameIdentifier
=	TokenNameEQUAL
180.0	TokenNameDoubleLiteral
/	TokenNameDIVIDE
Math	TokenNameIdentifier
.	TokenNameDOT
PI	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
DEG_45_AS_RADS	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
PI	TokenNameIdentifier
/	TokenNameDIVIDE
4.0	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
SIN_45_AS_RADS	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
sin	TokenNameIdentifier
(	TokenNameLPAREN
DEG_45_AS_RADS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
DEG_90_AS_RADS	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
PI	TokenNameIdentifier
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
DEG_180_AS_RADS	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
PI	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
DEG_225_AS_RADS	TokenNameIdentifier
=	TokenNameEQUAL
5	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
DEG_45_AS_RADS	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
DEG_270_AS_RADS	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
DEG_90_AS_RADS	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
KM_TO_MILES	TokenNameIdentifier
=	TokenNameEQUAL
0.621371192	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
MILES_TO_KM	TokenNameIdentifier
=	TokenNameEQUAL
1.609344	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
EARTH_MEAN_RADIUS_KM	TokenNameIdentifier
=	TokenNameEQUAL
6371.009	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
EARTH_MEAN_RADIUS_MI	TokenNameIdentifier
=	TokenNameEQUAL
EARTH_MEAN_RADIUS_KM	TokenNameIdentifier
/	TokenNameDIVIDE
MILES_TO_KM	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
EARTH_EQUATORIAL_RADIUS_MI	TokenNameIdentifier
=	TokenNameEQUAL
3963.205	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
EARTH_EQUATORIAL_RADIUS_KM	TokenNameIdentifier
=	TokenNameEQUAL
EARTH_EQUATORIAL_RADIUS_MI	TokenNameIdentifier
*	TokenNameMULTIPLY
MILES_TO_KM	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
getDistanceMi	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
x1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
y1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
x2	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
y2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getLLMDistance	TokenNameIdentifier
(	TokenNameLPAREN
x1	TokenNameIdentifier
,	TokenNameCOMMA
y1	TokenNameIdentifier
,	TokenNameCOMMA
x2	TokenNameIdentifier
,	TokenNameCOMMA
y2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
Rectangle	TokenNameIdentifier
getBoundary	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
x1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
y1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
miles	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
LLRect	TokenNameIdentifier
box	TokenNameIdentifier
=	TokenNameEQUAL
LLRect	TokenNameIdentifier
.	TokenNameDOT
createBox	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
FloatLatLng	TokenNameIdentifier
(	TokenNameLPAREN
x1	TokenNameIdentifier
,	TokenNameCOMMA
y1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
miles	TokenNameIdentifier
,	TokenNameCOMMA
miles	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
box	TokenNameIdentifier
.	TokenNameDOT
toRectangle	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
getLLMDistance	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
x1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
y1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
x2	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
y2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
LatLng	TokenNameIdentifier
p1	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FloatLatLng	TokenNameIdentifier
(	TokenNameLPAREN
x1	TokenNameIdentifier
,	TokenNameCOMMA
y1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
LatLng	TokenNameIdentifier
p2	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FloatLatLng	TokenNameIdentifier
(	TokenNameLPAREN
x2	TokenNameIdentifier
,	TokenNameCOMMA
y2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
p1	TokenNameIdentifier
.	TokenNameDOT
arcDistance	TokenNameIdentifier
(	TokenNameLPAREN
p2	TokenNameIdentifier
,	TokenNameCOMMA
DistanceUnits	TokenNameIdentifier
.	TokenNameDOT
MILES	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
angularDistance	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
distance	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
radius	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
distance	TokenNameIdentifier
/	TokenNameDIVIDE
radius	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
vectorDistance	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
vec1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
vec2	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
power	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
vectorDistance	TokenNameIdentifier
(	TokenNameLPAREN
vec1	TokenNameIdentifier
,	TokenNameCOMMA
vec2	TokenNameIdentifier
,	TokenNameCOMMA
power	TokenNameIdentifier
,	TokenNameCOMMA
1.0	TokenNameDoubleLiteral
/	TokenNameDIVIDE
power	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
vectorDistance	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
vec1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
vec2	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
power	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
oneOverPower	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
double	TokenNamedouble
result	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
power	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
vec1	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
vec1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
-	TokenNameMINUS
vec2	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
0	TokenNameIntegerLiteral
:	TokenNameCOLON
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
power	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
vec1	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
vec1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
-	TokenNameMINUS
vec2	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
power	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
2.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
sqrt	TokenNameIdentifier
(	TokenNameLPAREN
squaredEuclideanDistance	TokenNameIdentifier
(	TokenNameLPAREN
vec1	TokenNameIdentifier
,	TokenNameCOMMA
vec2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
power	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
Integer	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
||	TokenNameOR_OR
Double	TokenNameIdentifier
.	TokenNameDOT
isInfinite	TokenNameIdentifier
(	TokenNameLPAREN
power	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
vec1	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
,	TokenNameCOMMA
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
vec1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
vec2	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
vec1	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
pow	TokenNameIdentifier
(	TokenNameLPAREN
vec1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
-	TokenNameMINUS
vec2	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
power	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
pow	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
,	TokenNameCOMMA
oneOverPower	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
vectorBoxCorner	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
center	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
result	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
distance	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
upperRight	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
center	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
double	TokenNamedouble
[	TokenNameLBRACKET
center	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
upperRight	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
false	TokenNamefalse
)	TokenNameRPAREN
{	TokenNameLBRACE
distance	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
distance	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
distance	TokenNameIdentifier
=	TokenNameEQUAL
SIN_45_AS_RADS	TokenNameIdentifier
*	TokenNameMULTIPLY
distance	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
center	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
center	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
+	TokenNamePLUS
distance	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
latLonCornerDegs	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
latCenter	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
lonCenter	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
distance	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
result	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
upperRight	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
sphereRadius	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
latLonCorner	TokenNameIdentifier
(	TokenNameLPAREN
latCenter	TokenNameIdentifier
*	TokenNameMULTIPLY
DEGREES_TO_RADIANS	TokenNameIdentifier
,	TokenNameCOMMA
lonCenter	TokenNameIdentifier
*	TokenNameMULTIPLY
DEGREES_TO_RADIANS	TokenNameIdentifier
,	TokenNameCOMMA
distance	TokenNameIdentifier
,	TokenNameCOMMA
result	TokenNameIdentifier
,	TokenNameCOMMA
upperRight	TokenNameIdentifier
,	TokenNameCOMMA
sphereRadius	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
result	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
*	TokenNameMULTIPLY
RADIANS_TO_DEGREES	TokenNameIdentifier
;	TokenNameSEMICOLON
result	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
result	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
*	TokenNameMULTIPLY
RADIANS_TO_DEGREES	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
latLonCorner	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
latCenter	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
lonCenter	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
distance	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
result	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
upperRight	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
sphereRadius	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
double	TokenNamedouble
brng	TokenNameIdentifier
=	TokenNameEQUAL
upperRight	TokenNameIdentifier
?	TokenNameQUESTION
DEG_45_AS_RADS	TokenNameIdentifier
:	TokenNameCOLON
DEG_225_AS_RADS	TokenNameIdentifier
;	TokenNameSEMICOLON
result	TokenNameIdentifier
=	TokenNameEQUAL
pointOnBearing	TokenNameIdentifier
(	TokenNameLPAREN
latCenter	TokenNameIdentifier
,	TokenNameCOMMA
lonCenter	TokenNameIdentifier
,	TokenNameCOMMA
distance	TokenNameIdentifier
,	TokenNameCOMMA
brng	TokenNameIdentifier
,	TokenNameCOMMA
result	TokenNameIdentifier
,	TokenNameCOMMA
sphereRadius	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
pointOnBearing	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
startLat	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
startLon	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
distance	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
bearing	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
result	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
sphereRadius	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
double	TokenNamedouble
cosAngDist	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
cos	TokenNameIdentifier
(	TokenNameLPAREN
distance	TokenNameIdentifier
/	TokenNameDIVIDE
sphereRadius	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
double	TokenNamedouble
cosStartLat	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
cos	TokenNameIdentifier
(	TokenNameLPAREN
startLat	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
double	TokenNamedouble
sinAngDist	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
sin	TokenNameIdentifier
(	TokenNameLPAREN
distance	TokenNameIdentifier
/	TokenNameDIVIDE
sphereRadius	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
double	TokenNamedouble
lat2	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
asin	TokenNameIdentifier
(	TokenNameLPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
sin	TokenNameIdentifier
(	TokenNameLPAREN
startLat	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
cosAngDist	TokenNameIdentifier
+	TokenNamePLUS
cosStartLat	TokenNameIdentifier
*	TokenNameMULTIPLY
sinAngDist	TokenNameIdentifier
*	TokenNameMULTIPLY
Math	TokenNameIdentifier
.	TokenNameDOT
cos	TokenNameIdentifier
(	TokenNameLPAREN
bearing	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
double	TokenNamedouble
lon2	TokenNameIdentifier
=	TokenNameEQUAL
startLon	TokenNameIdentifier
+	TokenNamePLUS
Math	TokenNameIdentifier
.	TokenNameDOT
atan2	TokenNameIdentifier
(	TokenNameLPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
sin	TokenNameIdentifier
(	TokenNameLPAREN
bearing	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
sinAngDist	TokenNameIdentifier
*	TokenNameMULTIPLY
cosStartLat	TokenNameIdentifier
,	TokenNameCOMMA
cosAngDist	TokenNameIdentifier
-	TokenNameMINUS
Math	TokenNameIdentifier
.	TokenNameDOT
sin	TokenNameIdentifier
(	TokenNameLPAREN
startLat	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
Math	TokenNameIdentifier
.	TokenNameDOT
sin	TokenNameIdentifier
(	TokenNameLPAREN
lat2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
double	TokenNamedouble
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
result	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
lat2	TokenNameIdentifier
;	TokenNameSEMICOLON
result	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
lon2	TokenNameIdentifier
;	TokenNameSEMICOLON
normLng	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
normLat	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
normLat	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
latLng	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
>	TokenNameGREATER
DEG_90_AS_RADS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
DEG_90_AS_RADS	TokenNameIdentifier
-	TokenNameMINUS
(	TokenNameLPAREN
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-	TokenNameMINUS
DEG_90_AS_RADS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
DEG_180_AS_RADS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-	TokenNameMINUS
DEG_180_AS_RADS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
<	TokenNameLESS
-	TokenNameMINUS
DEG_90_AS_RADS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
DEG_90_AS_RADS	TokenNameIdentifier
-	TokenNameMINUS
(	TokenNameLPAREN
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
DEG_90_AS_RADS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
DEG_180_AS_RADS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-	TokenNameMINUS
DEG_180_AS_RADS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
normLng	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
latLng	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
>	TokenNameGREATER
DEG_180_AS_RADS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1.0	TokenNameDoubleLiteral
*	TokenNameMULTIPLY
(	TokenNameLPAREN
DEG_180_AS_RADS	TokenNameIdentifier
-	TokenNameMINUS
(	TokenNameLPAREN
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
-	TokenNameMINUS
DEG_180_AS_RADS	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
<	TokenNameLESS
-	TokenNameMINUS
DEG_180_AS_RADS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
latLng	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
DEG_180_AS_RADS	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
DEG_180_AS_RADS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
squaredEuclideanDistance	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
vec1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
vec2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
double	TokenNamedouble
result	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
vec1	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
double	TokenNamedouble
v	TokenNameIdentifier
=	TokenNameEQUAL
vec1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
-	TokenNameMINUS
vec2	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
result	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
v	TokenNameIdentifier
*	TokenNameMULTIPLY
v	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
haversine	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
y1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
x1	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
y2	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
x2	TokenNameIdentifier
,	TokenNameCOMMA
double	TokenNamedouble
radius	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
double	TokenNamedouble
result	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
x1	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
x2	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
y1	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
y2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
double	TokenNamedouble
diffX	TokenNameIdentifier
=	TokenNameEQUAL
x1	TokenNameIdentifier
-	TokenNameMINUS
x2	TokenNameIdentifier
;	TokenNameSEMICOLON
double	TokenNamedouble
diffY	TokenNameIdentifier
=	TokenNameEQUAL
y1	TokenNameIdentifier
-	TokenNameMINUS
y2	TokenNameIdentifier
;	TokenNameSEMICOLON
double	TokenNamedouble
hsinX	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
sin	TokenNameIdentifier
(	TokenNameLPAREN
diffX	TokenNameIdentifier
*	TokenNameMULTIPLY
0.5	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
double	TokenNamedouble
hsinY	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
sin	TokenNameIdentifier
(	TokenNameLPAREN
diffY	TokenNameIdentifier
*	TokenNameMULTIPLY
0.5	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
double	TokenNamedouble
h	TokenNameIdentifier
=	TokenNameEQUAL
hsinY	TokenNameIdentifier
*	TokenNameMULTIPLY
hsinY	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
cos	TokenNameIdentifier
(	TokenNameLPAREN
y1	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
Math	TokenNameIdentifier
.	TokenNameDOT
cos	TokenNameIdentifier
(	TokenNameLPAREN
y2	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
hsinX	TokenNameIdentifier
*	TokenNameMULTIPLY
hsinX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
radius	TokenNameIdentifier
*	TokenNameMULTIPLY
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
Math	TokenNameIdentifier
.	TokenNameDOT
atan2	TokenNameIdentifier
(	TokenNameLPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
sqrt	TokenNameIdentifier
(	TokenNameLPAREN
h	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
Math	TokenNameIdentifier
.	TokenNameDOT
sqrt	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
-	TokenNameMINUS
h	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
parsePoint	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
out	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
externalVal	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
dimension	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidGeoException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
out	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
out	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
dimension	TokenNameIdentifier
)	TokenNameRPAREN
out	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
String	TokenNameIdentifier
[	TokenNameLBRACKET
dimension	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
externalVal	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
','	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
idx	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
idx	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
dimension	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
externalVal	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
externalVal	TokenNameIdentifier
.	TokenNameDOT
trim	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
idx	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
dimension	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
start	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
&&	TokenNameAND_AND
externalVal	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
' '	TokenNameCharacterLiteral
)	TokenNameRPAREN
start	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
end	TokenNameIdentifier
>	TokenNameGREATER
start	TokenNameIdentifier
&&	TokenNameAND_AND
externalVal	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
' '	TokenNameCharacterLiteral
)	TokenNameRPAREN
end	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
start	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
externalVal	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
start	TokenNameIdentifier
=	TokenNameEQUAL
idx	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
end	TokenNameIdentifier
=	TokenNameEQUAL
externalVal	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
','	TokenNameCharacterLiteral
,	TokenNameCOMMA
start	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
end	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
end	TokenNameIdentifier
=	TokenNameEQUAL
externalVal	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
dimension	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidGeoException	TokenNameIdentifier
(	TokenNameLPAREN
"incompatible dimension ("	TokenNameStringLiteral
+	TokenNamePLUS
dimension	TokenNameIdentifier
+	TokenNamePLUS
") and values ("	TokenNameStringLiteral
+	TokenNamePLUS
externalVal	TokenNameIdentifier
+	TokenNamePLUS
").  Only "	TokenNameStringLiteral
+	TokenNamePLUS
i	TokenNameIdentifier
+	TokenNamePLUS
" values specified"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
out	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
parsePointDouble	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
out	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
externalVal	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
dimension	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidGeoException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
out	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
out	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
dimension	TokenNameIdentifier
)	TokenNameRPAREN
out	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
double	TokenNamedouble
[	TokenNameLBRACKET
dimension	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
externalVal	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
','	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
idx	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
idx	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
dimension	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
externalVal	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
Double	TokenNameIdentifier
.	TokenNameDOT
parseDouble	TokenNameIdentifier
(	TokenNameLPAREN
externalVal	TokenNameIdentifier
.	TokenNameDOT
trim	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
idx	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
dimension	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
start	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
&&	TokenNameAND_AND
externalVal	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
' '	TokenNameCharacterLiteral
)	TokenNameRPAREN
start	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
end	TokenNameIdentifier
>	TokenNameGREATER
start	TokenNameIdentifier
&&	TokenNameAND_AND
externalVal	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
' '	TokenNameCharacterLiteral
)	TokenNameRPAREN
end	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
start	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
Double	TokenNameIdentifier
.	TokenNameDOT
parseDouble	TokenNameIdentifier
(	TokenNameLPAREN
externalVal	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
start	TokenNameIdentifier
=	TokenNameEQUAL
idx	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
end	TokenNameIdentifier
=	TokenNameEQUAL
externalVal	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
','	TokenNameCharacterLiteral
,	TokenNameCOMMA
start	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
end	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
end	TokenNameIdentifier
=	TokenNameEQUAL
externalVal	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
dimension	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidGeoException	TokenNameIdentifier
(	TokenNameLPAREN
"incompatible dimension ("	TokenNameStringLiteral
+	TokenNamePLUS
dimension	TokenNameIdentifier
+	TokenNamePLUS
") and values ("	TokenNameStringLiteral
+	TokenNamePLUS
externalVal	TokenNameIdentifier
+	TokenNamePLUS
").  Only "	TokenNameStringLiteral
+	TokenNamePLUS
i	TokenNameIdentifier
+	TokenNamePLUS
" values specified"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
out	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
parseLatitudeLongitude	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
latLonStr	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidGeoException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
parseLatitudeLongitude	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
latLonStr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
parseLatitudeLongitude	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
latLon	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
latLonStr	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
InvalidGeoException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
latLon	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
latLon	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
double	TokenNamedouble
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
double	TokenNamedouble
[	TokenNameLBRACKET
]	TokenNameRBRACKET
toks	TokenNameIdentifier
=	TokenNameEQUAL
parsePointDouble	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
latLonStr	TokenNameIdentifier
,	TokenNameCOMMA
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
toks	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
<	TokenNameLESS
-	TokenNameMINUS
90.0	TokenNameDoubleLiteral
||	TokenNameOR_OR
toks	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
>	TokenNameGREATER
90.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidGeoException	TokenNameIdentifier
(	TokenNameLPAREN
"Invalid latitude: latitudes are range -90 to 90: provided lat: ["	TokenNameStringLiteral
+	TokenNamePLUS
toks	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
"]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
latLon	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
toks	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
toks	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
<	TokenNameLESS
-	TokenNameMINUS
180.0	TokenNameDoubleLiteral
||	TokenNameOR_OR
toks	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
>	TokenNameGREATER
180.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
InvalidGeoException	TokenNameIdentifier
(	TokenNameLPAREN
"Invalid longitude: longitudes are range -180 to 180: provided lon: ["	TokenNameStringLiteral
+	TokenNamePLUS
toks	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
"]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
latLon	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
toks	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
return	TokenNamereturn
latLon	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
