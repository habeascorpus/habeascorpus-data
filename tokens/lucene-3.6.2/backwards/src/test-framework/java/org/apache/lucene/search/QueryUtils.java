package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
ByteArrayInputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
ByteArrayOutputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
ObjectInputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
ObjectOutputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Random	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
junit	TokenNameIdentifier
.	TokenNameDOT
framework	TokenNameIdentifier
.	TokenNameDOT
Assert	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
MockAnalyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
.	TokenNameDOT
Document	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
IndexReader	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
IndexWriter	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
IndexWriterConfig	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
MultiReader	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
Directory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
MockDirectoryWrapper	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
RAMDirectory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
_TestUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
static	TokenNamestatic
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
LuceneTestCase	TokenNameIdentifier
.	TokenNameDOT
TEST_VERSION_CURRENT	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
QueryUtils	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
check	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
q	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
checkHashEquals	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
checkHashEquals	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
q	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Query	TokenNameIdentifier
q2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Query	TokenNameIdentifier
)	TokenNameRPAREN
q	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkEqual	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
q2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Query	TokenNameIdentifier
q3	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Query	TokenNameIdentifier
)	TokenNameRPAREN
q	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q3	TokenNameIdentifier
.	TokenNameDOT
setBoost	TokenNameIdentifier
(	TokenNameLPAREN
7.21792348f	TokenNameFloatingPointLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkUnequal	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
q3	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Query	TokenNameIdentifier
whacky	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Query	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"My Whacky Query"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
whacky	TokenNameIdentifier
.	TokenNameDOT
setBoost	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
.	TokenNameDOT
getBoost	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkUnequal	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
whacky	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertFalse	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
checkEqual	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
q1	TokenNameIdentifier
,	TokenNameCOMMA
Query	TokenNameIdentifier
q2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Assert	TokenNameIdentifier
.	TokenNameDOT
assertEquals	TokenNameIdentifier
(	TokenNameLPAREN
q1	TokenNameIdentifier
,	TokenNameCOMMA
q2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertEquals	TokenNameIdentifier
(	TokenNameLPAREN
q1	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
q2	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
checkUnequal	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
q1	TokenNameIdentifier
,	TokenNameCOMMA
Query	TokenNameIdentifier
q2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Assert	TokenNameIdentifier
.	TokenNameDOT
assertTrue	TokenNameIdentifier
(	TokenNameLPAREN
!	TokenNameNOT
q1	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
q2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertTrue	TokenNameIdentifier
(	TokenNameLPAREN
!	TokenNameNOT
q2	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
q1	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertTrue	TokenNameIdentifier
(	TokenNameLPAREN
q1	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
q2	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
checkExplanations	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
Query	TokenNameIdentifier
q	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
Searcher	TokenNameIdentifier
s	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
CheckHits	TokenNameIdentifier
.	TokenNameDOT
checkExplanations	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
s	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
check	TokenNameIdentifier
(	TokenNameLPAREN
Random	TokenNameIdentifier
random	TokenNameIdentifier
,	TokenNameCOMMA
Query	TokenNameIdentifier
q1	TokenNameIdentifier
,	TokenNameCOMMA
Searcher	TokenNameIdentifier
s	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
check	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
q1	TokenNameIdentifier
,	TokenNameCOMMA
s	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
check	TokenNameIdentifier
(	TokenNameLPAREN
Random	TokenNameIdentifier
random	TokenNameIdentifier
,	TokenNameCOMMA
Query	TokenNameIdentifier
q1	TokenNameIdentifier
,	TokenNameCOMMA
Searcher	TokenNameIdentifier
s	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
wrap	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
check	TokenNameIdentifier
(	TokenNameLPAREN
q1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
s	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
s	TokenNameIdentifier
instanceof	TokenNameinstanceof
IndexSearcher	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
IndexSearcher	TokenNameIdentifier
is	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
IndexSearcher	TokenNameIdentifier
)	TokenNameRPAREN
s	TokenNameIdentifier
;	TokenNameSEMICOLON
checkFirstSkipTo	TokenNameIdentifier
(	TokenNameLPAREN
q1	TokenNameIdentifier
,	TokenNameCOMMA
is	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkSkipTo	TokenNameIdentifier
(	TokenNameLPAREN
q1	TokenNameIdentifier
,	TokenNameCOMMA
is	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
wrap	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
check	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
q1	TokenNameIdentifier
,	TokenNameCOMMA
wrapUnderlyingReader	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
is	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
check	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
q1	TokenNameIdentifier
,	TokenNameCOMMA
wrapUnderlyingReader	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
is	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
check	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
q1	TokenNameIdentifier
,	TokenNameCOMMA
wrapUnderlyingReader	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
is	TokenNameIdentifier
,	TokenNameCOMMA
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
wrap	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
check	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
q1	TokenNameIdentifier
,	TokenNameCOMMA
wrapSearcher	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
s	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
check	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
q1	TokenNameIdentifier
,	TokenNameCOMMA
wrapSearcher	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
s	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
check	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
q1	TokenNameIdentifier
,	TokenNameCOMMA
wrapSearcher	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
s	TokenNameIdentifier
,	TokenNameCOMMA
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
checkExplanations	TokenNameIdentifier
(	TokenNameLPAREN
q1	TokenNameIdentifier
,	TokenNameCOMMA
s	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkSerialization	TokenNameIdentifier
(	TokenNameLPAREN
q1	TokenNameIdentifier
,	TokenNameCOMMA
s	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Query	TokenNameIdentifier
q2	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Query	TokenNameIdentifier
)	TokenNameRPAREN
q1	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkEqual	TokenNameIdentifier
(	TokenNameLPAREN
s	TokenNameIdentifier
.	TokenNameDOT
rewrite	TokenNameIdentifier
(	TokenNameLPAREN
q1	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
s	TokenNameIdentifier
.	TokenNameDOT
rewrite	TokenNameIdentifier
(	TokenNameLPAREN
q2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
IndexSearcher	TokenNameIdentifier
wrapUnderlyingReader	TokenNameIdentifier
(	TokenNameLPAREN
Random	TokenNameIdentifier
random	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
IndexSearcher	TokenNameIdentifier
s	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
edge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
IndexReader	TokenNameIdentifier
r	TokenNameIdentifier
=	TokenNameEQUAL
s	TokenNameIdentifier
.	TokenNameDOT
getIndexReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
IndexReader	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
readers	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IndexReader	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
edge	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
r	TokenNameIdentifier
:	TokenNameCOLON
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
MultiReader	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
IndexReader	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
edge	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
4	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
edge	TokenNameIdentifier
?	TokenNameQUESTION
r	TokenNameIdentifier
:	TokenNameCOLON
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
,	TokenNameCOMMA
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
<	TokenNameLESS
edge	TokenNameIdentifier
?	TokenNameQUESTION
0	TokenNameIntegerLiteral
:	TokenNameCOLON
7	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
MultiReader	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
IndexReader	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
<	TokenNameLESS
edge	TokenNameIdentifier
?	TokenNameQUESTION
0	TokenNameIntegerLiteral
:	TokenNameCOLON
5	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
<	TokenNameLESS
edge	TokenNameIdentifier
?	TokenNameQUESTION
r	TokenNameIdentifier
:	TokenNameCOLON
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
}	TokenNameRBRACE
;	TokenNameSEMICOLON
IndexSearcher	TokenNameIdentifier
out	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
MultiReader	TokenNameIdentifier
(	TokenNameLPAREN
readers	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
.	TokenNameDOT
setSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
s	TokenNameIdentifier
.	TokenNameDOT
getSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
out	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
MultiSearcher	TokenNameIdentifier
wrapSearcher	TokenNameIdentifier
(	TokenNameLPAREN
Random	TokenNameIdentifier
random	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
Searcher	TokenNameIdentifier
s	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
edge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
Searcher	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
searchers	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Searcher	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
edge	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
s	TokenNameIdentifier
:	TokenNameCOLON
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
MultiSearcher	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Searcher	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
edge	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
65	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
edge	TokenNameIdentifier
?	TokenNameQUESTION
s	TokenNameIdentifier
:	TokenNameCOLON
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
<	TokenNameLESS
edge	TokenNameIdentifier
?	TokenNameQUESTION
0	TokenNameIntegerLiteral
:	TokenNameCOLON
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
MultiSearcher	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Searcher	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
<	TokenNameLESS
edge	TokenNameIdentifier
?	TokenNameQUESTION
0	TokenNameIntegerLiteral
:	TokenNameCOLON
5	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
<	TokenNameLESS
edge	TokenNameIdentifier
?	TokenNameQUESTION
s	TokenNameIdentifier
:	TokenNameCOLON
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
}	TokenNameRBRACE
)	TokenNameRPAREN
}	TokenNameRBRACE
;	TokenNameSEMICOLON
MultiSearcher	TokenNameIdentifier
out	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MultiSearcher	TokenNameIdentifier
(	TokenNameLPAREN
searchers	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
.	TokenNameDOT
setSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
s	TokenNameIdentifier
.	TokenNameDOT
getSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
out	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
Directory	TokenNameIdentifier
makeEmptyIndex	TokenNameIdentifier
(	TokenNameLPAREN
Random	TokenNameIdentifier
random	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
numDeletedDocs	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
Directory	TokenNameIdentifier
d	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MockDirectoryWrapper	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
RAMDirectory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
IndexWriter	TokenNameIdentifier
w	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IndexWriter	TokenNameIdentifier
(	TokenNameLPAREN
d	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
IndexWriterConfig	TokenNameIdentifier
(	TokenNameLPAREN
TEST_VERSION_CURRENT	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
MockAnalyzer	TokenNameIdentifier
(	TokenNameLPAREN
random	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numDeletedDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
w	TokenNameIdentifier
.	TokenNameDOT
addDocument	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Document	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
w	TokenNameIdentifier
.	TokenNameDOT
commit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
w	TokenNameIdentifier
.	TokenNameDOT
deleteDocuments	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
MatchAllDocsQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
_TestUtil	TokenNameIdentifier
.	TokenNameDOT
keepFullyDeletedSegments	TokenNameIdentifier
(	TokenNameLPAREN
w	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
w	TokenNameIdentifier
.	TokenNameDOT
commit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
<	TokenNameLESS
numDeletedDocs	TokenNameIdentifier
)	TokenNameRPAREN
Assert	TokenNameIdentifier
.	TokenNameDOT
assertTrue	TokenNameIdentifier
(	TokenNameLPAREN
"writer has no deletions"	TokenNameStringLiteral
,	TokenNameCOMMA
w	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertEquals	TokenNameIdentifier
(	TokenNameLPAREN
"writer is missing some deleted docs"	TokenNameStringLiteral
,	TokenNameCOMMA
numDeletedDocs	TokenNameIdentifier
,	TokenNameCOMMA
w	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertEquals	TokenNameIdentifier
(	TokenNameLPAREN
"writer has non-deleted docs"	TokenNameStringLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
w	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
w	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
IndexReader	TokenNameIdentifier
r	TokenNameIdentifier
=	TokenNameEQUAL
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
d	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertEquals	TokenNameIdentifier
(	TokenNameLPAREN
"reader has wrong number of deleted docs"	TokenNameStringLiteral
,	TokenNameCOMMA
numDeletedDocs	TokenNameIdentifier
,	TokenNameCOMMA
r	TokenNameIdentifier
.	TokenNameDOT
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
r	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
d	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkSerialization	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
q	TokenNameIdentifier
,	TokenNameCOMMA
Searcher	TokenNameIdentifier
s	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
Weight	TokenNameIdentifier
w	TokenNameIdentifier
=	TokenNameEQUAL
s	TokenNameIdentifier
.	TokenNameDOT
createNormalizedWeight	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
ByteArrayOutputStream	TokenNameIdentifier
bos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ByteArrayOutputStream	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ObjectOutputStream	TokenNameIdentifier
oos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ObjectOutputStream	TokenNameIdentifier
(	TokenNameLPAREN
bos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
oos	TokenNameIdentifier
.	TokenNameDOT
writeObject	TokenNameIdentifier
(	TokenNameLPAREN
w	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
oos	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ObjectInputStream	TokenNameIdentifier
ois	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ObjectInputStream	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
ByteArrayInputStream	TokenNameIdentifier
(	TokenNameLPAREN
bos	TokenNameIdentifier
.	TokenNameDOT
toByteArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ois	TokenNameIdentifier
.	TokenNameDOT
readObject	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ois	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
IOException	TokenNameIdentifier
e2	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"Serialization failed for "	TokenNameStringLiteral
+	TokenNamePLUS
w	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
e2	TokenNameIdentifier
.	TokenNameDOT
initCause	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
e2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
checkSkipTo	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
Query	TokenNameIdentifier
q	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
IndexSearcher	TokenNameIdentifier
s	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
s	TokenNameIdentifier
.	TokenNameDOT
createNormalizedWeight	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
scoresDocsOutOfOrder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
skip_op	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
next_op	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
orders	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
{	TokenNameLBRACE
{	TokenNameLBRACE
next_op	TokenNameIdentifier
}	TokenNameRBRACE
,	TokenNameCOMMA
{	TokenNameLBRACE
skip_op	TokenNameIdentifier
}	TokenNameRBRACE
,	TokenNameCOMMA
{	TokenNameLBRACE
skip_op	TokenNameIdentifier
,	TokenNameCOMMA
next_op	TokenNameIdentifier
}	TokenNameRBRACE
,	TokenNameCOMMA
{	TokenNameLBRACE
next_op	TokenNameIdentifier
,	TokenNameCOMMA
skip_op	TokenNameIdentifier
}	TokenNameRBRACE
,	TokenNameCOMMA
{	TokenNameLBRACE
skip_op	TokenNameIdentifier
,	TokenNameCOMMA
skip_op	TokenNameIdentifier
,	TokenNameCOMMA
next_op	TokenNameIdentifier
,	TokenNameCOMMA
next_op	TokenNameIdentifier
}	TokenNameRBRACE
,	TokenNameCOMMA
{	TokenNameLBRACE
next_op	TokenNameIdentifier
,	TokenNameCOMMA
next_op	TokenNameIdentifier
,	TokenNameCOMMA
skip_op	TokenNameIdentifier
,	TokenNameCOMMA
skip_op	TokenNameIdentifier
}	TokenNameRBRACE
,	TokenNameCOMMA
{	TokenNameLBRACE
skip_op	TokenNameIdentifier
,	TokenNameCOMMA
skip_op	TokenNameIdentifier
,	TokenNameCOMMA
skip_op	TokenNameIdentifier
,	TokenNameCOMMA
next_op	TokenNameIdentifier
,	TokenNameCOMMA
next_op	TokenNameIdentifier
}	TokenNameRBRACE
,	TokenNameCOMMA
}	TokenNameRBRACE
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
k	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
k	TokenNameIdentifier
<	TokenNameLESS
orders	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
k	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
order	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
orders	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
opidx	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
{	TokenNameLBRACE
0	TokenNameIntegerLiteral
}	TokenNameRBRACE
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
{	TokenNameLBRACE
-	TokenNameMINUS
1	TokenNameIntegerLiteral
}	TokenNameRBRACE
;	TokenNameSEMICOLON
final	TokenNamefinal
float	TokenNamefloat
maxDiff	TokenNameIdentifier
=	TokenNameEQUAL
1e-5f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
IndexReader	TokenNameIdentifier
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
{	TokenNameLBRACE
null	TokenNamenull
}	TokenNameRBRACE
;	TokenNameSEMICOLON
s	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
Collector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
private	TokenNameprivate
Scorer	TokenNameIdentifier
sc	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setScorer	TokenNameIdentifier
(	TokenNameLPAREN
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
sc	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
collect	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
doc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
float	TokenNamefloat
score	TokenNameIdentifier
=	TokenNameEQUAL
sc	TokenNameIdentifier
.	TokenNameDOT
score	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
scorer	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
Weight	TokenNameIdentifier
w	TokenNameIdentifier
=	TokenNameEQUAL
s	TokenNameIdentifier
.	TokenNameDOT
createNormalizedWeight	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
scorer	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
.	TokenNameDOT
scorer	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
op	TokenNameIdentifier
=	TokenNameEQUAL
order	TokenNameIdentifier
[	TokenNameLBRACKET
(	TokenNameLPAREN
opidx	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
%	TokenNameREMAINDER
order	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
boolean	TokenNameboolean
more	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
skip_op	TokenNameIdentifier
?	TokenNameQUESTION
scorer	TokenNameIdentifier
.	TokenNameDOT
advance	TokenNameIdentifier
(	TokenNameLPAREN
scorer	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
:	TokenNameCOLON
scorer	TokenNameIdentifier
.	TokenNameDOT
nextDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
scorerDoc	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
scorerScore	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
.	TokenNameDOT
score	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
scorerScore2	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
.	TokenNameDOT
score	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
scoreDiff	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
abs	TokenNameIdentifier
(	TokenNameLPAREN
score	TokenNameIdentifier
-	TokenNameMINUS
scorerScore	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
scorerDiff	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
abs	TokenNameIdentifier
(	TokenNameLPAREN
scorerScore2	TokenNameIdentifier
-	TokenNameMINUS
scorerScore	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
more	TokenNameIdentifier
||	TokenNameOR_OR
doc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
scorerDoc	TokenNameIdentifier
||	TokenNameOR_OR
scoreDiff	TokenNameIdentifier
>	TokenNameGREATER
maxDiff	TokenNameIdentifier
||	TokenNameOR_OR
scorerDiff	TokenNameIdentifier
>	TokenNameGREATER
maxDiff	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuilder	TokenNameIdentifier
sbord	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
order	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
sbord	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
order	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
skip_op	TokenNameIdentifier
?	TokenNameQUESTION
" skip()"	TokenNameStringLiteral
:	TokenNameCOLON
" next()"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR matching docs:"	TokenNameStringLiteral
+	TokenNamePLUS
"  "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
doc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
scorerDoc	TokenNameIdentifier
?	TokenNameQUESTION
"--> "	TokenNameStringLiteral
:	TokenNameCOLON
""	TokenNameStringLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
"doc="	TokenNameStringLiteral
+	TokenNamePLUS
doc	TokenNameIdentifier
+	TokenNamePLUS
", scorerDoc="	TokenNameStringLiteral
+	TokenNamePLUS
scorerDoc	TokenNameIdentifier
+	TokenNamePLUS
"  "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
!	TokenNameNOT
more	TokenNameIdentifier
?	TokenNameQUESTION
"--> "	TokenNameStringLiteral
:	TokenNameCOLON
""	TokenNameStringLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
"tscorer.more="	TokenNameStringLiteral
+	TokenNamePLUS
more	TokenNameIdentifier
+	TokenNamePLUS
"  "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
scoreDiff	TokenNameIdentifier
>	TokenNameGREATER
maxDiff	TokenNameIdentifier
?	TokenNameQUESTION
"--> "	TokenNameStringLiteral
:	TokenNameCOLON
""	TokenNameStringLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
"scorerScore="	TokenNameStringLiteral
+	TokenNamePLUS
scorerScore	TokenNameIdentifier
+	TokenNamePLUS
" scoreDiff="	TokenNameStringLiteral
+	TokenNamePLUS
scoreDiff	TokenNameIdentifier
+	TokenNamePLUS
" maxDiff="	TokenNameStringLiteral
+	TokenNamePLUS
maxDiff	TokenNameIdentifier
+	TokenNamePLUS
"  "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
scorerDiff	TokenNameIdentifier
>	TokenNameGREATER
maxDiff	TokenNameIdentifier
?	TokenNameQUESTION
"--> "	TokenNameStringLiteral
:	TokenNameCOLON
""	TokenNameStringLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
"scorerScore2="	TokenNameStringLiteral
+	TokenNamePLUS
scorerScore2	TokenNameIdentifier
+	TokenNamePLUS
" scorerDiff="	TokenNameStringLiteral
+	TokenNamePLUS
scorerDiff	TokenNameIdentifier
+	TokenNamePLUS
"  hitCollector.doc="	TokenNameStringLiteral
+	TokenNamePLUS
doc	TokenNameIdentifier
+	TokenNamePLUS
" score="	TokenNameStringLiteral
+	TokenNamePLUS
score	TokenNameIdentifier
+	TokenNamePLUS
"   Scorer="	TokenNameStringLiteral
+	TokenNamePLUS
scorer	TokenNameIdentifier
+	TokenNamePLUS
"   Query="	TokenNameStringLiteral
+	TokenNamePLUS
q	TokenNameIdentifier
+	TokenNamePLUS
"  "	TokenNameStringLiteral
+	TokenNamePLUS
q	TokenNameIdentifier
.	TokenNameDOT
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"   Searcher="	TokenNameStringLiteral
+	TokenNamePLUS
s	TokenNameIdentifier
+	TokenNamePLUS
"   Order="	TokenNameStringLiteral
+	TokenNamePLUS
sbord	TokenNameIdentifier
+	TokenNamePLUS
"   Op="	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
op	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
skip_op	TokenNameIdentifier
?	TokenNameQUESTION
" skip()"	TokenNameStringLiteral
:	TokenNameCOLON
" next()"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setNextReader	TokenNameIdentifier
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
docBase	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
IndexReader	TokenNameIdentifier
previousReader	TokenNameIdentifier
=	TokenNameEQUAL
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Weight	TokenNameIdentifier
w	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
createNormalizedWeight	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
.	TokenNameDOT
scorer	TokenNameIdentifier
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
scorer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
more	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
.	TokenNameDOT
advance	TokenNameIdentifier
(	TokenNameLPAREN
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertFalse	TokenNameIdentifier
(	TokenNameLPAREN
"query's last doc was "	TokenNameStringLiteral
+	TokenNamePLUS
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
" but skipTo("	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
") got to "	TokenNameStringLiteral
+	TokenNamePLUS
scorer	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
more	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
reader	TokenNameIdentifier
=	TokenNameEQUAL
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
reader	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
scorer	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
acceptsDocsOutOfOrder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
IndexReader	TokenNameIdentifier
previousReader	TokenNameIdentifier
=	TokenNameEQUAL
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Weight	TokenNameIdentifier
w	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
createNormalizedWeight	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
.	TokenNameDOT
scorer	TokenNameIdentifier
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
scorer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
more	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
.	TokenNameDOT
advance	TokenNameIdentifier
(	TokenNameLPAREN
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertFalse	TokenNameIdentifier
(	TokenNameLPAREN
"query's last doc was "	TokenNameStringLiteral
+	TokenNamePLUS
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
" but skipTo("	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
") got to "	TokenNameStringLiteral
+	TokenNamePLUS
scorer	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
more	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
checkFirstSkipTo	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
Query	TokenNameIdentifier
q	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
IndexSearcher	TokenNameIdentifier
s	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
float	TokenNamefloat
maxDiff	TokenNameIdentifier
=	TokenNameEQUAL
1e-3f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
{	TokenNameLBRACE
-	TokenNameMINUS
1	TokenNameIntegerLiteral
}	TokenNameRBRACE
;	TokenNameSEMICOLON
final	TokenNamefinal
IndexReader	TokenNameIdentifier
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
=	TokenNameEQUAL
{	TokenNameLBRACE
null	TokenNamenull
}	TokenNameRBRACE
;	TokenNameSEMICOLON
s	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
Collector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
private	TokenNameprivate
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setScorer	TokenNameIdentifier
(	TokenNameLPAREN
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
scorer	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
collect	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
doc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
float	TokenNamefloat
score	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
.	TokenNameDOT
score	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
Weight	TokenNameIdentifier
w	TokenNameIdentifier
=	TokenNameEQUAL
s	TokenNameIdentifier
.	TokenNameDOT
createNormalizedWeight	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
.	TokenNameDOT
scorer	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertTrue	TokenNameIdentifier
(	TokenNameLPAREN
"query collected "	TokenNameStringLiteral
+	TokenNamePLUS
doc	TokenNameIdentifier
+	TokenNamePLUS
" but skipTo("	TokenNameStringLiteral
+	TokenNamePLUS
i	TokenNameIdentifier
+	TokenNamePLUS
") says no more docs!"	TokenNameStringLiteral
,	TokenNameCOMMA
scorer	TokenNameIdentifier
.	TokenNameDOT
advance	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertEquals	TokenNameIdentifier
(	TokenNameLPAREN
"query collected "	TokenNameStringLiteral
+	TokenNamePLUS
doc	TokenNameIdentifier
+	TokenNamePLUS
" but skipTo("	TokenNameStringLiteral
+	TokenNamePLUS
i	TokenNameIdentifier
+	TokenNamePLUS
") got to "	TokenNameStringLiteral
+	TokenNamePLUS
scorer	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
doc	TokenNameIdentifier
,	TokenNameCOMMA
scorer	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
float	TokenNamefloat
skipToScore	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
.	TokenNameDOT
score	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertEquals	TokenNameIdentifier
(	TokenNameLPAREN
"unstable skipTo("	TokenNameStringLiteral
+	TokenNamePLUS
i	TokenNameIdentifier
+	TokenNamePLUS
") score!"	TokenNameStringLiteral
,	TokenNameCOMMA
skipToScore	TokenNameIdentifier
,	TokenNameCOMMA
scorer	TokenNameIdentifier
.	TokenNameDOT
score	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
maxDiff	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertEquals	TokenNameIdentifier
(	TokenNameLPAREN
"query assigned doc "	TokenNameStringLiteral
+	TokenNamePLUS
doc	TokenNameIdentifier
+	TokenNamePLUS
" a score of <"	TokenNameStringLiteral
+	TokenNamePLUS
score	TokenNameIdentifier
+	TokenNamePLUS
"> but skipTo("	TokenNameStringLiteral
+	TokenNamePLUS
i	TokenNameIdentifier
+	TokenNamePLUS
") has <"	TokenNameStringLiteral
+	TokenNamePLUS
skipToScore	TokenNameIdentifier
+	TokenNamePLUS
">!"	TokenNameStringLiteral
,	TokenNameCOMMA
score	TokenNameIdentifier
,	TokenNameCOMMA
skipToScore	TokenNameIdentifier
,	TokenNameCOMMA
maxDiff	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setNextReader	TokenNameIdentifier
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
docBase	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
IndexReader	TokenNameIdentifier
previousReader	TokenNameIdentifier
=	TokenNameEQUAL
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Weight	TokenNameIdentifier
w	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
createNormalizedWeight	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
.	TokenNameDOT
scorer	TokenNameIdentifier
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
scorer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
more	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
.	TokenNameDOT
advance	TokenNameIdentifier
(	TokenNameLPAREN
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertFalse	TokenNameIdentifier
(	TokenNameLPAREN
"query's last doc was "	TokenNameStringLiteral
+	TokenNamePLUS
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
" but skipTo("	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
") got to "	TokenNameStringLiteral
+	TokenNamePLUS
scorer	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
more	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
reader	TokenNameIdentifier
=	TokenNameEQUAL
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
reader	TokenNameIdentifier
;	TokenNameSEMICOLON
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
acceptsDocsOutOfOrder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
IndexReader	TokenNameIdentifier
previousReader	TokenNameIdentifier
=	TokenNameEQUAL
lastReader	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Weight	TokenNameIdentifier
w	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
createNormalizedWeight	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
.	TokenNameDOT
scorer	TokenNameIdentifier
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
scorer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
more	TokenNameIdentifier
=	TokenNameEQUAL
scorer	TokenNameIdentifier
.	TokenNameDOT
advance	TokenNameIdentifier
(	TokenNameLPAREN
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
Assert	TokenNameIdentifier
.	TokenNameDOT
assertFalse	TokenNameIdentifier
(	TokenNameLPAREN
"query's last doc was "	TokenNameStringLiteral
+	TokenNamePLUS
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
" but skipTo("	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
lastDoc	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
") got to "	TokenNameStringLiteral
+	TokenNamePLUS
scorer	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
more	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
