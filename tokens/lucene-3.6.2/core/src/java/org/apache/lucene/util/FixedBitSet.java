package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Arrays	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
DocIdSet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
DocIdSetIterator	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
class	TokenNameclass
FixedBitSet	TokenNameIdentifier
extends	TokenNameextends
DocIdSet	TokenNameIdentifier
implements	TokenNameimplements
Bits	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
int	TokenNameint
bits2words	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
numBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
numLong	TokenNameIdentifier
=	TokenNameEQUAL
numBits	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
numBits	TokenNameIdentifier
&	TokenNameAND
63	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
numLong	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
numLong	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
FixedBitSet	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
numBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
numBits	TokenNameIdentifier
=	TokenNameEQUAL
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
long	TokenNamelong
[	TokenNameLBRACKET
bits2words	TokenNameIdentifier
(	TokenNameLPAREN
numBits	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
FixedBitSet	TokenNameIdentifier
(	TokenNameLPAREN
FixedBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
long	TokenNamelong
[	TokenNameLBRACKET
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
bits	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
numBits	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
DocIdSetIterator	TokenNameIdentifier
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
OpenBitSetIterator	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
isCacheable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getBits	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
cardinality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_array	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
get	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
:	TokenNameCOLON
"index="	TokenNameStringLiteral
+	TokenNamePLUS
index	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
set	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getAndSet	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
val	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
val	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x03f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getAndClear	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
val	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
val	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
nextSetBit	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
subIndex	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
>>	TokenNameRIGHT_SHIFT
subIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
i	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
subIndex	TokenNameIdentifier
+	TokenNamePLUS
BitUtil	TokenNameIdentifier
.	TokenNameDOT
ntz	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
<	TokenNameLESS
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
i	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
BitUtil	TokenNameIdentifier
.	TokenNameDOT
ntz	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
prevSetBit	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
:	TokenNameCOLON
"index="	TokenNameStringLiteral
+	TokenNamePLUS
index	TokenNameIdentifier
+	TokenNamePLUS
" numBits="	TokenNameStringLiteral
+	TokenNamePLUS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
subIndex	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
word	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
<<	TokenNameLEFT_SHIFT
(	TokenNameLPAREN
63	TokenNameIntegerLiteral
-	TokenNameMINUS
subIndex	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
i	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
subIndex	TokenNameIdentifier
-	TokenNameMINUS
Long	TokenNameIdentifier
.	TokenNameDOT
numberOfLeadingZeros	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
i	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
63	TokenNameIntegerLiteral
-	TokenNameMINUS
Long	TokenNameIdentifier
.	TokenNameDOT
numberOfLeadingZeros	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
or	TokenNameIdentifier
(	TokenNameLPAREN
DocIdSetIterator	TokenNameIdentifier
iter	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
iter	TokenNameIdentifier
instanceof	TokenNameinstanceof
OpenBitSetIterator	TokenNameIdentifier
&&	TokenNameAND_AND
iter	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
OpenBitSetIterator	TokenNameIdentifier
obs	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
OpenBitSetIterator	TokenNameIdentifier
)	TokenNameRPAREN
iter	TokenNameIdentifier
;	TokenNameSEMICOLON
or	TokenNameIdentifier
(	TokenNameLPAREN
obs	TokenNameIdentifier
.	TokenNameDOT
arr	TokenNameIdentifier
,	TokenNameCOMMA
obs	TokenNameIdentifier
.	TokenNameDOT
words	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
obs	TokenNameIdentifier
.	TokenNameDOT
advance	TokenNameIdentifier
(	TokenNameLPAREN
numBits	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
doc	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
nextDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
numBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
set	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
or	TokenNameIdentifier
(	TokenNameLPAREN
FixedBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
or	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
or	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
otherArr	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
otherLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
thisArr	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
thisArr	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
,	TokenNameCOMMA
otherLen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
pos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
thisArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
otherArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
and	TokenNameIdentifier
(	TokenNameLPAREN
DocIdSetIterator	TokenNameIdentifier
iter	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
iter	TokenNameIdentifier
instanceof	TokenNameinstanceof
OpenBitSetIterator	TokenNameIdentifier
&&	TokenNameAND_AND
iter	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
OpenBitSetIterator	TokenNameIdentifier
obs	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
OpenBitSetIterator	TokenNameIdentifier
)	TokenNameRPAREN
iter	TokenNameIdentifier
;	TokenNameSEMICOLON
and	TokenNameIdentifier
(	TokenNameLPAREN
obs	TokenNameIdentifier
.	TokenNameDOT
arr	TokenNameIdentifier
,	TokenNameCOMMA
obs	TokenNameIdentifier
.	TokenNameDOT
words	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
obs	TokenNameIdentifier
.	TokenNameDOT
advance	TokenNameIdentifier
(	TokenNameLPAREN
numBits	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
numBits	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
disiDoc	TokenNameIdentifier
,	TokenNameCOMMA
bitSetDoc	TokenNameIdentifier
=	TokenNameEQUAL
nextSetBit	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
bitSetDoc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
disiDoc	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
advance	TokenNameIdentifier
(	TokenNameLPAREN
bitSetDoc	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
numBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
clear	TokenNameIdentifier
(	TokenNameLPAREN
bitSetDoc	TokenNameIdentifier
,	TokenNameCOMMA
disiDoc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
disiDoc	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
bitSetDoc	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
disiDoc	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
nextSetBit	TokenNameIdentifier
(	TokenNameLPAREN
disiDoc	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
bitSetDoc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
clear	TokenNameIdentifier
(	TokenNameLPAREN
bitSetDoc	TokenNameIdentifier
,	TokenNameCOMMA
numBits	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
and	TokenNameIdentifier
(	TokenNameLPAREN
FixedBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
and	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
and	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
otherArr	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
otherLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
thisArr	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
thisArr	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
,	TokenNameCOMMA
otherLen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
pos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
thisArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
otherArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
thisArr	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
otherLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
thisArr	TokenNameIdentifier
,	TokenNameCOMMA
otherLen	TokenNameIdentifier
,	TokenNameCOMMA
thisArr	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
,	TokenNameCOMMA
0L	TokenNameLongLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
andNot	TokenNameIdentifier
(	TokenNameLPAREN
DocIdSetIterator	TokenNameIdentifier
iter	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
iter	TokenNameIdentifier
instanceof	TokenNameinstanceof
OpenBitSetIterator	TokenNameIdentifier
&&	TokenNameAND_AND
iter	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
OpenBitSetIterator	TokenNameIdentifier
obs	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
OpenBitSetIterator	TokenNameIdentifier
)	TokenNameRPAREN
iter	TokenNameIdentifier
;	TokenNameSEMICOLON
andNot	TokenNameIdentifier
(	TokenNameLPAREN
obs	TokenNameIdentifier
.	TokenNameDOT
arr	TokenNameIdentifier
,	TokenNameCOMMA
obs	TokenNameIdentifier
.	TokenNameDOT
words	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
obs	TokenNameIdentifier
.	TokenNameDOT
advance	TokenNameIdentifier
(	TokenNameLPAREN
numBits	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
doc	TokenNameIdentifier
=	TokenNameEQUAL
iter	TokenNameIdentifier
.	TokenNameDOT
nextDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
<	TokenNameLESS
numBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
clear	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
andNot	TokenNameIdentifier
(	TokenNameLPAREN
FixedBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
andNot	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
andNot	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
otherArr	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
otherLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
thisArr	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
thisArr	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
,	TokenNameCOMMA
otherLen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
pos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
thisArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
otherArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
flip	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
startIndex	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
endIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
startIndex	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
startIndex	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
endIndex	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
endIndex	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
startIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
startWord	TokenNameIdentifier
=	TokenNameEQUAL
startIndex	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
endWord	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
startmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
startIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
endmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
-	TokenNameMINUS
endIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startWord	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
endWord	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
(	TokenNameLPAREN
startmask	TokenNameIdentifier
&	TokenNameAND
endmask	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
startmask	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
startWord	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
endWord	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
~	TokenNameTWIDDLE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
endWord	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
endmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
set	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
startIndex	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
endIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
startIndex	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
startIndex	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
endIndex	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
endIndex	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
startIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
startWord	TokenNameIdentifier
=	TokenNameEQUAL
startIndex	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
endWord	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
startmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
startIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
endmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
-	TokenNameMINUS
endIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startWord	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
endWord	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
(	TokenNameLPAREN
startmask	TokenNameIdentifier
&	TokenNameAND
endmask	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
startmask	TokenNameIdentifier
;	TokenNameSEMICOLON
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
startWord	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
endWord	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1L	TokenNameLongLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
endWord	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
endmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
startIndex	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
endIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
startIndex	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
startIndex	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
endIndex	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
endIndex	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
startIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
startWord	TokenNameIdentifier
=	TokenNameEQUAL
startIndex	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
endWord	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
startmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
startIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
endmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
-	TokenNameMINUS
endIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
startmask	TokenNameIdentifier
=	TokenNameEQUAL
~	TokenNameTWIDDLE
startmask	TokenNameIdentifier
;	TokenNameSEMICOLON
endmask	TokenNameIdentifier
=	TokenNameEQUAL
~	TokenNameTWIDDLE
endmask	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startWord	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
endWord	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
(	TokenNameLPAREN
startmask	TokenNameIdentifier
|	TokenNameOR
endmask	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
startmask	TokenNameIdentifier
;	TokenNameSEMICOLON
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
startWord	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
endWord	TokenNameIdentifier
,	TokenNameCOMMA
0L	TokenNameLongLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
endWord	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
endmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
Object	TokenNameIdentifier
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
FixedBitSet	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
o	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
==	TokenNameEQUAL_EQUAL
o	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
o	TokenNameIdentifier
instanceof	TokenNameinstanceof
FixedBitSet	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
FixedBitSet	TokenNameIdentifier
other	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
FixedBitSet	TokenNameIdentifier
)	TokenNameRPAREN
o	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numBits	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
other	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
Arrays	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
h	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
h	TokenNameIdentifier
^=	TokenNameXOR_EQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
h	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
h	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
h	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
63	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
h	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
32	TokenNameIntegerLiteral
)	TokenNameRPAREN
^	TokenNameXOR
h	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
0x98761234	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
