package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Arrays	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashMap	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Map	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
concurrent	TokenNameIdentifier
.	TokenNameDOT
atomic	TokenNameIdentifier
.	TokenNameDOT
AtomicInteger	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
.	TokenNameDOT
Document	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
.	TokenNameDOT
FieldSelector	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
FieldCache	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
Similarity	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
BufferedIndexInput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
Directory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
IndexInput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
BitVector	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
CloseableThreadLocal	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
StringHelper	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
SegmentReader	TokenNameIdentifier
extends	TokenNameextends
IndexReader	TokenNameIdentifier
implements	TokenNameimplements
Cloneable	TokenNameIdentifier
{	TokenNameLBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
protected	TokenNameprotected
boolean	TokenNameboolean
readOnly	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
SegmentInfo	TokenNameIdentifier
si	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
readBufferSize	TokenNameIdentifier
;	TokenNameSEMICOLON
CloseableThreadLocal	TokenNameIdentifier
<	TokenNameLESS
FieldsReader	TokenNameIdentifier
>	TokenNameGREATER
fieldsReaderLocal	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FieldsReaderLocal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
CloseableThreadLocal	TokenNameIdentifier
<	TokenNameLESS
TermVectorsReader	TokenNameIdentifier
>	TokenNameGREATER
termVectorsLocal	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CloseableThreadLocal	TokenNameIdentifier
<	TokenNameLESS
TermVectorsReader	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
BitVector	TokenNameIdentifier
deletedDocs	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
AtomicInteger	TokenNameIdentifier
deletedDocsRef	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
deletedDocsDirty	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
normsDirty	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
pendingDeleteCount	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
rollbackHasChanges	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
rollbackDeletedDocsDirty	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
rollbackNormsDirty	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
SegmentInfo	TokenNameIdentifier
rollbackSegmentInfo	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
rollbackPendingDeleteCount	TokenNameIdentifier
;	TokenNameSEMICOLON
IndexInput	TokenNameIdentifier
singleNormStream	TokenNameIdentifier
;	TokenNameSEMICOLON
AtomicInteger	TokenNameIdentifier
singleNormRef	TokenNameIdentifier
;	TokenNameSEMICOLON
SegmentCoreReaders	TokenNameIdentifier
core	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
class	TokenNameclass
FieldsReaderLocal	TokenNameIdentifier
extends	TokenNameextends
CloseableThreadLocal	TokenNameIdentifier
<	TokenNameLESS
FieldsReader	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
FieldsReader	TokenNameIdentifier
initialValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
FieldsReader	TokenNameIdentifier
)	TokenNameRPAREN
core	TokenNameIdentifier
.	TokenNameDOT
getFieldsReaderOrig	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
SegmentNorms	TokenNameIdentifier
>	TokenNameGREATER
norms	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
SegmentNorms	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
SegmentReader	TokenNameIdentifier
get	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
readOnly	TokenNameIdentifier
,	TokenNameCOMMA
SegmentInfo	TokenNameIdentifier
si	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
termInfosIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
get	TokenNameIdentifier
(	TokenNameLPAREN
readOnly	TokenNameIdentifier
,	TokenNameCOMMA
si	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
,	TokenNameCOMMA
si	TokenNameIdentifier
,	TokenNameCOMMA
BufferedIndexInput	TokenNameIdentifier
.	TokenNameDOT
BUFFER_SIZE	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
termInfosIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
SegmentReader	TokenNameIdentifier
get	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
readOnly	TokenNameIdentifier
,	TokenNameCOMMA
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
,	TokenNameCOMMA
SegmentInfo	TokenNameIdentifier
si	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
readBufferSize	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
doOpenStores	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
termInfosIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
SegmentReader	TokenNameIdentifier
instance	TokenNameIdentifier
=	TokenNameEQUAL
readOnly	TokenNameIdentifier
?	TokenNameQUESTION
new	TokenNamenew
ReadOnlySegmentReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
SegmentReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
instance	TokenNameIdentifier
.	TokenNameDOT
readOnly	TokenNameIdentifier
=	TokenNameEQUAL
readOnly	TokenNameIdentifier
;	TokenNameSEMICOLON
instance	TokenNameIdentifier
.	TokenNameDOT
si	TokenNameIdentifier
=	TokenNameEQUAL
si	TokenNameIdentifier
;	TokenNameSEMICOLON
instance	TokenNameIdentifier
.	TokenNameDOT
readBufferSize	TokenNameIdentifier
=	TokenNameEQUAL
readBufferSize	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
instance	TokenNameIdentifier
.	TokenNameDOT
core	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentCoreReaders	TokenNameIdentifier
(	TokenNameLPAREN
instance	TokenNameIdentifier
,	TokenNameCOMMA
dir	TokenNameIdentifier
,	TokenNameCOMMA
si	TokenNameIdentifier
,	TokenNameCOMMA
readBufferSize	TokenNameIdentifier
,	TokenNameCOMMA
termInfosIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doOpenStores	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
instance	TokenNameIdentifier
.	TokenNameDOT
core	TokenNameIdentifier
.	TokenNameDOT
openDocStores	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
instance	TokenNameIdentifier
.	TokenNameDOT
loadDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
instance	TokenNameIdentifier
.	TokenNameDOT
openNorms	TokenNameIdentifier
(	TokenNameLPAREN
instance	TokenNameIdentifier
.	TokenNameDOT
core	TokenNameIdentifier
.	TokenNameDOT
cfsDir	TokenNameIdentifier
,	TokenNameCOMMA
readBufferSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
instance	TokenNameIdentifier
.	TokenNameDOT
doClose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
instance	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
openDocStores	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
core	TokenNameIdentifier
.	TokenNameDOT
openDocStores	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
checkDeletedCounts	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
recomputedCount	TokenNameIdentifier
=	TokenNameEQUAL
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
getRecomputedCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
recomputedCount	TokenNameIdentifier
:	TokenNameCOLON
"deleted count="	TokenNameStringLiteral
+	TokenNamePLUS
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs recomputed count="	TokenNameStringLiteral
+	TokenNamePLUS
recomputedCount	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
si	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
recomputedCount	TokenNameIdentifier
:	TokenNameCOLON
"delete count mismatch: info="	TokenNameStringLiteral
+	TokenNamePLUS
si	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs BitVector="	TokenNameStringLiteral
+	TokenNamePLUS
recomputedCount	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
si	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
<=	TokenNameLESS_EQUAL
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
"delete count mismatch: "	TokenNameStringLiteral
+	TokenNamePLUS
recomputedCount	TokenNameIdentifier
+	TokenNamePLUS
") exceeds max doc ("	TokenNameStringLiteral
+	TokenNamePLUS
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
") for segment "	TokenNameStringLiteral
+	TokenNamePLUS
si	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
loadDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
deletedDocs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BitVector	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
si	TokenNameIdentifier
.	TokenNameDOT
getDelFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deletedDocsRef	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicInteger	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
checkDeletedCounts	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
si	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
CorruptIndexException	TokenNameIdentifier
(	TokenNameLPAREN
"document count mismatch: deleted docs count "	TokenNameStringLiteral
+	TokenNamePLUS
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs segment doc count "	TokenNameStringLiteral
+	TokenNamePLUS
si	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
+	TokenNamePLUS
" segment="	TokenNameStringLiteral
+	TokenNamePLUS
si	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
assert	TokenNameassert
si	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
protected	TokenNameprotected
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
cloneNormBytes	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
cloneBytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
cloneBytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
cloneBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
protected	TokenNameprotected
BitVector	TokenNameIdentifier
cloneDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
BitVector	TokenNameIdentifier
bv	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
BitVector	TokenNameIdentifier
)	TokenNameRPAREN
bv	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
final	TokenNamefinal
synchronized	TokenNamesynchronized
Object	TokenNameIdentifier
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
clone	TokenNameIdentifier
(	TokenNameLPAREN
readOnly	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
ex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
ex	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
final	TokenNamefinal
synchronized	TokenNamesynchronized
IndexReader	TokenNameIdentifier
clone	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
openReadOnly	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
reopenSegment	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
openReadOnly	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
synchronized	TokenNamesynchronized
IndexReader	TokenNameIdentifier
doOpenIfChanged	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
reopenSegment	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
readOnly	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
@	TokenNameAT
Deprecated	TokenNameIdentifier
protected	TokenNameprotected
synchronized	TokenNamesynchronized
IndexReader	TokenNameIdentifier
doOpenIfChanged	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
openReadOnly	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
reopenSegment	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
openReadOnly	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
SegmentReader	TokenNameIdentifier
reopenSegment	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
si	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
doClone	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
openReadOnly	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
deletionsUpToDate	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
si	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
si	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
!	TokenNameNOT
si	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
this	TokenNamethis
.	TokenNameDOT
si	TokenNameIdentifier
.	TokenNameDOT
getDelFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
.	TokenNameDOT
getDelFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
normsUpToDate	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fieldNormsChanged	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
core	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
fieldCount	TokenNameIdentifier
=	TokenNameEQUAL
core	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fieldCount	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
this	TokenNamethis
.	TokenNameDOT
si	TokenNameIdentifier
.	TokenNameDOT
getNormFileName	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
.	TokenNameDOT
getNormFileName	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
normsUpToDate	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
fieldNormsChanged	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
normsUpToDate	TokenNameIdentifier
&&	TokenNameAND_AND
deletionsUpToDate	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
doClone	TokenNameIdentifier
&&	TokenNameAND_AND
openReadOnly	TokenNameIdentifier
&&	TokenNameAND_AND
readOnly	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
!	TokenNameNOT
doClone	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
normsUpToDate	TokenNameIdentifier
&&	TokenNameAND_AND
deletionsUpToDate	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentReader	TokenNameIdentifier
clone	TokenNameIdentifier
=	TokenNameEQUAL
openReadOnly	TokenNameIdentifier
?	TokenNameQUESTION
new	TokenNamenew
ReadOnlySegmentReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
SegmentReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
core	TokenNameIdentifier
.	TokenNameDOT
incRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
core	TokenNameIdentifier
=	TokenNameEQUAL
core	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
readOnly	TokenNameIdentifier
=	TokenNameEQUAL
openReadOnly	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
si	TokenNameIdentifier
=	TokenNameEQUAL
si	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
readBufferSize	TokenNameIdentifier
=	TokenNameEQUAL
readBufferSize	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
pendingDeleteCount	TokenNameIdentifier
=	TokenNameEQUAL
pendingDeleteCount	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
openReadOnly	TokenNameIdentifier
&&	TokenNameAND_AND
hasChanges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
clone	TokenNameIdentifier
.	TokenNameDOT
deletedDocsDirty	TokenNameIdentifier
=	TokenNameEQUAL
deletedDocsDirty	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
normsDirty	TokenNameIdentifier
=	TokenNameEQUAL
normsDirty	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
=	TokenNameEQUAL
hasChanges	TokenNameIdentifier
;	TokenNameSEMICOLON
hasChanges	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doClone	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
deletedDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
deletedDocsRef	TokenNameIdentifier
.	TokenNameDOT
incrementAndGet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
=	TokenNameEQUAL
deletedDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
deletedDocsRef	TokenNameIdentifier
=	TokenNameEQUAL
deletedDocsRef	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
deletionsUpToDate	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
clone	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
loadDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
deletedDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
deletedDocsRef	TokenNameIdentifier
.	TokenNameDOT
incrementAndGet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
=	TokenNameEQUAL
deletedDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
deletedDocsRef	TokenNameIdentifier
=	TokenNameEQUAL
deletedDocsRef	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
clone	TokenNameIdentifier
.	TokenNameDOT
norms	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
SegmentNorms	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fieldNormsChanged	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
doClone	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
fieldNormsChanged	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
String	TokenNameIdentifier
curField	TokenNameIdentifier
=	TokenNameEQUAL
core	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
name	TokenNameIdentifier
;	TokenNameSEMICOLON
SegmentNorms	TokenNameIdentifier
norm	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
norms	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
curField	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
norm	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
clone	TokenNameIdentifier
.	TokenNameDOT
norms	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
curField	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
SegmentNorms	TokenNameIdentifier
)	TokenNameRPAREN
norm	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
clone	TokenNameIdentifier
.	TokenNameDOT
openNorms	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
.	TokenNameDOT
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
core	TokenNameIdentifier
.	TokenNameDOT
getCFSReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
directory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
readBufferSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
clone	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
clone	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
@	TokenNameAT
Deprecated	TokenNameIdentifier
protected	TokenNameprotected
void	TokenNamevoid
doCommit	TokenNameIdentifier
(	TokenNameLPAREN
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hasChanges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
startCommit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
commitChanges	TokenNameIdentifier
(	TokenNameLPAREN
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
rollbackCommit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
void	TokenNamevoid
commitChanges	TokenNameIdentifier
(	TokenNameLPAREN
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
deletedDocsDirty	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
si	TokenNameIdentifier
.	TokenNameDOT
advanceDelGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
si	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
delFileName	TokenNameIdentifier
=	TokenNameEQUAL
si	TokenNameIdentifier
.	TokenNameDOT
getDelFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
write	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
delFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
directory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
deleteFile	TokenNameIdentifier
(	TokenNameLPAREN
delFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
si	TokenNameIdentifier
.	TokenNameDOT
setDelCount	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
pendingDeleteCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pendingDeleteCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
si	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
"delete count mismatch during commit: info="	TokenNameStringLiteral
+	TokenNamePLUS
si	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs BitVector="	TokenNameStringLiteral
+	TokenNamePLUS
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
assert	TokenNameassert
pendingDeleteCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
normsDirty	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
si	TokenNameIdentifier
.	TokenNameDOT
setNumFields	TokenNameIdentifier
(	TokenNameLPAREN
core	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
SegmentNorms	TokenNameIdentifier
norm	TokenNameIdentifier
:	TokenNameCOLON
norms	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
norm	TokenNameIdentifier
.	TokenNameDOT
dirty	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
norm	TokenNameIdentifier
.	TokenNameDOT
reWrite	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
deletedDocsDirty	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
normsDirty	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
hasChanges	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
FieldsReader	TokenNameIdentifier
getFieldsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fieldsReaderLocal	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
void	TokenNamevoid
doClose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
termVectorsLocal	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fieldsReaderLocal	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
deletedDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
deletedDocsRef	TokenNameIdentifier
.	TokenNameDOT
decrementAndGet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deletedDocs	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
SegmentNorms	TokenNameIdentifier
norm	TokenNameIdentifier
:	TokenNameCOLON
norms	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
norm	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
core	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
core	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
static	TokenNamestatic
boolean	TokenNameboolean
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
si	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
si	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
deletedDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
boolean	TokenNameboolean
usesCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
si	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
si	TokenNameIdentifier
.	TokenNameDOT
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
boolean	TokenNameboolean
hasSeparateNorms	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
si	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
si	TokenNameIdentifier
.	TokenNameDOT
hasSeparateNorms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
@	TokenNameAT
Deprecated	TokenNameIdentifier
protected	TokenNameprotected
void	TokenNamevoid
doDelete	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
docNum	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
deletedDocs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
deletedDocs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BitVector	TokenNameIdentifier
(	TokenNameLPAREN
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deletedDocsRef	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicInteger	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
deletedDocsRef	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
AtomicInteger	TokenNameIdentifier
oldRef	TokenNameIdentifier
=	TokenNameEQUAL
deletedDocsRef	TokenNameIdentifier
;	TokenNameSEMICOLON
deletedDocs	TokenNameIdentifier
=	TokenNameEQUAL
cloneDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
deletedDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deletedDocsRef	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicInteger	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
oldRef	TokenNameIdentifier
.	TokenNameDOT
decrementAndGet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
deletedDocsDirty	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
getAndSet	TokenNameIdentifier
(	TokenNameLPAREN
docNum	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
pendingDeleteCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
@	TokenNameAT
Deprecated	TokenNameIdentifier
protected	TokenNameprotected
void	TokenNamevoid
doUndeleteAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
deletedDocsDirty	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
deletedDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
deletedDocsRef	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
deletedDocsRef	TokenNameIdentifier
.	TokenNameDOT
decrementAndGet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deletedDocs	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
deletedDocsRef	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
pendingDeleteCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
si	TokenNameIdentifier
.	TokenNameDOT
clearDelGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
si	TokenNameIdentifier
.	TokenNameDOT
setDelCount	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
assert	TokenNameassert
deletedDocsRef	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
assert	TokenNameassert
pendingDeleteCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
List	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
si	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
TermEnum	TokenNameIdentifier
terms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
getTermsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
terms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
TermEnum	TokenNameIdentifier
terms	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
getTermsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
terms	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
FieldInfos	TokenNameIdentifier
getFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
FieldInfos	TokenNameIdentifier
fieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
Document	TokenNameIdentifier
document	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
n	TokenNameIdentifier
,	TokenNameCOMMA
FieldSelector	TokenNameIdentifier
fieldSelector	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
n	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
n	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"docID must be >= 0 and < maxDoc="	TokenNameStringLiteral
+	TokenNamePLUS
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" (got docID="	TokenNameStringLiteral
+	TokenNamePLUS
n	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
getFieldsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
n	TokenNameIdentifier
,	TokenNameCOMMA
fieldSelector	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
n	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
deletedDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
n	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
TermDocs	TokenNameIdentifier
termDocs	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
term	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
AllTermDocs	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
super	TokenNamesuper
.	TokenNameDOT
termDocs	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
TermDocs	TokenNameIdentifier
rawTermDocs	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
term	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"term must not be null"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
TermDocs	TokenNameIdentifier
td	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentTermDocs	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
td	TokenNameIdentifier
.	TokenNameDOT
seek	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
td	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
TermDocs	TokenNameIdentifier
termDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
new	TokenNamenew
SegmentTermDocs	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
TermPositions	TokenNameIdentifier
termPositions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
new	TokenNamenew
SegmentTermPositions	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
docFreq	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
TermInfo	TokenNameIdentifier
ti	TokenNameIdentifier
=	TokenNameEQUAL
core	TokenNameIdentifier
.	TokenNameDOT
getTermsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ti	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
ti	TokenNameIdentifier
.	TokenNameDOT
docFreq	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
n	TokenNameIdentifier
=	TokenNameEQUAL
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
deletedDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
n	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
n	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
si	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
hasNorms	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
norms	TokenNameIdentifier
.	TokenNameDOT
containsKey	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
norms	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
SegmentNorms	TokenNameIdentifier
norm	TokenNameIdentifier
=	TokenNameEQUAL
norms	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
norm	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
norm	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
@	TokenNameAT
Deprecated	TokenNameIdentifier
protected	TokenNameprotected
void	TokenNamevoid
doSetNorm	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
doc	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
byte	TokenNamebyte
value	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
SegmentNorms	TokenNameIdentifier
norm	TokenNameIdentifier
=	TokenNameEQUAL
norms	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
norm	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot setNorm for field "	TokenNameStringLiteral
+	TokenNamePLUS
field	TokenNameIdentifier
+	TokenNamePLUS
": norms were omitted"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
normsDirty	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
norm	TokenNameIdentifier
.	TokenNameDOT
copyOnWrite	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
[	TokenNameLBRACKET
doc	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
value	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
norms	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytes	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentNorms	TokenNameIdentifier
norm	TokenNameIdentifier
=	TokenNameEQUAL
norms	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
norm	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
,	TokenNameCOMMA
Similarity	TokenNameIdentifier
.	TokenNameDOT
getDefault	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
encodeNormValue	TokenNameIdentifier
(	TokenNameLPAREN
1.0f	TokenNameFloatingPointLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
norm	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
getPostingsSkipInterval	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
getTermsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getSkipInterval	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
openNorms	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
cfsDir	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
readBufferSize	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
normsInitiallyEmpty	TokenNameIdentifier
=	TokenNameEQUAL
norms	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
nextNormSeek	TokenNameIdentifier
=	TokenNameEQUAL
SegmentNorms	TokenNameIdentifier
.	TokenNameDOT
NORMS_HEADER	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
maxDoc	TokenNameIdentifier
=	TokenNameEQUAL
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
core	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
FieldInfo	TokenNameIdentifier
fi	TokenNameIdentifier
=	TokenNameEQUAL
core	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
norms	TokenNameIdentifier
.	TokenNameDOT
containsKey	TokenNameIdentifier
(	TokenNameLPAREN
fi	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fi	TokenNameIdentifier
.	TokenNameDOT
isIndexed	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
fi	TokenNameIdentifier
.	TokenNameDOT
omitNorms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Directory	TokenNameIdentifier
d	TokenNameIdentifier
=	TokenNameEQUAL
directory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
fileName	TokenNameIdentifier
=	TokenNameEQUAL
si	TokenNameIdentifier
.	TokenNameDOT
getNormFileName	TokenNameIdentifier
(	TokenNameLPAREN
fi	TokenNameIdentifier
.	TokenNameDOT
number	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
si	TokenNameIdentifier
.	TokenNameDOT
hasSeparateNorms	TokenNameIdentifier
(	TokenNameLPAREN
fi	TokenNameIdentifier
.	TokenNameDOT
number	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
d	TokenNameIdentifier
=	TokenNameEQUAL
cfsDir	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
singleNormFile	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
matchesExtension	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
NORMS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
IndexInput	TokenNameIdentifier
normInput	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
long	TokenNamelong
normSeek	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
singleNormFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
normSeek	TokenNameIdentifier
=	TokenNameEQUAL
nextNormSeek	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
singleNormStream	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
singleNormStream	TokenNameIdentifier
=	TokenNameEQUAL
d	TokenNameIdentifier
.	TokenNameDOT
openInput	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
,	TokenNameCOMMA
readBufferSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
singleNormRef	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicInteger	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
singleNormRef	TokenNameIdentifier
.	TokenNameDOT
incrementAndGet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
normInput	TokenNameIdentifier
=	TokenNameEQUAL
singleNormStream	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
normInput	TokenNameIdentifier
=	TokenNameEQUAL
d	TokenNameIdentifier
.	TokenNameDOT
openInput	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
version	TokenNameIdentifier
=	TokenNameEQUAL
si	TokenNameIdentifier
.	TokenNameDOT
getVersion	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
isUnversioned	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
version	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
StringHelper	TokenNameIdentifier
.	TokenNameDOT
getVersionComparator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
version	TokenNameIdentifier
,	TokenNameCOMMA
"3.2"	TokenNameStringLiteral
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
normInput	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isUnversioned	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
normSeek	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
normSeek	TokenNameIdentifier
=	TokenNameEQUAL
SegmentNorms	TokenNameIdentifier
.	TokenNameDOT
NORMS_HEADER	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
norms	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
fi	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
SegmentNorms	TokenNameIdentifier
(	TokenNameLPAREN
normInput	TokenNameIdentifier
,	TokenNameCOMMA
fi	TokenNameIdentifier
.	TokenNameDOT
number	TokenNameIdentifier
,	TokenNameCOMMA
normSeek	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
nextNormSeek	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
maxDoc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
assert	TokenNameassert
singleNormStream	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
!	TokenNameNOT
normsInitiallyEmpty	TokenNameIdentifier
||	TokenNameOR_OR
nextNormSeek	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
singleNormStream	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
termsIndexLoaded	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
termsIndexIsLoaded	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
loadTermsIndex	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
termsIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
core	TokenNameIdentifier
.	TokenNameDOT
loadTermsIndex	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
,	TokenNameCOMMA
termsIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
normsClosed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
singleNormStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
SegmentNorms	TokenNameIdentifier
norm	TokenNameIdentifier
:	TokenNameCOLON
norms	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
norm	TokenNameIdentifier
.	TokenNameDOT
refCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
normsClosed	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
norms	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
refCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
TermVectorsReader	TokenNameIdentifier
getTermVectorsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
TermVectorsReader	TokenNameIdentifier
tvReader	TokenNameIdentifier
=	TokenNameEQUAL
termVectorsLocal	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
tvReader	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
TermVectorsReader	TokenNameIdentifier
orig	TokenNameIdentifier
=	TokenNameEQUAL
core	TokenNameIdentifier
.	TokenNameDOT
getTermVectorsReaderOrig	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
orig	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
tvReader	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
TermVectorsReader	TokenNameIdentifier
)	TokenNameRPAREN
orig	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
CloneNotSupportedException	TokenNameIdentifier
cnse	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
termVectorsLocal	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
tvReader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
tvReader	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
TermVectorsReader	TokenNameIdentifier
getTermVectorsReaderOrig	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
getTermVectorsReaderOrig	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
TermFreqVector	TokenNameIdentifier
getTermFreqVector	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
docNumber	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
field	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
FieldInfo	TokenNameIdentifier
fi	TokenNameIdentifier
=	TokenNameEQUAL
core	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fi	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
!	TokenNameNOT
fi	TokenNameIdentifier
.	TokenNameDOT
storeTermVector	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
TermVectorsReader	TokenNameIdentifier
termVectorsReader	TokenNameIdentifier
=	TokenNameEQUAL
getTermVectorsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
termVectorsReader	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
return	TokenNamereturn
termVectorsReader	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
docNumber	TokenNameIdentifier
,	TokenNameCOMMA
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
getTermFreqVector	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
docNumber	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
TermVectorMapper	TokenNameIdentifier
mapper	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
FieldInfo	TokenNameIdentifier
fi	TokenNameIdentifier
=	TokenNameEQUAL
core	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fi	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
!	TokenNameNOT
fi	TokenNameIdentifier
.	TokenNameDOT
storeTermVector	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
TermVectorsReader	TokenNameIdentifier
termVectorsReader	TokenNameIdentifier
=	TokenNameEQUAL
getTermVectorsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
termVectorsReader	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
termVectorsReader	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
docNumber	TokenNameIdentifier
,	TokenNameCOMMA
field	TokenNameIdentifier
,	TokenNameCOMMA
mapper	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
getTermFreqVector	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
docNumber	TokenNameIdentifier
,	TokenNameCOMMA
TermVectorMapper	TokenNameIdentifier
mapper	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
TermVectorsReader	TokenNameIdentifier
termVectorsReader	TokenNameIdentifier
=	TokenNameEQUAL
getTermVectorsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
termVectorsReader	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
termVectorsReader	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
docNumber	TokenNameIdentifier
,	TokenNameCOMMA
mapper	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
TermFreqVector	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getTermFreqVectors	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
docNumber	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
TermVectorsReader	TokenNameIdentifier
termVectorsReader	TokenNameIdentifier
=	TokenNameEQUAL
getTermVectorsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
termVectorsReader	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
return	TokenNamereturn
termVectorsReader	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
docNumber	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
StringBuilder	TokenNameIdentifier
buffer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hasChanges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
buffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'*'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
buffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
si	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
core	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
,	TokenNameCOMMA
pendingDeleteCount	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
buffer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getSegmentName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
segment	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
SegmentInfo	TokenNameIdentifier
getSegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
si	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setSegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
si	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
startCommit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
rollbackSegmentInfo	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
)	TokenNameRPAREN
si	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
rollbackHasChanges	TokenNameIdentifier
=	TokenNameEQUAL
hasChanges	TokenNameIdentifier
;	TokenNameSEMICOLON
rollbackDeletedDocsDirty	TokenNameIdentifier
=	TokenNameEQUAL
deletedDocsDirty	TokenNameIdentifier
;	TokenNameSEMICOLON
rollbackNormsDirty	TokenNameIdentifier
=	TokenNameEQUAL
normsDirty	TokenNameIdentifier
;	TokenNameSEMICOLON
rollbackPendingDeleteCount	TokenNameIdentifier
=	TokenNameEQUAL
pendingDeleteCount	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentNorms	TokenNameIdentifier
norm	TokenNameIdentifier
:	TokenNameCOLON
norms	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
norm	TokenNameIdentifier
.	TokenNameDOT
rollbackDirty	TokenNameIdentifier
=	TokenNameEQUAL
norm	TokenNameIdentifier
.	TokenNameDOT
dirty	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
void	TokenNamevoid
rollbackCommit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
si	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
rollbackSegmentInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hasChanges	TokenNameIdentifier
=	TokenNameEQUAL
rollbackHasChanges	TokenNameIdentifier
;	TokenNameSEMICOLON
deletedDocsDirty	TokenNameIdentifier
=	TokenNameEQUAL
rollbackDeletedDocsDirty	TokenNameIdentifier
;	TokenNameSEMICOLON
normsDirty	TokenNameIdentifier
=	TokenNameEQUAL
rollbackNormsDirty	TokenNameIdentifier
;	TokenNameSEMICOLON
pendingDeleteCount	TokenNameIdentifier
=	TokenNameEQUAL
rollbackPendingDeleteCount	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentNorms	TokenNameIdentifier
norm	TokenNameIdentifier
:	TokenNameCOLON
norms	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
norm	TokenNameIdentifier
.	TokenNameDOT
dirty	TokenNameIdentifier
=	TokenNameEQUAL
norm	TokenNameIdentifier
.	TokenNameDOT
rollbackDirty	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
Directory	TokenNameIdentifier
directory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
final	TokenNamefinal
Object	TokenNameIdentifier
getCoreCacheKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
freqStream	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
Object	TokenNameIdentifier
getDeletesCacheKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
deletedDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
long	TokenNamelong
getUniqueTermCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
getTermsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
static	TokenNamestatic
SegmentReader	TokenNameIdentifier
getOnlySegmentReader	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
getOnlySegmentReader	TokenNameIdentifier
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
dir	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
SegmentReader	TokenNameIdentifier
getOnlySegmentReader	TokenNameIdentifier
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
instanceof	TokenNameinstanceof
SegmentReader	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
SegmentReader	TokenNameIdentifier
)	TokenNameRPAREN
reader	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
instanceof	TokenNameinstanceof
DirectoryReader	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
IndexReader	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
subReaders	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
getSequentialSubReaders	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
subReaders	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
+	TokenNamePLUS
" has "	TokenNameStringLiteral
+	TokenNamePLUS
subReaders	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
+	TokenNamePLUS
" segments instead of exactly one"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
SegmentReader	TokenNameIdentifier
)	TokenNameRPAREN
subReaders	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
+	TokenNamePLUS
" is not a SegmentReader or a single-segment DirectoryReader"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
getTermInfosIndexDivisor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
core	TokenNameIdentifier
.	TokenNameDOT
termsIndexDivisor	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
interface	TokenNameinterface
CoreClosedListener	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
void	TokenNamevoid
onClose	TokenNameIdentifier
(	TokenNameLPAREN
SegmentReader	TokenNameIdentifier
owner	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addCoreClosedListener	TokenNameIdentifier
(	TokenNameLPAREN
CoreClosedListener	TokenNameIdentifier
listener	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
core	TokenNameIdentifier
.	TokenNameDOT
addCoreClosedListener	TokenNameIdentifier
(	TokenNameLPAREN
listener	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
removeCoreClosedListener	TokenNameIdentifier
(	TokenNameLPAREN
CoreClosedListener	TokenNameIdentifier
listener	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
core	TokenNameIdentifier
.	TokenNameDOT
removeCoreClosedListener	TokenNameIdentifier
(	TokenNameLPAREN
listener	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
