package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
Directory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
IndexOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
IndexInput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
BitVector	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Constants	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashSet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Map	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashMap	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collections	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Set	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
class	TokenNameclass
SegmentInfo	TokenNameIdentifier
implements	TokenNameimplements
Cloneable	TokenNameIdentifier
{	TokenNameLBRACE
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
NO	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
YES	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
CHECK_DIR	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
WITHOUT_GEN	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
String	TokenNameIdentifier
name	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
preLockless	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
delGen	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
normGen	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
byte	TokenNamebyte
isCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
hasSingleNormFile	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
List	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
files	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
long	TokenNamelong
sizeInBytesNoStore	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
long	TokenNamelong
sizeInBytesWithStore	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
docStoreOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
docStoreSegment	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
docStoreIsCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
hasProx	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
hasVectors	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
diagnostics	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
version	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
bufferedDeletesGen	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
SegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
docCount	TokenNameIdentifier
,	TokenNameCOMMA
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isCompoundFile	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
hasSingleNormFile	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
hasProx	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
hasVectors	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
name	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
docCount	TokenNameIdentifier
=	TokenNameEQUAL
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
dir	TokenNameIdentifier
=	TokenNameEQUAL
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
delGen	TokenNameIdentifier
=	TokenNameEQUAL
NO	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
isCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
isCompoundFile	TokenNameIdentifier
?	TokenNameQUESTION
YES	TokenNameIdentifier
:	TokenNameCOLON
NO	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
preLockless	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
hasSingleNormFile	TokenNameIdentifier
=	TokenNameEQUAL
hasSingleNormFile	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
hasProx	TokenNameIdentifier
=	TokenNameEQUAL
hasProx	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
hasVectors	TokenNameIdentifier
=	TokenNameEQUAL
hasVectors	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
version	TokenNameIdentifier
=	TokenNameEQUAL
Constants	TokenNameIdentifier
.	TokenNameDOT
LUCENE_MAIN_VERSION	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
reset	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
src	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
version	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
version	TokenNameIdentifier
;	TokenNameSEMICOLON
name	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
;	TokenNameSEMICOLON
docCount	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
dir	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
preLockless	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
preLockless	TokenNameIdentifier
;	TokenNameSEMICOLON
delGen	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
delGen	TokenNameIdentifier
;	TokenNameSEMICOLON
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
docStoreOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
docStoreIsCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
docStoreIsCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
hasVectors	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
hasVectors	TokenNameIdentifier
;	TokenNameSEMICOLON
hasProx	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
hasProx	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
src	TokenNameIdentifier
.	TokenNameDOT
normGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
normGen	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
normGen	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
long	TokenNamelong
[	TokenNameLBRACKET
src	TokenNameIdentifier
.	TokenNameDOT
normGen	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
src	TokenNameIdentifier
.	TokenNameDOT
normGen	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
normGen	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
src	TokenNameIdentifier
.	TokenNameDOT
normGen	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
isCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
isCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
hasSingleNormFile	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
hasSingleNormFile	TokenNameIdentifier
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
=	TokenNameEQUAL
src	TokenNameIdentifier
.	TokenNameDOT
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setDiagnostics	TokenNameIdentifier
(	TokenNameLPAREN
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
diagnostics	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
diagnostics	TokenNameIdentifier
=	TokenNameEQUAL
diagnostics	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
getDiagnostics	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
diagnostics	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
SegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
format	TokenNameIdentifier
,	TokenNameCOMMA
IndexInput	TokenNameIdentifier
input	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
dir	TokenNameIdentifier
=	TokenNameEQUAL
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_3_1	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
version	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
name	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docCount	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_LOCKLESS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
delGen	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readLong	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_SHARED_DOC_STORE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docStoreOffset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
docStoreSegment	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docStoreIsCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
docStoreSegment	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
docStoreIsCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
docStoreSegment	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
docStoreIsCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_SINGLE_NORM_FILE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
hasSingleNormFile	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
hasSingleNormFile	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
numNormGen	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numNormGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
NO	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
normGen	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
normGen	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
long	TokenNamelong
[	TokenNameLBRACKET
numNormGen	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
numNormGen	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readLong	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
isCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
preLockless	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
isCompoundFile	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CHECK_DIR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_DEL_COUNT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
delCount	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
delCount	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
delCount	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_HAS_PROX	TokenNameIdentifier
)	TokenNameRPAREN
hasProx	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
hasProx	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_DIAGNOSTICS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
diagnostics	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readStringStringMap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
diagnostics	TokenNameIdentifier
=	TokenNameEQUAL
Collections	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
emptyMap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_HAS_VECTORS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
hasVectors	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
String	TokenNameIdentifier
storesSegment	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
ext	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
isCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docStoreOffset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
storesSegment	TokenNameIdentifier
=	TokenNameEQUAL
docStoreSegment	TokenNameIdentifier
;	TokenNameSEMICOLON
isCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
docStoreIsCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
ext	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
COMPOUND_FILE_STORE_EXTENSION	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
storesSegment	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
isCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ext	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
COMPOUND_FILE_EXTENSION	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
Directory	TokenNameIdentifier
dirToTest	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dirToTest	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CompoundFileReader	TokenNameIdentifier
(	TokenNameLPAREN
dir	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
storesSegment	TokenNameIdentifier
,	TokenNameCOMMA
ext	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
dirToTest	TokenNameIdentifier
=	TokenNameEQUAL
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
hasVectors	TokenNameIdentifier
=	TokenNameEQUAL
dirToTest	TokenNameIdentifier
.	TokenNameDOT
fileExists	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
storesSegment	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
VECTORS_INDEX_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dirToTest	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
delGen	TokenNameIdentifier
=	TokenNameEQUAL
CHECK_DIR	TokenNameIdentifier
;	TokenNameSEMICOLON
normGen	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
isCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
CHECK_DIR	TokenNameIdentifier
;	TokenNameSEMICOLON
preLockless	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
hasSingleNormFile	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
docStoreIsCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
docStoreSegment	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
hasProx	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
diagnostics	TokenNameIdentifier
=	TokenNameEQUAL
Collections	TokenNameIdentifier
.	TokenNameDOT
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
emptyMap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
void	TokenNamevoid
setNumFields	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
numFields	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
normGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
normGen	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
long	TokenNamelong
[	TokenNameLBRACKET
numFields	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
preLockless	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numFields	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
NO	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
includeDocStores	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
includeDocStores	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
sizeInBytesWithStore	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
sizeInBytesWithStore	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
long	TokenNamelong
sum	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
String	TokenNameIdentifier
fileName	TokenNameIdentifier
:	TokenNameCOLON
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
docStoreOffset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
!	TokenNameNOT
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
isDocStoreFile	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
sum	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dir	TokenNameIdentifier
.	TokenNameDOT
fileLength	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
sizeInBytesWithStore	TokenNameIdentifier
=	TokenNameEQUAL
sum	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
sizeInBytesWithStore	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
sizeInBytesNoStore	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
sizeInBytesNoStore	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
long	TokenNamelong
sum	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
String	TokenNameIdentifier
fileName	TokenNameIdentifier
:	TokenNameCOLON
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
isDocStoreFile	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
sum	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
dir	TokenNameIdentifier
.	TokenNameDOT
fileLength	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
sizeInBytesNoStore	TokenNameIdentifier
=	TokenNameEQUAL
sum	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
sizeInBytesNoStore	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getHasVectors	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
hasVectors	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setHasVectors	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
hasVectors	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
delGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
NO	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
delGen	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
YES	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
dir	TokenNameIdentifier
.	TokenNameDOT
fileExists	TokenNameIdentifier
(	TokenNameLPAREN
getDelFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
void	TokenNamevoid
advanceDelGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
delGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
NO	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
delGen	TokenNameIdentifier
=	TokenNameEQUAL
YES	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
delGen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
clearDelGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
delGen	TokenNameIdentifier
=	TokenNameEQUAL
NO	TokenNameIdentifier
;	TokenNameSEMICOLON
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
Object	TokenNameIdentifier
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
SegmentInfo	TokenNameIdentifier
si	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
docCount	TokenNameIdentifier
,	TokenNameCOMMA
dir	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
hasSingleNormFile	TokenNameIdentifier
,	TokenNameCOMMA
hasProx	TokenNameIdentifier
,	TokenNameCOMMA
hasVectors	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
si	TokenNameIdentifier
.	TokenNameDOT
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
docStoreOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
si	TokenNameIdentifier
.	TokenNameDOT
docStoreSegment	TokenNameIdentifier
=	TokenNameEQUAL
docStoreSegment	TokenNameIdentifier
;	TokenNameSEMICOLON
si	TokenNameIdentifier
.	TokenNameDOT
docStoreIsCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
docStoreIsCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
si	TokenNameIdentifier
.	TokenNameDOT
delGen	TokenNameIdentifier
=	TokenNameEQUAL
delGen	TokenNameIdentifier
;	TokenNameSEMICOLON
si	TokenNameIdentifier
.	TokenNameDOT
delCount	TokenNameIdentifier
=	TokenNameEQUAL
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
si	TokenNameIdentifier
.	TokenNameDOT
preLockless	TokenNameIdentifier
=	TokenNameEQUAL
preLockless	TokenNameIdentifier
;	TokenNameSEMICOLON
si	TokenNameIdentifier
.	TokenNameDOT
isCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
isCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
si	TokenNameIdentifier
.	TokenNameDOT
diagnostics	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
diagnostics	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
normGen	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
si	TokenNameIdentifier
.	TokenNameDOT
normGen	TokenNameIdentifier
=	TokenNameEQUAL
normGen	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
si	TokenNameIdentifier
.	TokenNameDOT
version	TokenNameIdentifier
=	TokenNameEQUAL
version	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
si	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getDelFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
delGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
NO	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
fileNameFromGeneration	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
DELETES_EXTENSION	TokenNameIdentifier
,	TokenNameCOMMA
delGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
hasSeparateNorms	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
fieldNumber	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
normGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
preLockless	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
normGen	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
fieldNumber	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
CHECK_DIR	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
fileName	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
+	TokenNamePLUS
".s"	TokenNameStringLiteral
+	TokenNamePLUS
fieldNumber	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
dir	TokenNameIdentifier
.	TokenNameDOT
fileExists	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
normGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
fieldNumber	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
NO	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
hasSeparateNorms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
normGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
preLockless	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
result	TokenNameIdentifier
=	TokenNameEQUAL
dir	TokenNameIdentifier
.	TokenNameDOT
listAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"cannot read directory "	TokenNameStringLiteral
+	TokenNamePLUS
dir	TokenNameIdentifier
+	TokenNamePLUS
": listAll() returned null"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
IndexFileNameFilter	TokenNameIdentifier
filter	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNameFilter	TokenNameIdentifier
.	TokenNameDOT
getFilter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
pattern	TokenNameIdentifier
;	TokenNameSEMICOLON
pattern	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
+	TokenNamePLUS
".s"	TokenNameStringLiteral
;	TokenNameSEMICOLON
int	TokenNameint
patternLength	TokenNameIdentifier
=	TokenNameEQUAL
pattern	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
fileName	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
filter	TokenNameIdentifier
.	TokenNameDOT
accept	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
fileName	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
fileName	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
pattern	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
Character	TokenNameIdentifier
.	TokenNameDOT
isDigit	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
patternLength	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
normGen	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
>=	TokenNameGREATER_EQUAL
YES	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
normGen	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
CHECK_DIR	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hasSeparateNorms	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
advanceNormGen	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
fieldIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
fieldIndex	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
NO	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
fieldIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
YES	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
fieldIndex	TokenNameIdentifier
]	TokenNameRBRACKET
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getNormFileName	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
number	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
long	TokenNamelong
gen	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
normGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
gen	TokenNameIdentifier
=	TokenNameEQUAL
CHECK_DIR	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
gen	TokenNameIdentifier
=	TokenNameEQUAL
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
number	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
hasSeparateNorms	TokenNameIdentifier
(	TokenNameLPAREN
number	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
fileNameFromGeneration	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
"s"	TokenNameStringLiteral
+	TokenNamePLUS
number	TokenNameIdentifier
,	TokenNameCOMMA
gen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
hasSingleNormFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
fileNameFromGeneration	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
NORMS_EXTENSION	TokenNameIdentifier
,	TokenNameCOMMA
WITHOUT_GEN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
fileNameFromGeneration	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
"f"	TokenNameStringLiteral
+	TokenNamePLUS
number	TokenNameIdentifier
,	TokenNameCOMMA
WITHOUT_GEN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
isCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
isCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
YES	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
isCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
NO	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isCompoundFile	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
NO	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
isCompoundFile	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
YES	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
dir	TokenNameIdentifier
.	TokenNameDOT
fileExists	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
COMPOUND_FILE_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
delCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
String	TokenNameIdentifier
delFileName	TokenNameIdentifier
=	TokenNameEQUAL
getDelFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BitVector	TokenNameIdentifier
(	TokenNameLPAREN
dir	TokenNameIdentifier
,	TokenNameCOMMA
delFileName	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
delCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
delCount	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setDelCount	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
delCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
delCount	TokenNameIdentifier
=	TokenNameEQUAL
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
delCount	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getDocStoreOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
docStoreOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getDocStoreIsCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
docStoreIsCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setDocStoreIsCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
docStoreIsCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getDocStoreSegment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
docStoreSegment	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setDocStoreSegment	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
segment	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
docStoreSegment	TokenNameIdentifier
=	TokenNameEQUAL
segment	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setDocStoreOffset	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setDocStore	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
segment	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
docStoreSegment	TokenNameIdentifier
=	TokenNameEQUAL
segment	TokenNameIdentifier
;	TokenNameSEMICOLON
docStoreIsCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
isCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
write	TokenNameIdentifier
(	TokenNameLPAREN
IndexOutput	TokenNameIdentifier
output	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
delCount	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
docCount	TokenNameIdentifier
:	TokenNameCOLON
"delCount="	TokenNameStringLiteral
+	TokenNamePLUS
delCount	TokenNameIdentifier
+	TokenNamePLUS
" docCount="	TokenNameStringLiteral
+	TokenNamePLUS
docCount	TokenNameIdentifier
+	TokenNamePLUS
" segment="	TokenNameStringLiteral
+	TokenNamePLUS
name	TokenNameIdentifier
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeString	TokenNameIdentifier
(	TokenNameLPAREN
version	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeString	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeInt	TokenNameIdentifier
(	TokenNameLPAREN
docCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeLong	TokenNameIdentifier
(	TokenNameLPAREN
delGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeInt	TokenNameIdentifier
(	TokenNameLPAREN
docStoreOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docStoreOffset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
output	TokenNameIdentifier
.	TokenNameDOT
writeString	TokenNameIdentifier
(	TokenNameLPAREN
docStoreSegment	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
docStoreIsCompoundFile	TokenNameIdentifier
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
output	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
hasSingleNormFile	TokenNameIdentifier
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
normGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
output	TokenNameIdentifier
.	TokenNameDOT
writeInt	TokenNameIdentifier
(	TokenNameLPAREN
NO	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
output	TokenNameIdentifier
.	TokenNameDOT
writeInt	TokenNameIdentifier
(	TokenNameLPAREN
normGen	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
normGen	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
output	TokenNameIdentifier
.	TokenNameDOT
writeLong	TokenNameIdentifier
(	TokenNameLPAREN
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
output	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
isCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeInt	TokenNameIdentifier
(	TokenNameLPAREN
delCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
hasProx	TokenNameIdentifier
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeStringStringMap	TokenNameIdentifier
(	TokenNameLPAREN
diagnostics	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
hasVectors	TokenNameIdentifier
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setHasProx	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
hasProx	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
hasProx	TokenNameIdentifier
=	TokenNameEQUAL
hasProx	TokenNameIdentifier
;	TokenNameSEMICOLON
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getHasProx	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
hasProx	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
addIfExists	TokenNameIdentifier
(	TokenNameLPAREN
Set	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
files	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
fileName	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dir	TokenNameIdentifier
.	TokenNameDOT
fileExists	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
files	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
List	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
files	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
files	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
HashSet	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
filesSet	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
useCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
COMPOUND_FILE_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
String	TokenNameIdentifier
ext	TokenNameIdentifier
:	TokenNameCOLON
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
NON_STORE_INDEX_EXTENSIONS	TokenNameIdentifier
)	TokenNameRPAREN
addIfExists	TokenNameIdentifier
(	TokenNameLPAREN
filesSet	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
ext	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
docStoreOffset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
docStoreSegment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docStoreIsCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
docStoreSegment	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
COMPOUND_FILE_STORE_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
docStoreSegment	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
FIELDS_INDEX_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
docStoreSegment	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
FIELDS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hasVectors	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
docStoreSegment	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
VECTORS_INDEX_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
docStoreSegment	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
VECTORS_DOCUMENTS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
docStoreSegment	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
VECTORS_FIELDS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
FIELDS_INDEX_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
FIELDS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hasVectors	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
VECTORS_INDEX_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
VECTORS_DOCUMENTS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
VECTORS_FIELDS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
String	TokenNameIdentifier
delFileName	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
fileNameFromGeneration	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
DELETES_EXTENSION	TokenNameIdentifier
,	TokenNameCOMMA
delGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
delFileName	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
(	TokenNameLPAREN
delGen	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
YES	TokenNameIdentifier
||	TokenNameOR_OR
dir	TokenNameIdentifier
.	TokenNameDOT
fileExists	TokenNameIdentifier
(	TokenNameLPAREN
delFileName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
delFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
normGen	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
normGen	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
gen	TokenNameIdentifier
=	TokenNameEQUAL
normGen	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
gen	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
YES	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
fileNameFromGeneration	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
SEPARATE_NORMS_EXTENSION	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
,	TokenNameCOMMA
gen	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
NO	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
gen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
hasSingleNormFile	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
fileName	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
PLAIN_NORMS_EXTENSION	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dir	TokenNameIdentifier
.	TokenNameDOT
fileExists	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
CHECK_DIR	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
gen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
fileName	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fileName	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
SEPARATE_NORMS_EXTENSION	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
hasSingleNormFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fileName	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
PLAIN_NORMS_EXTENSION	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fileName	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
dir	TokenNameIdentifier
.	TokenNameDOT
fileExists	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
preLockless	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
!	TokenNameNOT
hasSingleNormFile	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
prefix	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
prefix	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
SEPARATE_NORMS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
prefix	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
PLAIN_NORMS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
prefixLength	TokenNameIdentifier
=	TokenNameEQUAL
prefix	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
allFiles	TokenNameIdentifier
=	TokenNameEQUAL
dir	TokenNameIdentifier
.	TokenNameDOT
listAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
IndexFileNameFilter	TokenNameIdentifier
filter	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNameFilter	TokenNameIdentifier
.	TokenNameDOT
getFilter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
allFiles	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
fileName	TokenNameIdentifier
=	TokenNameEQUAL
allFiles	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
filter	TokenNameIdentifier
.	TokenNameDOT
accept	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
fileName	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
fileName	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
prefixLength	TokenNameIdentifier
&&	TokenNameAND_AND
Character	TokenNameIdentifier
.	TokenNameDOT
isDigit	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
prefixLength	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
fileName	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
prefix	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
filesSet	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
files	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
filesSet	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
clearFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
files	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
sizeInBytesNoStore	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
sizeInBytesWithStore	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
toString	TokenNameIdentifier
(	TokenNameLPAREN
dir	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
pendingDelCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuilder	TokenNameIdentifier
s	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'('	TokenNameCharacterLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
version	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
"?"	TokenNameStringLiteral
:	TokenNameCOLON
version	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
')'	TokenNameCharacterLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
':'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
cfs	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
cfs	TokenNameIdentifier
=	TokenNameEQUAL
'c'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
cfs	TokenNameIdentifier
=	TokenNameEQUAL
'C'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
ioe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
cfs	TokenNameIdentifier
=	TokenNameEQUAL
'?'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
cfs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
dir	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
dir	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'x'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
hasVectors	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'v'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
docCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
delCount	TokenNameIdentifier
=	TokenNameEQUAL
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
ioe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
delCount	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
delCount	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
delCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
pendingDelCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
delCount	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'/'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
delCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'?'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
delCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
docStoreOffset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"->"	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
docStoreSegment	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docStoreIsCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'c'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'C'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
s	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'+'	TokenNameCharacterLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
docStoreOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
s	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
obj	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
==	TokenNameEQUAL_EQUAL
obj	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
obj	TokenNameIdentifier
instanceof	TokenNameinstanceof
SegmentInfo	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
other	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
)	TokenNameRPAREN
obj	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
other	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
dir	TokenNameIdentifier
&&	TokenNameAND_AND
other	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
dir	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
name	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setVersion	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
version	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
version	TokenNameIdentifier
=	TokenNameEQUAL
version	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getVersion	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
version	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
long	TokenNamelong
getBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bufferedDeletesGen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bufferedDeletesGen	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
