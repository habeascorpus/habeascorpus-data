package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collection	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
.	TokenNameDOT
Document	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
FieldInfo	TokenNameIdentifier
.	TokenNameDOT
IndexOptions	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
MergeAbortedException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
PayloadProcessorProvider	TokenNameIdentifier
.	TokenNameDOT
PayloadProcessor	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
Directory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
IndexInput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
IndexOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
IOUtils	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ReaderUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
class	TokenNameclass
SegmentMerger	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
Directory	TokenNameIdentifier
directory	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
segment	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
termIndexInterval	TokenNameIdentifier
=	TokenNameEQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_TERM_INDEX_INTERVAL	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
List	TokenNameIdentifier
<	TokenNameLESS
IndexReader	TokenNameIdentifier
>	TokenNameGREATER
readers	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
IndexReader	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
FieldInfos	TokenNameIdentifier
fieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
mergedDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
CheckAbort	TokenNameIdentifier
checkAbort	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
MAX_RAW_MERGE_DOCS	TokenNameIdentifier
=	TokenNameEQUAL
4192	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
SegmentWriteState	TokenNameIdentifier
segmentWriteState	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
PayloadProcessorProvider	TokenNameIdentifier
payloadProcessorProvider	TokenNameIdentifier
;	TokenNameSEMICOLON
SegmentMerger	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
termIndexInterval	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
,	TokenNameCOMMA
PayloadProcessorProvider	TokenNameIdentifier
payloadProcessorProvider	TokenNameIdentifier
,	TokenNameCOMMA
FieldInfos	TokenNameIdentifier
fieldInfos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
payloadProcessorProvider	TokenNameIdentifier
=	TokenNameEQUAL
payloadProcessorProvider	TokenNameIdentifier
;	TokenNameSEMICOLON
directory	TokenNameIdentifier
=	TokenNameEQUAL
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
=	TokenNameEQUAL
fieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
segment	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
checkAbort	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CheckAbort	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
,	TokenNameCOMMA
directory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
checkAbort	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CheckAbort	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
work	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
units	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MergeAbortedException	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
termIndexInterval	TokenNameIdentifier
=	TokenNameEQUAL
termIndexInterval	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
FieldInfos	TokenNameIdentifier
fieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
void	TokenNamevoid
add	TokenNameIdentifier
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ReaderUtil	TokenNameIdentifier
.	TokenNameDOT
gatherSubReaders	TokenNameIdentifier
(	TokenNameLPAREN
readers	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
merge	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
mergedDocs	TokenNameIdentifier
=	TokenNameEQUAL
mergeFields	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeNorms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
hasVectors	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
mergeVectors	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
mergedDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
Collection	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
createCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
fileName	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
Collection	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
files	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
CompoundFileWriter	TokenNameIdentifier
cfsWriter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CompoundFileWriter	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
fileName	TokenNameIdentifier
,	TokenNameCOMMA
checkAbort	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
String	TokenNameIdentifier
file	TokenNameIdentifier
:	TokenNameCOLON
files	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
!	TokenNameNOT
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
matchesExtension	TokenNameIdentifier
(	TokenNameLPAREN
file	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
DELETES_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
".del file is not allowed in .cfs: "	TokenNameStringLiteral
+	TokenNamePLUS
file	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
!	TokenNameNOT
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
isSeparateNormsFile	TokenNameIdentifier
(	TokenNameLPAREN
file	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
"separate norms file (.s[0-9]+) is not allowed in .cfs: "	TokenNameStringLiteral
+	TokenNamePLUS
file	TokenNameIdentifier
;	TokenNameSEMICOLON
cfsWriter	TokenNameIdentifier
.	TokenNameDOT
addFile	TokenNameIdentifier
(	TokenNameLPAREN
file	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
cfsWriter	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
files	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
SegmentReader	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
matchingSegmentReaders	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rawDocLengths	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rawDocLengths2	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
matchedCount	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
getMatchedSubReaderCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
matchedCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setMatchingSegmentReaders	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
numReaders	TokenNameIdentifier
=	TokenNameEQUAL
readers	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
matchingSegmentReaders	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentReader	TokenNameIdentifier
[	TokenNameLBRACKET
numReaders	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numReaders	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
=	TokenNameEQUAL
readers	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
instanceof	TokenNameinstanceof
SegmentReader	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
SegmentReader	TokenNameIdentifier
segmentReader	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
SegmentReader	TokenNameIdentifier
)	TokenNameRPAREN
reader	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
same	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
FieldInfos	TokenNameIdentifier
segmentFieldInfos	TokenNameIdentifier
=	TokenNameEQUAL
segmentReader	TokenNameIdentifier
.	TokenNameDOT
getFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
numFieldInfos	TokenNameIdentifier
=	TokenNameEQUAL
segmentFieldInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
numFieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
fieldName	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
segmentFieldInfos	TokenNameIdentifier
.	TokenNameDOT
fieldName	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
same	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
same	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
matchingSegmentReaders	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
segmentReader	TokenNameIdentifier
;	TokenNameSEMICOLON
matchedCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
rawDocLengths	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
MAX_RAW_MERGE_DOCS	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
rawDocLengths2	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
MAX_RAW_MERGE_DOCS	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
mergeFields	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
:	TokenNameCOLON
readers	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
getFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
write	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
segment	TokenNameIdentifier
+	TokenNamePLUS
".fnm"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
docCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
setMatchingSegmentReaders	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
FieldsWriter	TokenNameIdentifier
fieldsWriter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FieldsWriter	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
segment	TokenNameIdentifier
,	TokenNameCOMMA
fieldInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
:	TokenNameCOLON
readers	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentReader	TokenNameIdentifier
matchingSegmentReader	TokenNameIdentifier
=	TokenNameEQUAL
matchingSegmentReaders	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
FieldsReader	TokenNameIdentifier
matchingFieldsReader	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchingSegmentReader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
FieldsReader	TokenNameIdentifier
fieldsReader	TokenNameIdentifier
=	TokenNameEQUAL
matchingSegmentReader	TokenNameIdentifier
.	TokenNameDOT
getFieldsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fieldsReader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
fieldsReader	TokenNameIdentifier
.	TokenNameDOT
canReadRawDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
matchingFieldsReader	TokenNameIdentifier
=	TokenNameEQUAL
fieldsReader	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
docCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
copyFieldsWithDeletions	TokenNameIdentifier
(	TokenNameLPAREN
fieldsWriter	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
,	TokenNameCOMMA
matchingFieldsReader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
docCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
copyFieldsNoDeletions	TokenNameIdentifier
(	TokenNameLPAREN
fieldsWriter	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
,	TokenNameCOMMA
matchingFieldsReader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
fieldsWriter	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
docCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
fieldsWriter	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
segmentWriteState	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentWriteState	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
directory	TokenNameIdentifier
,	TokenNameCOMMA
segment	TokenNameIdentifier
,	TokenNameCOMMA
fieldInfos	TokenNameIdentifier
,	TokenNameCOMMA
docCount	TokenNameIdentifier
,	TokenNameCOMMA
termIndexInterval	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
copyFieldsWithDeletions	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
FieldsWriter	TokenNameIdentifier
fieldsWriter	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
FieldsReader	TokenNameIdentifier
matchingFieldsReader	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
MergeAbortedException	TokenNameIdentifier
,	TokenNameCOMMA
CorruptIndexException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
docCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
maxDoc	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchingFieldsReader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
maxDoc	TokenNameIdentifier
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
++	TokenNamePLUS_PLUS
j	TokenNameIdentifier
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
j	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
do	TokenNamedo
{	TokenNameLBRACE
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
numDocs	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
j	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
maxDoc	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
numDocs	TokenNameIdentifier
<	TokenNameLESS
MAX_RAW_MERGE_DOCS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
IndexInput	TokenNameIdentifier
stream	TokenNameIdentifier
=	TokenNameEQUAL
matchingFieldsReader	TokenNameIdentifier
.	TokenNameDOT
rawDocs	TokenNameIdentifier
(	TokenNameLPAREN
rawDocLengths	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fieldsWriter	TokenNameIdentifier
.	TokenNameDOT
addRawDocuments	TokenNameIdentifier
(	TokenNameLPAREN
stream	TokenNameIdentifier
,	TokenNameCOMMA
rawDocLengths	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
numDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
checkAbort	TokenNameIdentifier
.	TokenNameDOT
work	TokenNameIdentifier
(	TokenNameLPAREN
300	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
maxDoc	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Document	TokenNameIdentifier
doc	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fieldsWriter	TokenNameIdentifier
.	TokenNameDOT
addDocument	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
checkAbort	TokenNameIdentifier
.	TokenNameDOT
work	TokenNameIdentifier
(	TokenNameLPAREN
300	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
copyFieldsNoDeletions	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
FieldsWriter	TokenNameIdentifier
fieldsWriter	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
FieldsReader	TokenNameIdentifier
matchingFieldsReader	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
MergeAbortedException	TokenNameIdentifier
,	TokenNameCOMMA
CorruptIndexException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
maxDoc	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
docCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchingFieldsReader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
docCount	TokenNameIdentifier
<	TokenNameLESS
maxDoc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
MAX_RAW_MERGE_DOCS	TokenNameIdentifier
,	TokenNameCOMMA
maxDoc	TokenNameIdentifier
-	TokenNameMINUS
docCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
IndexInput	TokenNameIdentifier
stream	TokenNameIdentifier
=	TokenNameEQUAL
matchingFieldsReader	TokenNameIdentifier
.	TokenNameDOT
rawDocs	TokenNameIdentifier
(	TokenNameLPAREN
rawDocLengths	TokenNameIdentifier
,	TokenNameCOMMA
docCount	TokenNameIdentifier
,	TokenNameCOMMA
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fieldsWriter	TokenNameIdentifier
.	TokenNameDOT
addRawDocuments	TokenNameIdentifier
(	TokenNameLPAREN
stream	TokenNameIdentifier
,	TokenNameCOMMA
rawDocLengths	TokenNameIdentifier
,	TokenNameCOMMA
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
len	TokenNameIdentifier
;	TokenNameSEMICOLON
checkAbort	TokenNameIdentifier
.	TokenNameDOT
work	TokenNameIdentifier
(	TokenNameLPAREN
300	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
docCount	TokenNameIdentifier
<	TokenNameLESS
maxDoc	TokenNameIdentifier
;	TokenNameSEMICOLON
docCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
Document	TokenNameIdentifier
doc	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
(	TokenNameLPAREN
docCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fieldsWriter	TokenNameIdentifier
.	TokenNameDOT
addDocument	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkAbort	TokenNameIdentifier
.	TokenNameDOT
work	TokenNameIdentifier
(	TokenNameLPAREN
300	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
void	TokenNamevoid
mergeVectors	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
TermVectorsWriter	TokenNameIdentifier
termVectorsWriter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
TermVectorsWriter	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
segment	TokenNameIdentifier
,	TokenNameCOMMA
fieldInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
:	TokenNameCOLON
readers	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentReader	TokenNameIdentifier
matchingSegmentReader	TokenNameIdentifier
=	TokenNameEQUAL
matchingSegmentReaders	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
TermVectorsReader	TokenNameIdentifier
matchingVectorsReader	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchingSegmentReader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
TermVectorsReader	TokenNameIdentifier
vectorsReader	TokenNameIdentifier
=	TokenNameEQUAL
matchingSegmentReader	TokenNameIdentifier
.	TokenNameDOT
getTermVectorsReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
vectorsReader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
vectorsReader	TokenNameIdentifier
.	TokenNameDOT
canReadRawDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
matchingVectorsReader	TokenNameIdentifier
=	TokenNameEQUAL
vectorsReader	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
copyVectorsWithDeletions	TokenNameIdentifier
(	TokenNameLPAREN
termVectorsWriter	TokenNameIdentifier
,	TokenNameCOMMA
matchingVectorsReader	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
copyVectorsNoDeletions	TokenNameIdentifier
(	TokenNameLPAREN
termVectorsWriter	TokenNameIdentifier
,	TokenNameCOMMA
matchingVectorsReader	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
termVectorsWriter	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
mergedDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
termVectorsWriter	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
copyVectorsWithDeletions	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
TermVectorsWriter	TokenNameIdentifier
termVectorsWriter	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
TermVectorsReader	TokenNameIdentifier
matchingVectorsReader	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
MergeAbortedException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
maxDoc	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchingVectorsReader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
docNum	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
docNum	TokenNameIdentifier
<	TokenNameLESS
maxDoc	TokenNameIdentifier
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
docNum	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
++	TokenNamePLUS_PLUS
docNum	TokenNameIdentifier
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
docNum	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
do	TokenNamedo
{	TokenNameLBRACE
docNum	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
numDocs	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docNum	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
maxDoc	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
docNum	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
docNum	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
numDocs	TokenNameIdentifier
<	TokenNameLESS
MAX_RAW_MERGE_DOCS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
matchingVectorsReader	TokenNameIdentifier
.	TokenNameDOT
rawDocs	TokenNameIdentifier
(	TokenNameLPAREN
rawDocLengths	TokenNameIdentifier
,	TokenNameCOMMA
rawDocLengths2	TokenNameIdentifier
,	TokenNameCOMMA
start	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
termVectorsWriter	TokenNameIdentifier
.	TokenNameDOT
addRawDocuments	TokenNameIdentifier
(	TokenNameLPAREN
matchingVectorsReader	TokenNameIdentifier
,	TokenNameCOMMA
rawDocLengths	TokenNameIdentifier
,	TokenNameCOMMA
rawDocLengths2	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkAbort	TokenNameIdentifier
.	TokenNameDOT
work	TokenNameIdentifier
(	TokenNameLPAREN
300	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
docNum	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
docNum	TokenNameIdentifier
<	TokenNameLESS
maxDoc	TokenNameIdentifier
;	TokenNameSEMICOLON
docNum	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
docNum	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
TermFreqVector	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
vectors	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
getTermFreqVectors	TokenNameIdentifier
(	TokenNameLPAREN
docNum	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
termVectorsWriter	TokenNameIdentifier
.	TokenNameDOT
addAllDocVectors	TokenNameIdentifier
(	TokenNameLPAREN
vectors	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkAbort	TokenNameIdentifier
.	TokenNameDOT
work	TokenNameIdentifier
(	TokenNameLPAREN
300	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
copyVectorsNoDeletions	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
TermVectorsWriter	TokenNameIdentifier
termVectorsWriter	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
TermVectorsReader	TokenNameIdentifier
matchingVectorsReader	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
MergeAbortedException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
maxDoc	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchingVectorsReader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
docCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
docCount	TokenNameIdentifier
<	TokenNameLESS
maxDoc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
MAX_RAW_MERGE_DOCS	TokenNameIdentifier
,	TokenNameCOMMA
maxDoc	TokenNameIdentifier
-	TokenNameMINUS
docCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
matchingVectorsReader	TokenNameIdentifier
.	TokenNameDOT
rawDocs	TokenNameIdentifier
(	TokenNameLPAREN
rawDocLengths	TokenNameIdentifier
,	TokenNameCOMMA
rawDocLengths2	TokenNameIdentifier
,	TokenNameCOMMA
docCount	TokenNameIdentifier
,	TokenNameCOMMA
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
termVectorsWriter	TokenNameIdentifier
.	TokenNameDOT
addRawDocuments	TokenNameIdentifier
(	TokenNameLPAREN
matchingVectorsReader	TokenNameIdentifier
,	TokenNameCOMMA
rawDocLengths	TokenNameIdentifier
,	TokenNameCOMMA
rawDocLengths2	TokenNameIdentifier
,	TokenNameCOMMA
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
len	TokenNameIdentifier
;	TokenNameSEMICOLON
checkAbort	TokenNameIdentifier
.	TokenNameDOT
work	TokenNameIdentifier
(	TokenNameLPAREN
300	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
docNum	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
docNum	TokenNameIdentifier
<	TokenNameLESS
maxDoc	TokenNameIdentifier
;	TokenNameSEMICOLON
docNum	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
TermFreqVector	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
vectors	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
getTermFreqVectors	TokenNameIdentifier
(	TokenNameLPAREN
docNum	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
termVectorsWriter	TokenNameIdentifier
.	TokenNameDOT
addAllDocVectors	TokenNameIdentifier
(	TokenNameLPAREN
vectors	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkAbort	TokenNameIdentifier
.	TokenNameDOT
work	TokenNameIdentifier
(	TokenNameLPAREN
300	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
SegmentMergeQueue	TokenNameIdentifier
queue	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
void	TokenNamevoid
mergeTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
FormatPostingsFieldsConsumer	TokenNameIdentifier
fieldsConsumer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FormatPostingsFieldsWriter	TokenNameIdentifier
(	TokenNameLPAREN
segmentWriteState	TokenNameIdentifier
,	TokenNameCOMMA
fieldInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
queue	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentMergeQueue	TokenNameIdentifier
(	TokenNameLPAREN
readers	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeTermInfos	TokenNameIdentifier
(	TokenNameLPAREN
fieldsConsumer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
fieldsConsumer	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
queue	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
queue	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
IndexOptions	TokenNameIdentifier
indexOptions	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
void	TokenNamevoid
mergeTermInfos	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
FormatPostingsFieldsConsumer	TokenNameIdentifier
consumer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
base	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
readerCount	TokenNameIdentifier
=	TokenNameEQUAL
readers	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
readerCount	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
=	TokenNameEQUAL
readers	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
TermEnum	TokenNameIdentifier
termEnum	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
terms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentMergeInfo	TokenNameIdentifier
smi	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentMergeInfo	TokenNameIdentifier
(	TokenNameLPAREN
base	TokenNameIdentifier
,	TokenNameCOMMA
termEnum	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
payloadProcessorProvider	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
smi	TokenNameIdentifier
.	TokenNameDOT
readerPayloadProcessor	TokenNameIdentifier
=	TokenNameEQUAL
payloadProcessorProvider	TokenNameIdentifier
.	TokenNameDOT
getReaderProcessor	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
docMap	TokenNameIdentifier
=	TokenNameEQUAL
smi	TokenNameIdentifier
.	TokenNameDOT
getDocMap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docMap	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
docMaps	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
docMaps	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
readerCount	TokenNameIdentifier
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
docMaps	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
docMap	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
base	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
reader	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
smi	TokenNameIdentifier
.	TokenNameDOT
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
smi	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
queue	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
smi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
smi	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
SegmentMergeInfo	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
match	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentMergeInfo	TokenNameIdentifier
[	TokenNameLBRACKET
readers	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
String	TokenNameIdentifier
currentField	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
FormatPostingsTermsConsumer	TokenNameIdentifier
termsConsumer	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
queue	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
matchSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
match	TokenNameIdentifier
[	TokenNameLBRACKET
matchSize	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
queue	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Term	TokenNameIdentifier
term	TokenNameIdentifier
=	TokenNameEQUAL
match	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
term	TokenNameIdentifier
;	TokenNameSEMICOLON
SegmentMergeInfo	TokenNameIdentifier
top	TokenNameIdentifier
=	TokenNameEQUAL
queue	TokenNameIdentifier
.	TokenNameDOT
top	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
top	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
term	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
top	TokenNameIdentifier
.	TokenNameDOT
term	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
match	TokenNameIdentifier
[	TokenNameLBRACKET
matchSize	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
queue	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
top	TokenNameIdentifier
=	TokenNameEQUAL
queue	TokenNameIdentifier
.	TokenNameDOT
top	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
currentField	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
term	TokenNameIdentifier
.	TokenNameDOT
field	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
currentField	TokenNameIdentifier
=	TokenNameEQUAL
term	TokenNameIdentifier
.	TokenNameDOT
field	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
termsConsumer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
termsConsumer	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
FieldInfo	TokenNameIdentifier
fieldInfo	TokenNameIdentifier
=	TokenNameEQUAL
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
(	TokenNameLPAREN
currentField	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
termsConsumer	TokenNameIdentifier
=	TokenNameEQUAL
consumer	TokenNameIdentifier
.	TokenNameDOT
addField	TokenNameIdentifier
(	TokenNameLPAREN
fieldInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
indexOptions	TokenNameIdentifier
=	TokenNameEQUAL
fieldInfo	TokenNameIdentifier
.	TokenNameDOT
indexOptions	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
df	TokenNameIdentifier
=	TokenNameEQUAL
appendPostings	TokenNameIdentifier
(	TokenNameLPAREN
termsConsumer	TokenNameIdentifier
,	TokenNameCOMMA
match	TokenNameIdentifier
,	TokenNameCOMMA
matchSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkAbort	TokenNameIdentifier
.	TokenNameDOT
work	TokenNameIdentifier
(	TokenNameLPAREN
df	TokenNameIdentifier
/	TokenNameDIVIDE
3.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
matchSize	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
SegmentMergeInfo	TokenNameIdentifier
smi	TokenNameIdentifier
=	TokenNameEQUAL
match	TokenNameIdentifier
[	TokenNameLBRACKET
--	TokenNameMINUS_MINUS
matchSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
smi	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
queue	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
smi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
smi	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
payloadBuffer	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
docMaps	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
appendPostings	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
FormatPostingsTermsConsumer	TokenNameIdentifier
termsConsumer	TokenNameIdentifier
,	TokenNameCOMMA
SegmentMergeInfo	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
smis	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
n	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
FormatPostingsDocsConsumer	TokenNameIdentifier
docConsumer	TokenNameIdentifier
=	TokenNameEQUAL
termsConsumer	TokenNameIdentifier
.	TokenNameDOT
addTerm	TokenNameIdentifier
(	TokenNameLPAREN
smis	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
term	TokenNameIdentifier
.	TokenNameDOT
text	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
df	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
n	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
SegmentMergeInfo	TokenNameIdentifier
smi	TokenNameIdentifier
=	TokenNameEQUAL
smis	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
TermPositions	TokenNameIdentifier
postings	TokenNameIdentifier
=	TokenNameEQUAL
smi	TokenNameIdentifier
.	TokenNameDOT
getPositions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
postings	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
base	TokenNameIdentifier
=	TokenNameEQUAL
smi	TokenNameIdentifier
.	TokenNameDOT
base	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
docMap	TokenNameIdentifier
=	TokenNameEQUAL
smi	TokenNameIdentifier
.	TokenNameDOT
getDocMap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
postings	TokenNameIdentifier
.	TokenNameDOT
seek	TokenNameIdentifier
(	TokenNameLPAREN
smi	TokenNameIdentifier
.	TokenNameDOT
termEnum	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
PayloadProcessor	TokenNameIdentifier
payloadProcessor	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
smi	TokenNameIdentifier
.	TokenNameDOT
readerPayloadProcessor	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
payloadProcessor	TokenNameIdentifier
=	TokenNameEQUAL
smi	TokenNameIdentifier
.	TokenNameDOT
readerPayloadProcessor	TokenNameIdentifier
.	TokenNameDOT
getProcessor	TokenNameIdentifier
(	TokenNameLPAREN
smi	TokenNameIdentifier
.	TokenNameDOT
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
postings	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
df	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
int	TokenNameint
doc	TokenNameIdentifier
=	TokenNameEQUAL
postings	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docMap	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
doc	TokenNameIdentifier
=	TokenNameEQUAL
docMap	TokenNameIdentifier
[	TokenNameLBRACKET
doc	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
doc	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
base	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
freq	TokenNameIdentifier
=	TokenNameEQUAL
postings	TokenNameIdentifier
.	TokenNameDOT
freq	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
FormatPostingsPositionsConsumer	TokenNameIdentifier
posConsumer	TokenNameIdentifier
=	TokenNameEQUAL
docConsumer	TokenNameIdentifier
.	TokenNameDOT
addDoc	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
,	TokenNameCOMMA
freq	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
indexOptions	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
IndexOptions	TokenNameIdentifier
.	TokenNameDOT
DOCS_AND_FREQS_AND_POSITIONS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
freq	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
position	TokenNameIdentifier
=	TokenNameEQUAL
postings	TokenNameIdentifier
.	TokenNameDOT
nextPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
payloadLength	TokenNameIdentifier
=	TokenNameEQUAL
postings	TokenNameIdentifier
.	TokenNameDOT
getPayloadLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
payloadLength	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
payloadBuffer	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
payloadBuffer	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
payloadLength	TokenNameIdentifier
)	TokenNameRPAREN
payloadBuffer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
payloadLength	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
postings	TokenNameIdentifier
.	TokenNameDOT
getPayload	TokenNameIdentifier
(	TokenNameLPAREN
payloadBuffer	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
payloadProcessor	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
payloadBuffer	TokenNameIdentifier
=	TokenNameEQUAL
payloadProcessor	TokenNameIdentifier
.	TokenNameDOT
processPayload	TokenNameIdentifier
(	TokenNameLPAREN
payloadBuffer	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
payloadLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
payloadLength	TokenNameIdentifier
=	TokenNameEQUAL
payloadProcessor	TokenNameIdentifier
.	TokenNameDOT
payloadLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
posConsumer	TokenNameIdentifier
.	TokenNameDOT
addPosition	TokenNameIdentifier
(	TokenNameLPAREN
position	TokenNameIdentifier
,	TokenNameCOMMA
payloadBuffer	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
payloadLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
posConsumer	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
docConsumer	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
df	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getAnyNonBulkMerges	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
matchedCount	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
readers	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
matchedCount	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
readers	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
mergeNorms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
bufferSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
:	TokenNameCOLON
readers	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bufferSize	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
bufferSize	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
normBuffer	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
IndexOutput	TokenNameIdentifier
output	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
int	TokenNameint
numFieldInfos	TokenNameIdentifier
=	TokenNameEQUAL
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numFieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
FieldInfo	TokenNameIdentifier
fi	TokenNameIdentifier
=	TokenNameEQUAL
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fi	TokenNameIdentifier
.	TokenNameDOT
isIndexed	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
fi	TokenNameIdentifier
.	TokenNameDOT
omitNorms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
output	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
output	TokenNameIdentifier
=	TokenNameEQUAL
directory	TokenNameIdentifier
.	TokenNameDOT
createOutput	TokenNameIdentifier
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
segment	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
NORMS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
writeBytes	TokenNameIdentifier
(	TokenNameLPAREN
SegmentNorms	TokenNameIdentifier
.	TokenNameDOT
NORMS_HEADER	TokenNameIdentifier
,	TokenNameCOMMA
SegmentNorms	TokenNameIdentifier
.	TokenNameDOT
NORMS_HEADER	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
normBuffer	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
normBuffer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
bufferSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
:	TokenNameCOLON
readers	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
maxDoc	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reader	TokenNameIdentifier
.	TokenNameDOT
norms	TokenNameIdentifier
(	TokenNameLPAREN
fi	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
,	TokenNameCOMMA
normBuffer	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
reader	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
output	TokenNameIdentifier
.	TokenNameDOT
writeBytes	TokenNameIdentifier
(	TokenNameLPAREN
normBuffer	TokenNameIdentifier
,	TokenNameCOMMA
maxDoc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
k	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
k	TokenNameIdentifier
<	TokenNameLESS
maxDoc	TokenNameIdentifier
;	TokenNameSEMICOLON
k	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
k	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
output	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
normBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
checkAbort	TokenNameIdentifier
.	TokenNameDOT
work	TokenNameIdentifier
(	TokenNameLPAREN
maxDoc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
IOUtils	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
IOUtils	TokenNameIdentifier
.	TokenNameDOT
closeWhileHandlingException	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
static	TokenNamestatic
class	TokenNameclass
CheckAbort	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
double	TokenNamedouble
workCount	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
CheckAbort	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
,	TokenNameCOMMA
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
merge	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
dir	TokenNameIdentifier
=	TokenNameEQUAL
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
work	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
units	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
MergeAbortedException	TokenNameIdentifier
{	TokenNameLBRACE
workCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
units	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
workCount	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
10000.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
checkAborted	TokenNameIdentifier
(	TokenNameLPAREN
dir	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
workCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
