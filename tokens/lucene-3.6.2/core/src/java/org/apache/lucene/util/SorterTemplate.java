package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
class	TokenNameclass
SorterTemplate	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MERGESORT_THRESHOLD	TokenNameIdentifier
=	TokenNameEQUAL
12	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
QUICKSORT_THRESHOLD	TokenNameIdentifier
=	TokenNameEQUAL
7	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
void	TokenNamevoid
swap	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
void	TokenNamevoid
setPivot	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
abstract	TokenNameabstract
int	TokenNameint
comparePivot	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
insertionSort	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
lo	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hi	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
lo	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
hi	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
>	TokenNameGREATER
lo	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
j	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
swap	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
quickSort	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
int	TokenNameint
lo	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
hi	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hi	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
lo	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
quickSort	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
Integer	TokenNameIdentifier
.	TokenNameDOT
SIZE	TokenNameIdentifier
-	TokenNameMINUS
Integer	TokenNameIdentifier
.	TokenNameDOT
numberOfLeadingZeros	TokenNameIdentifier
(	TokenNameLPAREN
hi	TokenNameIdentifier
-	TokenNameMINUS
lo	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
quickSort	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
lo	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hi	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
maxDepth	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
diff	TokenNameIdentifier
=	TokenNameEQUAL
hi	TokenNameIdentifier
-	TokenNameMINUS
lo	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
diff	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
QUICKSORT_THRESHOLD	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
insertionSort	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
maxDepth	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
mergeSort	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
mid	TokenNameIdentifier
=	TokenNameEQUAL
lo	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
diff	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
mid	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
swap	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
mid	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
(	TokenNameLPAREN
mid	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
swap	TokenNameIdentifier
(	TokenNameLPAREN
mid	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
mid	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
swap	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
mid	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
left	TokenNameIdentifier
=	TokenNameEQUAL
lo	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
right	TokenNameIdentifier
=	TokenNameEQUAL
hi	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
setPivot	TokenNameIdentifier
(	TokenNameLPAREN
mid	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
comparePivot	TokenNameIdentifier
(	TokenNameLPAREN
right	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
--	TokenNameMINUS_MINUS
right	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
left	TokenNameIdentifier
<	TokenNameLESS
right	TokenNameIdentifier
&&	TokenNameAND_AND
comparePivot	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
++	TokenNamePLUS_PLUS
left	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
left	TokenNameIdentifier
<	TokenNameLESS
right	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
swap	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
,	TokenNameCOMMA
right	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
--	TokenNameMINUS_MINUS
right	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
quickSort	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
left	TokenNameIdentifier
,	TokenNameCOMMA
maxDepth	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
quickSort	TokenNameIdentifier
(	TokenNameLPAREN
left	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
hi	TokenNameIdentifier
,	TokenNameCOMMA
maxDepth	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
mergeSort	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
lo	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hi	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
diff	TokenNameIdentifier
=	TokenNameEQUAL
hi	TokenNameIdentifier
-	TokenNameMINUS
lo	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
diff	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
MERGESORT_THRESHOLD	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
insertionSort	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
mid	TokenNameIdentifier
=	TokenNameEQUAL
lo	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
diff	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeSort	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
mid	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeSort	TokenNameIdentifier
(	TokenNameLPAREN
mid	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
mid	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
,	TokenNameCOMMA
mid	TokenNameIdentifier
-	TokenNameMINUS
lo	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
-	TokenNameMINUS
mid	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
merge	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
lo	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
pivot	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hi	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
len1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
len2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
len1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
len2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
len1	TokenNameIdentifier
+	TokenNamePLUS
len2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
(	TokenNameLPAREN
pivot	TokenNameIdentifier
,	TokenNameCOMMA
lo	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
swap	TokenNameIdentifier
(	TokenNameLPAREN
pivot	TokenNameIdentifier
,	TokenNameCOMMA
lo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
first_cut	TokenNameIdentifier
,	TokenNameCOMMA
second_cut	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
len11	TokenNameIdentifier
,	TokenNameCOMMA
len22	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
len1	TokenNameIdentifier
>	TokenNameGREATER
len2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
len11	TokenNameIdentifier
=	TokenNameEQUAL
len1	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
first_cut	TokenNameIdentifier
=	TokenNameEQUAL
lo	TokenNameIdentifier
+	TokenNamePLUS
len11	TokenNameIdentifier
;	TokenNameSEMICOLON
second_cut	TokenNameIdentifier
=	TokenNameEQUAL
lower	TokenNameIdentifier
(	TokenNameLPAREN
pivot	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
,	TokenNameCOMMA
first_cut	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
len22	TokenNameIdentifier
=	TokenNameEQUAL
second_cut	TokenNameIdentifier
-	TokenNameMINUS
pivot	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
len22	TokenNameIdentifier
=	TokenNameEQUAL
len2	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
second_cut	TokenNameIdentifier
=	TokenNameEQUAL
pivot	TokenNameIdentifier
+	TokenNamePLUS
len22	TokenNameIdentifier
;	TokenNameSEMICOLON
first_cut	TokenNameIdentifier
=	TokenNameEQUAL
upper	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
pivot	TokenNameIdentifier
,	TokenNameCOMMA
second_cut	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
len11	TokenNameIdentifier
=	TokenNameEQUAL
first_cut	TokenNameIdentifier
-	TokenNameMINUS
lo	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
rotate	TokenNameIdentifier
(	TokenNameLPAREN
first_cut	TokenNameIdentifier
,	TokenNameCOMMA
pivot	TokenNameIdentifier
,	TokenNameCOMMA
second_cut	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
new_mid	TokenNameIdentifier
=	TokenNameEQUAL
first_cut	TokenNameIdentifier
+	TokenNamePLUS
len22	TokenNameIdentifier
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
(	TokenNameLPAREN
lo	TokenNameIdentifier
,	TokenNameCOMMA
first_cut	TokenNameIdentifier
,	TokenNameCOMMA
new_mid	TokenNameIdentifier
,	TokenNameCOMMA
len11	TokenNameIdentifier
,	TokenNameCOMMA
len22	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
(	TokenNameLPAREN
new_mid	TokenNameIdentifier
,	TokenNameCOMMA
second_cut	TokenNameIdentifier
,	TokenNameCOMMA
hi	TokenNameIdentifier
,	TokenNameCOMMA
len1	TokenNameIdentifier
-	TokenNameMINUS
len11	TokenNameIdentifier
,	TokenNameCOMMA
len2	TokenNameIdentifier
-	TokenNameMINUS
len22	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
rotate	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
lo	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
mid	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hi	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
lot	TokenNameIdentifier
=	TokenNameEQUAL
lo	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
hit	TokenNameIdentifier
=	TokenNameEQUAL
mid	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
lot	TokenNameIdentifier
<	TokenNameLESS
hit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
swap	TokenNameIdentifier
(	TokenNameLPAREN
lot	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
hit	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lot	TokenNameIdentifier
=	TokenNameEQUAL
mid	TokenNameIdentifier
;	TokenNameSEMICOLON
hit	TokenNameIdentifier
=	TokenNameEQUAL
hi	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
lot	TokenNameIdentifier
<	TokenNameLESS
hit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
swap	TokenNameIdentifier
(	TokenNameLPAREN
lot	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
hit	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lot	TokenNameIdentifier
=	TokenNameEQUAL
lo	TokenNameIdentifier
;	TokenNameSEMICOLON
hit	TokenNameIdentifier
=	TokenNameEQUAL
hi	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
lot	TokenNameIdentifier
<	TokenNameLESS
hit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
swap	TokenNameIdentifier
(	TokenNameLPAREN
lot	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
hit	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
lower	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
lo	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hi	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
val	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
hi	TokenNameIdentifier
-	TokenNameMINUS
lo	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
len	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
half	TokenNameIdentifier
=	TokenNameEQUAL
len	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
mid	TokenNameIdentifier
=	TokenNameEQUAL
lo	TokenNameIdentifier
+	TokenNamePLUS
half	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
(	TokenNameLPAREN
mid	TokenNameIdentifier
,	TokenNameCOMMA
val	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
lo	TokenNameIdentifier
=	TokenNameEQUAL
mid	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
len	TokenNameIdentifier
=	TokenNameEQUAL
len	TokenNameIdentifier
-	TokenNameMINUS
half	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
len	TokenNameIdentifier
=	TokenNameEQUAL
half	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
lo	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
upper	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
lo	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
hi	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
val	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
len	TokenNameIdentifier
=	TokenNameEQUAL
hi	TokenNameIdentifier
-	TokenNameMINUS
lo	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
len	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
half	TokenNameIdentifier
=	TokenNameEQUAL
len	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
mid	TokenNameIdentifier
=	TokenNameEQUAL
lo	TokenNameIdentifier
+	TokenNamePLUS
half	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
compare	TokenNameIdentifier
(	TokenNameLPAREN
val	TokenNameIdentifier
,	TokenNameCOMMA
mid	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
len	TokenNameIdentifier
=	TokenNameEQUAL
half	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
lo	TokenNameIdentifier
=	TokenNameEQUAL
mid	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
len	TokenNameIdentifier
=	TokenNameEQUAL
len	TokenNameIdentifier
-	TokenNameMINUS
half	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
lo	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
