package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
class	TokenNameclass
UnicodeUtil	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
UnicodeUtil	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
UNI_SUR_HIGH_START	TokenNameIdentifier
=	TokenNameEQUAL
0xD800	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
UNI_SUR_HIGH_END	TokenNameIdentifier
=	TokenNameEQUAL
0xDBFF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
UNI_SUR_LOW_START	TokenNameIdentifier
=	TokenNameEQUAL
0xDC00	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
UNI_SUR_LOW_END	TokenNameIdentifier
=	TokenNameEQUAL
0xDFFF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
UNI_REPLACEMENT_CHAR	TokenNameIdentifier
=	TokenNameEQUAL
0xFFFD	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
UNI_MAX_BMP	TokenNameIdentifier
=	TokenNameEQUAL
0x0000FFFF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
HALF_BASE	TokenNameIdentifier
=	TokenNameEQUAL
0x0010000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
HALF_SHIFT	TokenNameIdentifier
=	TokenNameEQUAL
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
HALF_MASK	TokenNameIdentifier
=	TokenNameEQUAL
0x3FFL	TokenNameLongLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
SURROGATE_OFFSET	TokenNameIdentifier
=	TokenNameEQUAL
Character	TokenNameIdentifier
.	TokenNameDOT
MIN_SUPPLEMENTARY_CODE_POINT	TokenNameIdentifier
-	TokenNameMINUS
(	TokenNameLPAREN
UNI_SUR_HIGH_START	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
HALF_SHIFT	TokenNameIdentifier
)	TokenNameRPAREN
-	TokenNameMINUS
UNI_SUR_LOW_START	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
UTF8Result	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
result	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
10	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
length	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
void	TokenNamevoid
setLength	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
newLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
newLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
,	TokenNameCOMMA
newLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
length	TokenNameIdentifier
=	TokenNameEQUAL
newLength	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
UTF16Result	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
result	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
10	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
offsets	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
10	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
length	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
void	TokenNamevoid
setLength	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
newLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
newLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
,	TokenNameCOMMA
newLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
length	TokenNameIdentifier
=	TokenNameEQUAL
newLength	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
copyText	TokenNameIdentifier
(	TokenNameLPAREN
UTF16Result	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
setLength	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
result	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
result	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
int	TokenNameint
UTF16toUTF8WithHash	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
source	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
length	TokenNameIdentifier
,	TokenNameCOMMA
BytesRef	TokenNameIdentifier
result	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
hash	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
upto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
maxLen	TokenNameIdentifier
=	TokenNameEQUAL
length	TokenNameIdentifier
*	TokenNameMULTIPLY
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
out	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
maxLen	TokenNameIdentifier
)	TokenNameRPAREN
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
oversize	TokenNameIdentifier
(	TokenNameLPAREN
maxLen	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
code	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
source	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x80	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
code	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x800	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xC0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xD800	TokenNameIntegerLiteral
||	TokenNameOR_OR
code	TokenNameIdentifier
>	TokenNameGREATER
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xE0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
source	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
utf32	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
code	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
10	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
utf32	TokenNameIdentifier
+	TokenNamePLUS
SURROGATE_OFFSET	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xF0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
18	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xEF	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBF	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hash	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hash	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBD	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
=	TokenNameEQUAL
upto	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
hash	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
UTF16toUTF8	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
source	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
UTF8Result	TokenNameIdentifier
result	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
upto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
result	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
code	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
source	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
upto	TokenNameIdentifier
+	TokenNamePLUS
4	TokenNameIntegerLiteral
>	TokenNameGREATER
out	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
result	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
out	TokenNameIdentifier
,	TokenNameCOMMA
upto	TokenNameIdentifier
+	TokenNamePLUS
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x80	TokenNameIntegerLiteral
)	TokenNameRPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
code	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x800	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xC0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xD800	TokenNameIntegerLiteral
||	TokenNameOR_OR
code	TokenNameIdentifier
>	TokenNameGREATER
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0xffff	TokenNameIntegerLiteral
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xE0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
source	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
0xffff	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
source	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
utf32	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
-	TokenNameMINUS
0xD7C0	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
10	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
utf32	TokenNameIdentifier
&	TokenNameAND
0x3FF	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xF0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
18	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xEF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBD	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
=	TokenNameEQUAL
upto	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
UTF16toUTF8	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
source	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
length	TokenNameIdentifier
,	TokenNameCOMMA
UTF8Result	TokenNameIdentifier
result	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
upto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
result	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
code	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
source	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
upto	TokenNameIdentifier
+	TokenNamePLUS
4	TokenNameIntegerLiteral
>	TokenNameGREATER
out	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
result	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
out	TokenNameIdentifier
,	TokenNameCOMMA
upto	TokenNameIdentifier
+	TokenNamePLUS
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x80	TokenNameIntegerLiteral
)	TokenNameRPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
code	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x800	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xC0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xD800	TokenNameIntegerLiteral
||	TokenNameOR_OR
code	TokenNameIdentifier
>	TokenNameGREATER
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xE0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
&&	TokenNameAND_AND
source	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
0xffff	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
source	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
utf32	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
-	TokenNameMINUS
0xD7C0	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
10	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
utf32	TokenNameIdentifier
&	TokenNameAND
0x3FF	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xF0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
18	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xEF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBD	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
=	TokenNameEQUAL
upto	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
UTF16toUTF8	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
String	TokenNameIdentifier
s	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
length	TokenNameIdentifier
,	TokenNameCOMMA
UTF8Result	TokenNameIdentifier
result	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
result	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
upto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
code	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
s	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
upto	TokenNameIdentifier
+	TokenNamePLUS
4	TokenNameIntegerLiteral
>	TokenNameGREATER
out	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
result	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
out	TokenNameIdentifier
,	TokenNameCOMMA
upto	TokenNameIdentifier
+	TokenNamePLUS
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x80	TokenNameIntegerLiteral
)	TokenNameRPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
code	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x800	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xC0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xD800	TokenNameIntegerLiteral
||	TokenNameOR_OR
code	TokenNameIdentifier
>	TokenNameGREATER
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xE0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
s	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
utf32	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
-	TokenNameMINUS
0xD7C0	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
10	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
utf32	TokenNameIdentifier
&	TokenNameAND
0x3FF	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xF0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
18	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xEF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBD	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
=	TokenNameEQUAL
upto	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
UTF16toUTF8	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
CharSequence	TokenNameIdentifier
s	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
length	TokenNameIdentifier
,	TokenNameCOMMA
BytesRef	TokenNameIdentifier
result	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
maxLen	TokenNameIdentifier
=	TokenNameEQUAL
length	TokenNameIdentifier
*	TokenNameMULTIPLY
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
out	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
maxLen	TokenNameIdentifier
)	TokenNameRPAREN
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
maxLen	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
upto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
code	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
s	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x80	TokenNameIntegerLiteral
)	TokenNameRPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
code	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x800	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xC0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xD800	TokenNameIntegerLiteral
||	TokenNameOR_OR
code	TokenNameIdentifier
>	TokenNameGREATER
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xE0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
s	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
utf32	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
code	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
10	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
utf32	TokenNameIdentifier
+	TokenNamePLUS
SURROGATE_OFFSET	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xF0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
18	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xEF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBD	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
=	TokenNameEQUAL
upto	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
UTF16toUTF8	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
source	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
length	TokenNameIdentifier
,	TokenNameCOMMA
BytesRef	TokenNameIdentifier
result	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
upto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
maxLen	TokenNameIdentifier
=	TokenNameEQUAL
length	TokenNameIdentifier
*	TokenNameMULTIPLY
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
out	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
maxLen	TokenNameIdentifier
)	TokenNameRPAREN
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
maxLen	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
code	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
source	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x80	TokenNameIntegerLiteral
)	TokenNameRPAREN
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
code	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0x800	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xC0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xD800	TokenNameIntegerLiteral
||	TokenNameOR_OR
code	TokenNameIdentifier
>	TokenNameGREATER
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xE0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
source	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0xDC00	TokenNameIntegerLiteral
&&	TokenNameAND_AND
utf32	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0xDFFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
utf32	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
code	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
10	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
utf32	TokenNameIdentifier
+	TokenNamePLUS
SURROGATE_OFFSET	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0xF0	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
18	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
(	TokenNameLPAREN
utf32	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
utf32	TokenNameIdentifier
&	TokenNameAND
0x3F	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xEF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0xBD	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
=	TokenNameEQUAL
upto	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
UTF8toUTF16	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
utf8	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
int	TokenNameint
length	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
UTF16Result	TokenNameIdentifier
result	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
result	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
offsets	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
offsets	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
upto	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
upto	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
int	TokenNameint
outUpto	TokenNameIdentifier
=	TokenNameEQUAL
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
outUpto	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
out	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
result	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
out	TokenNameIdentifier
,	TokenNameCOMMA
outUpto	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
upto	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
b	TokenNameIdentifier
=	TokenNameEQUAL
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
outUpto	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
<	TokenNameLESS
0xc0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
b	TokenNameIdentifier
<	TokenNameLESS
0x80	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
=	TokenNameEQUAL
b	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
<	TokenNameLESS
0xe0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
b	TokenNameIdentifier
&	TokenNameAND
0x1f	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
<	TokenNameLESS
0xf0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
ch	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
b	TokenNameIdentifier
&	TokenNameAND
0xf	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
assert	TokenNameassert
b	TokenNameIdentifier
<	TokenNameLESS
0xf8	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
ch	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
b	TokenNameIdentifier
&	TokenNameAND
0x7	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
18	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
UNI_MAX_BMP	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
outUpto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
chHalf	TokenNameIdentifier
=	TokenNameEQUAL
ch	TokenNameIdentifier
-	TokenNameMINUS
HALF_BASE	TokenNameIdentifier
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
outUpto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
chHalf	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
HALF_SHIFT	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
UNI_SUR_HIGH_START	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
outUpto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
chHalf	TokenNameIdentifier
&	TokenNameAND
HALF_MASK	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
UNI_SUR_LOW_START	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
offsets	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
outUpto	TokenNameIdentifier
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
=	TokenNameEQUAL
outUpto	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
LEAD_SURROGATE_SHIFT_	TokenNameIdentifier
=	TokenNameEQUAL
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
TRAIL_SURROGATE_MASK_	TokenNameIdentifier
=	TokenNameEQUAL
0x3FF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
TRAIL_SURROGATE_MIN_VALUE	TokenNameIdentifier
=	TokenNameEQUAL
0xDC00	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
LEAD_SURROGATE_MIN_VALUE	TokenNameIdentifier
=	TokenNameEQUAL
0xD800	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
SUPPLEMENTARY_MIN_VALUE	TokenNameIdentifier
=	TokenNameEQUAL
0x10000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
LEAD_SURROGATE_OFFSET_	TokenNameIdentifier
=	TokenNameEQUAL
LEAD_SURROGATE_MIN_VALUE	TokenNameIdentifier
-	TokenNameMINUS
(	TokenNameLPAREN
SUPPLEMENTARY_MIN_VALUE	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
LEAD_SURROGATE_SHIFT_	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
String	TokenNameIdentifier
newString	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
codePoints	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
chars	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
count	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
w	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
r	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
,	TokenNameCOMMA
e	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
+	TokenNamePLUS
count	TokenNameIdentifier
;	TokenNameSEMICOLON
r	TokenNameIdentifier
<	TokenNameLESS
e	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
r	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
cp	TokenNameIdentifier
=	TokenNameEQUAL
codePoints	TokenNameIdentifier
[	TokenNameLBRACKET
r	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cp	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
cp	TokenNameIdentifier
>	TokenNameGREATER
0x10ffff	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cp	TokenNameIdentifier
<	TokenNameLESS
0x010000	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
chars	TokenNameIdentifier
[	TokenNameLBRACKET
w	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
cp	TokenNameIdentifier
;	TokenNameSEMICOLON
w	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
chars	TokenNameIdentifier
[	TokenNameLBRACKET
w	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
LEAD_SURROGATE_OFFSET_	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
cp	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
LEAD_SURROGATE_SHIFT_	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
chars	TokenNameIdentifier
[	TokenNameLBRACKET
w	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
TRAIL_SURROGATE_MIN_VALUE	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
cp	TokenNameIdentifier
&	TokenNameAND
TRAIL_SURROGATE_MASK_	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
w	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IndexOutOfBoundsException	TokenNameIdentifier
ex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
newlen	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
Math	TokenNameIdentifier
.	TokenNameDOT
ceil	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
codePoints	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
w	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
/	TokenNameDIVIDE
(	TokenNameLPAREN
r	TokenNameIdentifier
-	TokenNameMINUS
offset	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
temp	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
newlen	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
chars	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
temp	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
w	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
chars	TokenNameIdentifier
=	TokenNameEQUAL
temp	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
String	TokenNameIdentifier
(	TokenNameLPAREN
chars	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
w	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
UTF8toUTF16	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
utf8	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
,	TokenNameCOMMA
CharsRef	TokenNameIdentifier
chars	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
out_offset	TokenNameIdentifier
=	TokenNameEQUAL
chars	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
out	TokenNameIdentifier
=	TokenNameEQUAL
chars	TokenNameIdentifier
.	TokenNameDOT
chars	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
chars	TokenNameIdentifier
.	TokenNameDOT
chars	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
limit	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
offset	TokenNameIdentifier
<	TokenNameLESS
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
b	TokenNameIdentifier
=	TokenNameEQUAL
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
<	TokenNameLESS
0xc0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
b	TokenNameIdentifier
<	TokenNameLESS
0x80	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
out_offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
b	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
<	TokenNameLESS
0xe0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
out_offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b	TokenNameIdentifier
&	TokenNameAND
0x1f	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
<	TokenNameLESS
0xf0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
out_offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
b	TokenNameIdentifier
&	TokenNameAND
0xf	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
offset	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
assert	TokenNameassert
b	TokenNameIdentifier
<	TokenNameLESS
0xf8	TokenNameIntegerLiteral
:	TokenNameCOLON
"b="	TokenNameStringLiteral
+	TokenNamePLUS
b	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
ch	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
b	TokenNameIdentifier
&	TokenNameAND
0x7	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
18	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
12	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
utf8	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
offset	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
<	TokenNameLESS
UNI_MAX_BMP	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
[	TokenNameLBRACKET
out_offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
ch	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
chHalf	TokenNameIdentifier
=	TokenNameEQUAL
ch	TokenNameIdentifier
-	TokenNameMINUS
0x0010000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
out_offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
chHalf	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
10	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
0xD800	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
[	TokenNameLBRACKET
out_offset	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
chHalf	TokenNameIdentifier
&	TokenNameAND
HALF_MASK	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
0xDC00	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
chars	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
=	TokenNameEQUAL
out_offset	TokenNameIdentifier
-	TokenNameMINUS
chars	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
UTF8toUTF16	TokenNameIdentifier
(	TokenNameLPAREN
BytesRef	TokenNameIdentifier
bytesRef	TokenNameIdentifier
,	TokenNameCOMMA
CharsRef	TokenNameIdentifier
chars	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
UTF8toUTF16	TokenNameIdentifier
(	TokenNameLPAREN
bytesRef	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
,	TokenNameCOMMA
bytesRef	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
,	TokenNameCOMMA
bytesRef	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
,	TokenNameCOMMA
chars	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
validUTF16String	TokenNameIdentifier
(	TokenNameLPAREN
CharSequence	TokenNameIdentifier
s	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
s	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
size	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
ch	TokenNameIdentifier
=	TokenNameEQUAL
s	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
UNI_SUR_HIGH_START	TokenNameIdentifier
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
UNI_SUR_HIGH_END	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
size	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
char	TokenNamechar
nextCH	TokenNameIdentifier
=	TokenNameEQUAL
s	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nextCH	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
UNI_SUR_LOW_START	TokenNameIdentifier
&&	TokenNameAND_AND
nextCH	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
UNI_SUR_LOW_END	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
else	TokenNameelse
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
ch	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
UNI_SUR_LOW_START	TokenNameIdentifier
&&	TokenNameAND_AND
ch	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
UNI_SUR_LOW_END	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
