package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
queryParser	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
StringReader	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
text	TokenNameIdentifier
.	TokenNameDOT
Collator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
text	TokenNameIdentifier
.	TokenNameDOT
DateFormat	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Calendar	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Date	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashMap	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Locale	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Map	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
Analyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
CachingTokenFilter	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
TokenStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
tokenattributes	TokenNameIdentifier
.	TokenNameDOT
PositionIncrementAttribute	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
tokenattributes	TokenNameIdentifier
.	TokenNameDOT
CharTermAttribute	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
.	TokenNameDOT
DateField	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
.	TokenNameDOT
DateTools	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
Term	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
BooleanClause	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
BooleanQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
FuzzyQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
MultiTermQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
MatchAllDocsQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
MultiPhraseQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
PhraseQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
PrefixQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
Query	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
TermRangeQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
TermQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
WildcardQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Version	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
VirtualMethod	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
QueryParser	TokenNameIdentifier
implements	TokenNameimplements
QueryParserConstants	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
CONJ_NONE	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
CONJ_AND	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
CONJ_OR	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MOD_NONE	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MOD_NOT	TokenNameIdentifier
=	TokenNameEQUAL
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
MOD_REQ	TokenNameIdentifier
=	TokenNameEQUAL
11	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
Operator	TokenNameIdentifier
AND_OPERATOR	TokenNameIdentifier
=	TokenNameEQUAL
Operator	TokenNameIdentifier
.	TokenNameDOT
AND	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
Operator	TokenNameIdentifier
OR_OPERATOR	TokenNameIdentifier
=	TokenNameEQUAL
Operator	TokenNameIdentifier
.	TokenNameDOT
OR	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Operator	TokenNameIdentifier
operator	TokenNameIdentifier
=	TokenNameEQUAL
OR_OPERATOR	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
lowercaseExpandedTerms	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
MultiTermQuery	TokenNameIdentifier
.	TokenNameDOT
RewriteMethod	TokenNameIdentifier
multiTermRewriteMethod	TokenNameIdentifier
=	TokenNameEQUAL
MultiTermQuery	TokenNameIdentifier
.	TokenNameDOT
CONSTANT_SCORE_AUTO_REWRITE_DEFAULT	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
allowLeadingWildcard	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
enablePositionIncrements	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
Analyzer	TokenNameIdentifier
analyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
String	TokenNameIdentifier
field	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
phraseSlop	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
float	TokenNamefloat
fuzzyMinSim	TokenNameIdentifier
=	TokenNameEQUAL
FuzzyQuery	TokenNameIdentifier
.	TokenNameDOT
defaultMinSimilarity	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
fuzzyPrefixLength	TokenNameIdentifier
=	TokenNameEQUAL
FuzzyQuery	TokenNameIdentifier
.	TokenNameDOT
defaultPrefixLength	TokenNameIdentifier
;	TokenNameSEMICOLON
Locale	TokenNameIdentifier
locale	TokenNameIdentifier
=	TokenNameEQUAL
Locale	TokenNameIdentifier
.	TokenNameDOT
getDefault	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
DateTools	TokenNameIdentifier
.	TokenNameDOT
Resolution	TokenNameIdentifier
dateResolution	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
DateTools	TokenNameIdentifier
.	TokenNameDOT
Resolution	TokenNameIdentifier
>	TokenNameGREATER
fieldToDateResolution	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
Collator	TokenNameIdentifier
rangeCollator	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
VirtualMethod	TokenNameIdentifier
<	TokenNameLESS
QueryParser	TokenNameIdentifier
>	TokenNameGREATER
getFieldQueryMethod	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
VirtualMethod	TokenNameIdentifier
<	TokenNameLESS
QueryParser	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
QueryParser	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
,	TokenNameCOMMA
"getFieldQuery"	TokenNameStringLiteral
,	TokenNameCOMMA
String	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
,	TokenNameCOMMA
String	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
)	TokenNameRPAREN
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
VirtualMethod	TokenNameIdentifier
<	TokenNameLESS
QueryParser	TokenNameIdentifier
>	TokenNameGREATER
getFieldQueryWithQuotedMethod	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
VirtualMethod	TokenNameIdentifier
<	TokenNameLESS
QueryParser	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
QueryParser	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
,	TokenNameCOMMA
"getFieldQuery"	TokenNameStringLiteral
,	TokenNameCOMMA
String	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
,	TokenNameCOMMA
String	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
,	TokenNameCOMMA
boolean	TokenNameboolean
.	TokenNameDOT
class	TokenNameclass
)	TokenNameRPAREN
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
hasNewAPI	TokenNameIdentifier
=	TokenNameEQUAL
VirtualMethod	TokenNameIdentifier
.	TokenNameDOT
compareImplementationDistance	TokenNameIdentifier
(	TokenNameLPAREN
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
getFieldQueryWithQuotedMethod	TokenNameIdentifier
,	TokenNameCOMMA
getFieldQueryMethod	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
autoGeneratePhraseQueries	TokenNameIdentifier
;	TokenNameSEMICOLON
static	TokenNamestatic
public	TokenNamepublic
enum	TokenNameenum
Operator	TokenNameIdentifier
{	TokenNameLBRACE
OR	TokenNameIdentifier
,	TokenNameCOMMA
AND	TokenNameIdentifier
}	TokenNameRBRACE
public	TokenNamepublic
QueryParser	TokenNameIdentifier
(	TokenNameLPAREN
Version	TokenNameIdentifier
matchVersion	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
f	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
a	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
new	TokenNamenew
FastCharStream	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
StringReader	TokenNameIdentifier
(	TokenNameLPAREN
""	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
analyzer	TokenNameIdentifier
=	TokenNameEQUAL
a	TokenNameIdentifier
;	TokenNameSEMICOLON
field	TokenNameIdentifier
=	TokenNameEQUAL
f	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchVersion	TokenNameIdentifier
.	TokenNameDOT
onOrAfter	TokenNameIdentifier
(	TokenNameLPAREN
Version	TokenNameIdentifier
.	TokenNameDOT
LUCENE_29	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
enablePositionIncrements	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
enablePositionIncrements	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
matchVersion	TokenNameIdentifier
.	TokenNameDOT
onOrAfter	TokenNameIdentifier
(	TokenNameLPAREN
Version	TokenNameIdentifier
.	TokenNameDOT
LUCENE_31	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
setAutoGeneratePhraseQueries	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
setAutoGeneratePhraseQueries	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
Query	TokenNameIdentifier
parse	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
query	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
ReInit	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
FastCharStream	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
StringReader	TokenNameIdentifier
(	TokenNameLPAREN
query	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
Query	TokenNameIdentifier
res	TokenNameIdentifier
=	TokenNameEQUAL
TopLevelQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
res	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
res	TokenNameIdentifier
:	TokenNameCOLON
newBooleanQuery	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ParseException	TokenNameIdentifier
tme	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ParseException	TokenNameIdentifier
e	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot parse '"	TokenNameStringLiteral
+	TokenNamePLUS
query	TokenNameIdentifier
+	TokenNamePLUS
"': "	TokenNameStringLiteral
+	TokenNamePLUS
tme	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
e	TokenNameIdentifier
.	TokenNameDOT
initCause	TokenNameIdentifier
(	TokenNameLPAREN
tme	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
e	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
TokenMgrError	TokenNameIdentifier
tme	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ParseException	TokenNameIdentifier
e	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot parse '"	TokenNameStringLiteral
+	TokenNamePLUS
query	TokenNameIdentifier
+	TokenNamePLUS
"': "	TokenNameStringLiteral
+	TokenNamePLUS
tme	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
e	TokenNameIdentifier
.	TokenNameDOT
initCause	TokenNameIdentifier
(	TokenNameLPAREN
tme	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
e	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
BooleanQuery	TokenNameIdentifier
.	TokenNameDOT
TooManyClauses	TokenNameIdentifier
tmc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ParseException	TokenNameIdentifier
e	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot parse '"	TokenNameStringLiteral
+	TokenNamePLUS
query	TokenNameIdentifier
+	TokenNamePLUS
"': too many boolean clauses"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
e	TokenNameIdentifier
.	TokenNameDOT
initCause	TokenNameIdentifier
(	TokenNameLPAREN
tmc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
e	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
Analyzer	TokenNameIdentifier
getAnalyzer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
analyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
String	TokenNameIdentifier
getField	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
field	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
boolean	TokenNameboolean
getAutoGeneratePhraseQueries	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
autoGeneratePhraseQueries	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
setAutoGeneratePhraseQueries	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
value	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
value	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
false	TokenNamefalse
&&	TokenNameAND_AND
!	TokenNameNOT
hasNewAPI	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"You must implement the new API: getFieldQuery(String,String,boolean)"	TokenNameStringLiteral
+	TokenNamePLUS
" to use setAutoGeneratePhraseQueries(false)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
autoGeneratePhraseQueries	TokenNameIdentifier
=	TokenNameEQUAL
value	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
float	TokenNamefloat
getFuzzyMinSim	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fuzzyMinSim	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setFuzzyMinSim	TokenNameIdentifier
(	TokenNameLPAREN
float	TokenNamefloat
fuzzyMinSim	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fuzzyMinSim	TokenNameIdentifier
=	TokenNameEQUAL
fuzzyMinSim	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getFuzzyPrefixLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fuzzyPrefixLength	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setFuzzyPrefixLength	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
fuzzyPrefixLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
fuzzyPrefixLength	TokenNameIdentifier
=	TokenNameEQUAL
fuzzyPrefixLength	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPhraseSlop	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
phraseSlop	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
phraseSlop	TokenNameIdentifier
=	TokenNameEQUAL
phraseSlop	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getPhraseSlop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
phraseSlop	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setAllowLeadingWildcard	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
allowLeadingWildcard	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
allowLeadingWildcard	TokenNameIdentifier
=	TokenNameEQUAL
allowLeadingWildcard	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getAllowLeadingWildcard	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
allowLeadingWildcard	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setEnablePositionIncrements	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
enable	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
enablePositionIncrements	TokenNameIdentifier
=	TokenNameEQUAL
enable	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getEnablePositionIncrements	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
enablePositionIncrements	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setDefaultOperator	TokenNameIdentifier
(	TokenNameLPAREN
Operator	TokenNameIdentifier
op	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
operator	TokenNameIdentifier
=	TokenNameEQUAL
op	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Operator	TokenNameIdentifier
getDefaultOperator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
operator	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setLowercaseExpandedTerms	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
lowercaseExpandedTerms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
lowercaseExpandedTerms	TokenNameIdentifier
=	TokenNameEQUAL
lowercaseExpandedTerms	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getLowercaseExpandedTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
lowercaseExpandedTerms	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setMultiTermRewriteMethod	TokenNameIdentifier
(	TokenNameLPAREN
MultiTermQuery	TokenNameIdentifier
.	TokenNameDOT
RewriteMethod	TokenNameIdentifier
method	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
multiTermRewriteMethod	TokenNameIdentifier
=	TokenNameEQUAL
method	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
MultiTermQuery	TokenNameIdentifier
.	TokenNameDOT
RewriteMethod	TokenNameIdentifier
getMultiTermRewriteMethod	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
multiTermRewriteMethod	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setLocale	TokenNameIdentifier
(	TokenNameLPAREN
Locale	TokenNameIdentifier
locale	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
locale	TokenNameIdentifier
=	TokenNameEQUAL
locale	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Locale	TokenNameIdentifier
getLocale	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
locale	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setDateResolution	TokenNameIdentifier
(	TokenNameLPAREN
DateTools	TokenNameIdentifier
.	TokenNameDOT
Resolution	TokenNameIdentifier
dateResolution	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
dateResolution	TokenNameIdentifier
=	TokenNameEQUAL
dateResolution	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setDateResolution	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
fieldName	TokenNameIdentifier
,	TokenNameCOMMA
DateTools	TokenNameIdentifier
.	TokenNameDOT
Resolution	TokenNameIdentifier
dateResolution	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fieldName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Field cannot be null."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fieldToDateResolution	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
fieldToDateResolution	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
DateTools	TokenNameIdentifier
.	TokenNameDOT
Resolution	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fieldToDateResolution	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
fieldName	TokenNameIdentifier
,	TokenNameCOMMA
dateResolution	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
DateTools	TokenNameIdentifier
.	TokenNameDOT
Resolution	TokenNameIdentifier
getDateResolution	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
fieldName	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fieldName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Field cannot be null."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fieldToDateResolution	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
this	TokenNamethis
.	TokenNameDOT
dateResolution	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
DateTools	TokenNameIdentifier
.	TokenNameDOT
Resolution	TokenNameIdentifier
resolution	TokenNameIdentifier
=	TokenNameEQUAL
fieldToDateResolution	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
fieldName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
resolution	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
resolution	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
dateResolution	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
resolution	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setRangeCollator	TokenNameIdentifier
(	TokenNameLPAREN
Collator	TokenNameIdentifier
rc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
rangeCollator	TokenNameIdentifier
=	TokenNameEQUAL
rc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Collator	TokenNameIdentifier
getRangeCollator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
rangeCollator	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
addClause	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
BooleanClause	TokenNameIdentifier
>	TokenNameGREATER
clauses	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
conj	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
mods	TokenNameIdentifier
,	TokenNameCOMMA
Query	TokenNameIdentifier
q	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
required	TokenNameIdentifier
,	TokenNameCOMMA
prohibited	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
clauses	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
conj	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CONJ_AND	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
BooleanClause	TokenNameIdentifier
c	TokenNameIdentifier
=	TokenNameEQUAL
clauses	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
clauses	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
c	TokenNameIdentifier
.	TokenNameDOT
isProhibited	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
c	TokenNameIdentifier
.	TokenNameDOT
setOccur	TokenNameIdentifier
(	TokenNameLPAREN
BooleanClause	TokenNameIdentifier
.	TokenNameDOT
Occur	TokenNameIdentifier
.	TokenNameDOT
MUST	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
clauses	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
operator	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
AND_OPERATOR	TokenNameIdentifier
&&	TokenNameAND_AND
conj	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CONJ_OR	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
BooleanClause	TokenNameIdentifier
c	TokenNameIdentifier
=	TokenNameEQUAL
clauses	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
clauses	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
c	TokenNameIdentifier
.	TokenNameDOT
isProhibited	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
c	TokenNameIdentifier
.	TokenNameDOT
setOccur	TokenNameIdentifier
(	TokenNameLPAREN
BooleanClause	TokenNameIdentifier
.	TokenNameDOT
Occur	TokenNameIdentifier
.	TokenNameDOT
SHOULD	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
q	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
operator	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
OR_OPERATOR	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
prohibited	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
mods	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
MOD_NOT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
required	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
mods	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
MOD_REQ	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
conj	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CONJ_AND	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
prohibited	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
required	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
prohibited	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
mods	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
MOD_NOT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
required	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
!	TokenNameNOT
prohibited	TokenNameIdentifier
&&	TokenNameAND_AND
conj	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
CONJ_OR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
required	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
prohibited	TokenNameIdentifier
)	TokenNameRPAREN
clauses	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
newBooleanClause	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
BooleanClause	TokenNameIdentifier
.	TokenNameDOT
Occur	TokenNameIdentifier
.	TokenNameDOT
MUST	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
required	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
prohibited	TokenNameIdentifier
)	TokenNameRPAREN
clauses	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
newBooleanClause	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
BooleanClause	TokenNameIdentifier
.	TokenNameDOT
Occur	TokenNameIdentifier
.	TokenNameDOT
SHOULD	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
required	TokenNameIdentifier
&&	TokenNameAND_AND
prohibited	TokenNameIdentifier
)	TokenNameRPAREN
clauses	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
newBooleanClause	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
BooleanClause	TokenNameIdentifier
.	TokenNameDOT
Occur	TokenNameIdentifier
.	TokenNameDOT
MUST_NOT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Clause cannot be both required and prohibited"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
protected	TokenNameprotected
Query	TokenNameIdentifier
getFieldQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
queryText	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
getFieldQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
queryText	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
getFieldQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
queryText	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
quoted	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
TokenStream	TokenNameIdentifier
source	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
source	TokenNameIdentifier
=	TokenNameEQUAL
analyzer	TokenNameIdentifier
.	TokenNameDOT
reusableTokenStream	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
StringReader	TokenNameIdentifier
(	TokenNameLPAREN
queryText	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
source	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
source	TokenNameIdentifier
=	TokenNameEQUAL
analyzer	TokenNameIdentifier
.	TokenNameDOT
tokenStream	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
StringReader	TokenNameIdentifier
(	TokenNameLPAREN
queryText	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
CachingTokenFilter	TokenNameIdentifier
buffer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CachingTokenFilter	TokenNameIdentifier
(	TokenNameLPAREN
source	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
CharTermAttribute	TokenNameIdentifier
termAtt	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
PositionIncrementAttribute	TokenNameIdentifier
posIncrAtt	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
numTokens	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
buffer	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
buffer	TokenNameIdentifier
.	TokenNameDOT
hasAttribute	TokenNameIdentifier
(	TokenNameLPAREN
CharTermAttribute	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
termAtt	TokenNameIdentifier
=	TokenNameEQUAL
buffer	TokenNameIdentifier
.	TokenNameDOT
getAttribute	TokenNameIdentifier
(	TokenNameLPAREN
CharTermAttribute	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
buffer	TokenNameIdentifier
.	TokenNameDOT
hasAttribute	TokenNameIdentifier
(	TokenNameLPAREN
PositionIncrementAttribute	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
posIncrAtt	TokenNameIdentifier
=	TokenNameEQUAL
buffer	TokenNameIdentifier
.	TokenNameDOT
getAttribute	TokenNameIdentifier
(	TokenNameLPAREN
PositionIncrementAttribute	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
positionCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
severalTokensAtSamePosition	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
hasMoreTokens	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
termAtt	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
hasMoreTokens	TokenNameIdentifier
=	TokenNameEQUAL
buffer	TokenNameIdentifier
.	TokenNameDOT
incrementToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
hasMoreTokens	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
numTokens	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
int	TokenNameint
positionIncrement	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
posIncrAtt	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
?	TokenNameQUESTION
posIncrAtt	TokenNameIdentifier
.	TokenNameDOT
getPositionIncrement	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
positionIncrement	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
positionCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
positionIncrement	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
severalTokensAtSamePosition	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
hasMoreTokens	TokenNameIdentifier
=	TokenNameEQUAL
buffer	TokenNameIdentifier
.	TokenNameDOT
incrementToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
buffer	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
source	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
numTokens	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
numTokens	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
term	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
boolean	TokenNameboolean
hasNext	TokenNameIdentifier
=	TokenNameEQUAL
buffer	TokenNameIdentifier
.	TokenNameDOT
incrementToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
hasNext	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
termAtt	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
return	TokenNamereturn
newTermQuery	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Term	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
term	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
severalTokensAtSamePosition	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
!	TokenNameNOT
quoted	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
autoGeneratePhraseQueries	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
positionCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
!	TokenNameNOT
quoted	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
autoGeneratePhraseQueries	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
BooleanQuery	TokenNameIdentifier
q	TokenNameIdentifier
=	TokenNameEQUAL
newBooleanQuery	TokenNameIdentifier
(	TokenNameLPAREN
positionCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
BooleanClause	TokenNameIdentifier
.	TokenNameDOT
Occur	TokenNameIdentifier
occur	TokenNameIdentifier
=	TokenNameEQUAL
positionCount	TokenNameIdentifier
>	TokenNameGREATER
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
operator	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
AND_OPERATOR	TokenNameIdentifier
?	TokenNameQUESTION
BooleanClause	TokenNameIdentifier
.	TokenNameDOT
Occur	TokenNameIdentifier
.	TokenNameDOT
MUST	TokenNameIdentifier
:	TokenNameCOLON
BooleanClause	TokenNameIdentifier
.	TokenNameDOT
Occur	TokenNameIdentifier
.	TokenNameDOT
SHOULD	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numTokens	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
term	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
boolean	TokenNameboolean
hasNext	TokenNameIdentifier
=	TokenNameEQUAL
buffer	TokenNameIdentifier
.	TokenNameDOT
incrementToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
hasNext	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
termAtt	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
Query	TokenNameIdentifier
currentQuery	TokenNameIdentifier
=	TokenNameEQUAL
newTermQuery	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Term	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
term	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
currentQuery	TokenNameIdentifier
,	TokenNameCOMMA
occur	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
q	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
MultiPhraseQuery	TokenNameIdentifier
mpq	TokenNameIdentifier
=	TokenNameEQUAL
newMultiPhraseQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mpq	TokenNameIdentifier
.	TokenNameDOT
setSlop	TokenNameIdentifier
(	TokenNameLPAREN
phraseSlop	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
>	TokenNameGREATER
multiTerms	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
position	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numTokens	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
term	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
positionIncrement	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
boolean	TokenNameboolean
hasNext	TokenNameIdentifier
=	TokenNameEQUAL
buffer	TokenNameIdentifier
.	TokenNameDOT
incrementToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
hasNext	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
termAtt	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
posIncrAtt	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
positionIncrement	TokenNameIdentifier
=	TokenNameEQUAL
posIncrAtt	TokenNameIdentifier
.	TokenNameDOT
getPositionIncrement	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
positionIncrement	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
multiTerms	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
enablePositionIncrements	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
mpq	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
multiTerms	TokenNameIdentifier
.	TokenNameDOT
toArray	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Term	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
,	TokenNameCOMMA
position	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
mpq	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
multiTerms	TokenNameIdentifier
.	TokenNameDOT
toArray	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Term	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
multiTerms	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
position	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
positionIncrement	TokenNameIdentifier
;	TokenNameSEMICOLON
multiTerms	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Term	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
term	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
enablePositionIncrements	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
mpq	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
multiTerms	TokenNameIdentifier
.	TokenNameDOT
toArray	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Term	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
,	TokenNameCOMMA
position	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
mpq	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
multiTerms	TokenNameIdentifier
.	TokenNameDOT
toArray	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Term	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
mpq	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
PhraseQuery	TokenNameIdentifier
pq	TokenNameIdentifier
=	TokenNameEQUAL
newPhraseQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pq	TokenNameIdentifier
.	TokenNameDOT
setSlop	TokenNameIdentifier
(	TokenNameLPAREN
phraseSlop	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
position	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numTokens	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
term	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
positionIncrement	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
boolean	TokenNameboolean
hasNext	TokenNameIdentifier
=	TokenNameEQUAL
buffer	TokenNameIdentifier
.	TokenNameDOT
incrementToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
hasNext	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
termAtt	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
posIncrAtt	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
positionIncrement	TokenNameIdentifier
=	TokenNameEQUAL
posIncrAtt	TokenNameIdentifier
.	TokenNameDOT
getPositionIncrement	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
enablePositionIncrements	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
position	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
positionIncrement	TokenNameIdentifier
;	TokenNameSEMICOLON
pq	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Term	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
term	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
position	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
pq	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Term	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
term	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
pq	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
getFieldQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
queryText	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
slop	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Query	TokenNameIdentifier
query	TokenNameIdentifier
=	TokenNameEQUAL
hasNewAPI	TokenNameIdentifier
?	TokenNameQUESTION
getFieldQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
queryText	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
:	TokenNameCOLON
getFieldQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
queryText	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
query	TokenNameIdentifier
instanceof	TokenNameinstanceof
PhraseQuery	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
(	TokenNameLPAREN
(	TokenNameLPAREN
PhraseQuery	TokenNameIdentifier
)	TokenNameRPAREN
query	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
setSlop	TokenNameIdentifier
(	TokenNameLPAREN
slop	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
query	TokenNameIdentifier
instanceof	TokenNameinstanceof
MultiPhraseQuery	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
(	TokenNameLPAREN
(	TokenNameLPAREN
MultiPhraseQuery	TokenNameIdentifier
)	TokenNameRPAREN
query	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
setSlop	TokenNameIdentifier
(	TokenNameLPAREN
slop	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
query	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
getRangeQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part1	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part2	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
inclusive	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
lowercaseExpandedTerms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
part1	TokenNameIdentifier
=	TokenNameEQUAL
part1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
part1	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
part2	TokenNameIdentifier
=	TokenNameEQUAL
part2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
part2	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
DateFormat	TokenNameIdentifier
df	TokenNameIdentifier
=	TokenNameEQUAL
DateFormat	TokenNameIdentifier
.	TokenNameDOT
getDateInstance	TokenNameIdentifier
(	TokenNameLPAREN
DateFormat	TokenNameIdentifier
.	TokenNameDOT
SHORT	TokenNameIdentifier
,	TokenNameCOMMA
locale	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
df	TokenNameIdentifier
.	TokenNameDOT
setLenient	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
DateTools	TokenNameIdentifier
.	TokenNameDOT
Resolution	TokenNameIdentifier
resolution	TokenNameIdentifier
=	TokenNameEQUAL
getDateResolution	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
Date	TokenNameIdentifier
d1	TokenNameIdentifier
=	TokenNameEQUAL
df	TokenNameIdentifier
.	TokenNameDOT
parse	TokenNameIdentifier
(	TokenNameLPAREN
part1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
resolution	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
part1	TokenNameIdentifier
=	TokenNameEQUAL
DateField	TokenNameIdentifier
.	TokenNameDOT
dateToString	TokenNameIdentifier
(	TokenNameLPAREN
d1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
part1	TokenNameIdentifier
=	TokenNameEQUAL
DateTools	TokenNameIdentifier
.	TokenNameDOT
dateToString	TokenNameIdentifier
(	TokenNameLPAREN
d1	TokenNameIdentifier
,	TokenNameCOMMA
resolution	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
Date	TokenNameIdentifier
d2	TokenNameIdentifier
=	TokenNameEQUAL
df	TokenNameIdentifier
.	TokenNameDOT
parse	TokenNameIdentifier
(	TokenNameLPAREN
part2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
inclusive	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Calendar	TokenNameIdentifier
cal	TokenNameIdentifier
=	TokenNameEQUAL
Calendar	TokenNameIdentifier
.	TokenNameDOT
getInstance	TokenNameIdentifier
(	TokenNameLPAREN
locale	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cal	TokenNameIdentifier
.	TokenNameDOT
setTime	TokenNameIdentifier
(	TokenNameLPAREN
d2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cal	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
Calendar	TokenNameIdentifier
.	TokenNameDOT
HOUR_OF_DAY	TokenNameIdentifier
,	TokenNameCOMMA
23	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cal	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
Calendar	TokenNameIdentifier
.	TokenNameDOT
MINUTE	TokenNameIdentifier
,	TokenNameCOMMA
59	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cal	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
Calendar	TokenNameIdentifier
.	TokenNameDOT
SECOND	TokenNameIdentifier
,	TokenNameCOMMA
59	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cal	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
Calendar	TokenNameIdentifier
.	TokenNameDOT
MILLISECOND	TokenNameIdentifier
,	TokenNameCOMMA
999	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
d2	TokenNameIdentifier
=	TokenNameEQUAL
cal	TokenNameIdentifier
.	TokenNameDOT
getTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
resolution	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
part2	TokenNameIdentifier
=	TokenNameEQUAL
DateField	TokenNameIdentifier
.	TokenNameDOT
dateToString	TokenNameIdentifier
(	TokenNameLPAREN
d2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
part2	TokenNameIdentifier
=	TokenNameEQUAL
DateTools	TokenNameIdentifier
.	TokenNameDOT
dateToString	TokenNameIdentifier
(	TokenNameLPAREN
d2	TokenNameIdentifier
,	TokenNameCOMMA
resolution	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
return	TokenNamereturn
newRangeQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
part1	TokenNameIdentifier
,	TokenNameCOMMA
part2	TokenNameIdentifier
,	TokenNameCOMMA
inclusive	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
BooleanQuery	TokenNameIdentifier
newBooleanQuery	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
disableCoord	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
BooleanQuery	TokenNameIdentifier
(	TokenNameLPAREN
disableCoord	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
BooleanClause	TokenNameIdentifier
newBooleanClause	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
q	TokenNameIdentifier
,	TokenNameCOMMA
BooleanClause	TokenNameIdentifier
.	TokenNameDOT
Occur	TokenNameIdentifier
occur	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
BooleanClause	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
,	TokenNameCOMMA
occur	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
newTermQuery	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
TermQuery	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
PhraseQuery	TokenNameIdentifier
newPhraseQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
PhraseQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
MultiPhraseQuery	TokenNameIdentifier
newMultiPhraseQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
MultiPhraseQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
newPrefixQuery	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
prefix	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
PrefixQuery	TokenNameIdentifier
query	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
PrefixQuery	TokenNameIdentifier
(	TokenNameLPAREN
prefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
query	TokenNameIdentifier
.	TokenNameDOT
setRewriteMethod	TokenNameIdentifier
(	TokenNameLPAREN
multiTermRewriteMethod	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
query	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
newFuzzyQuery	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
minimumSimilarity	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
prefixLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
FuzzyQuery	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
,	TokenNameCOMMA
minimumSimilarity	TokenNameIdentifier
,	TokenNameCOMMA
prefixLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
newRangeQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part1	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
part2	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
inclusive	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
TermRangeQuery	TokenNameIdentifier
query	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
TermRangeQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
part1	TokenNameIdentifier
,	TokenNameCOMMA
part2	TokenNameIdentifier
,	TokenNameCOMMA
inclusive	TokenNameIdentifier
,	TokenNameCOMMA
inclusive	TokenNameIdentifier
,	TokenNameCOMMA
rangeCollator	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
query	TokenNameIdentifier
.	TokenNameDOT
setRewriteMethod	TokenNameIdentifier
(	TokenNameLPAREN
multiTermRewriteMethod	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
query	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
newMatchAllDocsQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
MatchAllDocsQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
newWildcardQuery	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
WildcardQuery	TokenNameIdentifier
query	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
WildcardQuery	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
query	TokenNameIdentifier
.	TokenNameDOT
setRewriteMethod	TokenNameIdentifier
(	TokenNameLPAREN
multiTermRewriteMethod	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
query	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
getBooleanQuery	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
BooleanClause	TokenNameIdentifier
>	TokenNameGREATER
clauses	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
getBooleanQuery	TokenNameIdentifier
(	TokenNameLPAREN
clauses	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
getBooleanQuery	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
BooleanClause	TokenNameIdentifier
>	TokenNameGREATER
clauses	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
disableCoord	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
clauses	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
BooleanQuery	TokenNameIdentifier
query	TokenNameIdentifier
=	TokenNameEQUAL
newBooleanQuery	TokenNameIdentifier
(	TokenNameLPAREN
disableCoord	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
BooleanClause	TokenNameIdentifier
clause	TokenNameIdentifier
:	TokenNameCOLON
clauses	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
query	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
clause	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
query	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
getWildcardQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
termStr	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
"*"	TokenNameStringLiteral
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
"*"	TokenNameStringLiteral
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
termStr	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
newMatchAllDocsQuery	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
allowLeadingWildcard	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
termStr	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
"*"	TokenNameStringLiteral
)	TokenNameRPAREN
||	TokenNameOR_OR
termStr	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
"?"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
"'*' or '?' not allowed as first character in WildcardQuery"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lowercaseExpandedTerms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
termStr	TokenNameIdentifier
=	TokenNameEQUAL
termStr	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Term	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Term	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
termStr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
newWildcardQuery	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
getPrefixQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
termStr	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
allowLeadingWildcard	TokenNameIdentifier
&&	TokenNameAND_AND
termStr	TokenNameIdentifier
.	TokenNameDOT
startsWith	TokenNameIdentifier
(	TokenNameLPAREN
"*"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
"'*' not allowed as first character in PrefixQuery"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lowercaseExpandedTerms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
termStr	TokenNameIdentifier
=	TokenNameEQUAL
termStr	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Term	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Term	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
termStr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
newPrefixQuery	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
Query	TokenNameIdentifier
getFuzzyQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
termStr	TokenNameIdentifier
,	TokenNameCOMMA
float	TokenNamefloat
minSimilarity	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
lowercaseExpandedTerms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
termStr	TokenNameIdentifier
=	TokenNameEQUAL
termStr	TokenNameIdentifier
.	TokenNameDOT
toLowerCase	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Term	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Term	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
termStr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
newFuzzyQuery	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
,	TokenNameCOMMA
minSimilarity	TokenNameIdentifier
,	TokenNameCOMMA
fuzzyPrefixLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
String	TokenNameIdentifier
discardEscapeChar	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
input	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
output	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
input	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
length	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
lastCharWasEscapeChar	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
int	TokenNameint
codePointMultiplier	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
codePoint	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
input	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
curChar	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
codePointMultiplier	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
codePoint	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
hexToInt	TokenNameIdentifier
(	TokenNameLPAREN
curChar	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
codePointMultiplier	TokenNameIdentifier
;	TokenNameSEMICOLON
codePointMultiplier	TokenNameIdentifier
>>>=	TokenNameUNSIGNED_RIGHT_SHIFT_EQUAL
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
codePointMultiplier	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
output	TokenNameIdentifier
[	TokenNameLBRACKET
length	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
codePoint	TokenNameIdentifier
;	TokenNameSEMICOLON
codePoint	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
lastCharWasEscapeChar	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
curChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'u'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
codePointMultiplier	TokenNameIdentifier
=	TokenNameEQUAL
16	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
output	TokenNameIdentifier
[	TokenNameLBRACKET
length	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
curChar	TokenNameIdentifier
;	TokenNameSEMICOLON
length	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lastCharWasEscapeChar	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
curChar	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'\\'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
lastCharWasEscapeChar	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
output	TokenNameIdentifier
[	TokenNameLBRACKET
length	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
curChar	TokenNameIdentifier
;	TokenNameSEMICOLON
length	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
codePointMultiplier	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
"Truncated unicode escape sequence."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
lastCharWasEscapeChar	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
"Term can not end with escape character."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
String	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
hexToInt	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
c	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
'0'	TokenNameCharacterLiteral
<=	TokenNameLESS_EQUAL
c	TokenNameIdentifier
&&	TokenNameAND_AND
c	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'9'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
c	TokenNameIdentifier
-	TokenNameMINUS
'0'	TokenNameCharacterLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
'a'	TokenNameCharacterLiteral
<=	TokenNameLESS_EQUAL
c	TokenNameIdentifier
&&	TokenNameAND_AND
c	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'f'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
c	TokenNameIdentifier
-	TokenNameMINUS
'a'	TokenNameCharacterLiteral
+	TokenNamePLUS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
'A'	TokenNameCharacterLiteral
<=	TokenNameLESS_EQUAL
c	TokenNameIdentifier
&&	TokenNameAND_AND
c	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
'F'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
c	TokenNameIdentifier
-	TokenNameMINUS
'A'	TokenNameCharacterLiteral
+	TokenNamePLUS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
"None-hex character in unicode escape sequence: "	TokenNameStringLiteral
+	TokenNamePLUS
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
String	TokenNameIdentifier
escape	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
s	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuilder	TokenNameIdentifier
sb	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
s	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
c	TokenNameIdentifier
=	TokenNameEQUAL
s	TokenNameIdentifier
.	TokenNameDOT
charAt	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'\\'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'+'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'-'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'!'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'('	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
')'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
':'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'^'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'['	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
']'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'\"'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'{'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'}'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'~'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'*'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'?'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'|'	TokenNameCharacterLiteral
||	TokenNameOR_OR
c	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
'&'	TokenNameCharacterLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
'\\'	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
c	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
sb	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
main	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
args	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
Exception	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
args	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"Usage: java org.apache.lucene.queryParser.QueryParser <input>"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
exit	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
QueryParser	TokenNameIdentifier
qp	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
QueryParser	TokenNameIdentifier
(	TokenNameLPAREN
Version	TokenNameIdentifier
.	TokenNameDOT
LUCENE_CURRENT	TokenNameIdentifier
,	TokenNameCOMMA
"field"	TokenNameStringLiteral
,	TokenNameCOMMA
new	TokenNamenew
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
SimpleAnalyzer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Query	TokenNameIdentifier
q	TokenNameIdentifier
=	TokenNameEQUAL
qp	TokenNameIdentifier
.	TokenNameDOT
parse	TokenNameIdentifier
(	TokenNameLPAREN
args	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
q	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
"field"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
int	TokenNameint
Conjunction	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
ret	TokenNameIdentifier
=	TokenNameEQUAL
CONJ_NONE	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
AND	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
OR	TokenNameIdentifier
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
AND	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
AND	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
CONJ_AND	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
OR	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
OR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
CONJ_OR	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
int	TokenNameint
Modifiers	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
ret	TokenNameIdentifier
=	TokenNameEQUAL
MOD_NONE	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
NOT	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
PLUS	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
MINUS	TokenNameIdentifier
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
PLUS	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
PLUS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
MOD_REQ	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
MINUS	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
MINUS	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
MOD_NOT	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
NOT	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
NOT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ret	TokenNameIdentifier
=	TokenNameEQUAL
MOD_NOT	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
ret	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
Query	TokenNameIdentifier
TopLevelQuery	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Query	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
Query	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
q	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
Query	TokenNameIdentifier
Query	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
BooleanClause	TokenNameIdentifier
>	TokenNameGREATER
clauses	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
BooleanClause	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Query	TokenNameIdentifier
q	TokenNameIdentifier
,	TokenNameCOMMA
firstQuery	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
conj	TokenNameIdentifier
,	TokenNameCOMMA
mods	TokenNameIdentifier
;	TokenNameSEMICOLON
mods	TokenNameIdentifier
=	TokenNameEQUAL
Modifiers	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
Clause	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addClause	TokenNameIdentifier
(	TokenNameLPAREN
clauses	TokenNameIdentifier
,	TokenNameCOMMA
CONJ_NONE	TokenNameIdentifier
,	TokenNameCOMMA
mods	TokenNameIdentifier
,	TokenNameCOMMA
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
mods	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
MOD_NONE	TokenNameIdentifier
)	TokenNameRPAREN
firstQuery	TokenNameIdentifier
=	TokenNameEQUAL
q	TokenNameIdentifier
;	TokenNameSEMICOLON
label_1	TokenNameIdentifier
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
AND	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
OR	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
NOT	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
PLUS	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
MINUS	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
BAREOPER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
LPAREN	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
STAR	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
QUOTED	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
TERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
PREFIXTERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
WILDTERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
RANGEIN_START	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
RANGEEX_START	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
NUMBER	TokenNameIdentifier
:	TokenNameCOLON
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
4	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
label_1	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
conj	TokenNameIdentifier
=	TokenNameEQUAL
Conjunction	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mods	TokenNameIdentifier
=	TokenNameEQUAL
Modifiers	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
Clause	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addClause	TokenNameIdentifier
(	TokenNameLPAREN
clauses	TokenNameIdentifier
,	TokenNameCOMMA
conj	TokenNameIdentifier
,	TokenNameCOMMA
mods	TokenNameIdentifier
,	TokenNameCOMMA
q	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
clauses	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
firstQuery	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
firstQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
getBooleanQuery	TokenNameIdentifier
(	TokenNameLPAREN
clauses	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
Query	TokenNameIdentifier
Clause	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Query	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
fieldToken	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
,	TokenNameCOMMA
boost	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_2_1	TokenNameIdentifier
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
TERM	TokenNameIdentifier
:	TokenNameCOLON
fieldToken	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
TERM	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
COLON	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
field	TokenNameIdentifier
=	TokenNameEQUAL
discardEscapeChar	TokenNameIdentifier
(	TokenNameLPAREN
fieldToken	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
STAR	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
STAR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
COLON	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
field	TokenNameIdentifier
=	TokenNameEQUAL
"*"	TokenNameStringLiteral
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
5	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
BAREOPER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
STAR	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
QUOTED	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
TERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
PREFIXTERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
WILDTERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
RANGEIN_START	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
RANGEEX_START	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
NUMBER	TokenNameIdentifier
:	TokenNameCOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
Term	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
LPAREN	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
LPAREN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
=	TokenNameEQUAL
Query	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RPAREN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
CARAT	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
CARAT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boost	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
NUMBER	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
6	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
7	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
boost	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
f	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
1.0	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
f	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
valueOf	TokenNameIdentifier
(	TokenNameLPAREN
boost	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
floatValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
q	TokenNameIdentifier
.	TokenNameDOT
setBoost	TokenNameIdentifier
(	TokenNameLPAREN
f	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
ignored	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
q	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
Query	TokenNameIdentifier
Term	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
field	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Token	TokenNameIdentifier
term	TokenNameIdentifier
,	TokenNameCOMMA
boost	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
,	TokenNameCOMMA
fuzzySlop	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
,	TokenNameCOMMA
goop1	TokenNameIdentifier
,	TokenNameCOMMA
goop2	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
prefix	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
wildcard	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
fuzzy	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
Query	TokenNameIdentifier
q	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
BAREOPER	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
STAR	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
TERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
PREFIXTERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
WILDTERM	TokenNameIdentifier
:	TokenNameCOLON
case	TokenNamecase
NUMBER	TokenNameIdentifier
:	TokenNameCOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
TERM	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
TERM	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
STAR	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
STAR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
wildcard	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
PREFIXTERM	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
PREFIXTERM	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
prefix	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
WILDTERM	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
WILDTERM	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
wildcard	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
NUMBER	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
NUMBER	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
BAREOPER	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
BAREOPER	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
=	TokenNameEQUAL
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
8	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
FUZZY_SLOP	TokenNameIdentifier
:	TokenNameCOLON
fuzzySlop	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
FUZZY_SLOP	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fuzzy	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
9	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
CARAT	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
CARAT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boost	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
NUMBER	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
FUZZY_SLOP	TokenNameIdentifier
:	TokenNameCOLON
fuzzySlop	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
FUZZY_SLOP	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fuzzy	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
10	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
11	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
String	TokenNameIdentifier
termImage	TokenNameIdentifier
=	TokenNameEQUAL
discardEscapeChar	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
wildcard	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
q	TokenNameIdentifier
=	TokenNameEQUAL
getWildcardQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
termImage	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
prefix	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
q	TokenNameIdentifier
=	TokenNameEQUAL
getPrefixQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
discardEscapeChar	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
fuzzy	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
fms	TokenNameIdentifier
=	TokenNameEQUAL
fuzzyMinSim	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
fms	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
valueOf	TokenNameIdentifier
(	TokenNameLPAREN
fuzzySlop	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
floatValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
ignored	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
fms	TokenNameIdentifier
<	TokenNameLESS
0.0f	TokenNameFloatingPointLiteral
||	TokenNameOR_OR
fms	TokenNameIdentifier
>	TokenNameGREATER
1.0f	TokenNameFloatingPointLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
"Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
q	TokenNameIdentifier
=	TokenNameEQUAL
getFuzzyQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
termImage	TokenNameIdentifier
,	TokenNameCOMMA
fms	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
q	TokenNameIdentifier
=	TokenNameEQUAL
hasNewAPI	TokenNameIdentifier
?	TokenNameQUESTION
getFieldQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
termImage	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
:	TokenNameCOLON
getFieldQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
termImage	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
RANGEIN_START	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEIN_START	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
RANGEIN_GOOP	TokenNameIdentifier
:	TokenNameCOLON
goop1	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEIN_GOOP	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
RANGEIN_QUOTED	TokenNameIdentifier
:	TokenNameCOLON
goop1	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEIN_QUOTED	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
12	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
RANGEIN_TO	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEIN_TO	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
13	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
RANGEIN_GOOP	TokenNameIdentifier
:	TokenNameCOLON
goop2	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEIN_GOOP	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
RANGEIN_QUOTED	TokenNameIdentifier
:	TokenNameCOLON
goop2	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEIN_QUOTED	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
14	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEIN_END	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
CARAT	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
CARAT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boost	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
NUMBER	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
15	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
boolean	TokenNameboolean
startOpen	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
endOpen	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
goop1	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RANGEIN_QUOTED	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
goop1	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
=	TokenNameEQUAL
goop1	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
goop1	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
"*"	TokenNameStringLiteral
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
goop1	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
startOpen	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
goop2	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RANGEIN_QUOTED	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
goop2	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
=	TokenNameEQUAL
goop2	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
goop2	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
"*"	TokenNameStringLiteral
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
goop2	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
endOpen	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
q	TokenNameIdentifier
=	TokenNameEQUAL
getRangeQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
startOpen	TokenNameIdentifier
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
discardEscapeChar	TokenNameIdentifier
(	TokenNameLPAREN
goop1	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
endOpen	TokenNameIdentifier
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
discardEscapeChar	TokenNameIdentifier
(	TokenNameLPAREN
goop2	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
RANGEEX_START	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEEX_START	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
RANGEEX_GOOP	TokenNameIdentifier
:	TokenNameCOLON
goop1	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEEX_GOOP	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
RANGEEX_QUOTED	TokenNameIdentifier
:	TokenNameCOLON
goop1	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEEX_QUOTED	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
16	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
RANGEEX_TO	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEEX_TO	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
17	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
RANGEEX_GOOP	TokenNameIdentifier
:	TokenNameCOLON
goop2	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEEX_GOOP	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
RANGEEX_QUOTED	TokenNameIdentifier
:	TokenNameCOLON
goop2	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEEX_QUOTED	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
18	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
RANGEEX_END	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
CARAT	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
CARAT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boost	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
NUMBER	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
19	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
boolean	TokenNameboolean
startOpen	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
endOpen	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
goop1	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RANGEEX_QUOTED	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
goop1	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
=	TokenNameEQUAL
goop1	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
goop1	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
"*"	TokenNameStringLiteral
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
goop1	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
startOpen	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
goop2	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
RANGEEX_QUOTED	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
goop2	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
=	TokenNameEQUAL
goop2	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
goop2	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
"*"	TokenNameStringLiteral
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
goop2	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
endOpen	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
q	TokenNameIdentifier
=	TokenNameEQUAL
getRangeQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
startOpen	TokenNameIdentifier
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
discardEscapeChar	TokenNameIdentifier
(	TokenNameLPAREN
goop1	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
endOpen	TokenNameIdentifier
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
discardEscapeChar	TokenNameIdentifier
(	TokenNameLPAREN
goop2	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
QUOTED	TokenNameIdentifier
:	TokenNameCOLON
term	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
QUOTED	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
FUZZY_SLOP	TokenNameIdentifier
:	TokenNameCOLON
fuzzySlop	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
FUZZY_SLOP	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
20	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
switch	TokenNameswitch
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
?	TokenNameQUESTION
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
jj_ntk	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
CARAT	TokenNameIdentifier
:	TokenNameCOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
CARAT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boost	TokenNameIdentifier
=	TokenNameEQUAL
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
NUMBER	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
21	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
s	TokenNameIdentifier
=	TokenNameEQUAL
phraseSlop	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fuzzySlop	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
s	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
valueOf	TokenNameIdentifier
(	TokenNameLPAREN
fuzzySlop	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
intValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
ignored	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
q	TokenNameIdentifier
=	TokenNameEQUAL
getFieldQuery	TokenNameIdentifier
(	TokenNameLPAREN
field	TokenNameIdentifier
,	TokenNameCOMMA
discardEscapeChar	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
term	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
s	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
22	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
boost	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
float	TokenNamefloat
f	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
1.0	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
f	TokenNameIdentifier
=	TokenNameEQUAL
Float	TokenNameIdentifier
.	TokenNameDOT
valueOf	TokenNameIdentifier
(	TokenNameLPAREN
boost	TokenNameIdentifier
.	TokenNameDOT
image	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
floatValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
ignored	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
q	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
q	TokenNameIdentifier
.	TokenNameDOT
setBoost	TokenNameIdentifier
(	TokenNameLPAREN
f	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
return	TokenNamereturn
q	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
Error	TokenNameIdentifier
(	TokenNameLPAREN
"Missing return statement in function"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
jj_2_1	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
xla	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_la	TokenNameIdentifier
=	TokenNameEQUAL
xla	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_lastpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
!	TokenNameNOT
jj_3_1	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
LookaheadSuccess	TokenNameIdentifier
ls	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
jj_save	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
xla	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
jj_3_1	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Token	TokenNameIdentifier
xsp	TokenNameIdentifier
;	TokenNameSEMICOLON
xsp	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_3R_2	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
xsp	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_3R_3	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
jj_3R_3	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_scan_token	TokenNameIdentifier
(	TokenNameLPAREN
STAR	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_scan_token	TokenNameIdentifier
(	TokenNameLPAREN
COLON	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
jj_3R_2	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_scan_token	TokenNameIdentifier
(	TokenNameLPAREN
TERM	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_scan_token	TokenNameIdentifier
(	TokenNameLPAREN
COLON	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
QueryParserTokenManager	TokenNameIdentifier
token_source	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Token	TokenNameIdentifier
token	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Token	TokenNameIdentifier
jj_nt	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_ntk	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Token	TokenNameIdentifier
jj_scanpos	TokenNameIdentifier
,	TokenNameCOMMA
jj_lastpos	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_la	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_gen	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_la1	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
23	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_la1_0	TokenNameIdentifier
;	TokenNameSEMICOLON
static	TokenNamestatic
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_la1_1	TokenNameIdentifier
;	TokenNameSEMICOLON
static	TokenNamestatic
{	TokenNameLBRACE
jj_la1_init_0	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_la1_init_1	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
jj_la1_init_0	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_la1_0	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
0x300	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x300	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x1c00	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x1c00	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x7da7f00	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x120000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x40000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x7da6000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x4d22000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x200000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x200000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x40000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x60000000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x8000000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x60000000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x40000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x80000000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x40000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x200000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x40000	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x7da2000	TokenNameIntegerLiteral
,	TokenNameCOMMA
}	TokenNameRBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
void	TokenNamevoid
jj_la1_init_1	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_la1_1	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x6	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x6	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0x0	TokenNameIntegerLiteral
,	TokenNameCOMMA
}	TokenNameRBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
private	TokenNameprivate
JJCalls	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_2_rtns	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
jj_rescan	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_gc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
protected	TokenNameprotected
QueryParser	TokenNameIdentifier
(	TokenNameLPAREN
CharStream	TokenNameIdentifier
stream	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
token_source	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
QueryParserTokenManager	TokenNameIdentifier
(	TokenNameLPAREN
stream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
token	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_gen	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
23	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_2_rtns	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
ReInit	TokenNameIdentifier
(	TokenNameLPAREN
CharStream	TokenNameIdentifier
stream	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
token_source	TokenNameIdentifier
.	TokenNameDOT
ReInit	TokenNameIdentifier
(	TokenNameLPAREN
stream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
token	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_gen	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
23	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_2_rtns	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
QueryParser	TokenNameIdentifier
(	TokenNameLPAREN
QueryParserTokenManager	TokenNameIdentifier
tm	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
token_source	TokenNameIdentifier
=	TokenNameEQUAL
tm	TokenNameIdentifier
;	TokenNameSEMICOLON
token	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_gen	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
23	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_2_rtns	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
ReInit	TokenNameIdentifier
(	TokenNameLPAREN
QueryParserTokenManager	TokenNameIdentifier
tm	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
token_source	TokenNameIdentifier
=	TokenNameEQUAL
tm	TokenNameIdentifier
;	TokenNameSEMICOLON
token	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_gen	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
23	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_2_rtns	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Token	TokenNameIdentifier
jj_consume_token	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
kind	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
ParseException	TokenNameIdentifier
{	TokenNameLBRACE
Token	TokenNameIdentifier
oldToken	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
oldToken	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
next	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
token	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
token	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
token_source	TokenNameIdentifier
.	TokenNameDOT
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
token	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
kind	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_gen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
jj_gc	TokenNameIdentifier
>	TokenNameGREATER
100	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_gc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_2_rtns	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
JJCalls	TokenNameIdentifier
c	TokenNameIdentifier
=	TokenNameEQUAL
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
c	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
c	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
<	TokenNameLESS
jj_gen	TokenNameIdentifier
)	TokenNameRPAREN
c	TokenNameIdentifier
.	TokenNameDOT
first	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
c	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
token	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
token	TokenNameIdentifier
=	TokenNameEQUAL
oldToken	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_kind	TokenNameIdentifier
=	TokenNameEQUAL
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
throw	TokenNamethrow
generateParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
private	TokenNameprivate
final	TokenNamefinal
class	TokenNameclass
LookaheadSuccess	TokenNameIdentifier
extends	TokenNameextends
java	TokenNameIdentifier
.	TokenNameDOT
lang	TokenNameIdentifier
.	TokenNameDOT
Error	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
final	TokenNamefinal
private	TokenNameprivate
LookaheadSuccess	TokenNameIdentifier
jj_ls	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
LookaheadSuccess	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
jj_scan_token	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
kind	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_scanpos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
jj_lastpos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_la	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_scanpos	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_lastpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
token_source	TokenNameIdentifier
.	TokenNameDOT
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
jj_lastpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_rescan	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
tok	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
tok	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
tok	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
jj_scanpos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
tok	TokenNameIdentifier
=	TokenNameEQUAL
tok	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
tok	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
jj_add_error_token	TokenNameIdentifier
(	TokenNameLPAREN
kind	TokenNameIdentifier
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_scanpos	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
kind	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_la	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
jj_scanpos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
jj_lastpos	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
jj_ls	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
Token	TokenNameIdentifier
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
token	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
token	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
token_source	TokenNameIdentifier
.	TokenNameDOT
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_gen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
return	TokenNamereturn
token	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
Token	TokenNameIdentifier
getToken	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Token	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
index	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
t	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
t	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
token_source	TokenNameIdentifier
.	TokenNameDOT
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
jj_ntk	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_nt	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
token	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
token_source	TokenNameIdentifier
.	TokenNameDOT
getNextToken	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
.	TokenNameDOT
kind	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
(	TokenNameLPAREN
jj_ntk	TokenNameIdentifier
=	TokenNameEQUAL
jj_nt	TokenNameIdentifier
.	TokenNameDOT
kind	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
<	TokenNameLESS
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
jj_expentries	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
<	TokenNameLESS
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_expentry	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_kind	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
jj_lasttokens	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
100	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
jj_endpos	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
void	TokenNamevoid
jj_add_error_token	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
kind	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
pos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
100	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
jj_endpos	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_lasttokens	TokenNameIdentifier
[	TokenNameLBRACKET
jj_endpos	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
jj_endpos	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_expentry	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
jj_endpos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_endpos	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_expentry	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_lasttokens	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
jj_entries_loop	TokenNameIdentifier
:	TokenNameCOLON
for	TokenNamefor
(	TokenNameLPAREN
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Iterator	TokenNameIdentifier
<	TokenNameLESS
?	TokenNameQUESTION
>	TokenNameGREATER
it	TokenNameIdentifier
=	TokenNameEQUAL
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
it	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
oldentry	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
)	TokenNameRPAREN
(	TokenNameLPAREN
it	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
oldentry	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
jj_expentry	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_expentry	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
oldentry	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
jj_expentry	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
jj_entries_loop	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
jj_expentry	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
jj_entries_loop	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
jj_lasttokens	TokenNameIdentifier
[	TokenNameLBRACKET
(	TokenNameLPAREN
jj_endpos	TokenNameIdentifier
=	TokenNameEQUAL
pos	TokenNameIdentifier
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
kind	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
ParseException	TokenNameIdentifier
generateParseException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
la1tokens	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
35	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
jj_kind	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
la1tokens	TokenNameIdentifier
[	TokenNameLBRACKET
jj_kind	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
jj_kind	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
23	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
jj_la1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
jj_gen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
32	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_la1_0	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
la1tokens	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
jj_la1_1	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
la1tokens	TokenNameIdentifier
[	TokenNameLBRACKET
32	TokenNameIntegerLiteral
+	TokenNamePLUS
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
35	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
la1tokens	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_expentry	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
jj_expentry	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
jj_expentry	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
jj_endpos	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
jj_rescan_token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
jj_add_error_token	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
exptokseq	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
exptokseq	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
jj_expentries	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
ParseException	TokenNameIdentifier
(	TokenNameLPAREN
token	TokenNameIdentifier
,	TokenNameCOMMA
exptokseq	TokenNameIdentifier
,	TokenNameCOMMA
tokenImage	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
void	TokenNamevoid
enable_tracing	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
final	TokenNamefinal
public	TokenNamepublic
void	TokenNamevoid
disable_tracing	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
jj_rescan_token	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_rescan	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
JJCalls	TokenNameIdentifier
p	TokenNameIdentifier
=	TokenNameEQUAL
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
do	TokenNamedo
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
>	TokenNameGREATER
jj_gen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
jj_la	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
arg	TokenNameIdentifier
;	TokenNameSEMICOLON
jj_lastpos	TokenNameIdentifier
=	TokenNameEQUAL
jj_scanpos	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
first	TokenNameIdentifier
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0	TokenNameIntegerLiteral
:	TokenNameCOLON
jj_3_1	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
p	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
p	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
LookaheadSuccess	TokenNameIdentifier
ls	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
jj_rescan	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
jj_save	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
xla	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
JJCalls	TokenNameIdentifier
p	TokenNameIdentifier
=	TokenNameEQUAL
jj_2_rtns	TokenNameIdentifier
[	TokenNameLBRACKET
index	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
>	TokenNameGREATER
jj_gen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
p	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
p	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
JJCalls	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
p	TokenNameIdentifier
=	TokenNameEQUAL
p	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
p	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
=	TokenNameEQUAL
jj_gen	TokenNameIdentifier
+	TokenNamePLUS
xla	TokenNameIdentifier
-	TokenNameMINUS
jj_la	TokenNameIdentifier
;	TokenNameSEMICOLON
p	TokenNameIdentifier
.	TokenNameDOT
first	TokenNameIdentifier
=	TokenNameEQUAL
token	TokenNameIdentifier
;	TokenNameSEMICOLON
p	TokenNameIdentifier
.	TokenNameDOT
arg	TokenNameIdentifier
=	TokenNameEQUAL
xla	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
JJCalls	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
gen	TokenNameIdentifier
;	TokenNameSEMICOLON
Token	TokenNameIdentifier
first	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
arg	TokenNameIdentifier
;	TokenNameSEMICOLON
JJCalls	TokenNameIdentifier
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
