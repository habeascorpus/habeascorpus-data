package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Arrays	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
*	TokenNameMULTIPLY
;	TokenNameSEMICOLON
final	TokenNamefinal
class	TokenNameclass
ExactPhraseScorer	TokenNameIdentifier
extends	TokenNameextends
Scorer	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
norms	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
float	TokenNamefloat
value	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
SCORE_CACHE_SIZE	TokenNameIdentifier
=	TokenNameEQUAL
32	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
float	TokenNamefloat
[	TokenNameLBRACKET
]	TokenNameRBRACKET
scoreCache	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
float	TokenNamefloat
[	TokenNameLBRACKET
SCORE_CACHE_SIZE	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
endMinus1	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
CHUNK	TokenNameIdentifier
=	TokenNameEQUAL
4096	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
gen	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
counts	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
CHUNK	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
gens	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
CHUNK	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
boolean	TokenNameboolean
noDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
class	TokenNameclass
ChunkState	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
TermPositions	TokenNameIdentifier
posEnum	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
useAdvance	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
posUpto	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
posLimit	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
lastPos	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
ChunkState	TokenNameIdentifier
(	TokenNameLPAREN
TermPositions	TokenNameIdentifier
posEnum	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
useAdvance	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
posEnum	TokenNameIdentifier
=	TokenNameEQUAL
posEnum	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
offset	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
useAdvance	TokenNameIdentifier
=	TokenNameEQUAL
useAdvance	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
ChunkState	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
chunkStates	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
docID	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
freq	TokenNameIdentifier
;	TokenNameSEMICOLON
ExactPhraseScorer	TokenNameIdentifier
(	TokenNameLPAREN
Weight	TokenNameIdentifier
weight	TokenNameIdentifier
,	TokenNameCOMMA
PhraseQuery	TokenNameIdentifier
.	TokenNameDOT
PostingsAndFreq	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
postings	TokenNameIdentifier
,	TokenNameCOMMA
Similarity	TokenNameIdentifier
similarity	TokenNameIdentifier
,	TokenNameCOMMA
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
norms	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
similarity	TokenNameIdentifier
,	TokenNameCOMMA
weight	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
norms	TokenNameIdentifier
=	TokenNameEQUAL
norms	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
value	TokenNameIdentifier
=	TokenNameEQUAL
weight	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
chunkStates	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ChunkState	TokenNameIdentifier
[	TokenNameLBRACKET
postings	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
endMinus1	TokenNameIdentifier
=	TokenNameEQUAL
postings	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
postings	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
boolean	TokenNameboolean
useAdvance	TokenNameIdentifier
=	TokenNameEQUAL
postings	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
docFreq	TokenNameIdentifier
>	TokenNameGREATER
5	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
postings	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
docFreq	TokenNameIdentifier
;	TokenNameSEMICOLON
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
ChunkState	TokenNameIdentifier
(	TokenNameLPAREN
postings	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
postings	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
postings	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
position	TokenNameIdentifier
,	TokenNameCOMMA
useAdvance	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
postings	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
postings	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
noDocs	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
SCORE_CACHE_SIZE	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
scoreCache	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
getSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
tf	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
value	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
nextDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
docID	TokenNameIdentifier
=	TokenNameEQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
doc	TokenNameIdentifier
=	TokenNameEQUAL
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
chunkStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
ChunkState	TokenNameIdentifier
cs	TokenNameIdentifier
=	TokenNameEQUAL
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
doc2	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
useAdvance	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
doc2	TokenNameIdentifier
<	TokenNameLESS
doc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
skipTo	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
docID	TokenNameIdentifier
=	TokenNameEQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
doc2	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
iter	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
doc2	TokenNameIdentifier
<	TokenNameLESS
doc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
iter	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
50	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
skipTo	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
docID	TokenNameIdentifier
=	TokenNameEQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
doc2	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
doc2	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
docID	TokenNameIdentifier
=	TokenNameEQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doc2	TokenNameIdentifier
>	TokenNameGREATER
doc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
chunkStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
docID	TokenNameIdentifier
=	TokenNameEQUAL
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
freq	TokenNameIdentifier
=	TokenNameEQUAL
phraseFreq	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
freq	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
advance	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
target	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
skipTo	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
docID	TokenNameIdentifier
=	TokenNameEQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
doc	TokenNameIdentifier
=	TokenNameEQUAL
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
chunkStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
doc2	TokenNameIdentifier
=	TokenNameEQUAL
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doc2	TokenNameIdentifier
<	TokenNameLESS
doc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
skipTo	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
docID	TokenNameIdentifier
=	TokenNameEQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
doc2	TokenNameIdentifier
=	TokenNameEQUAL
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doc2	TokenNameIdentifier
>	TokenNameGREATER
doc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
chunkStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
docID	TokenNameIdentifier
=	TokenNameEQUAL
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
freq	TokenNameIdentifier
=	TokenNameEQUAL
phraseFreq	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
freq	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
docID	TokenNameIdentifier
=	TokenNameEQUAL
DocIdSetIterator	TokenNameIdentifier
.	TokenNameDOT
NO_MORE_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
doc	TokenNameIdentifier
=	TokenNameEQUAL
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"ExactPhraseScorer("	TokenNameStringLiteral
+	TokenNamePLUS
weight	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
float	TokenNamefloat
freq	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
freq	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
float	TokenNamefloat
score	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
float	TokenNamefloat
raw	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
freq	TokenNameIdentifier
<	TokenNameLESS
SCORE_CACHE_SIZE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
raw	TokenNameIdentifier
=	TokenNameEQUAL
scoreCache	TokenNameIdentifier
[	TokenNameLBRACKET
freq	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
raw	TokenNameIdentifier
=	TokenNameEQUAL
getSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
tf	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
freq	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
value	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
norms	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
raw	TokenNameIdentifier
:	TokenNameCOLON
raw	TokenNameIdentifier
*	TokenNameMULTIPLY
getSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
decodeNormValue	TokenNameIdentifier
(	TokenNameLPAREN
norms	TokenNameIdentifier
[	TokenNameLBRACKET
docID	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
phraseFreq	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
freq	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
chunkStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
ChunkState	TokenNameIdentifier
cs	TokenNameIdentifier
=	TokenNameEQUAL
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
cs	TokenNameIdentifier
.	TokenNameDOT
posLimit	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
freq	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
nextPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cs	TokenNameIdentifier
.	TokenNameDOT
posUpto	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
cs	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
chunkStart	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
chunkEnd	TokenNameIdentifier
=	TokenNameEQUAL
CHUNK	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
end	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
gen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
gen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
gens	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
gen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
final	TokenNamefinal
ChunkState	TokenNameIdentifier
cs	TokenNameIdentifier
=	TokenNameEQUAL
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
<	TokenNameLESS
chunkEnd	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
>	TokenNameGREATER
cs	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
cs	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
posIndex	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
-	TokenNameMINUS
chunkStart	TokenNameIdentifier
;	TokenNameSEMICOLON
counts	TokenNameIdentifier
[	TokenNameLBRACKET
posIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
gens	TokenNameIdentifier
[	TokenNameLBRACKET
posIndex	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
gen	TokenNameIdentifier
;	TokenNameSEMICOLON
gens	TokenNameIdentifier
[	TokenNameLBRACKET
posIndex	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
gen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
posUpto	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
posLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
end	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
cs	TokenNameIdentifier
.	TokenNameDOT
posUpto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
nextPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
boolean	TokenNameboolean
any	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
t	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
t	TokenNameIdentifier
<	TokenNameLESS
endMinus1	TokenNameIdentifier
;	TokenNameSEMICOLON
t	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
ChunkState	TokenNameIdentifier
cs	TokenNameIdentifier
=	TokenNameEQUAL
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
t	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
any	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
<	TokenNameLESS
chunkEnd	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
>	TokenNameGREATER
cs	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
cs	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
posIndex	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
-	TokenNameMINUS
chunkStart	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
posIndex	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
gens	TokenNameIdentifier
[	TokenNameLBRACKET
posIndex	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
gen	TokenNameIdentifier
&&	TokenNameAND_AND
counts	TokenNameIdentifier
[	TokenNameLBRACKET
posIndex	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
counts	TokenNameIdentifier
[	TokenNameLBRACKET
posIndex	TokenNameIdentifier
]	TokenNameRBRACKET
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
any	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
posUpto	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
posLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
end	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
cs	TokenNameIdentifier
.	TokenNameDOT
posUpto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
nextPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
any	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
any	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
chunkStart	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
CHUNK	TokenNameIdentifier
;	TokenNameSEMICOLON
chunkEnd	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
CHUNK	TokenNameIdentifier
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
{	TokenNameLBRACE
final	TokenNamefinal
ChunkState	TokenNameIdentifier
cs	TokenNameIdentifier
=	TokenNameEQUAL
chunkStates	TokenNameIdentifier
[	TokenNameLBRACKET
endMinus1	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
<	TokenNameLESS
chunkEnd	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
>	TokenNameGREATER
cs	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
cs	TokenNameIdentifier
.	TokenNameDOT
lastPos	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
posIndex	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
-	TokenNameMINUS
chunkStart	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
posIndex	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
gens	TokenNameIdentifier
[	TokenNameLBRACKET
posIndex	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
gen	TokenNameIdentifier
&&	TokenNameAND_AND
counts	TokenNameIdentifier
[	TokenNameLBRACKET
posIndex	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
endMinus1	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
freq	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
cs	TokenNameIdentifier
.	TokenNameDOT
posUpto	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
posLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
end	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
cs	TokenNameIdentifier
.	TokenNameDOT
posUpto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
cs	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
=	TokenNameEQUAL
cs	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
cs	TokenNameIdentifier
.	TokenNameDOT
posEnum	TokenNameIdentifier
.	TokenNameDOT
nextPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
chunkStart	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
CHUNK	TokenNameIdentifier
;	TokenNameSEMICOLON
chunkEnd	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
CHUNK	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
freq	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
