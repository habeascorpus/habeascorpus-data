package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
EOFException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
File	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
ByteBuffer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
channels	TokenNameIdentifier
.	TokenNameDOT
ClosedChannelException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
channels	TokenNameIdentifier
.	TokenNameDOT
FileChannel	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
concurrent	TokenNameIdentifier
.	TokenNameDOT
Future	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
NIOFSDirectory	TokenNameIdentifier
extends	TokenNameextends
FSDirectory	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
NIOFSDirectory	TokenNameIdentifier
(	TokenNameLPAREN
File	TokenNameIdentifier
path	TokenNameIdentifier
,	TokenNameCOMMA
LockFactory	TokenNameIdentifier
lockFactory	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
path	TokenNameIdentifier
,	TokenNameCOMMA
lockFactory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
NIOFSDirectory	TokenNameIdentifier
(	TokenNameLPAREN
File	TokenNameIdentifier
path	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
path	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
IndexInput	TokenNameIdentifier
openInput	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
bufferSize	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
new	TokenNamenew
NIOFSIndexInput	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
File	TokenNameIdentifier
(	TokenNameLPAREN
getDirectory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
name	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
bufferSize	TokenNameIdentifier
,	TokenNameCOMMA
getReadChunkSize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
static	TokenNamestatic
class	TokenNameclass
NIOFSIndexInput	TokenNameIdentifier
extends	TokenNameextends
SimpleFSDirectory	TokenNameIdentifier
.	TokenNameDOT
SimpleFSIndexInput	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
ByteBuffer	TokenNameIdentifier
byteBuf	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
otherBuffer	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
ByteBuffer	TokenNameIdentifier
otherByteBuf	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
FileChannel	TokenNameIdentifier
channel	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
NIOFSIndexInput	TokenNameIdentifier
(	TokenNameLPAREN
File	TokenNameIdentifier
path	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
bufferSize	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
chunkSize	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
"NIOFSIndexInput(path=""	TokenNameStringLiteral
+	TokenNamePLUS
path	TokenNameIdentifier
+	TokenNamePLUS
"")"	TokenNameStringLiteral
,	TokenNameCOMMA
path	TokenNameIdentifier
,	TokenNameCOMMA
bufferSize	TokenNameIdentifier
,	TokenNameCOMMA
chunkSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
channel	TokenNameIdentifier
=	TokenNameEQUAL
file	TokenNameIdentifier
.	TokenNameDOT
getChannel	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
void	TokenNamevoid
newBuffer	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newBuffer	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
.	TokenNameDOT
newBuffer	TokenNameIdentifier
(	TokenNameLPAREN
newBuffer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
byteBuf	TokenNameIdentifier
=	TokenNameEQUAL
ByteBuffer	TokenNameIdentifier
.	TokenNameDOT
wrap	TokenNameIdentifier
(	TokenNameLPAREN
newBuffer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
isClone	TokenNameIdentifier
&&	TokenNameAND_AND
file	TokenNameIdentifier
.	TokenNameDOT
isOpen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
channel	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
file	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
void	TokenNamevoid
readInternal	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
b	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
len	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
ByteBuffer	TokenNameIdentifier
bb	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
buffer	TokenNameIdentifier
&&	TokenNameAND_AND
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
byteBuf	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
byteBuf	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
byteBuf	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
(	TokenNameLPAREN
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bb	TokenNameIdentifier
=	TokenNameEQUAL
byteBuf	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
otherBuffer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
otherBuffer	TokenNameIdentifier
=	TokenNameEQUAL
b	TokenNameIdentifier
;	TokenNameSEMICOLON
otherByteBuf	TokenNameIdentifier
=	TokenNameEQUAL
ByteBuffer	TokenNameIdentifier
.	TokenNameDOT
wrap	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
otherByteBuf	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
otherByteBuf	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
(	TokenNameLPAREN
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bb	TokenNameIdentifier
=	TokenNameEQUAL
otherByteBuf	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
bb	TokenNameIdentifier
=	TokenNameEQUAL
ByteBuffer	TokenNameIdentifier
.	TokenNameDOT
wrap	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
readOffset	TokenNameIdentifier
=	TokenNameEQUAL
bb	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
readLength	TokenNameIdentifier
=	TokenNameEQUAL
bb	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
readOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
readLength	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
len	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
pos	TokenNameIdentifier
=	TokenNameEQUAL
getFilePointer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
readLength	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
readLength	TokenNameIdentifier
>	TokenNameGREATER
chunkSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
limit	TokenNameIdentifier
=	TokenNameEQUAL
readOffset	TokenNameIdentifier
+	TokenNamePLUS
chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
limit	TokenNameIdentifier
=	TokenNameEQUAL
readOffset	TokenNameIdentifier
+	TokenNamePLUS
readLength	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bb	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
(	TokenNameLPAREN
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
channel	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
bb	TokenNameIdentifier
,	TokenNameCOMMA
pos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
EOFException	TokenNameIdentifier
(	TokenNameLPAREN
"read past EOF: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pos	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
readOffset	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
readLength	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
i	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
OutOfMemoryError	TokenNameIdentifier
outOfMemoryError	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
OutOfMemoryError	TokenNameIdentifier
(	TokenNameLPAREN
"OutOfMemoryError likely caused by the Sun VM Bug described in "	TokenNameStringLiteral
+	TokenNamePLUS
"https://issues.apache.org/jira/browse/LUCENE-1566; try calling FSDirectory.setReadChunkSize "	TokenNameStringLiteral
+	TokenNamePLUS
"with a value smaller than the current chunk size ("	TokenNameStringLiteral
+	TokenNamePLUS
chunkSize	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outOfMemoryError	TokenNameIdentifier
.	TokenNameDOT
initCause	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
outOfMemoryError	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
ioe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
IOException	TokenNameIdentifier
newIOE	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
ioe	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
": "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
newIOE	TokenNameIdentifier
.	TokenNameDOT
initCause	TokenNameIdentifier
(	TokenNameLPAREN
ioe	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
newIOE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
