package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
EOFException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
File	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
RandomAccessFile	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
ByteBuffer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
BufferUnderflowException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
channels	TokenNameIdentifier
.	TokenNameDOT
ClosedChannelException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
channels	TokenNameIdentifier
.	TokenNameDOT
FileChannel	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
channels	TokenNameIdentifier
.	TokenNameDOT
FileChannel	TokenNameIdentifier
.	TokenNameDOT
MapMode	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Iterator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
security	TokenNameIdentifier
.	TokenNameDOT
AccessController	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
security	TokenNameIdentifier
.	TokenNameDOT
PrivilegedExceptionAction	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
security	TokenNameIdentifier
.	TokenNameDOT
PrivilegedActionException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
lang	TokenNameIdentifier
.	TokenNameDOT
reflect	TokenNameIdentifier
.	TokenNameDOT
Method	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Constants	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
WeakIdentityMap	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
MMapDirectory	TokenNameIdentifier
extends	TokenNameextends
FSDirectory	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
boolean	TokenNameboolean
useUnmapHack	TokenNameIdentifier
=	TokenNameEQUAL
UNMAP_SUPPORTED	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DEFAULT_MAX_BUFF	TokenNameIdentifier
=	TokenNameEQUAL
Constants	TokenNameIdentifier
.	TokenNameDOT
JRE_IS_64BIT	TokenNameIdentifier
?	TokenNameQUESTION
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
30	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
28	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
chunkSizePower	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
MMapDirectory	TokenNameIdentifier
(	TokenNameLPAREN
File	TokenNameIdentifier
path	TokenNameIdentifier
,	TokenNameCOMMA
LockFactory	TokenNameIdentifier
lockFactory	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
path	TokenNameIdentifier
,	TokenNameCOMMA
lockFactory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setMaxChunkSize	TokenNameIdentifier
(	TokenNameLPAREN
DEFAULT_MAX_BUFF	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
MMapDirectory	TokenNameIdentifier
(	TokenNameLPAREN
File	TokenNameIdentifier
path	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
path	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setMaxChunkSize	TokenNameIdentifier
(	TokenNameLPAREN
DEFAULT_MAX_BUFF	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
boolean	TokenNameboolean
UNMAP_SUPPORTED	TokenNameIdentifier
;	TokenNameSEMICOLON
static	TokenNamestatic
{	TokenNameLBRACE
boolean	TokenNameboolean
v	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
Class	TokenNameIdentifier
.	TokenNameDOT
forName	TokenNameIdentifier
(	TokenNameLPAREN
"sun.misc.Cleaner"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Class	TokenNameIdentifier
.	TokenNameDOT
forName	TokenNameIdentifier
(	TokenNameLPAREN
"java.nio.DirectByteBuffer"	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
getMethod	TokenNameIdentifier
(	TokenNameLPAREN
"cleaner"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
v	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Exception	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
v	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
UNMAP_SUPPORTED	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setUseUnmap	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
boolean	TokenNameboolean
useUnmapHack	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
useUnmapHack	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
UNMAP_SUPPORTED	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Unmap hack not supported on this platform!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
useUnmapHack	TokenNameIdentifier
=	TokenNameEQUAL
useUnmapHack	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getUseUnmap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
useUnmapHack	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
void	TokenNamevoid
cleanMapping	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
ByteBuffer	TokenNameIdentifier
buffer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
useUnmapHack	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
AccessController	TokenNameIdentifier
.	TokenNameDOT
doPrivileged	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
PrivilegedExceptionAction	TokenNameIdentifier
<	TokenNameLESS
Object	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
Object	TokenNameIdentifier
run	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
Exception	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
Method	TokenNameIdentifier
getCleanerMethod	TokenNameIdentifier
=	TokenNameEQUAL
buffer	TokenNameIdentifier
.	TokenNameDOT
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getMethod	TokenNameIdentifier
(	TokenNameLPAREN
"cleaner"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
getCleanerMethod	TokenNameIdentifier
.	TokenNameDOT
setAccessible	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
Object	TokenNameIdentifier
cleaner	TokenNameIdentifier
=	TokenNameEQUAL
getCleanerMethod	TokenNameIdentifier
.	TokenNameDOT
invoke	TokenNameIdentifier
(	TokenNameLPAREN
buffer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cleaner	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
cleaner	TokenNameIdentifier
.	TokenNameDOT
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getMethod	TokenNameIdentifier
(	TokenNameLPAREN
"clean"	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
invoke	TokenNameIdentifier
(	TokenNameLPAREN
cleaner	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
PrivilegedActionException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
IOException	TokenNameIdentifier
ioe	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"unable to unmap the mapped buffer"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ioe	TokenNameIdentifier
.	TokenNameDOT
initCause	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getCause	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
ioe	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
setMaxChunkSize	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
int	TokenNameint
maxChunkSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
maxChunkSize	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Maximum chunk size for mmap must be >0"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
chunkSizePower	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
-	TokenNameMINUS
Integer	TokenNameIdentifier
.	TokenNameDOT
numberOfLeadingZeros	TokenNameIdentifier
(	TokenNameLPAREN
maxChunkSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
this	TokenNamethis
.	TokenNameDOT
chunkSizePower	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
this	TokenNamethis
.	TokenNameDOT
chunkSizePower	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
30	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
int	TokenNameint
getMaxChunkSize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
chunkSizePower	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
IndexInput	TokenNameIdentifier
openInput	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
bufferSize	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
File	TokenNameIdentifier
f	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
File	TokenNameIdentifier
(	TokenNameLPAREN
getDirectory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
RandomAccessFile	TokenNameIdentifier
raf	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
RandomAccessFile	TokenNameIdentifier
(	TokenNameLPAREN
f	TokenNameIdentifier
,	TokenNameCOMMA
"r"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
MMapIndexInput	TokenNameIdentifier
(	TokenNameLPAREN
"MMapIndexInput(path=""	TokenNameStringLiteral
+	TokenNamePLUS
f	TokenNameIdentifier
+	TokenNamePLUS
"")"	TokenNameStringLiteral
,	TokenNameCOMMA
raf	TokenNameIdentifier
,	TokenNameCOMMA
chunkSizePower	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
raf	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
class	TokenNameclass
MMapIndexInput	TokenNameIdentifier
extends	TokenNameextends
IndexInput	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
ByteBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
buffers	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
long	TokenNamelong
length	TokenNameIdentifier
,	TokenNameCOMMA
chunkSizeMask	TokenNameIdentifier
,	TokenNameCOMMA
chunkSize	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
chunkSizePower	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
curBufIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
ByteBuffer	TokenNameIdentifier
curBuf	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
isClone	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
WeakIdentityMap	TokenNameIdentifier
<	TokenNameLESS
MMapIndexInput	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
>	TokenNameGREATER
clones	TokenNameIdentifier
=	TokenNameEQUAL
WeakIdentityMap	TokenNameIdentifier
.	TokenNameDOT
newConcurrentHashMap	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
MMapIndexInput	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
resourceDescription	TokenNameIdentifier
,	TokenNameCOMMA
RandomAccessFile	TokenNameIdentifier
raf	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
chunkSizePower	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
resourceDescription	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
length	TokenNameIdentifier
=	TokenNameEQUAL
raf	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
chunkSizePower	TokenNameIdentifier
=	TokenNameEQUAL
chunkSizePower	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
chunkSize	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
chunkSizePower	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
chunkSizeMask	TokenNameIdentifier
=	TokenNameEQUAL
chunkSize	TokenNameIdentifier
-	TokenNameMINUS
1L	TokenNameLongLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
chunkSizePower	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
chunkSizePower	TokenNameIdentifier
>	TokenNameGREATER
30	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Invalid chunkSizePower used for ByteBuffer size: "	TokenNameStringLiteral
+	TokenNamePLUS
chunkSizePower	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
length	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
chunkSizePower	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
Integer	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"RandomAccessFile too big for chunk size: "	TokenNameStringLiteral
+	TokenNamePLUS
raf	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
nrBuffers	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
length	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
chunkSizePower	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
buffers	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ByteBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
nrBuffers	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
long	TokenNamelong
bufferStart	TokenNameIdentifier
=	TokenNameEQUAL
0L	TokenNameLongLiteral
;	TokenNameSEMICOLON
FileChannel	TokenNameIdentifier
rafc	TokenNameIdentifier
=	TokenNameEQUAL
raf	TokenNameIdentifier
.	TokenNameDOT
getChannel	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
bufNr	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
bufNr	TokenNameIdentifier
<	TokenNameLESS
nrBuffers	TokenNameIdentifier
;	TokenNameSEMICOLON
bufNr	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
bufSize	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
length	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
bufferStart	TokenNameIdentifier
+	TokenNamePLUS
chunkSize	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
?	TokenNameQUESTION
chunkSize	TokenNameIdentifier
:	TokenNameCOLON
(	TokenNameLPAREN
length	TokenNameIdentifier
-	TokenNameMINUS
bufferStart	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
buffers	TokenNameIdentifier
[	TokenNameLBRACKET
bufNr	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
rafc	TokenNameIdentifier
.	TokenNameDOT
map	TokenNameIdentifier
(	TokenNameLPAREN
MapMode	TokenNameIdentifier
.	TokenNameDOT
READ_ONLY	TokenNameIdentifier
,	TokenNameCOMMA
bufferStart	TokenNameIdentifier
,	TokenNameCOMMA
bufSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bufferStart	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
bufSize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
seek	TokenNameIdentifier
(	TokenNameLPAREN
0L	TokenNameLongLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
byte	TokenNamebyte
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
curBuf	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
BufferUnderflowException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
curBufIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
curBufIndex	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
buffers	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
EOFException	TokenNameIdentifier
(	TokenNameLPAREN
"read past EOF: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
curBuf	TokenNameIdentifier
=	TokenNameEQUAL
buffers	TokenNameIdentifier
[	TokenNameLBRACKET
curBufIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
curBuf	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
curBuf	TokenNameIdentifier
.	TokenNameDOT
hasRemaining	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
curBuf	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NullPointerException	TokenNameIdentifier
npe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AlreadyClosedException	TokenNameIdentifier
(	TokenNameLPAREN
"MMapIndexInput already closed: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
readBytes	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
b	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
len	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
curBuf	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
BufferUnderflowException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
curAvail	TokenNameIdentifier
=	TokenNameEQUAL
curBuf	TokenNameIdentifier
.	TokenNameDOT
remaining	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
len	TokenNameIdentifier
>	TokenNameGREATER
curAvail	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
curBuf	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
curAvail	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
len	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
curAvail	TokenNameIdentifier
;	TokenNameSEMICOLON
offset	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
curAvail	TokenNameIdentifier
;	TokenNameSEMICOLON
curBufIndex	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
curBufIndex	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
buffers	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
EOFException	TokenNameIdentifier
(	TokenNameLPAREN
"read past EOF: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
curBuf	TokenNameIdentifier
=	TokenNameEQUAL
buffers	TokenNameIdentifier
[	TokenNameLBRACKET
curBufIndex	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
curBuf	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
curAvail	TokenNameIdentifier
=	TokenNameEQUAL
curBuf	TokenNameIdentifier
.	TokenNameDOT
remaining	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
curBuf	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NullPointerException	TokenNameIdentifier
npe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AlreadyClosedException	TokenNameIdentifier
(	TokenNameLPAREN
"MMapIndexInput already closed: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
short	TokenNameshort
readShort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
curBuf	TokenNameIdentifier
.	TokenNameDOT
getShort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
BufferUnderflowException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
super	TokenNamesuper
.	TokenNameDOT
readShort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NullPointerException	TokenNameIdentifier
npe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AlreadyClosedException	TokenNameIdentifier
(	TokenNameLPAREN
"MMapIndexInput already closed: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
curBuf	TokenNameIdentifier
.	TokenNameDOT
getInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
BufferUnderflowException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
super	TokenNamesuper
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NullPointerException	TokenNameIdentifier
npe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AlreadyClosedException	TokenNameIdentifier
(	TokenNameLPAREN
"MMapIndexInput already closed: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
long	TokenNamelong
readLong	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
curBuf	TokenNameIdentifier
.	TokenNameDOT
getLong	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
BufferUnderflowException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
super	TokenNamesuper
.	TokenNameDOT
readLong	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NullPointerException	TokenNameIdentifier
npe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AlreadyClosedException	TokenNameIdentifier
(	TokenNameLPAREN
"MMapIndexInput already closed: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
long	TokenNamelong
getFilePointer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
curBufIndex	TokenNameIdentifier
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
chunkSizePower	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
curBuf	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NullPointerException	TokenNameIdentifier
npe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AlreadyClosedException	TokenNameIdentifier
(	TokenNameLPAREN
"MMapIndexInput already closed: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
seek	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
pos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
bi	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
pos	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
chunkSizePower	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
final	TokenNamefinal
ByteBuffer	TokenNameIdentifier
b	TokenNameIdentifier
=	TokenNameEQUAL
buffers	TokenNameIdentifier
[	TokenNameLBRACKET
bi	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
b	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
pos	TokenNameIdentifier
&	TokenNameAND
chunkSizeMask	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
curBufIndex	TokenNameIdentifier
=	TokenNameEQUAL
bi	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
curBuf	TokenNameIdentifier
=	TokenNameEQUAL
b	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
ArrayIndexOutOfBoundsException	TokenNameIdentifier
aioobe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
<	TokenNameLESS
0L	TokenNameLongLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Seeking to negative position: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
EOFException	TokenNameIdentifier
(	TokenNameLPAREN
"seek past EOF: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IllegalArgumentException	TokenNameIdentifier
iae	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
<	TokenNameLESS
0L	TokenNameLongLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Seeking to negative position: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
new	TokenNamenew
EOFException	TokenNameIdentifier
(	TokenNameLPAREN
"seek past EOF: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
NullPointerException	TokenNameIdentifier
npe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AlreadyClosedException	TokenNameIdentifier
(	TokenNameLPAREN
"MMapIndexInput already closed: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
long	TokenNamelong
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
length	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
Object	TokenNameIdentifier
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
buffers	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AlreadyClosedException	TokenNameIdentifier
(	TokenNameLPAREN
"MMapIndexInput already closed: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
MMapIndexInput	TokenNameIdentifier
clone	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
MMapIndexInput	TokenNameIdentifier
)	TokenNameRPAREN
super	TokenNamesuper
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
isClone	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
assert	TokenNameassert
clone	TokenNameIdentifier
.	TokenNameDOT
clones	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
this	TokenNamethis
.	TokenNameDOT
clones	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
buffers	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ByteBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
buffers	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
bufNr	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
bufNr	TokenNameIdentifier
<	TokenNameLESS
buffers	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
bufNr	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
clone	TokenNameIdentifier
.	TokenNameDOT
buffers	TokenNameIdentifier
[	TokenNameLBRACKET
bufNr	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
buffers	TokenNameIdentifier
[	TokenNameLBRACKET
bufNr	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
duplicate	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
clone	TokenNameIdentifier
.	TokenNameDOT
seek	TokenNameIdentifier
(	TokenNameLPAREN
getFilePointer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
ioe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Should never happen: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
,	TokenNameCOMMA
ioe	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
clones	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
clone	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
.	TokenNameDOT
TRUE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
clone	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
unsetBuffers	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
buffers	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
curBuf	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
curBufIndex	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
isClone	TokenNameIdentifier
||	TokenNameOR_OR
buffers	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
final	TokenNamefinal
ByteBuffer	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bufs	TokenNameIdentifier
=	TokenNameEQUAL
buffers	TokenNameIdentifier
;	TokenNameSEMICOLON
unsetBuffers	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Iterator	TokenNameIdentifier
<	TokenNameLESS
MMapIndexInput	TokenNameIdentifier
>	TokenNameGREATER
it	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
clones	TokenNameIdentifier
.	TokenNameDOT
keyIterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
it	TokenNameIdentifier
.	TokenNameDOT
hasNext	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
MMapIndexInput	TokenNameIdentifier
clone	TokenNameIdentifier
=	TokenNameEQUAL
it	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
clone	TokenNameIdentifier
.	TokenNameDOT
isClone	TokenNameIdentifier
;	TokenNameSEMICOLON
clone	TokenNameIdentifier
.	TokenNameDOT
unsetBuffers	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
clones	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
ByteBuffer	TokenNameIdentifier
b	TokenNameIdentifier
:	TokenNameCOLON
bufs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
cleanMapping	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
unsetBuffers	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
