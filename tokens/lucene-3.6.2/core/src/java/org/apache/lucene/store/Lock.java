package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ThreadInterruptedException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
class	TokenNameclass
Lock	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
long	TokenNamelong
LOCK_POLL_INTERVAL	TokenNameIdentifier
=	TokenNameEQUAL
1000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
long	TokenNamelong
LOCK_OBTAIN_WAIT_FOREVER	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
boolean	TokenNameboolean
obtain	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
Throwable	TokenNameIdentifier
failureReason	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
obtain	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
lockWaitTimeout	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
LockObtainFailedException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
failureReason	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
locked	TokenNameIdentifier
=	TokenNameEQUAL
obtain	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lockWaitTimeout	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
lockWaitTimeout	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
LOCK_OBTAIN_WAIT_FOREVER	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"lockWaitTimeout should be LOCK_OBTAIN_WAIT_FOREVER or a non-negative number (got "	TokenNameStringLiteral
+	TokenNamePLUS
lockWaitTimeout	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
maxSleepCount	TokenNameIdentifier
=	TokenNameEQUAL
lockWaitTimeout	TokenNameIdentifier
/	TokenNameDIVIDE
LOCK_POLL_INTERVAL	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
sleepCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
locked	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
lockWaitTimeout	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
LOCK_OBTAIN_WAIT_FOREVER	TokenNameIdentifier
&&	TokenNameAND_AND
sleepCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
>=	TokenNameGREATER_EQUAL
maxSleepCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
reason	TokenNameIdentifier
=	TokenNameEQUAL
"Lock obtain timed out: "	TokenNameStringLiteral
+	TokenNamePLUS
this	TokenNamethis
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
failureReason	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
reason	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
": "	TokenNameStringLiteral
+	TokenNamePLUS
failureReason	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
LockObtainFailedException	TokenNameIdentifier
e	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
LockObtainFailedException	TokenNameIdentifier
(	TokenNameLPAREN
reason	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
failureReason	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
e	TokenNameIdentifier
.	TokenNameDOT
initCause	TokenNameIdentifier
(	TokenNameLPAREN
failureReason	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
throw	TokenNamethrow
e	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
Thread	TokenNameIdentifier
.	TokenNameDOT
sleep	TokenNameIdentifier
(	TokenNameLPAREN
LOCK_POLL_INTERVAL	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InterruptedException	TokenNameIdentifier
ie	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ThreadInterruptedException	TokenNameIdentifier
(	TokenNameLPAREN
ie	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
locked	TokenNameIdentifier
=	TokenNameEQUAL
obtain	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
locked	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
abstract	TokenNameabstract
void	TokenNamevoid
release	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
boolean	TokenNameboolean
isLocked	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
static	TokenNamestatic
class	TokenNameclass
With	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
Lock	TokenNameIdentifier
lock	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
lockWaitTimeout	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
With	TokenNameIdentifier
(	TokenNameLPAREN
Lock	TokenNameIdentifier
lock	TokenNameIdentifier
,	TokenNameCOMMA
long	TokenNamelong
lockWaitTimeout	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
lock	TokenNameIdentifier
=	TokenNameEQUAL
lock	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
lockWaitTimeout	TokenNameIdentifier
=	TokenNameEQUAL
lockWaitTimeout	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
abstract	TokenNameabstract
Object	TokenNameIdentifier
doBody	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Object	TokenNameIdentifier
run	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
LockObtainFailedException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
locked	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
locked	TokenNameIdentifier
=	TokenNameEQUAL
lock	TokenNameIdentifier
.	TokenNameDOT
obtain	TokenNameIdentifier
(	TokenNameLPAREN
lockWaitTimeout	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
doBody	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
locked	TokenNameIdentifier
)	TokenNameRPAREN
lock	TokenNameIdentifier
.	TokenNameDOT
release	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
