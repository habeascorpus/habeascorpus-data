package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
fst	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
BufferedInputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
BufferedOutputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
File	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
FileInputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
FileOutputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
InputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
OutputStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashMap	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Map	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
DataInput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
DataOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
InputStreamDataInput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
OutputStreamDataOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
CodecUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
IOUtils	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
IntsRef	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
PriorityQueue	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
RamUsageEstimator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
fst	TokenNameIdentifier
.	TokenNameDOT
Builder	TokenNameIdentifier
.	TokenNameDOT
UnCompiledNode	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
class	TokenNameclass
FST	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
enum	TokenNameenum
INPUT_TYPE	TokenNameIdentifier
{	TokenNameLBRACE
BYTE1	TokenNameIdentifier
,	TokenNameCOMMA
BYTE2	TokenNameIdentifier
,	TokenNameCOMMA
BYTE4	TokenNameIdentifier
}	TokenNameRBRACE
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
INPUT_TYPE	TokenNameIdentifier
inputType	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BIT_FINAL_ARC	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BIT_LAST_ARC	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BIT_TARGET_NEXT	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BIT_STOP_NODE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
5	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BIT_TARGET_DELTA	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
byte	TokenNamebyte
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier
=	TokenNameEQUAL
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
FIXED_ARRAY_SHALLOW_DISTANCE	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
FIXED_ARRAY_NUM_ARCS_SHALLOW	TokenNameIdentifier
=	TokenNameEQUAL
5	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
FIXED_ARRAY_NUM_ARCS_DEEP	TokenNameIdentifier
=	TokenNameEQUAL
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
String	TokenNameIdentifier
FILE_FORMAT_NAME	TokenNameIdentifier
=	TokenNameEQUAL
"FST"	TokenNameStringLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
VERSION_START	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
VERSION_INT_NUM_BYTES_PER_ARC	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
VERSION_SHORT_BYTE2_LABELS	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
VERSION_PACKED	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
VERSION_CURRENT	TokenNameIdentifier
=	TokenNameEQUAL
VERSION_PACKED	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
FINAL_END_NODE	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
NON_FINAL_END_NODE	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
T	TokenNameIdentifier
emptyOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
emptyOutputBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytes	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
byteUpto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
startNode	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
Outputs	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
outputs	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
lastFrozenNode	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
T	TokenNameIdentifier
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
nodeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
arcCount	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
arcWithOutputCount	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
packed	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
nodeRefToAddress	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
END_LABEL	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
allowArrayArcs	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
private	TokenNameprivate
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
cachedRootArcs	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
static	TokenNamestatic
class	TokenNameclass
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
label	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
T	TokenNameIdentifier
output	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
node	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
target	TokenNameIdentifier
;	TokenNameSEMICOLON
byte	TokenNamebyte
flags	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
T	TokenNameIdentifier
nextFinalOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
nextArc	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
posArcsStart	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
bytesPerArc	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
arcIdx	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
copyFrom	TokenNameIdentifier
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
node	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
;	TokenNameSEMICOLON
label	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
;	TokenNameSEMICOLON
target	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
flags	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
;	TokenNameSEMICOLON
output	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
;	TokenNameSEMICOLON
nextFinalOutput	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
nextArc	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
;	TokenNameSEMICOLON
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bytesPerArc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
posArcsStart	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
posArcsStart	TokenNameIdentifier
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
arcIdx	TokenNameIdentifier
;	TokenNameSEMICOLON
numArcs	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
flag	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
flag	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
FST	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
flags	TokenNameIdentifier
,	TokenNameCOMMA
flag	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isLast	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_LAST_ARC	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isFinal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_FINAL_ARC	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuilder	TokenNameIdentifier
b	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
b	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"node="	TokenNameStringLiteral
+	TokenNamePLUS
node	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
b	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" target="	TokenNameStringLiteral
+	TokenNamePLUS
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
b	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" label="	TokenNameStringLiteral
+	TokenNamePLUS
label	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_LAST_ARC	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" last"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_FINAL_ARC	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" final"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_TARGET_NEXT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" targetNext"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" output="	TokenNameStringLiteral
+	TokenNamePLUS
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" nextFinalOutput="	TokenNameStringLiteral
+	TokenNamePLUS
nextFinalOutput	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
bytesPerArc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
" arcArray(idx="	TokenNameStringLiteral
+	TokenNamePLUS
arcIdx	TokenNameIdentifier
+	TokenNamePLUS
" of "	TokenNameStringLiteral
+	TokenNamePLUS
numArcs	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
b	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
boolean	TokenNameboolean
flag	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
flags	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
bit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
flags	TokenNameIdentifier
&	TokenNameAND
bit	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
BytesWriter	TokenNameIdentifier
writer	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
nodeAddress	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
inCounts	TokenNameIdentifier
;	TokenNameSEMICOLON
FST	TokenNameIdentifier
(	TokenNameLPAREN
INPUT_TYPE	TokenNameIdentifier
inputType	TokenNameIdentifier
,	TokenNameCOMMA
Outputs	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
outputs	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
willPackFST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
inputType	TokenNameIdentifier
=	TokenNameEQUAL
inputType	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
outputs	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
128	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
NO_OUTPUT	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
getNoOutput	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
willPackFST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
nodeAddress	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
8	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
inCounts	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
8	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
nodeAddress	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
inCounts	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
writer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BytesWriter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
emptyOutput	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
packed	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
nodeRefToAddress	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
FST	TokenNameIdentifier
(	TokenNameLPAREN
DataInput	TokenNameIdentifier
in	TokenNameIdentifier
,	TokenNameCOMMA
Outputs	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
outputs	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
outputs	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
CodecUtil	TokenNameIdentifier
.	TokenNameDOT
checkHeader	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
,	TokenNameCOMMA
FILE_FORMAT_NAME	TokenNameIdentifier
,	TokenNameCOMMA
VERSION_PACKED	TokenNameIdentifier
,	TokenNameCOMMA
VERSION_PACKED	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
packed	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
numBytes	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
numBytes	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
in	TokenNameIdentifier
.	TokenNameDOT
readBytes	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
numBytes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
emptyOutput	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
emptyOutput	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
numBytes	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
emptyOutput	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
byte	TokenNamebyte
t	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
switch	TokenNameswitch
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
case	TokenNamecase
0	TokenNameIntegerLiteral
:	TokenNameCOLON
inputType	TokenNameIdentifier
=	TokenNameEQUAL
INPUT_TYPE	TokenNameIdentifier
.	TokenNameDOT
BYTE1	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
1	TokenNameIntegerLiteral
:	TokenNameCOLON
inputType	TokenNameIdentifier
=	TokenNameEQUAL
INPUT_TYPE	TokenNameIdentifier
.	TokenNameDOT
BYTE2	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
case	TokenNamecase
2	TokenNameIntegerLiteral
:	TokenNameCOLON
inputType	TokenNameIdentifier
=	TokenNameEQUAL
INPUT_TYPE	TokenNameIdentifier
.	TokenNameDOT
BYTE4	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
default	TokenNamedefault
:	TokenNameCOLON
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"invalid input type "	TokenNameStringLiteral
+	TokenNamePLUS
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
nodeRefCount	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
nodeRefToAddress	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
nodeRefCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
<	TokenNameLESS
nodeRefCount	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
nodeRefToAddress	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
nodeRefToAddress	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
startNode	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
nodeCount	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
arcCount	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
arcWithOutputCount	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
in	TokenNameIdentifier
.	TokenNameDOT
readBytes	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
NO_OUTPUT	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
getNoOutput	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cacheRootArcs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
INPUT_TYPE	TokenNameIdentifier
getInputType	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
inputType	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
size	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
nodeRefToAddress	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
nodeAddress	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
size	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
nodeAddress	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
;	TokenNameSEMICOLON
size	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
inCounts	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
size	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
finish	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
startNode	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
startNode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
FINAL_END_NODE	TokenNameIdentifier
&&	TokenNameAND_AND
emptyOutput	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
startNode	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
startNode	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"already finished"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
finalBytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
finalBytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
=	TokenNameEQUAL
finalBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
startNode	TokenNameIdentifier
=	TokenNameEQUAL
startNode	TokenNameIdentifier
;	TokenNameSEMICOLON
cacheRootArcs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
getNodeAddress	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
node	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nodeAddress	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
nodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
node	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
node	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
{	TokenNameLBRACE
"rawtypes"	TokenNameStringLiteral
,	TokenNameCOMMA
"unchecked"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
private	TokenNameprivate
void	TokenNamevoid
cacheRootArcs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
cachedRootArcs	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
[	TokenNameLBRACKET
]	TokenNameRBRACKET
)	TokenNameRPAREN
new	TokenNamenew
Arc	TokenNameIdentifier
[	TokenNameLBRACKET
0x80	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
getFirstArc	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
BytesReader	TokenNameIdentifier
in	TokenNameIdentifier
=	TokenNameEQUAL
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
targetHasArcs	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
readFirstRealTargetArc	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
,	TokenNameCOMMA
arc	TokenNameIdentifier
,	TokenNameCOMMA
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
END_LABEL	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
<	TokenNameLESS
cachedRootArcs	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
cachedRootArcs	TokenNameIdentifier
[	TokenNameLBRACKET
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
copyFrom	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
isLast	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
readNextRealArc	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
,	TokenNameCOMMA
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
T	TokenNameIdentifier
getEmptyOutput	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
emptyOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
setEmptyOutput	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
v	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
emptyOutput	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
emptyOutput	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
merge	TokenNameIdentifier
(	TokenNameLPAREN
emptyOutput	TokenNameIdentifier
,	TokenNameCOMMA
v	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
emptyOutput	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
posSave	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
outputs	TokenNameIdentifier
.	TokenNameDOT
write	TokenNameIdentifier
(	TokenNameLPAREN
emptyOutput	TokenNameIdentifier
,	TokenNameCOMMA
writer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
emptyOutputBytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
-	TokenNameMINUS
posSave	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
stopAt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
-	TokenNameMINUS
posSave	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
upto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
upto	TokenNameIdentifier
<	TokenNameLESS
stopAt	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
byte	TokenNamebyte
b	TokenNameIdentifier
=	TokenNameEQUAL
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
posSave	TokenNameIdentifier
+	TokenNamePLUS
upto	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
posSave	TokenNameIdentifier
+	TokenNamePLUS
upto	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
-	TokenNameMINUS
upto	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
-	TokenNameMINUS
upto	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
b	TokenNameIdentifier
;	TokenNameSEMICOLON
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
posSave	TokenNameIdentifier
,	TokenNameCOMMA
emptyOutputBytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
-	TokenNameMINUS
posSave	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
=	TokenNameEQUAL
posSave	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
save	TokenNameIdentifier
(	TokenNameLPAREN
DataOutput	TokenNameIdentifier
out	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
startNode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"call finish first"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
nodeAddress	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"cannot save an FST pre-packed FST; it must first be packed"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
CodecUtil	TokenNameIdentifier
.	TokenNameDOT
writeHeader	TokenNameIdentifier
(	TokenNameLPAREN
out	TokenNameIdentifier
,	TokenNameCOMMA
FILE_FORMAT_NAME	TokenNameIdentifier
,	TokenNameCOMMA
VERSION_CURRENT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
out	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
emptyOutput	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
emptyOutputBytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
.	TokenNameDOT
writeBytes	TokenNameIdentifier
(	TokenNameLPAREN
emptyOutputBytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
emptyOutputBytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
out	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
byte	TokenNamebyte
t	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
inputType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INPUT_TYPE	TokenNameIdentifier
.	TokenNameDOT
BYTE1	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
t	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
inputType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INPUT_TYPE	TokenNameIdentifier
.	TokenNameDOT
BYTE2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
t	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
t	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
out	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
nodeRefToAddress	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
out	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
nodeRefToAddress	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
<	TokenNameLESS
nodeRefToAddress	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
out	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
nodeRefToAddress	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
out	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
startNode	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
nodeCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
arcCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
arcWithOutputCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
out	TokenNameIdentifier
.	TokenNameDOT
writeBytes	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
save	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
File	TokenNameIdentifier
file	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
OutputStream	TokenNameIdentifier
os	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BufferedOutputStream	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
FileOutputStream	TokenNameIdentifier
(	TokenNameLPAREN
file	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
save	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
OutputStreamDataOutput	TokenNameIdentifier
(	TokenNameLPAREN
os	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
IOUtils	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
os	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
IOUtils	TokenNameIdentifier
.	TokenNameDOT
closeWhileHandlingException	TokenNameIdentifier
(	TokenNameLPAREN
os	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
FST	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
read	TokenNameIdentifier
(	TokenNameLPAREN
File	TokenNameIdentifier
file	TokenNameIdentifier
,	TokenNameCOMMA
Outputs	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
outputs	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
InputStream	TokenNameIdentifier
is	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BufferedInputStream	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
FileInputStream	TokenNameIdentifier
(	TokenNameLPAREN
file	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
FST	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
fst	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FST	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
new	TokenNamenew
InputStreamDataInput	TokenNameIdentifier
(	TokenNameLPAREN
is	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
outputs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
fst	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
IOUtils	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
is	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
IOUtils	TokenNameIdentifier
.	TokenNameDOT
closeWhileHandlingException	TokenNameIdentifier
(	TokenNameLPAREN
is	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
writeLabel	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
v	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
v	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
:	TokenNameCOLON
"v="	TokenNameStringLiteral
+	TokenNamePLUS
v	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
inputType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INPUT_TYPE	TokenNameIdentifier
.	TokenNameDOT
BYTE1	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
v	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
255	TokenNameIntegerLiteral
:	TokenNameCOLON
"v="	TokenNameStringLiteral
+	TokenNamePLUS
v	TokenNameIdentifier
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
v	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
inputType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INPUT_TYPE	TokenNameIdentifier
.	TokenNameDOT
BYTE2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
v	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
65535	TokenNameIntegerLiteral
:	TokenNameCOLON
"v="	TokenNameStringLiteral
+	TokenNamePLUS
v	TokenNameIdentifier
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
writeShort	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
v	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
v	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
readLabel	TokenNameIdentifier
(	TokenNameLPAREN
DataInput	TokenNameIdentifier
in	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
v	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
inputType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INPUT_TYPE	TokenNameIdentifier
.	TokenNameDOT
BYTE1	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
v	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&	TokenNameAND
0xFF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
inputType	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
INPUT_TYPE	TokenNameIdentifier
.	TokenNameDOT
BYTE2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
v	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readShort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&	TokenNameAND
0xFFFF	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
v	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
v	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
boolean	TokenNameboolean
targetHasArcs	TokenNameIdentifier
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
addNode	TokenNameIdentifier
(	TokenNameLPAREN
Builder	TokenNameIdentifier
.	TokenNameDOT
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
nodeIn	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nodeIn	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
FINAL_END_NODE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
NON_FINAL_END_NODE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
startAddress	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
doFixedArray	TokenNameIdentifier
=	TokenNameEQUAL
shouldExpand	TokenNameIdentifier
(	TokenNameLPAREN
nodeIn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
fixedArrayStart	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doFixedArray	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bytesPerArc	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
oversize	TokenNameIdentifier
(	TokenNameLPAREN
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
writeInt	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fixedArrayStart	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fixedArrayStart	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arcCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
lastArc	TokenNameIdentifier
=	TokenNameEQUAL
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
lastArcStart	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
maxBytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
arcIdx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
<	TokenNameLESS
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Builder	TokenNameIdentifier
.	TokenNameDOT
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
=	TokenNameEQUAL
nodeIn	TokenNameIdentifier
.	TokenNameDOT
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
Builder	TokenNameIdentifier
.	TokenNameDOT
CompiledNode	TokenNameIdentifier
target	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Builder	TokenNameIdentifier
.	TokenNameDOT
CompiledNode	TokenNameIdentifier
)	TokenNameRPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
flags	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arcIdx	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
lastArc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_LAST_ARC	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
lastFrozenNode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
target	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
doFixedArray	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_TARGET_NEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_FINAL_ARC	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
assert	TokenNameassert
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
targetHasArcs	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
targetHasArcs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_STOP_NODE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
inCounts	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
inCounts	TokenNameIdentifier
[	TokenNameLBRACKET
target	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
]	TokenNameRBRACKET
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
flags	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writeLabel	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputs	TokenNameIdentifier
.	TokenNameDOT
write	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
,	TokenNameCOMMA
writer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
arcWithOutputCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputs	TokenNameIdentifier
.	TokenNameDOT
write	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
,	TokenNameCOMMA
writer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
targetHasArcs	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
flags	TokenNameIdentifier
&	TokenNameAND
BIT_TARGET_NEXT	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
target	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
writeInt	TokenNameIdentifier
(	TokenNameLPAREN
target	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doFixedArray	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesPerArc	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
-	TokenNameMINUS
lastArcStart	TokenNameIdentifier
;	TokenNameSEMICOLON
lastArcStart	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
maxBytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
maxBytesPerArc	TokenNameIdentifier
,	TokenNameCOMMA
bytesPerArc	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doFixedArray	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
maxBytesPerArc	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
sizeNeeded	TokenNameIdentifier
=	TokenNameEQUAL
fixedArrayStart	TokenNameIdentifier
+	TokenNamePLUS
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
*	TokenNameMULTIPLY
maxBytesPerArc	TokenNameIdentifier
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
sizeNeeded	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
fixedArrayStart	TokenNameIdentifier
-	TokenNameMINUS
4	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
maxBytesPerArc	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
24	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
fixedArrayStart	TokenNameIdentifier
-	TokenNameMINUS
3	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
maxBytesPerArc	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
16	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
fixedArrayStart	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
maxBytesPerArc	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
fixedArrayStart	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
maxBytesPerArc	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
srcPos	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
destPos	TokenNameIdentifier
=	TokenNameEQUAL
fixedArrayStart	TokenNameIdentifier
+	TokenNamePLUS
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
*	TokenNameMULTIPLY
maxBytesPerArc	TokenNameIdentifier
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
=	TokenNameEQUAL
destPos	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
arcIdx	TokenNameIdentifier
=	TokenNameEQUAL
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
destPos	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
maxBytesPerArc	TokenNameIdentifier
;	TokenNameSEMICOLON
srcPos	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
bytesPerArc	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
srcPos	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
destPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
destPos	TokenNameIdentifier
>	TokenNameGREATER
srcPos	TokenNameIdentifier
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
srcPos	TokenNameIdentifier
,	TokenNameCOMMA
bytes	TokenNameIdentifier
,	TokenNameCOMMA
destPos	TokenNameIdentifier
,	TokenNameCOMMA
bytesPerArc	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
endAddress	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
left	TokenNameIdentifier
=	TokenNameEQUAL
startAddress	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
right	TokenNameIdentifier
=	TokenNameEQUAL
endAddress	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
left	TokenNameIdentifier
<	TokenNameLESS
right	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
byte	TokenNamebyte
b	TokenNameIdentifier
=	TokenNameEQUAL
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
left	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
left	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
right	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
right	TokenNameIdentifier
--	TokenNameMINUS_MINUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
b	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nodeCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
node	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nodeAddress	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nodeCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
nodeAddress	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
nodeAddress	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
nodeAddress	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
inCounts	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
inCounts	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
nodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
nodeCount	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
endAddress	TokenNameIdentifier
;	TokenNameSEMICOLON
node	TokenNameIdentifier
=	TokenNameEQUAL
nodeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
node	TokenNameIdentifier
=	TokenNameEQUAL
endAddress	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lastFrozenNode	TokenNameIdentifier
=	TokenNameEQUAL
node	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
node	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
getFirstArc	TokenNameIdentifier
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
emptyOutput	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
=	TokenNameEQUAL
BIT_FINAL_ARC	TokenNameIdentifier
|	TokenNameOR
BIT_LAST_ARC	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
=	TokenNameEQUAL
emptyOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
=	TokenNameEQUAL
BIT_LAST_ARC	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
=	TokenNameEQUAL
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
startNode	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
arc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
readLastTargetArc	TokenNameIdentifier
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
follow	TokenNameIdentifier
,	TokenNameCOMMA
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
targetHasArcs	TokenNameIdentifier
(	TokenNameLPAREN
follow	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
follow	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
=	TokenNameEQUAL
END_LABEL	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
FINAL_END_NODE	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
follow	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
=	TokenNameEQUAL
BIT_LAST_ARC	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
arc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
BytesReader	TokenNameIdentifier
in	TokenNameIdentifier
=	TokenNameEQUAL
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
getNodeAddress	TokenNameIdentifier
(	TokenNameLPAREN
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
=	TokenNameEQUAL
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
b	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
posArcsStart	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
arcIdx	TokenNameIdentifier
=	TokenNameEQUAL
arc	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
=	TokenNameEQUAL
b	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
arc	TokenNameIdentifier
.	TokenNameDOT
isLast	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
readLabel	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
outputs	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
outputs	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_STOP_NODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_TARGET_NEXT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
in	TokenNameIdentifier
.	TokenNameDOT
skip	TokenNameIdentifier
(	TokenNameLPAREN
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
in	TokenNameIdentifier
.	TokenNameDOT
skip	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
readNextRealArc	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
,	TokenNameCOMMA
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
arc	TokenNameIdentifier
.	TokenNameDOT
isLast	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
arc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
readFirstTargetArc	TokenNameIdentifier
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
follow	TokenNameIdentifier
,	TokenNameCOMMA
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
follow	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
=	TokenNameEQUAL
END_LABEL	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
follow	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
=	TokenNameEQUAL
BIT_FINAL_ARC	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
|=	TokenNameOR_EQUAL
BIT_LAST_ARC	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
=	TokenNameEQUAL
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
=	TokenNameEQUAL
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
FINAL_END_NODE	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
arc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
readFirstRealTargetArc	TokenNameIdentifier
(	TokenNameLPAREN
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
,	TokenNameCOMMA
arc	TokenNameIdentifier
,	TokenNameCOMMA
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
readFirstRealTargetArc	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
node	TokenNameIdentifier
,	TokenNameCOMMA
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
BytesReader	TokenNameIdentifier
in	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
in	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
bytes	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
address	TokenNameIdentifier
=	TokenNameEQUAL
getNodeAddress	TokenNameIdentifier
(	TokenNameLPAREN
node	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
=	TokenNameEQUAL
node	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
arcIdx	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
=	TokenNameEQUAL
arc	TokenNameIdentifier
.	TokenNameDOT
posArcsStart	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
readNextRealArc	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
,	TokenNameCOMMA
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
isExpandedTarget	TokenNameIdentifier
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
follow	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
targetHasArcs	TokenNameIdentifier
(	TokenNameLPAREN
follow	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
BytesReader	TokenNameIdentifier
in	TokenNameIdentifier
=	TokenNameEQUAL
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
getNodeAddress	TokenNameIdentifier
(	TokenNameLPAREN
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
readNextArc	TokenNameIdentifier
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
END_LABEL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"cannot readNextArc when arc.isLast()=true"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
readFirstRealTargetArc	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
,	TokenNameCOMMA
arc	TokenNameIdentifier
,	TokenNameCOMMA
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
readNextRealArc	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
,	TokenNameCOMMA
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
readNextArcLabel	TokenNameIdentifier
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
!	TokenNameNOT
arc	TokenNameIdentifier
.	TokenNameDOT
isLast	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
BytesReader	TokenNameIdentifier
in	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
END_LABEL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
in	TokenNameIdentifier
=	TokenNameEQUAL
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
getNodeAddress	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
b	TokenNameIdentifier
=	TokenNameEQUAL
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
in	TokenNameIdentifier
.	TokenNameDOT
skip	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
in	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
in	TokenNameIdentifier
=	TokenNameEQUAL
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
posArcsStart	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
in	TokenNameIdentifier
.	TokenNameDOT
skip	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
+	TokenNamePLUS
arc	TokenNameIdentifier
.	TokenNameDOT
arcIdx	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
in	TokenNameIdentifier
=	TokenNameEQUAL
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
readLabel	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
readNextRealArc	TokenNameIdentifier
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
BytesReader	TokenNameIdentifier
in	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
in	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
bytes	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
arcIdx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
assert	TokenNameassert
arc	TokenNameIdentifier
.	TokenNameDOT
arcIdx	TokenNameIdentifier
<	TokenNameLESS
arc	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
in	TokenNameIdentifier
.	TokenNameDOT
skip	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
posArcsStart	TokenNameIdentifier
,	TokenNameCOMMA
arc	TokenNameIdentifier
.	TokenNameDOT
arcIdx	TokenNameIdentifier
*	TokenNameMULTIPLY
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
=	TokenNameEQUAL
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
=	TokenNameEQUAL
readLabel	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
getNoOutput	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
getNoOutput	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_STOP_NODE	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_FINAL_ARC	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
FINAL_END_NODE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
NON_FINAL_END_NODE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_TARGET_NEXT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nodeAddress	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_LAST_ARC	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
seekToNextNode	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
in	TokenNameIdentifier
.	TokenNameDOT
skip	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
posArcsStart	TokenNameIdentifier
,	TokenNameCOMMA
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
*	TokenNameMULTIPLY
arc	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
arc	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
code	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
BIT_TARGET_DELTA	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
pos	TokenNameIdentifier
+	TokenNamePLUS
code	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
code	TokenNameIdentifier
<	TokenNameLESS
nodeRefToAddress	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
nodeRefToAddress	TokenNameIdentifier
[	TokenNameLBRACKET
code	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
code	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
arc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
findTargetArc	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
labelToMatch	TokenNameIdentifier
,	TokenNameCOMMA
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
follow	TokenNameIdentifier
,	TokenNameCOMMA
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
,	TokenNameCOMMA
BytesReader	TokenNameIdentifier
in	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
cachedRootArcs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
assert	TokenNameassert
in	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
bytes	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
labelToMatch	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
END_LABEL	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
follow	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
=	TokenNameEQUAL
BIT_LAST_ARC	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
flags	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
nextArc	TokenNameIdentifier
=	TokenNameEQUAL
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
=	TokenNameEQUAL
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
follow	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
=	TokenNameEQUAL
END_LABEL	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
arc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
startNode	TokenNameIdentifier
&&	TokenNameAND_AND
labelToMatch	TokenNameIdentifier
<	TokenNameLESS
cachedRootArcs	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
result	TokenNameIdentifier
=	TokenNameEQUAL
cachedRootArcs	TokenNameIdentifier
[	TokenNameLBRACKET
labelToMatch	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
copyFrom	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
arc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
targetHasArcs	TokenNameIdentifier
(	TokenNameLPAREN
follow	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
=	TokenNameEQUAL
getNodeAddress	TokenNameIdentifier
(	TokenNameLPAREN
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
=	TokenNameEQUAL
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
posArcsStart	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
low	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
high	TokenNameIdentifier
=	TokenNameEQUAL
arc	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
low	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
high	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
mid	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
low	TokenNameIdentifier
+	TokenNamePLUS
high	TokenNameIdentifier
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
in	TokenNameIdentifier
.	TokenNameDOT
skip	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
posArcsStart	TokenNameIdentifier
,	TokenNameCOMMA
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
*	TokenNameMULTIPLY
mid	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
midLabel	TokenNameIdentifier
=	TokenNameEQUAL
readLabel	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
cmp	TokenNameIdentifier
=	TokenNameEQUAL
midLabel	TokenNameIdentifier
-	TokenNameMINUS
labelToMatch	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cmp	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
low	TokenNameIdentifier
=	TokenNameEQUAL
mid	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
cmp	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
high	TokenNameIdentifier
=	TokenNameEQUAL
mid	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
arcIdx	TokenNameIdentifier
=	TokenNameEQUAL
mid	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
readNextRealArc	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
,	TokenNameCOMMA
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
readFirstRealTargetArc	TokenNameIdentifier
(	TokenNameLPAREN
follow	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
,	TokenNameCOMMA
arc	TokenNameIdentifier
,	TokenNameCOMMA
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
labelToMatch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
arc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
>	TokenNameGREATER
labelToMatch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
isLast	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
readNextRealArc	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
,	TokenNameCOMMA
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
seekToNextNode	TokenNameIdentifier
(	TokenNameLPAREN
BytesReader	TokenNameIdentifier
in	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
flags	TokenNameIdentifier
=	TokenNameEQUAL
in	TokenNameIdentifier
.	TokenNameDOT
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
readLabel	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
flag	TokenNameIdentifier
(	TokenNameLPAREN
flags	TokenNameIdentifier
,	TokenNameCOMMA
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
outputs	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
flag	TokenNameIdentifier
(	TokenNameLPAREN
flags	TokenNameIdentifier
,	TokenNameCOMMA
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
outputs	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
in	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
flags	TokenNameIdentifier
,	TokenNameCOMMA
BIT_STOP_NODE	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
flag	TokenNameIdentifier
(	TokenNameLPAREN
flags	TokenNameIdentifier
,	TokenNameCOMMA
BIT_TARGET_NEXT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
in	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
in	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
flag	TokenNameIdentifier
(	TokenNameLPAREN
flags	TokenNameIdentifier
,	TokenNameCOMMA
BIT_LAST_ARC	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getNodeCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
1	TokenNameIntegerLiteral
+	TokenNamePLUS
nodeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getArcCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
arcCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getArcWithOutputCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
arcWithOutputCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setAllowArrayArcs	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
allowArrayArcs	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
shouldExpand	TokenNameIdentifier
(	TokenNameLPAREN
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
node	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
allowArrayArcs	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
(	TokenNameLPAREN
node	TokenNameIdentifier
.	TokenNameDOT
depth	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
FIXED_ARRAY_SHALLOW_DISTANCE	TokenNameIdentifier
&&	TokenNameAND_AND
node	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
FIXED_ARRAY_NUM_ARCS_SHALLOW	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
node	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
FIXED_ARRAY_NUM_ARCS_DEEP	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
class	TokenNameclass
BytesWriter	TokenNameIdentifier
extends	TokenNameextends
DataOutput	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
BytesWriter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
posWrite	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
posWrite	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
posWrite	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bytes	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
posWrite	TokenNameIdentifier
<	TokenNameLESS
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
:	TokenNameCOLON
"posWrite="	TokenNameStringLiteral
+	TokenNamePLUS
posWrite	TokenNameIdentifier
+	TokenNamePLUS
" bytes.length="	TokenNameStringLiteral
+	TokenNamePLUS
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
posWrite	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
b	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPosWrite	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
posWrite	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
posWrite	TokenNameIdentifier
=	TokenNameEQUAL
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
posWrite	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bytes	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
posWrite	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
writeBytes	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
b	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
posWrite	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
size	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
bytes	TokenNameIdentifier
,	TokenNameCOMMA
posWrite	TokenNameIdentifier
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
posWrite	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
length	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
BytesReader	TokenNameIdentifier
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
pos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
packed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
ForwardBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
pos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
ReverseBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
pos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
abstract	TokenNameabstract
class	TokenNameclass
BytesReader	TokenNameIdentifier
extends	TokenNameextends
DataInput	TokenNameIdentifier
{	TokenNameLBRACE
protected	TokenNameprotected
int	TokenNameint
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytes	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
BytesReader	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytes	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
pos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
bytes	TokenNameIdentifier
=	TokenNameEQUAL
bytes	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
pos	TokenNameIdentifier
=	TokenNameEQUAL
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
abstract	TokenNameabstract
void	TokenNamevoid
skip	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
byteCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
abstract	TokenNameabstract
void	TokenNamevoid
skip	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
base	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
byteCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
static	TokenNamestatic
class	TokenNameclass
ReverseBytesReader	TokenNameIdentifier
extends	TokenNameextends
BytesReader	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
ReverseBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytes	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
pos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
pos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
byte	TokenNamebyte
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
--	TokenNameMINUS_MINUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
readBytes	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
b	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
len	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
len	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
+	TokenNamePLUS
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
--	TokenNameMINUS_MINUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
skip	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pos	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
skip	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
base	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pos	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
-	TokenNameMINUS
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
static	TokenNamestatic
class	TokenNameclass
ForwardBytesReader	TokenNameIdentifier
extends	TokenNameextends
BytesReader	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
ForwardBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytes	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
pos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
pos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
byte	TokenNamebyte
readByte	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
readBytes	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
b	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
len	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
pos	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
,	TokenNameCOMMA
offset	TokenNameIdentifier
,	TokenNameCOMMA
len	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pos	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
len	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
skip	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pos	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
skip	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
base	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pos	TokenNameIdentifier
=	TokenNameEQUAL
base	TokenNameIdentifier
+	TokenNamePLUS
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
ArcAndState	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
final	TokenNamefinal
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
IntsRef	TokenNameIdentifier
chain	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
ArcAndState	TokenNameIdentifier
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
,	TokenNameCOMMA
IntsRef	TokenNameIdentifier
chain	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
arc	TokenNameIdentifier
=	TokenNameEQUAL
arc	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
chain	TokenNameIdentifier
=	TokenNameEQUAL
chain	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
FST	TokenNameIdentifier
(	TokenNameLPAREN
INPUT_TYPE	TokenNameIdentifier
inputType	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
nodeRefToAddress	TokenNameIdentifier
,	TokenNameCOMMA
Outputs	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
outputs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
packed	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
inputType	TokenNameIdentifier
=	TokenNameEQUAL
inputType	TokenNameIdentifier
;	TokenNameSEMICOLON
bytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
128	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
nodeRefToAddress	TokenNameIdentifier
=	TokenNameEQUAL
nodeRefToAddress	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
outputs	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
;	TokenNameSEMICOLON
NO_OUTPUT	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
getNoOutput	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BytesWriter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
FST	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
pack	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
minInCountDeref	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
maxDerefNodes	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nodeAddress	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"this FST was not built with willPackFST=true"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
BytesReader	TokenNameIdentifier
r	TokenNameIdentifier
=	TokenNameEQUAL
getBytesReader	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
topN	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
maxDerefNodes	TokenNameIdentifier
,	TokenNameCOMMA
inCounts	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
NodeQueue	TokenNameIdentifier
q	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
NodeQueue	TokenNameIdentifier
(	TokenNameLPAREN
topN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
NodeAndInCount	TokenNameIdentifier
bottom	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
node	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
node	TokenNameIdentifier
<	TokenNameLESS
inCounts	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
node	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
inCounts	TokenNameIdentifier
[	TokenNameLBRACKET
node	TokenNameIdentifier
]	TokenNameRBRACKET
>=	TokenNameGREATER_EQUAL
minInCountDeref	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bottom	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
q	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NodeAndInCount	TokenNameIdentifier
(	TokenNameLPAREN
node	TokenNameIdentifier
,	TokenNameCOMMA
inCounts	TokenNameIdentifier
[	TokenNameLBRACKET
node	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
q	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
topN	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bottom	TokenNameIdentifier
=	TokenNameEQUAL
q	TokenNameIdentifier
.	TokenNameDOT
top	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
inCounts	TokenNameIdentifier
[	TokenNameLBRACKET
node	TokenNameIdentifier
]	TokenNameRBRACKET
>	TokenNameGREATER
bottom	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
q	TokenNameIdentifier
.	TokenNameDOT
insertWithOverflow	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NodeAndInCount	TokenNameIdentifier
(	TokenNameLPAREN
node	TokenNameIdentifier
,	TokenNameCOMMA
inCounts	TokenNameIdentifier
[	TokenNameLBRACKET
node	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
inCounts	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
final	TokenNamefinal
Map	TokenNameIdentifier
<	TokenNameLESS
Integer	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
topNodeMap	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
Integer	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
downTo	TokenNameIdentifier
=	TokenNameEQUAL
q	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
downTo	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
downTo	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
NodeAndInCount	TokenNameIdentifier
n	TokenNameIdentifier
=	TokenNameEQUAL
q	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
topNodeMap	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
n	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
,	TokenNameCOMMA
downTo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
nodeRefToAddressIn	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
topNodeMap	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
FST	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
fst	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FST	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
inputType	TokenNameIdentifier
,	TokenNameCOMMA
nodeRefToAddressIn	TokenNameIdentifier
,	TokenNameCOMMA
outputs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
BytesWriter	TokenNameIdentifier
writer	TokenNameIdentifier
=	TokenNameEQUAL
fst	TokenNameIdentifier
.	TokenNameDOT
writer	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newNodeAddress	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
+	TokenNamePLUS
nodeCount	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
node	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
node	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
nodeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
node	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
newNodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
node	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
+	TokenNamePLUS
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
nodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
node	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
absCount	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
deltaCount	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
topCount	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
nextCount	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
changed	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
negDelta	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fst	TokenNameIdentifier
.	TokenNameDOT
arcWithOutputCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fst	TokenNameIdentifier
.	TokenNameDOT
nodeCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fst	TokenNameIdentifier
.	TokenNameDOT
arcCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
absCount	TokenNameIdentifier
=	TokenNameEQUAL
deltaCount	TokenNameIdentifier
=	TokenNameEQUAL
topCount	TokenNameIdentifier
=	TokenNameEQUAL
nextCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
changedCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
addressError	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
node	TokenNameIdentifier
=	TokenNameEQUAL
nodeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
node	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
node	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
fst	TokenNameIdentifier
.	TokenNameDOT
nodeCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
address	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
address	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
newNodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
node	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
addressError	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
-	TokenNameMINUS
newNodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
node	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
changed	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
newNodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
node	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
address	TokenNameIdentifier
;	TokenNameSEMICOLON
changedCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
nodeArcCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
retry	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
anyNegDelta	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
writeNode	TokenNameIdentifier
:	TokenNameCOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
readFirstRealTargetArc	TokenNameIdentifier
(	TokenNameLPAREN
node	TokenNameIdentifier
,	TokenNameCOMMA
arc	TokenNameIdentifier
,	TokenNameCOMMA
r	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
useArcArray	TokenNameIdentifier
=	TokenNameEQUAL
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
useArcArray	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bytesPerArc	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
arc	TokenNameIdentifier
.	TokenNameDOT
bytesPerArc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
ARCS_AS_FIXED_ARRAY	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
bytesPerArc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
maxBytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
arcStartPos	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
nodeArcCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
byte	TokenNamebyte
flags	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
isLast	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_LAST_ARC	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
useArcArray	TokenNameIdentifier
&&	TokenNameAND_AND
node	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
node	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_TARGET_NEXT	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
retry	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
nextCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_FINAL_ARC	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_ARC_HAS_FINAL_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
assert	TokenNameassert
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
targetHasArcs	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_STOP_NODE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BIT_ARC_HAS_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
Integer	TokenNameIdentifier
ptr	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
absPtr	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
doWriteTarget	TokenNameIdentifier
=	TokenNameEQUAL
targetHasArcs	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
flags	TokenNameIdentifier
&	TokenNameAND
BIT_TARGET_NEXT	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doWriteTarget	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ptr	TokenNameIdentifier
=	TokenNameEQUAL
topNodeMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ptr	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
absPtr	TokenNameIdentifier
=	TokenNameEQUAL
ptr	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
absPtr	TokenNameIdentifier
=	TokenNameEQUAL
topNodeMap	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
newNodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
]	TokenNameRBRACKET
+	TokenNamePLUS
addressError	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
delta	TokenNameIdentifier
=	TokenNameEQUAL
newNodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
]	TokenNameRBRACKET
+	TokenNamePLUS
addressError	TokenNameIdentifier
-	TokenNameMINUS
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
delta	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
anyNegDelta	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
delta	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
delta	TokenNameIdentifier
<	TokenNameLESS
absPtr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flags	TokenNameIdentifier
|=	TokenNameOR_EQUAL
BIT_TARGET_DELTA	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ptr	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
absPtr	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
writeByte	TokenNameIdentifier
(	TokenNameLPAREN
flags	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fst	TokenNameIdentifier
.	TokenNameDOT
writeLabel	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputs	TokenNameIdentifier
.	TokenNameDOT
write	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
,	TokenNameCOMMA
writer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
retry	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fst	TokenNameIdentifier
.	TokenNameDOT
arcWithOutputCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputs	TokenNameIdentifier
.	TokenNameDOT
write	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
,	TokenNameCOMMA
writer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doWriteTarget	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
delta	TokenNameIdentifier
=	TokenNameEQUAL
newNodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
]	TokenNameRBRACKET
+	TokenNamePLUS
addressError	TokenNameIdentifier
-	TokenNameMINUS
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
delta	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
anyNegDelta	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
delta	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
flag	TokenNameIdentifier
(	TokenNameLPAREN
flags	TokenNameIdentifier
,	TokenNameCOMMA
BIT_TARGET_DELTA	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
delta	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
retry	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
deltaCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
writeVInt	TokenNameIdentifier
(	TokenNameLPAREN
absPtr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
retry	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
absPtr	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
topNodeMap	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
absCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
topCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
useArcArray	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
arcBytes	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
-	TokenNameMINUS
arcStartPos	TokenNameIdentifier
;	TokenNameSEMICOLON
maxBytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
maxBytesPerArc	TokenNameIdentifier
,	TokenNameCOMMA
arcBytes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
setPosWrite	TokenNameIdentifier
(	TokenNameLPAREN
arcStartPos	TokenNameIdentifier
+	TokenNamePLUS
bytesPerArc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
isLast	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
readNextRealArc	TokenNameIdentifier
(	TokenNameLPAREN
arc	TokenNameIdentifier
,	TokenNameCOMMA
r	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
useArcArray	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
maxBytesPerArc	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
bytesPerArc	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
retry	TokenNameIdentifier
&&	TokenNameAND_AND
maxBytesPerArc	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
bytesPerArc	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bytesPerArc	TokenNameIdentifier
=	TokenNameEQUAL
maxBytesPerArc	TokenNameIdentifier
;	TokenNameSEMICOLON
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
=	TokenNameEQUAL
address	TokenNameIdentifier
;	TokenNameSEMICOLON
nodeArcCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
retry	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
anyNegDelta	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
negDelta	TokenNameIdentifier
|=	TokenNameOR_EQUAL
anyNegDelta	TokenNameIdentifier
;	TokenNameSEMICOLON
fst	TokenNameIdentifier
.	TokenNameDOT
arcCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
nodeArcCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
changed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
!	TokenNameNOT
negDelta	TokenNameIdentifier
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
Map	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
<	TokenNameLESS
Integer	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
ent	TokenNameIdentifier
:	TokenNameCOLON
topNodeMap	TokenNameIdentifier
.	TokenNameDOT
entrySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
nodeRefToAddressIn	TokenNameIdentifier
[	TokenNameLBRACKET
ent	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
=	TokenNameEQUAL
newNodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
ent	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fst	TokenNameIdentifier
.	TokenNameDOT
startNode	TokenNameIdentifier
=	TokenNameEQUAL
newNodeAddress	TokenNameIdentifier
[	TokenNameLBRACKET
startNode	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
emptyOutput	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
fst	TokenNameIdentifier
.	TokenNameDOT
setEmptyOutput	TokenNameIdentifier
(	TokenNameLPAREN
emptyOutput	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
fst	TokenNameIdentifier
.	TokenNameDOT
nodeCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
nodeCount	TokenNameIdentifier
:	TokenNameCOLON
"fst.nodeCount="	TokenNameStringLiteral
+	TokenNamePLUS
fst	TokenNameIdentifier
.	TokenNameDOT
nodeCount	TokenNameIdentifier
+	TokenNamePLUS
" nodeCount="	TokenNameStringLiteral
+	TokenNamePLUS
nodeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
fst	TokenNameIdentifier
.	TokenNameDOT
arcCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
arcCount	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
fst	TokenNameIdentifier
.	TokenNameDOT
arcWithOutputCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
arcWithOutputCount	TokenNameIdentifier
:	TokenNameCOLON
"fst.arcWithOutputCount="	TokenNameStringLiteral
+	TokenNamePLUS
fst	TokenNameIdentifier
.	TokenNameDOT
arcWithOutputCount	TokenNameIdentifier
+	TokenNamePLUS
" arcWithOutputCount="	TokenNameStringLiteral
+	TokenNamePLUS
arcWithOutputCount	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
finalBytes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
fst	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
finalBytes	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
writer	TokenNameIdentifier
.	TokenNameDOT
posWrite	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fst	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
=	TokenNameEQUAL
finalBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
fst	TokenNameIdentifier
.	TokenNameDOT
cacheRootArcs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
fst	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
NodeAndInCount	TokenNameIdentifier
implements	TokenNameimplements
Comparable	TokenNameIdentifier
<	TokenNameLESS
NodeAndInCount	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
node	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
count	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
NodeAndInCount	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
node	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
node	TokenNameIdentifier
=	TokenNameEQUAL
node	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
count	TokenNameIdentifier
=	TokenNameEQUAL
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
NodeAndInCount	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
>	TokenNameGREATER
other	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
<	TokenNameLESS
other	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
other	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
-	TokenNameMINUS
node	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
NodeQueue	TokenNameIdentifier
extends	TokenNameextends
PriorityQueue	TokenNameIdentifier
<	TokenNameLESS
NodeAndInCount	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
public	TokenNamepublic
NodeQueue	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
topN	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
initialize	TokenNameIdentifier
(	TokenNameLPAREN
topN	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
lessThan	TokenNameIdentifier
(	TokenNameLPAREN
NodeAndInCount	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
NodeAndInCount	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
cmp	TokenNameIdentifier
=	TokenNameEQUAL
a	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
cmp	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
cmp	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
