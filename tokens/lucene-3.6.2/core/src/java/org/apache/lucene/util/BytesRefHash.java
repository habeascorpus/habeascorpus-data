package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
static	TokenNamestatic
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ByteBlockPool	TokenNameIdentifier
.	TokenNameDOT
BYTE_BLOCK_MASK	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
static	TokenNamestatic
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ByteBlockPool	TokenNameIdentifier
.	TokenNameDOT
BYTE_BLOCK_SHIFT	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
static	TokenNamestatic
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ByteBlockPool	TokenNameIdentifier
.	TokenNameDOT
BYTE_BLOCK_SIZE	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Arrays	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Comparator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
concurrent	TokenNameIdentifier
.	TokenNameDOT
atomic	TokenNameIdentifier
.	TokenNameDOT
AtomicLong	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ByteBlockPool	TokenNameIdentifier
.	TokenNameDOT
DirectAllocator	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
class	TokenNameclass
BytesRefHash	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
int	TokenNameint
DEFAULT_CAPACITY	TokenNameIdentifier
=	TokenNameEQUAL
16	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
ByteBlockPool	TokenNameIdentifier
pool	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytesStart	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
BytesRef	TokenNameIdentifier
scratch1	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BytesRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
hashSize	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
hashHalfSize	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
hashMask	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
count	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
lastCount	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
ords	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
BytesStartArray	TokenNameIdentifier
bytesStartArray	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
AtomicLong	TokenNameIdentifier
bytesUsed	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
BytesRefHash	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
new	TokenNamenew
ByteBlockPool	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
DirectAllocator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
BytesRefHash	TokenNameIdentifier
(	TokenNameLPAREN
ByteBlockPool	TokenNameIdentifier
pool	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
pool	TokenNameIdentifier
,	TokenNameCOMMA
DEFAULT_CAPACITY	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
DirectBytesStartArray	TokenNameIdentifier
(	TokenNameLPAREN
DEFAULT_CAPACITY	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
BytesRefHash	TokenNameIdentifier
(	TokenNameLPAREN
ByteBlockPool	TokenNameIdentifier
pool	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
capacity	TokenNameIdentifier
,	TokenNameCOMMA
BytesStartArray	TokenNameIdentifier
bytesStartArray	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
hashSize	TokenNameIdentifier
=	TokenNameEQUAL
capacity	TokenNameIdentifier
;	TokenNameSEMICOLON
hashHalfSize	TokenNameIdentifier
=	TokenNameEQUAL
hashSize	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
hashMask	TokenNameIdentifier
=	TokenNameEQUAL
hashSize	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
pool	TokenNameIdentifier
=	TokenNameEQUAL
pool	TokenNameIdentifier
;	TokenNameSEMICOLON
ords	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
hashSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
ords	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
bytesStartArray	TokenNameIdentifier
=	TokenNameEQUAL
bytesStartArray	TokenNameIdentifier
;	TokenNameSEMICOLON
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
bytesStartArray	TokenNameIdentifier
.	TokenNameDOT
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
=	TokenNameEQUAL
bytesStartArray	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
new	TokenNamenew
AtomicLong	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
bytesStartArray	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
hashSize	TokenNameIdentifier
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
BytesRef	TokenNameIdentifier
get	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
ord	TokenNameIdentifier
,	TokenNameCOMMA
BytesRef	TokenNameIdentifier
ref	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
bytesStart	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
:	TokenNameCOLON
"bytesStart is null - not initialized"	TokenNameStringLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
ord	TokenNameIdentifier
<	TokenNameLESS
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
:	TokenNameCOLON
"ord exceeds byteStart len: "	TokenNameStringLiteral
+	TokenNamePLUS
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
pool	TokenNameIdentifier
.	TokenNameDOT
setBytesRef	TokenNameIdentifier
(	TokenNameLPAREN
ref	TokenNameIdentifier
,	TokenNameCOMMA
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
ord	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
compact	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
bytesStart	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
:	TokenNameCOLON
"Bytesstart is null - not initialized"	TokenNameStringLiteral
;	TokenNameSEMICOLON
int	TokenNameint
upto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
hashSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ords	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
upto	TokenNameIdentifier
<	TokenNameLESS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ords	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
ords	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
ords	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
assert	TokenNameassert
upto	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
count	TokenNameIdentifier
;	TokenNameSEMICOLON
lastCount	TokenNameIdentifier
=	TokenNameEQUAL
count	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
ords	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
sort	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
Comparator	TokenNameIdentifier
<	TokenNameLESS
BytesRef	TokenNameIdentifier
>	TokenNameGREATER
comp	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
compact	TokenNameIdentifier
=	TokenNameEQUAL
compact	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
new	TokenNamenew
SorterTemplate	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
void	TokenNamevoid
swap	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
j	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
o	TokenNameIdentifier
=	TokenNameEQUAL
compact	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
compact	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
compact	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
compact	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
o	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
j	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
ord1	TokenNameIdentifier
=	TokenNameEQUAL
compact	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
ord2	TokenNameIdentifier
=	TokenNameEQUAL
compact	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
assert	TokenNameassert
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
ord1	TokenNameIdentifier
&&	TokenNameAND_AND
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
ord2	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
comp	TokenNameIdentifier
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
pool	TokenNameIdentifier
.	TokenNameDOT
setBytesRef	TokenNameIdentifier
(	TokenNameLPAREN
scratch1	TokenNameIdentifier
,	TokenNameCOMMA
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
ord1	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
,	TokenNameCOMMA
pool	TokenNameIdentifier
.	TokenNameDOT
setBytesRef	TokenNameIdentifier
(	TokenNameLPAREN
scratch2	TokenNameIdentifier
,	TokenNameCOMMA
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
ord2	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
void	TokenNamevoid
setPivot	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
ord	TokenNameIdentifier
=	TokenNameEQUAL
compact	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
assert	TokenNameassert
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
ord	TokenNameIdentifier
;	TokenNameSEMICOLON
pool	TokenNameIdentifier
.	TokenNameDOT
setBytesRef	TokenNameIdentifier
(	TokenNameLPAREN
pivot	TokenNameIdentifier
,	TokenNameCOMMA
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
ord	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
int	TokenNameint
comparePivot	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
ord	TokenNameIdentifier
=	TokenNameEQUAL
compact	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
assert	TokenNameassert
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
ord	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
comp	TokenNameIdentifier
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
pivot	TokenNameIdentifier
,	TokenNameCOMMA
pool	TokenNameIdentifier
.	TokenNameDOT
setBytesRef	TokenNameIdentifier
(	TokenNameLPAREN
scratch2	TokenNameIdentifier
,	TokenNameCOMMA
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
ord	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
BytesRef	TokenNameIdentifier
pivot	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BytesRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
scratch1	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BytesRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
scratch2	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BytesRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
.	TokenNameDOT
quickSort	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
count	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
compact	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
ord	TokenNameIdentifier
,	TokenNameCOMMA
BytesRef	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
pool	TokenNameIdentifier
.	TokenNameDOT
setBytesRef	TokenNameIdentifier
(	TokenNameLPAREN
scratch1	TokenNameIdentifier
,	TokenNameCOMMA
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
ord	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
.	TokenNameDOT
bytesEquals	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
shrink	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
targetSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
newSize	TokenNameIdentifier
=	TokenNameEQUAL
hashSize	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
newSize	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
8	TokenNameIntegerLiteral
&&	TokenNameAND_AND
newSize	TokenNameIdentifier
/	TokenNameDIVIDE
4	TokenNameIntegerLiteral
>	TokenNameGREATER
targetSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
newSize	TokenNameIdentifier
/=	TokenNameDIVIDE_EQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
newSize	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
hashSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
*	TokenNameMULTIPLY
-	TokenNameMINUS
(	TokenNameLPAREN
hashSize	TokenNameIdentifier
-	TokenNameMINUS
newSize	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hashSize	TokenNameIdentifier
=	TokenNameEQUAL
newSize	TokenNameIdentifier
;	TokenNameSEMICOLON
ords	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
hashSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
ords	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hashHalfSize	TokenNameIdentifier
=	TokenNameEQUAL
newSize	TokenNameIdentifier
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
hashMask	TokenNameIdentifier
=	TokenNameEQUAL
newSize	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
resetPool	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
lastCount	TokenNameIdentifier
=	TokenNameEQUAL
count	TokenNameIdentifier
;	TokenNameSEMICOLON
count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
resetPool	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pool	TokenNameIdentifier
.	TokenNameDOT
dropBuffersAndReset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
bytesStartArray	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lastCount	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
shrink	TokenNameIdentifier
(	TokenNameLPAREN
lastCount	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
ords	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
clear	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
clear	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ords	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
*	TokenNameMULTIPLY
-	TokenNameMINUS
hashSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
add	TokenNameIdentifier
(	TokenNameLPAREN
BytesRef	TokenNameIdentifier
bytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
add	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
,	TokenNameCOMMA
bytes	TokenNameIdentifier
.	TokenNameDOT
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
add	TokenNameIdentifier
(	TokenNameLPAREN
BytesRef	TokenNameIdentifier
bytes	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
code	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
bytesStart	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
:	TokenNameCOLON
"Bytesstart is null - not initialized"	TokenNameStringLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
length	TokenNameIdentifier
=	TokenNameEQUAL
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
hashPos	TokenNameIdentifier
=	TokenNameEQUAL
code	TokenNameIdentifier
&	TokenNameAND
hashMask	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
e	TokenNameIdentifier
=	TokenNameEQUAL
ords	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
e	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
,	TokenNameCOMMA
bytes	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
inc	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
code	TokenNameIdentifier
)	TokenNameRPAREN
|	TokenNameOR
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
do	TokenNamedo
{	TokenNameLBRACE
code	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
inc	TokenNameIdentifier
;	TokenNameSEMICOLON
hashPos	TokenNameIdentifier
=	TokenNameEQUAL
code	TokenNameIdentifier
&	TokenNameAND
hashMask	TokenNameIdentifier
;	TokenNameSEMICOLON
e	TokenNameIdentifier
=	TokenNameEQUAL
ords	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
e	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
,	TokenNameCOMMA
bytes	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
e	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
len2	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
+	TokenNamePLUS
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
len2	TokenNameIdentifier
+	TokenNamePLUS
pool	TokenNameIdentifier
.	TokenNameDOT
byteUpto	TokenNameIdentifier
>	TokenNameGREATER
BYTE_BLOCK_SIZE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
len2	TokenNameIdentifier
>	TokenNameGREATER
BYTE_BLOCK_SIZE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MaxBytesLengthExceededException	TokenNameIdentifier
(	TokenNameLPAREN
"bytes can be at most "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
BYTE_BLOCK_SIZE	TokenNameIdentifier
-	TokenNameMINUS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
" in length; got "	TokenNameStringLiteral
+	TokenNamePLUS
bytes	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pool	TokenNameIdentifier
.	TokenNameDOT
nextBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
buffer	TokenNameIdentifier
=	TokenNameEQUAL
pool	TokenNameIdentifier
.	TokenNameDOT
buffer	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
bufferUpto	TokenNameIdentifier
=	TokenNameEQUAL
pool	TokenNameIdentifier
.	TokenNameDOT
byteUpto	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
bytesStartArray	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
count	TokenNameIdentifier
<	TokenNameLESS
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
"count: "	TokenNameStringLiteral
+	TokenNamePLUS
count	TokenNameIdentifier
+	TokenNamePLUS
" len: "	TokenNameStringLiteral
+	TokenNamePLUS
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
e	TokenNameIdentifier
=	TokenNameEQUAL
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
e	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
bufferUpto	TokenNameIdentifier
+	TokenNamePLUS
pool	TokenNameIdentifier
.	TokenNameDOT
byteOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
length	TokenNameIdentifier
<	TokenNameLESS
128	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
buffer	TokenNameIdentifier
[	TokenNameLBRACKET
bufferUpto	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
length	TokenNameIdentifier
;	TokenNameSEMICOLON
pool	TokenNameIdentifier
.	TokenNameDOT
byteUpto	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
length	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
length	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
:	TokenNameCOLON
"Length must be positive: "	TokenNameStringLiteral
+	TokenNamePLUS
length	TokenNameIdentifier
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
,	TokenNameCOMMA
bytes	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
,	TokenNameCOMMA
buffer	TokenNameIdentifier
,	TokenNameCOMMA
bufferUpto	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
buffer	TokenNameIdentifier
[	TokenNameLBRACKET
bufferUpto	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
0x80	TokenNameIntegerLiteral
|	TokenNameOR
(	TokenNameLPAREN
length	TokenNameIdentifier
&	TokenNameAND
0x7f	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
buffer	TokenNameIdentifier
[	TokenNameLBRACKET
bufferUpto	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
length	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
7	TokenNameIntegerLiteral
)	TokenNameRPAREN
&	TokenNameAND
0xff	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pool	TokenNameIdentifier
.	TokenNameDOT
byteUpto	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
length	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
bytes	TokenNameIdentifier
.	TokenNameDOT
bytes	TokenNameIdentifier
,	TokenNameCOMMA
bytes	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
,	TokenNameCOMMA
buffer	TokenNameIdentifier
,	TokenNameCOMMA
bufferUpto	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
,	TokenNameCOMMA
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
ords	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
ords	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
e	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
hashHalfSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
rehash	TokenNameIdentifier
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hashSize	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
e	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
(	TokenNameLPAREN
e	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
addByPoolOffset	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
bytesStart	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
:	TokenNameCOLON
"Bytesstart is null - not initialized"	TokenNameStringLiteral
;	TokenNameSEMICOLON
int	TokenNameint
code	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
hashPos	TokenNameIdentifier
=	TokenNameEQUAL
offset	TokenNameIdentifier
&	TokenNameAND
hashMask	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
e	TokenNameIdentifier
=	TokenNameEQUAL
ords	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
e	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
e	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
offset	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
inc	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
code	TokenNameIdentifier
)	TokenNameRPAREN
|	TokenNameOR
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
do	TokenNamedo
{	TokenNameLBRACE
code	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
inc	TokenNameIdentifier
;	TokenNameSEMICOLON
hashPos	TokenNameIdentifier
=	TokenNameEQUAL
code	TokenNameIdentifier
&	TokenNameAND
hashMask	TokenNameIdentifier
;	TokenNameSEMICOLON
e	TokenNameIdentifier
=	TokenNameEQUAL
ords	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
e	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
e	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
offset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
e	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
bytesStartArray	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
count	TokenNameIdentifier
<	TokenNameLESS
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
"count: "	TokenNameStringLiteral
+	TokenNamePLUS
count	TokenNameIdentifier
+	TokenNamePLUS
" len: "	TokenNameStringLiteral
+	TokenNamePLUS
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
e	TokenNameIdentifier
=	TokenNameEQUAL
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
e	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
ords	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
ords	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
e	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
hashHalfSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
rehash	TokenNameIdentifier
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
hashSize	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
e	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
(	TokenNameLPAREN
e	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
rehash	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
int	TokenNameint
newSize	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
hashOnData	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
newMask	TokenNameIdentifier
=	TokenNameEQUAL
newSize	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
newSize	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newHash	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
newSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
newHash	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
hashSize	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
e0	TokenNameIdentifier
=	TokenNameEQUAL
ords	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
e0	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
code	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hashOnData	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
off	TokenNameIdentifier
=	TokenNameEQUAL
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
e0	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
off	TokenNameIdentifier
&	TokenNameAND
BYTE_BLOCK_MASK	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytes	TokenNameIdentifier
=	TokenNameEQUAL
pool	TokenNameIdentifier
.	TokenNameDOT
buffers	TokenNameIdentifier
[	TokenNameLBRACKET
off	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
BYTE_BLOCK_SHIFT	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
code	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
len	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
start	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0x80	TokenNameIntegerLiteral
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
len	TokenNameIdentifier
=	TokenNameEQUAL
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
start	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
pos	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
len	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
start	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0x7f	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
start	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0xff	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
7	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pos	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
endPos	TokenNameIdentifier
=	TokenNameEQUAL
pos	TokenNameIdentifier
+	TokenNamePLUS
len	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
pos	TokenNameIdentifier
<	TokenNameLESS
endPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
code	TokenNameIdentifier
=	TokenNameEQUAL
31	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
code	TokenNameIdentifier
+	TokenNamePLUS
bytes	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
code	TokenNameIdentifier
=	TokenNameEQUAL
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
e0	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
hashPos	TokenNameIdentifier
=	TokenNameEQUAL
code	TokenNameIdentifier
&	TokenNameAND
newMask	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
hashPos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
newHash	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
inc	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
code	TokenNameIdentifier
)	TokenNameRPAREN
|	TokenNameOR
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
do	TokenNamedo
{	TokenNameLBRACE
code	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
inc	TokenNameIdentifier
;	TokenNameSEMICOLON
hashPos	TokenNameIdentifier
=	TokenNameEQUAL
code	TokenNameIdentifier
&	TokenNameAND
newMask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
newHash	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
newHash	TokenNameIdentifier
[	TokenNameLBRACKET
hashPos	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
e0	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
hashMask	TokenNameIdentifier
=	TokenNameEQUAL
newMask	TokenNameIdentifier
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
-	TokenNameMINUS
ords	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ords	TokenNameIdentifier
=	TokenNameEQUAL
newHash	TokenNameIdentifier
;	TokenNameSEMICOLON
hashSize	TokenNameIdentifier
=	TokenNameEQUAL
newSize	TokenNameIdentifier
;	TokenNameSEMICOLON
hashHalfSize	TokenNameIdentifier
=	TokenNameEQUAL
newSize	TokenNameIdentifier
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
reinit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bytesStart	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
bytesStartArray	TokenNameIdentifier
.	TokenNameDOT
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
ords	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
ords	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
hashSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
*	TokenNameMULTIPLY
hashSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
byteStart	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
ord	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
bytesStart	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
:	TokenNameCOLON
"Bytesstart is null - not initialized"	TokenNameStringLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
ord	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
ord	TokenNameIdentifier
<	TokenNameLESS
count	TokenNameIdentifier
:	TokenNameCOLON
ord	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
bytesStart	TokenNameIdentifier
[	TokenNameLBRACKET
ord	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
"serial"	TokenNameStringLiteral
)	TokenNameRPAREN
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
MaxBytesLengthExceededException	TokenNameIdentifier
extends	TokenNameextends
RuntimeException	TokenNameIdentifier
{	TokenNameLBRACE
MaxBytesLengthExceededException	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
message	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
message	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
abstract	TokenNameabstract
static	TokenNamestatic
class	TokenNameclass
BytesStartArray	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
abstract	TokenNameabstract
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
grow	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
abstract	TokenNameabstract
AtomicLong	TokenNameIdentifier
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
TrackingDirectBytesStartArray	TokenNameIdentifier
extends	TokenNameextends
BytesStartArray	TokenNameIdentifier
{	TokenNameLBRACE
protected	TokenNameprotected
final	TokenNamefinal
int	TokenNameint
initSize	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytesStart	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
final	TokenNamefinal
AtomicLong	TokenNameIdentifier
bytesUsed	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
TrackingDirectBytesStartArray	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
initSize	TokenNameIdentifier
,	TokenNameCOMMA
AtomicLong	TokenNameIdentifier
bytesUsed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
initSize	TokenNameIdentifier
=	TokenNameEQUAL
initSize	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
=	TokenNameEQUAL
bytesUsed	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bytesStart	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
grow	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
bytesStart	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
oldSize	TokenNameIdentifier
=	TokenNameEQUAL
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
bytesStart	TokenNameIdentifier
,	TokenNameCOMMA
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
oldSize	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bytesStart	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
oversize	TokenNameIdentifier
(	TokenNameLPAREN
initSize	TokenNameIdentifier
,	TokenNameCOMMA
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
bytesStart	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
AtomicLong	TokenNameIdentifier
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bytesUsed	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
DirectBytesStartArray	TokenNameIdentifier
extends	TokenNameextends
BytesStartArray	TokenNameIdentifier
{	TokenNameLBRACE
protected	TokenNameprotected
final	TokenNamefinal
int	TokenNameint
initSize	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bytesStart	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
AtomicLong	TokenNameIdentifier
bytesUsed	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
DirectBytesStartArray	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
initSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicLong	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
initSize	TokenNameIdentifier
=	TokenNameEQUAL
initSize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
grow	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
bytesStart	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
return	TokenNamereturn
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
bytesStart	TokenNameIdentifier
,	TokenNameCOMMA
bytesStart	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
init	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bytesStart	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
oversize	TokenNameIdentifier
(	TokenNameLPAREN
initSize	TokenNameIdentifier
,	TokenNameCOMMA
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
AtomicLong	TokenNameIdentifier
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bytesUsed	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
