package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
PrintStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Date	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Comparator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collections	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
concurrent	TokenNameIdentifier
.	TokenNameDOT
atomic	TokenNameIdentifier
.	TokenNameDOT
AtomicInteger	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
concurrent	TokenNameIdentifier
.	TokenNameDOT
atomic	TokenNameIdentifier
.	TokenNameDOT
AtomicLong	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
DocIdSet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
DocIdSetIterator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
Query	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
QueryWrapperFilter	TokenNameIdentifier
;	TokenNameSEMICOLON
class	TokenNameclass
BufferedDeletesStream	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
FrozenBufferedDeletes	TokenNameIdentifier
>	TokenNameGREATER
deletes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
FrozenBufferedDeletes	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
nextGen	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
Term	TokenNameIdentifier
lastDeleteTerm	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
PrintStream	TokenNameIdentifier
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
AtomicLong	TokenNameIdentifier
bytesUsed	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicLong	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
AtomicInteger	TokenNameIdentifier
numTerms	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicInteger	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
messageID	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
BufferedDeletesStream	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
messageID	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
messageID	TokenNameIdentifier
=	TokenNameEQUAL
messageID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
void	TokenNamevoid
message	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
message	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
infoStream	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"BD "	TokenNameStringLiteral
+	TokenNamePLUS
messageID	TokenNameIdentifier
+	TokenNamePLUS
" ["	TokenNameStringLiteral
+	TokenNamePLUS
new	TokenNamenew
Date	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"; "	TokenNameStringLiteral
+	TokenNamePLUS
Thread	TokenNameIdentifier
.	TokenNameDOT
currentThread	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"]: "	TokenNameStringLiteral
+	TokenNamePLUS
message	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
setInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
PrintStream	TokenNameIdentifier
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
infoStream	TokenNameIdentifier
=	TokenNameEQUAL
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
push	TokenNameIdentifier
(	TokenNameLPAREN
FrozenBufferedDeletes	TokenNameIdentifier
packet	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
packet	TokenNameIdentifier
.	TokenNameDOT
any	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
checkDeleteStats	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
packet	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
<	TokenNameLESS
nextGen	TokenNameIdentifier
;	TokenNameSEMICOLON
deletes	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
packet	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
numTerms	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
packet	TokenNameIdentifier
.	TokenNameDOT
numTermDeletes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
packet	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"push deletes "	TokenNameStringLiteral
+	TokenNamePLUS
packet	TokenNameIdentifier
+	TokenNamePLUS
" delGen="	TokenNameStringLiteral
+	TokenNamePLUS
packet	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
+	TokenNamePLUS
" packetCount="	TokenNameStringLiteral
+	TokenNamePLUS
deletes	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
checkDeleteStats	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
deletes	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
nextGen	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
numTerms	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
any	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
numTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
numTerms	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
ApplyDeletesResult	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
final	TokenNamefinal
boolean	TokenNameboolean
anyDeletes	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
long	TokenNamelong
gen	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
allDeleted	TokenNameIdentifier
;	TokenNameSEMICOLON
ApplyDeletesResult	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
anyDeletes	TokenNameIdentifier
,	TokenNameCOMMA
long	TokenNamelong
gen	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
allDeleted	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
anyDeletes	TokenNameIdentifier
=	TokenNameEQUAL
anyDeletes	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
gen	TokenNameIdentifier
=	TokenNameEQUAL
gen	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
allDeleted	TokenNameIdentifier
=	TokenNameEQUAL
allDeleted	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
Comparator	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
sortByDelGen	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Comparator	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
si1	TokenNameIdentifier
,	TokenNameCOMMA
SegmentInfo	TokenNameIdentifier
si2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
cmp	TokenNameIdentifier
=	TokenNameEQUAL
si1	TokenNameIdentifier
.	TokenNameDOT
getBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
si2	TokenNameIdentifier
.	TokenNameDOT
getBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cmp	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
cmp	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
public	TokenNamepublic
synchronized	TokenNamesynchronized
ApplyDeletesResult	TokenNameIdentifier
applyDeletes	TokenNameIdentifier
(	TokenNameLPAREN
IndexWriter	TokenNameIdentifier
.	TokenNameDOT
ReaderPool	TokenNameIdentifier
readerPool	TokenNameIdentifier
,	TokenNameCOMMA
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
infos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
t0	TokenNameIdentifier
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
ApplyDeletesResult	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
nextGen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
checkDeleteStats	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
any	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"applyDeletes: no deletes; skipping"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
new	TokenNamenew
ApplyDeletesResult	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
nextGen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"applyDeletes: infos="	TokenNameStringLiteral
+	TokenNamePLUS
infos	TokenNameIdentifier
+	TokenNamePLUS
" packetCount="	TokenNameStringLiteral
+	TokenNamePLUS
deletes	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
infos2	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
infos2	TokenNameIdentifier
.	TokenNameDOT
addAll	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Collections	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
infos2	TokenNameIdentifier
,	TokenNameCOMMA
sortByDelGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
CoalescedDeletes	TokenNameIdentifier
coalescedDeletes	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
anyNewDeletes	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
int	TokenNameint
infosIDX	TokenNameIdentifier
=	TokenNameEQUAL
infos2	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
delIDX	TokenNameIdentifier
=	TokenNameEQUAL
deletes	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
allDeleted	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
infosIDX	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
FrozenBufferedDeletes	TokenNameIdentifier
packet	TokenNameIdentifier
=	TokenNameEQUAL
delIDX	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
deletes	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
delIDX	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
null	TokenNamenull
;	TokenNameSEMICOLON
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
infos2	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
infosIDX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
segGen	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
packet	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
segGen	TokenNameIdentifier
<	TokenNameLESS
packet	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
coalescedDeletes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
coalescedDeletes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CoalescedDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
coalescedDeletes	TokenNameIdentifier
.	TokenNameDOT
update	TokenNameIdentifier
(	TokenNameLPAREN
packet	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
delIDX	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
packet	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
segGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
packet	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
readerPool	TokenNameIdentifier
.	TokenNameDOT
infoIsLive	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
=	TokenNameEQUAL
readerPool	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
delCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
segAllDeletes	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
coalescedDeletes	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
delCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
applyTermDeletes	TokenNameIdentifier
(	TokenNameLPAREN
coalescedDeletes	TokenNameIdentifier
.	TokenNameDOT
termsIterable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
applyQueryDeletes	TokenNameIdentifier
(	TokenNameLPAREN
coalescedDeletes	TokenNameIdentifier
.	TokenNameDOT
queriesIterable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
delCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
applyQueryDeletes	TokenNameIdentifier
(	TokenNameLPAREN
packet	TokenNameIdentifier
.	TokenNameDOT
queriesIterable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segAllDeletes	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
readerPool	TokenNameIdentifier
.	TokenNameDOT
release	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
anyNewDeletes	TokenNameIdentifier
|=	TokenNameOR_EQUAL
delCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
allDeleted	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
allDeleted	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
allDeleted	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"seg="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
+	TokenNamePLUS
" segGen="	TokenNameStringLiteral
+	TokenNamePLUS
segGen	TokenNameIdentifier
+	TokenNamePLUS
" segDeletes=["	TokenNameStringLiteral
+	TokenNamePLUS
packet	TokenNameIdentifier
+	TokenNamePLUS
"]; coalesced deletes=["	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
coalescedDeletes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
"null"	TokenNameStringLiteral
:	TokenNameCOLON
coalescedDeletes	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
"] delCount="	TokenNameStringLiteral
+	TokenNamePLUS
delCount	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
segAllDeletes	TokenNameIdentifier
?	TokenNameQUESTION
" 100% deleted"	TokenNameStringLiteral
:	TokenNameCOLON
""	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
coalescedDeletes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
coalescedDeletes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CoalescedDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
coalescedDeletes	TokenNameIdentifier
.	TokenNameDOT
update	TokenNameIdentifier
(	TokenNameLPAREN
packet	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
delIDX	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
infosIDX	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
info	TokenNameIdentifier
.	TokenNameDOT
setBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
nextGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
coalescedDeletes	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
readerPool	TokenNameIdentifier
.	TokenNameDOT
infoIsLive	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
=	TokenNameEQUAL
readerPool	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
delCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
segAllDeletes	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
delCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
applyTermDeletes	TokenNameIdentifier
(	TokenNameLPAREN
coalescedDeletes	TokenNameIdentifier
.	TokenNameDOT
termsIterable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
applyQueryDeletes	TokenNameIdentifier
(	TokenNameLPAREN
coalescedDeletes	TokenNameIdentifier
.	TokenNameDOT
queriesIterable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segAllDeletes	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
readerPool	TokenNameIdentifier
.	TokenNameDOT
release	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
anyNewDeletes	TokenNameIdentifier
|=	TokenNameOR_EQUAL
delCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
allDeleted	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
allDeleted	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
allDeleted	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"seg="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
+	TokenNamePLUS
" segGen="	TokenNameStringLiteral
+	TokenNamePLUS
segGen	TokenNameIdentifier
+	TokenNamePLUS
" coalesced deletes=["	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
coalescedDeletes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
"null"	TokenNameStringLiteral
:	TokenNameCOLON
coalescedDeletes	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
"] delCount="	TokenNameStringLiteral
+	TokenNamePLUS
delCount	TokenNameIdentifier
+	TokenNamePLUS
(	TokenNameLPAREN
segAllDeletes	TokenNameIdentifier
?	TokenNameQUESTION
" 100% deleted"	TokenNameStringLiteral
:	TokenNameCOLON
""	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
info	TokenNameIdentifier
.	TokenNameDOT
setBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
nextGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
infosIDX	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
assert	TokenNameassert
checkDeleteStats	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"applyDeletes took "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
t0	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" msec"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
ApplyDeletesResult	TokenNameIdentifier
(	TokenNameLPAREN
anyNewDeletes	TokenNameIdentifier
,	TokenNameCOMMA
nextGen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
allDeleted	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
long	TokenNamelong
getNextGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
nextGen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
prune	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
checkDeleteStats	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
minGen	TokenNameIdentifier
=	TokenNameEQUAL
Long	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
minGen	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
getBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
minGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"prune sis="	TokenNameStringLiteral
+	TokenNamePLUS
segmentInfos	TokenNameIdentifier
+	TokenNamePLUS
" minGen="	TokenNameStringLiteral
+	TokenNamePLUS
minGen	TokenNameIdentifier
+	TokenNamePLUS
" packetCount="	TokenNameStringLiteral
+	TokenNamePLUS
deletes	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
limit	TokenNameIdentifier
=	TokenNameEQUAL
deletes	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
delIDX	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
delIDX	TokenNameIdentifier
<	TokenNameLESS
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
delIDX	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
deletes	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
delIDX	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
gen	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
minGen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
prune	TokenNameIdentifier
(	TokenNameLPAREN
delIDX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
checkDeleteStats	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
prune	TokenNameIdentifier
(	TokenNameLPAREN
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
!	TokenNameNOT
any	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
checkDeleteStats	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
void	TokenNamevoid
prune	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
count	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
count	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"pruneDeletes: prune "	TokenNameStringLiteral
+	TokenNamePLUS
count	TokenNameIdentifier
+	TokenNamePLUS
" packets; "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
deletes	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
count	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" packets remain"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
delIDX	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
delIDX	TokenNameIdentifier
<	TokenNameLESS
count	TokenNameIdentifier
;	TokenNameSEMICOLON
delIDX	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
FrozenBufferedDeletes	TokenNameIdentifier
packet	TokenNameIdentifier
=	TokenNameEQUAL
deletes	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
delIDX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
numTerms	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
packet	TokenNameIdentifier
.	TokenNameDOT
numTermDeletes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
numTerms	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
packet	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
deletes	TokenNameIdentifier
.	TokenNameDOT
subList	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
count	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
long	TokenNamelong
applyTermDeletes	TokenNameIdentifier
(	TokenNameLPAREN
Iterable	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
>	TokenNameGREATER
termsIter	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
long	TokenNamelong
delCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
checkDeleteTerm	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
TermDocs	TokenNameIdentifier
docs	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
termDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
:	TokenNameCOLON
termsIter	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
checkDeleteTerm	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docs	TokenNameIdentifier
.	TokenNameDOT
seek	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
docs	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
docID	TokenNameIdentifier
=	TokenNameEQUAL
docs	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reader	TokenNameIdentifier
.	TokenNameDOT
deleteDocument	TokenNameIdentifier
(	TokenNameLPAREN
docID	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
QueryAndLimit	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
final	TokenNamefinal
Query	TokenNameIdentifier
query	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
int	TokenNameint
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
QueryAndLimit	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
query	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
query	TokenNameIdentifier
=	TokenNameEQUAL
query	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
limit	TokenNameIdentifier
=	TokenNameEQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
long	TokenNamelong
applyQueryDeletes	TokenNameIdentifier
(	TokenNameLPAREN
Iterable	TokenNameIdentifier
<	TokenNameLESS
QueryAndLimit	TokenNameIdentifier
>	TokenNameGREATER
queriesIter	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
long	TokenNamelong
delCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
QueryAndLimit	TokenNameIdentifier
ent	TokenNameIdentifier
:	TokenNameCOLON
queriesIter	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Query	TokenNameIdentifier
query	TokenNameIdentifier
=	TokenNameEQUAL
ent	TokenNameIdentifier
.	TokenNameDOT
query	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
limit	TokenNameIdentifier
=	TokenNameEQUAL
ent	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
DocIdSet	TokenNameIdentifier
docs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
QueryWrapperFilter	TokenNameIdentifier
(	TokenNameLPAREN
query	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getDocIdSet	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
DocIdSetIterator	TokenNameIdentifier
it	TokenNameIdentifier
=	TokenNameEQUAL
docs	TokenNameIdentifier
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
it	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
doc	TokenNameIdentifier
=	TokenNameEQUAL
it	TokenNameIdentifier
.	TokenNameDOT
nextDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doc	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
limit	TokenNameIdentifier
)	TokenNameRPAREN
break	TokenNamebreak
;	TokenNameSEMICOLON
reader	TokenNameIdentifier
.	TokenNameDOT
deleteDocument	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
checkDeleteTerm	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
term	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
lastDeleteTerm	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
term	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
lastDeleteTerm	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
:	TokenNameCOLON
"lastTerm="	TokenNameStringLiteral
+	TokenNamePLUS
lastDeleteTerm	TokenNameIdentifier
+	TokenNamePLUS
" vs term="	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lastDeleteTerm	TokenNameIdentifier
=	TokenNameEQUAL
term	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
null	TokenNamenull
:	TokenNameCOLON
new	TokenNamenew
Term	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
field	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
term	TokenNameIdentifier
.	TokenNameDOT
text	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
checkDeleteStats	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
numTerms2	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bytesUsed2	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
FrozenBufferedDeletes	TokenNameIdentifier
packet	TokenNameIdentifier
:	TokenNameCOLON
deletes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
numTerms2	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
packet	TokenNameIdentifier
.	TokenNameDOT
numTermDeletes	TokenNameIdentifier
;	TokenNameSEMICOLON
bytesUsed2	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
packet	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
numTerms2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
numTerms	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
"numTerms2="	TokenNameStringLiteral
+	TokenNamePLUS
numTerms2	TokenNameIdentifier
+	TokenNamePLUS
" vs "	TokenNameStringLiteral
+	TokenNamePLUS
numTerms	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
bytesUsed2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
:	TokenNameCOLON
"bytesUsed2="	TokenNameStringLiteral
+	TokenNamePLUS
bytesUsed2	TokenNameIdentifier
+	TokenNamePLUS
" vs "	TokenNameStringLiteral
+	TokenNamePLUS
bytesUsed	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
