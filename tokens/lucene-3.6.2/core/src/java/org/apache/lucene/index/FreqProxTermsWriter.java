package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
FieldInfo	TokenNameIdentifier
.	TokenNameDOT
IndexOptions	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
UnicodeUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collection	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Map	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
BitVector	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
CollectionUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
class	TokenNameclass
FreqProxTermsWriter	TokenNameIdentifier
extends	TokenNameextends
TermsHashConsumer	TokenNameIdentifier
{	TokenNameLBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
TermsHashConsumerPerThread	TokenNameIdentifier
addThread	TokenNameIdentifier
(	TokenNameLPAREN
TermsHashPerThread	TokenNameIdentifier
perThread	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
FreqProxTermsWriterPerThread	TokenNameIdentifier
(	TokenNameLPAREN
perThread	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
int	TokenNameint
compareText	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
text1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
pos1	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
text2	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
pos2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
char	TokenNamechar
c1	TokenNameIdentifier
=	TokenNameEQUAL
text1	TokenNameIdentifier
[	TokenNameLBRACKET
pos1	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
c2	TokenNameIdentifier
=	TokenNameEQUAL
text2	TokenNameIdentifier
[	TokenNameLBRACKET
pos2	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
c1	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
c2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
0xffff	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
c2	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
0xffff	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
c1	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
return	TokenNamereturn
c1	TokenNameIdentifier
-	TokenNameMINUS
c2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
0xffff	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
c1	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
void	TokenNamevoid
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
flush	TokenNameIdentifier
(	TokenNameLPAREN
Map	TokenNameIdentifier
<	TokenNameLESS
TermsHashConsumerPerThread	TokenNameIdentifier
,	TokenNameCOMMA
Collection	TokenNameIdentifier
<	TokenNameLESS
TermsHashConsumerPerField	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
threadsAndFields	TokenNameIdentifier
,	TokenNameCOMMA
final	TokenNamefinal
SegmentWriteState	TokenNameIdentifier
state	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
List	TokenNameIdentifier
<	TokenNameLESS
FreqProxTermsWriterPerField	TokenNameIdentifier
>	TokenNameGREATER
allFields	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
FreqProxTermsWriterPerField	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Map	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
<	TokenNameLESS
TermsHashConsumerPerThread	TokenNameIdentifier
,	TokenNameCOMMA
Collection	TokenNameIdentifier
<	TokenNameLESS
TermsHashConsumerPerField	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
entry	TokenNameIdentifier
:	TokenNameCOLON
threadsAndFields	TokenNameIdentifier
.	TokenNameDOT
entrySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
Collection	TokenNameIdentifier
<	TokenNameLESS
TermsHashConsumerPerField	TokenNameIdentifier
>	TokenNameGREATER
fields	TokenNameIdentifier
=	TokenNameEQUAL
entry	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
TermsHashConsumerPerField	TokenNameIdentifier
i	TokenNameIdentifier
:	TokenNameCOLON
fields	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
FreqProxTermsWriterPerField	TokenNameIdentifier
perField	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
FreqProxTermsWriterPerField	TokenNameIdentifier
)	TokenNameRPAREN
i	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
perField	TokenNameIdentifier
.	TokenNameDOT
termsHashPerField	TokenNameIdentifier
.	TokenNameDOT
numPostings	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
allFields	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
perField	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
CollectionUtil	TokenNameIdentifier
.	TokenNameDOT
quickSort	TokenNameIdentifier
(	TokenNameLPAREN
allFields	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
numAllFields	TokenNameIdentifier
=	TokenNameEQUAL
allFields	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
FormatPostingsFieldsConsumer	TokenNameIdentifier
consumer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FormatPostingsFieldsWriter	TokenNameIdentifier
(	TokenNameLPAREN
state	TokenNameIdentifier
,	TokenNameCOMMA
fieldInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
start	TokenNameIdentifier
<	TokenNameLESS
numAllFields	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
FieldInfo	TokenNameIdentifier
fieldInfo	TokenNameIdentifier
=	TokenNameEQUAL
allFields	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
fieldName	TokenNameIdentifier
=	TokenNameEQUAL
fieldInfo	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
end	TokenNameIdentifier
<	TokenNameLESS
numAllFields	TokenNameIdentifier
&&	TokenNameAND_AND
allFields	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
fieldName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
end	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
FreqProxTermsWriterPerField	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fields	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FreqProxTermsWriterPerField	TokenNameIdentifier
[	TokenNameLBRACKET
end	TokenNameIdentifier
-	TokenNameMINUS
start	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
fields	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
-	TokenNameMINUS
start	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
allFields	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fieldInfo	TokenNameIdentifier
.	TokenNameDOT
indexOptions	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
IndexOptions	TokenNameIdentifier
.	TokenNameDOT
DOCS_AND_FREQS_AND_POSITIONS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fieldInfo	TokenNameIdentifier
.	TokenNameDOT
storePayloads	TokenNameIdentifier
|=	TokenNameOR_EQUAL
fields	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
-	TokenNameMINUS
start	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
hasPayloads	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
appendPostings	TokenNameIdentifier
(	TokenNameLPAREN
fieldName	TokenNameIdentifier
,	TokenNameCOMMA
state	TokenNameIdentifier
,	TokenNameCOMMA
fields	TokenNameIdentifier
,	TokenNameCOMMA
consumer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
fields	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
TermsHashPerField	TokenNameIdentifier
perField	TokenNameIdentifier
=	TokenNameEQUAL
fields	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
termsHashPerField	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
numPostings	TokenNameIdentifier
=	TokenNameEQUAL
perField	TokenNameIdentifier
.	TokenNameDOT
numPostings	TokenNameIdentifier
;	TokenNameSEMICOLON
perField	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
perField	TokenNameIdentifier
.	TokenNameDOT
shrinkHash	TokenNameIdentifier
(	TokenNameLPAREN
numPostings	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fields	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
start	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
Map	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
<	TokenNameLESS
TermsHashConsumerPerThread	TokenNameIdentifier
,	TokenNameCOMMA
Collection	TokenNameIdentifier
<	TokenNameLESS
TermsHashConsumerPerField	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
entry	TokenNameIdentifier
:	TokenNameCOLON
threadsAndFields	TokenNameIdentifier
.	TokenNameDOT
entrySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
FreqProxTermsWriterPerThread	TokenNameIdentifier
perThread	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
FreqProxTermsWriterPerThread	TokenNameIdentifier
)	TokenNameRPAREN
entry	TokenNameIdentifier
.	TokenNameDOT
getKey	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
perThread	TokenNameIdentifier
.	TokenNameDOT
termsHashPerThread	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
consumer	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
payloadBuffer	TokenNameIdentifier
;	TokenNameSEMICOLON
void	TokenNamevoid
appendPostings	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
fieldName	TokenNameIdentifier
,	TokenNameCOMMA
SegmentWriteState	TokenNameIdentifier
state	TokenNameIdentifier
,	TokenNameCOMMA
FreqProxTermsWriterPerField	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
fields	TokenNameIdentifier
,	TokenNameCOMMA
FormatPostingsFieldsConsumer	TokenNameIdentifier
consumer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
numFields	TokenNameIdentifier
=	TokenNameEQUAL
fields	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
FreqProxFieldMergeState	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
mergeStates	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FreqProxFieldMergeState	TokenNameIdentifier
[	TokenNameLBRACKET
numFields	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numFields	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
FreqProxFieldMergeState	TokenNameIdentifier
fms	TokenNameIdentifier
=	TokenNameEQUAL
mergeStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
FreqProxFieldMergeState	TokenNameIdentifier
(	TokenNameLPAREN
fields	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
fms	TokenNameIdentifier
.	TokenNameDOT
field	TokenNameIdentifier
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
fields	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
result	TokenNameIdentifier
=	TokenNameEQUAL
fms	TokenNameIdentifier
.	TokenNameDOT
nextTerm	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
FormatPostingsTermsConsumer	TokenNameIdentifier
termsConsumer	TokenNameIdentifier
=	TokenNameEQUAL
consumer	TokenNameIdentifier
.	TokenNameDOT
addField	TokenNameIdentifier
(	TokenNameLPAREN
fields	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
Term	TokenNameIdentifier
protoTerm	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Term	TokenNameIdentifier
(	TokenNameLPAREN
fieldName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
FreqProxFieldMergeState	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
termStates	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FreqProxFieldMergeState	TokenNameIdentifier
[	TokenNameLBRACKET
numFields	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
IndexOptions	TokenNameIdentifier
currentFieldIndexOptions	TokenNameIdentifier
=	TokenNameEQUAL
fields	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
.	TokenNameDOT
indexOptions	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
Map	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
segDeletes	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
state	TokenNameIdentifier
.	TokenNameDOT
segDeletes	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
state	TokenNameIdentifier
.	TokenNameDOT
segDeletes	TokenNameIdentifier
.	TokenNameDOT
terms	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
segDeletes	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
.	TokenNameDOT
segDeletes	TokenNameIdentifier
.	TokenNameDOT
terms	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
segDeletes	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
numFields	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
mergeStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
numToMerge	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numFields	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
text	TokenNameIdentifier
=	TokenNameEQUAL
mergeStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
text	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
textOffset	TokenNameIdentifier
=	TokenNameEQUAL
mergeStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
textOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
cmp	TokenNameIdentifier
=	TokenNameEQUAL
compareText	TokenNameIdentifier
(	TokenNameLPAREN
text	TokenNameIdentifier
,	TokenNameCOMMA
textOffset	TokenNameIdentifier
,	TokenNameCOMMA
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
text	TokenNameIdentifier
,	TokenNameCOMMA
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
textOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cmp	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
mergeStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
numToMerge	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
cmp	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
numToMerge	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
mergeStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
FormatPostingsDocsConsumer	TokenNameIdentifier
docConsumer	TokenNameIdentifier
=	TokenNameEQUAL
termsConsumer	TokenNameIdentifier
.	TokenNameDOT
addTerm	TokenNameIdentifier
(	TokenNameLPAREN
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
text	TokenNameIdentifier
,	TokenNameCOMMA
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
textOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
delDocLimit	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segDeletes	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Integer	TokenNameIdentifier
docIDUpto	TokenNameIdentifier
=	TokenNameEQUAL
segDeletes	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
protoTerm	TokenNameIdentifier
.	TokenNameDOT
createTerm	TokenNameIdentifier
(	TokenNameLPAREN
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
termText	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docIDUpto	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
delDocLimit	TokenNameIdentifier
=	TokenNameEQUAL
docIDUpto	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
delDocLimit	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
delDocLimit	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
numToMerge	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
FreqProxFieldMergeState	TokenNameIdentifier
minState	TokenNameIdentifier
=	TokenNameEQUAL
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numToMerge	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
docID	TokenNameIdentifier
<	TokenNameLESS
minState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
)	TokenNameRPAREN
minState	TokenNameIdentifier
=	TokenNameEQUAL
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
termDocFreq	TokenNameIdentifier
=	TokenNameEQUAL
minState	TokenNameIdentifier
.	TokenNameDOT
termFreq	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
FormatPostingsPositionsConsumer	TokenNameIdentifier
posConsumer	TokenNameIdentifier
=	TokenNameEQUAL
docConsumer	TokenNameIdentifier
.	TokenNameDOT
addDoc	TokenNameIdentifier
(	TokenNameLPAREN
minState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
,	TokenNameCOMMA
termDocFreq	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
minState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
<	TokenNameLESS
delDocLimit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
state	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BitVector	TokenNameIdentifier
(	TokenNameLPAREN
state	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
state	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
minState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
ByteSliceReader	TokenNameIdentifier
prox	TokenNameIdentifier
=	TokenNameEQUAL
minState	TokenNameIdentifier
.	TokenNameDOT
prox	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
currentFieldIndexOptions	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
IndexOptions	TokenNameIdentifier
.	TokenNameDOT
DOCS_AND_FREQS_AND_POSITIONS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
int	TokenNameint
position	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
termDocFreq	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
code	TokenNameIdentifier
=	TokenNameEQUAL
prox	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
position	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
code	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
payloadLength	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
code	TokenNameIdentifier
&	TokenNameAND
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
payloadLength	TokenNameIdentifier
=	TokenNameEQUAL
prox	TokenNameIdentifier
.	TokenNameDOT
readVInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
payloadBuffer	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
payloadBuffer	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
payloadLength	TokenNameIdentifier
)	TokenNameRPAREN
payloadBuffer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
payloadLength	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
prox	TokenNameIdentifier
.	TokenNameDOT
readBytes	TokenNameIdentifier
(	TokenNameLPAREN
payloadBuffer	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
payloadLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
payloadLength	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
posConsumer	TokenNameIdentifier
.	TokenNameDOT
addPosition	TokenNameIdentifier
(	TokenNameLPAREN
position	TokenNameIdentifier
,	TokenNameCOMMA
payloadBuffer	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
payloadLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
posConsumer	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
minState	TokenNameIdentifier
.	TokenNameDOT
nextDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
upto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numToMerge	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
minState	TokenNameIdentifier
)	TokenNameRPAREN
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
termStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
numToMerge	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
assert	TokenNameassert
upto	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
numToMerge	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
minState	TokenNameIdentifier
.	TokenNameDOT
nextTerm	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
upto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numFields	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
if	TokenNameif
(	TokenNameLPAREN
mergeStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
minState	TokenNameIdentifier
)	TokenNameRPAREN
mergeStates	TokenNameIdentifier
[	TokenNameLBRACKET
upto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
mergeStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
numFields	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
assert	TokenNameassert
upto	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
numFields	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
docConsumer	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
termsConsumer	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
UnicodeUtil	TokenNameIdentifier
.	TokenNameDOT
UTF8Result	TokenNameIdentifier
termsUTF8	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
UnicodeUtil	TokenNameIdentifier
.	TokenNameDOT
UTF8Result	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
