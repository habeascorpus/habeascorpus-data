package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Map	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collection	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collections	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashSet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Comparator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
TieredMergePolicy	TokenNameIdentifier
extends	TokenNameextends
MergePolicy	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
int	TokenNameint
maxMergeAtOnce	TokenNameIdentifier
=	TokenNameEQUAL
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
maxMergedSegmentBytes	TokenNameIdentifier
=	TokenNameEQUAL
5	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024L	TokenNameLongLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
maxMergeAtOnceExplicit	TokenNameIdentifier
=	TokenNameEQUAL
30	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
floorSegmentBytes	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024L	TokenNameLongLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
double	TokenNamedouble
segsPerTier	TokenNameIdentifier
=	TokenNameEQUAL
10.0	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
double	TokenNamedouble
forceMergeDeletesPctAllowed	TokenNameIdentifier
=	TokenNameEQUAL
10.0	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
useCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
private	TokenNameprivate
double	TokenNamedouble
noCFSRatio	TokenNameIdentifier
=	TokenNameEQUAL
0.1	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
double	TokenNamedouble
reclaimDeletesWeight	TokenNameIdentifier
=	TokenNameEQUAL
2.0	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
TieredMergePolicy	TokenNameIdentifier
setMaxMergeAtOnce	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
v	TokenNameIdentifier
<	TokenNameLESS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"maxMergeAtOnce must be > 1 (got "	TokenNameStringLiteral
+	TokenNamePLUS
v	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
maxMergeAtOnce	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getMaxMergeAtOnce	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
maxMergeAtOnce	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
TieredMergePolicy	TokenNameIdentifier
setMaxMergeAtOnceExplicit	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
v	TokenNameIdentifier
<	TokenNameLESS
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"maxMergeAtOnceExplicit must be > 1 (got "	TokenNameStringLiteral
+	TokenNamePLUS
v	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
maxMergeAtOnceExplicit	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getMaxMergeAtOnceExplicit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
maxMergeAtOnceExplicit	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
TieredMergePolicy	TokenNameIdentifier
setMaxMergedSegmentMB	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
maxMergedSegmentBytes	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
(	TokenNameLPAREN
v	TokenNameIdentifier
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
double	TokenNamedouble
getMaxMergedSegmentMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
maxMergedSegmentBytes	TokenNameIdentifier
/	TokenNameDIVIDE
1024	TokenNameIntegerLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
TieredMergePolicy	TokenNameIdentifier
setReclaimDeletesWeight	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
v	TokenNameIdentifier
<	TokenNameLESS
0.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"reclaimDeletesWeight must be >= 0.0 (got "	TokenNameStringLiteral
+	TokenNamePLUS
v	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
reclaimDeletesWeight	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
double	TokenNamedouble
getReclaimDeletesWeight	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
reclaimDeletesWeight	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
TieredMergePolicy	TokenNameIdentifier
setFloorSegmentMB	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
v	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"floorSegmentMB must be >= 0.0 (got "	TokenNameStringLiteral
+	TokenNamePLUS
v	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
floorSegmentBytes	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
(	TokenNameLPAREN
v	TokenNameIdentifier
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
double	TokenNamedouble
getFloorSegmentMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
floorSegmentBytes	TokenNameIdentifier
/	TokenNameDIVIDE
(	TokenNameLPAREN
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
TieredMergePolicy	TokenNameIdentifier
setForceMergeDeletesPctAllowed	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
v	TokenNameIdentifier
<	TokenNameLESS
0.0	TokenNameDoubleLiteral
||	TokenNameOR_OR
v	TokenNameIdentifier
>	TokenNameGREATER
100.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"forceMergeDeletesPctAllowed must be between 0.0 and 100.0 inclusive (got "	TokenNameStringLiteral
+	TokenNamePLUS
v	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
forceMergeDeletesPctAllowed	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
double	TokenNamedouble
getForceMergeDeletesPctAllowed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
forceMergeDeletesPctAllowed	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
TieredMergePolicy	TokenNameIdentifier
setSegmentsPerTier	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
v	TokenNameIdentifier
<	TokenNameLESS
2.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"segmentsPerTier must be >= 2.0 (got "	TokenNameStringLiteral
+	TokenNamePLUS
v	TokenNameIdentifier
+	TokenNamePLUS
")"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
segsPerTier	TokenNameIdentifier
=	TokenNameEQUAL
v	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
double	TokenNamedouble
getSegmentsPerTier	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
segsPerTier	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
TieredMergePolicy	TokenNameIdentifier
setUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
useCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
useCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
useCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
TieredMergePolicy	TokenNameIdentifier
setNoCFSRatio	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
noCFSRatio	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
noCFSRatio	TokenNameIdentifier
<	TokenNameLESS
0.0	TokenNameDoubleLiteral
||	TokenNameOR_OR
noCFSRatio	TokenNameIdentifier
>	TokenNameGREATER
1.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"noCFSRatio must be 0.0 to 1.0 inclusive; got "	TokenNameStringLiteral
+	TokenNamePLUS
noCFSRatio	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
noCFSRatio	TokenNameIdentifier
=	TokenNameEQUAL
noCFSRatio	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
double	TokenNamedouble
getNoCFSRatio	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
noCFSRatio	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
class	TokenNameclass
SegmentByteSizeDescending	TokenNameIdentifier
implements	TokenNameimplements
Comparator	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
o1	TokenNameIdentifier
,	TokenNameCOMMA
SegmentInfo	TokenNameIdentifier
o2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
sz1	TokenNameIdentifier
=	TokenNameEQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
o1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
sz2	TokenNameIdentifier
=	TokenNameEQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
o2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
sz1	TokenNameIdentifier
>	TokenNameGREATER
sz2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
sz2	TokenNameIdentifier
>	TokenNameGREATER
sz1	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
o1	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
o2	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
ioe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
ioe	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
Comparator	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
segmentByteSizeDescending	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentByteSizeDescending	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
protected	TokenNameprotected
static	TokenNamestatic
abstract	TokenNameabstract
class	TokenNameclass
MergeScore	TokenNameIdentifier
{	TokenNameLBRACE
abstract	TokenNameabstract
double	TokenNamedouble
getScore	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
abstract	TokenNameabstract
String	TokenNameIdentifier
getExplanation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
MergeSpecification	TokenNameIdentifier
findMerges	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"findMerges: "	TokenNameStringLiteral
+	TokenNamePLUS
infos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" segments"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
Collection	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
merging	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getMergingSegments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
Collection	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
toBeMerged	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
infosSorted	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
infos	TokenNameIdentifier
.	TokenNameDOT
asList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Collections	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
infosSorted	TokenNameIdentifier
,	TokenNameCOMMA
segmentByteSizeDescending	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
totIndexBytes	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
minSegmentBytes	TokenNameIdentifier
=	TokenNameEQUAL
Long	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
infosSorted	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
segBytes	TokenNameIdentifier
=	TokenNameEQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
extra	TokenNameIdentifier
=	TokenNameEQUAL
merging	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
" [merging]"	TokenNameStringLiteral
:	TokenNameCOLON
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segBytes	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
maxMergedSegmentBytes	TokenNameIdentifier
/	TokenNameDIVIDE
2.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
extra	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
" [skip: too large]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
segBytes	TokenNameIdentifier
<	TokenNameLESS
floorSegmentBytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
extra	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
" [floored]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"  seg="	TokenNameStringLiteral
+	TokenNamePLUS
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" size="	TokenNameStringLiteral
+	TokenNamePLUS
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%.3f"	TokenNameStringLiteral
,	TokenNameCOMMA
segBytes	TokenNameIdentifier
/	TokenNameDIVIDE
1024	TokenNameIntegerLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
" MB"	TokenNameStringLiteral
+	TokenNamePLUS
extra	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
minSegmentBytes	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
segBytes	TokenNameIdentifier
,	TokenNameCOMMA
minSegmentBytes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
totIndexBytes	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
segBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
tooBigCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
tooBigCount	TokenNameIdentifier
<	TokenNameLESS
infosSorted	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
size	TokenNameIdentifier
(	TokenNameLPAREN
infosSorted	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
tooBigCount	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
maxMergedSegmentBytes	TokenNameIdentifier
/	TokenNameDIVIDE
2.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
totIndexBytes	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
infosSorted	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
tooBigCount	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tooBigCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
minSegmentBytes	TokenNameIdentifier
=	TokenNameEQUAL
floorSize	TokenNameIdentifier
(	TokenNameLPAREN
minSegmentBytes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
levelSize	TokenNameIdentifier
=	TokenNameEQUAL
minSegmentBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
bytesLeft	TokenNameIdentifier
=	TokenNameEQUAL
totIndexBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
double	TokenNamedouble
allowedSegCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
double	TokenNamedouble
segCountLevel	TokenNameIdentifier
=	TokenNameEQUAL
bytesLeft	TokenNameIdentifier
/	TokenNameDIVIDE
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
levelSize	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segCountLevel	TokenNameIdentifier
<	TokenNameLESS
segsPerTier	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
allowedSegCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
ceil	TokenNameIdentifier
(	TokenNameLPAREN
segCountLevel	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
allowedSegCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
segsPerTier	TokenNameIdentifier
;	TokenNameSEMICOLON
bytesLeft	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
segsPerTier	TokenNameIdentifier
*	TokenNameMULTIPLY
levelSize	TokenNameIdentifier
;	TokenNameSEMICOLON
levelSize	TokenNameIdentifier
*=	TokenNameMULTIPLY_EQUAL
maxMergeAtOnce	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
allowedSegCountInt	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
allowedSegCount	TokenNameIdentifier
;	TokenNameSEMICOLON
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
mergingBytes	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
eligible	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
tooBigCount	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
<	TokenNameLESS
infosSorted	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
infosSorted	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
idx	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
merging	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
mergingBytes	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
info	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
toBeMerged	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
eligible	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
boolean	TokenNameboolean
maxMergeIsRunning	TokenNameIdentifier
=	TokenNameEQUAL
mergingBytes	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
maxMergedSegmentBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
message	TokenNameIdentifier
(	TokenNameLPAREN
"  allowedSegmentCount="	TokenNameStringLiteral
+	TokenNamePLUS
allowedSegCountInt	TokenNameIdentifier
+	TokenNamePLUS
" vs count="	TokenNameStringLiteral
+	TokenNamePLUS
infosSorted	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" (eligible count="	TokenNameStringLiteral
+	TokenNamePLUS
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
") tooBigCount="	TokenNameStringLiteral
+	TokenNamePLUS
tooBigCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
allowedSegCountInt	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
MergeScore	TokenNameIdentifier
bestScore	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
best	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
bestTooLarge	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
long	TokenNamelong
bestMergeBytes	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
startIdx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
startIdx	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
maxMergeAtOnce	TokenNameIdentifier
;	TokenNameSEMICOLON
startIdx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
totAfterMergeBytes	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
candidate	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
hitTooLarge	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
startIdx	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
<	TokenNameLESS
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
candidate	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
<	TokenNameLESS
maxMergeAtOnce	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
eligible	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
idx	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
segBytes	TokenNameIdentifier
=	TokenNameEQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
totAfterMergeBytes	TokenNameIdentifier
+	TokenNamePLUS
segBytes	TokenNameIdentifier
>	TokenNameGREATER
maxMergedSegmentBytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
hitTooLarge	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
candidate	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
totAfterMergeBytes	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
segBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
MergeScore	TokenNameIdentifier
score	TokenNameIdentifier
=	TokenNameEQUAL
score	TokenNameIdentifier
(	TokenNameLPAREN
candidate	TokenNameIdentifier
,	TokenNameCOMMA
hitTooLarge	TokenNameIdentifier
,	TokenNameCOMMA
mergingBytes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
message	TokenNameIdentifier
(	TokenNameLPAREN
"  maybe="	TokenNameStringLiteral
+	TokenNamePLUS
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
candidate	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" score="	TokenNameStringLiteral
+	TokenNamePLUS
score	TokenNameIdentifier
.	TokenNameDOT
getScore	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" "	TokenNameStringLiteral
+	TokenNamePLUS
score	TokenNameIdentifier
.	TokenNameDOT
getExplanation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" tooLarge="	TokenNameStringLiteral
+	TokenNamePLUS
hitTooLarge	TokenNameIdentifier
+	TokenNamePLUS
" size="	TokenNameStringLiteral
+	TokenNamePLUS
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%.3f MB"	TokenNameStringLiteral
,	TokenNameCOMMA
totAfterMergeBytes	TokenNameIdentifier
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
bestScore	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
score	TokenNameIdentifier
.	TokenNameDOT
getScore	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
<	TokenNameLESS
bestScore	TokenNameIdentifier
.	TokenNameDOT
getScore	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
!	TokenNameNOT
hitTooLarge	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
maxMergeIsRunning	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
best	TokenNameIdentifier
=	TokenNameEQUAL
candidate	TokenNameIdentifier
;	TokenNameSEMICOLON
bestScore	TokenNameIdentifier
=	TokenNameEQUAL
score	TokenNameIdentifier
;	TokenNameSEMICOLON
bestTooLarge	TokenNameIdentifier
=	TokenNameEQUAL
hitTooLarge	TokenNameIdentifier
;	TokenNameSEMICOLON
bestMergeBytes	TokenNameIdentifier
=	TokenNameEQUAL
totAfterMergeBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
best	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
spec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergeSpecification	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
best	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
toBeMerged	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"  add merge="	TokenNameStringLiteral
+	TokenNamePLUS
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" size="	TokenNameStringLiteral
+	TokenNamePLUS
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%.3f MB"	TokenNameStringLiteral
,	TokenNameCOMMA
bestMergeBytes	TokenNameIdentifier
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
" score="	TokenNameStringLiteral
+	TokenNamePLUS
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%.3f"	TokenNameStringLiteral
,	TokenNameCOMMA
bestScore	TokenNameIdentifier
.	TokenNameDOT
getScore	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" "	TokenNameStringLiteral
+	TokenNamePLUS
bestScore	TokenNameIdentifier
.	TokenNameDOT
getExplanation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
bestTooLarge	TokenNameIdentifier
?	TokenNameQUESTION
" [max merge]"	TokenNameStringLiteral
:	TokenNameCOLON
""	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
MergeScore	TokenNameIdentifier
score	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
candidate	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
hitTooLarge	TokenNameIdentifier
,	TokenNameCOMMA
long	TokenNamelong
mergingBytes	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
long	TokenNamelong
totBeforeMergeBytes	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
totAfterMergeBytes	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
totAfterMergeBytesFloored	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
candidate	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
segBytes	TokenNameIdentifier
=	TokenNameEQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
totAfterMergeBytes	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
segBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
totAfterMergeBytesFloored	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
floorSize	TokenNameIdentifier
(	TokenNameLPAREN
segBytes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
totBeforeMergeBytes	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
info	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
double	TokenNamedouble
skew	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hitTooLarge	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
skew	TokenNameIdentifier
=	TokenNameEQUAL
1.0	TokenNameDoubleLiteral
/	TokenNameDIVIDE
maxMergeAtOnce	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
skew	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
floorSize	TokenNameIdentifier
(	TokenNameLPAREN
size	TokenNameIdentifier
(	TokenNameLPAREN
candidate	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
/	TokenNameDIVIDE
totAfterMergeBytesFloored	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
double	TokenNamedouble
mergeScore	TokenNameIdentifier
=	TokenNameEQUAL
skew	TokenNameIdentifier
;	TokenNameSEMICOLON
mergeScore	TokenNameIdentifier
*=	TokenNameMULTIPLY_EQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
pow	TokenNameIdentifier
(	TokenNameLPAREN
totAfterMergeBytes	TokenNameIdentifier
,	TokenNameCOMMA
0.05	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
double	TokenNamedouble
nonDelRatio	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
totAfterMergeBytes	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
totBeforeMergeBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
mergeScore	TokenNameIdentifier
*=	TokenNameMULTIPLY_EQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
pow	TokenNameIdentifier
(	TokenNameLPAREN
nonDelRatio	TokenNameIdentifier
,	TokenNameCOMMA
reclaimDeletesWeight	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
double	TokenNamedouble
finalMergeScore	TokenNameIdentifier
=	TokenNameEQUAL
mergeScore	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
new	TokenNamenew
MergeScore	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
double	TokenNamedouble
getScore	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
finalMergeScore	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
getExplanation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
"skew="	TokenNameStringLiteral
+	TokenNamePLUS
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%.3f"	TokenNameStringLiteral
,	TokenNameCOMMA
skew	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" nonDelRatio="	TokenNameStringLiteral
+	TokenNamePLUS
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"%.3f"	TokenNameStringLiteral
,	TokenNameCOMMA
nonDelRatio	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
MergeSpecification	TokenNameIdentifier
findForcedMerges	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
maxSegmentCount	TokenNameIdentifier
,	TokenNameCOMMA
Map	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
>	TokenNameGREATER
segmentsToMerge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"findForcedMerges maxSegmentCount="	TokenNameStringLiteral
+	TokenNamePLUS
maxSegmentCount	TokenNameIdentifier
+	TokenNamePLUS
" infos="	TokenNameStringLiteral
+	TokenNamePLUS
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" segmentsToMerge="	TokenNameStringLiteral
+	TokenNamePLUS
segmentsToMerge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
eligible	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
forceMergeRunning	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
final	TokenNamefinal
Collection	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
merging	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getMergingSegments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
segmentIsOriginal	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
infos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Boolean	TokenNameIdentifier
isOriginal	TokenNameIdentifier
=	TokenNameEQUAL
segmentsToMerge	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
isOriginal	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
segmentIsOriginal	TokenNameIdentifier
=	TokenNameEQUAL
isOriginal	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
merging	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
eligible	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
forceMergeRunning	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
maxSegmentCount	TokenNameIdentifier
>	TokenNameGREATER
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
<=	TokenNameLESS_EQUAL
maxSegmentCount	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
maxSegmentCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
(	TokenNameLPAREN
!	TokenNameNOT
segmentIsOriginal	TokenNameIdentifier
||	TokenNameOR_OR
isMerged	TokenNameIdentifier
(	TokenNameLPAREN
eligible	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"already merged"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Collections	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
eligible	TokenNameIdentifier
,	TokenNameCOMMA
segmentByteSizeDescending	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"eligible="	TokenNameStringLiteral
+	TokenNamePLUS
eligible	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
message	TokenNameIdentifier
(	TokenNameLPAREN
"forceMergeRunning="	TokenNameStringLiteral
+	TokenNamePLUS
forceMergeRunning	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
end	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
maxMergeAtOnceExplicit	TokenNameIdentifier
+	TokenNamePLUS
maxSegmentCount	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
spec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergeSpecification	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
eligible	TokenNameIdentifier
.	TokenNameDOT
subList	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
-	TokenNameMINUS
maxMergeAtOnceExplicit	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"add merge="	TokenNameStringLiteral
+	TokenNamePLUS
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
end	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
maxMergeAtOnceExplicit	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
!	TokenNameNOT
forceMergeRunning	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
numToMerge	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
-	TokenNameMINUS
maxSegmentCount	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
eligible	TokenNameIdentifier
.	TokenNameDOT
subList	TokenNameIdentifier
(	TokenNameLPAREN
end	TokenNameIdentifier
-	TokenNameMINUS
numToMerge	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"add final merge="	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getDirectory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
spec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergeSpecification	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
MergeSpecification	TokenNameIdentifier
findForcedDeletesMerges	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"findForcedDeletesMerges infos="	TokenNameStringLiteral
+	TokenNamePLUS
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" forceMergeDeletesPctAllowed="	TokenNameStringLiteral
+	TokenNamePLUS
forceMergeDeletesPctAllowed	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
eligible	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
Collection	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
merging	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getMergingSegments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
infos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
double	TokenNamedouble
pctDeletes	TokenNameIdentifier
=	TokenNameEQUAL
100.	TokenNameDoubleLiteral
*	TokenNameMULTIPLY
(	TokenNameLPAREN
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
/	TokenNameDIVIDE
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pctDeletes	TokenNameIdentifier
>	TokenNameGREATER
forceMergeDeletesPctAllowed	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
merging	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
eligible	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
Collections	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
eligible	TokenNameIdentifier
,	TokenNameCOMMA
segmentByteSizeDescending	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"eligible="	TokenNameStringLiteral
+	TokenNamePLUS
eligible	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
start	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
start	TokenNameIdentifier
<	TokenNameLESS
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
end	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
+	TokenNamePLUS
maxMergeAtOnceExplicit	TokenNameIdentifier
,	TokenNameCOMMA
eligible	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
spec	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MergeSpecification	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
OneMerge	TokenNameIdentifier
(	TokenNameLPAREN
eligible	TokenNameIdentifier
.	TokenNameDOT
subList	TokenNameIdentifier
(	TokenNameLPAREN
start	TokenNameIdentifier
,	TokenNameCOMMA
end	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"add merge="	TokenNameStringLiteral
+	TokenNamePLUS
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
spec	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
start	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
useCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
,	TokenNameCOMMA
SegmentInfo	TokenNameIdentifier
mergedInfo	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
boolean	TokenNameboolean
doCFS	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
doCFS	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
noCFSRatio	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
doCFS	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
long	TokenNamelong
totalSize	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
infos	TokenNameIdentifier
)	TokenNameRPAREN
totalSize	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
doCFS	TokenNameIdentifier
=	TokenNameEQUAL
size	TokenNameIdentifier
(	TokenNameLPAREN
mergedInfo	TokenNameIdentifier
)	TokenNameRPAREN
<=	TokenNameLESS_EQUAL
noCFSRatio	TokenNameIdentifier
*	TokenNameMULTIPLY
totalSize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
doCFS	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
isMerged	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
IndexWriter	TokenNameIdentifier
w	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
w	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
hasDeletions	TokenNameIdentifier
=	TokenNameEQUAL
w	TokenNameIdentifier
.	TokenNameDOT
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
!	TokenNameNOT
hasDeletions	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
info	TokenNameIdentifier
.	TokenNameDOT
hasSeparateNorms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
info	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
w	TokenNameIdentifier
.	TokenNameDOT
getDirectory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
useCompoundFile	TokenNameIdentifier
||	TokenNameOR_OR
noCFSRatio	TokenNameIdentifier
<	TokenNameLESS
1.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
long	TokenNamelong
size	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
byteSize	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
delCount	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
double	TokenNamedouble
delRatio	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
0.0f	TokenNameFloatingPointLiteral
:	TokenNameCOLON
(	TokenNameLPAREN
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
delCount	TokenNameIdentifier
/	TokenNameDIVIDE
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
delRatio	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
1.0	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
(	TokenNameLPAREN
byteSize	TokenNameIdentifier
*	TokenNameMULTIPLY
(	TokenNameLPAREN
1.0	TokenNameDoubleLiteral
-	TokenNameMINUS
delRatio	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
long	TokenNamelong
floorSize	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
bytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
floorSegmentBytes	TokenNameIdentifier
,	TokenNameCOMMA
bytes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
IndexWriter	TokenNameIdentifier
w	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
w	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
w	TokenNameIdentifier
.	TokenNameDOT
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
message	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
message	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
message	TokenNameIdentifier
(	TokenNameLPAREN
"TMP: "	TokenNameStringLiteral
+	TokenNamePLUS
message	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
StringBuilder	TokenNameIdentifier
sb	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuilder	TokenNameIdentifier
(	TokenNameLPAREN
"["	TokenNameStringLiteral
+	TokenNamePLUS
getClass	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getSimpleName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
": "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"maxMergeAtOnce="	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
maxMergeAtOnce	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
", "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"maxMergeAtOnceExplicit="	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
maxMergeAtOnceExplicit	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
", "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"maxMergedSegmentMB="	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
maxMergedSegmentBytes	TokenNameIdentifier
/	TokenNameDIVIDE
1024	TokenNameIntegerLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
", "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"floorSegmentMB="	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
floorSegmentBytes	TokenNameIdentifier
/	TokenNameDIVIDE
1024	TokenNameIntegerLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
", "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"forceMergeDeletesPctAllowed="	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
forceMergeDeletesPctAllowed	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
", "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"segmentsPerTier="	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
segsPerTier	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
", "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"useCompoundFile="	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
", "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sb	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"noCFSRatio="	TokenNameStringLiteral
)	TokenNameRPAREN
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
noCFSRatio	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
sb	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
