package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Arrays	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
Serializable	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
DocIdSet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
DocIdSetIterator	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
OpenBitSet	TokenNameIdentifier
extends	TokenNameextends
DocIdSet	TokenNameIdentifier
implements	TokenNameimplements
Cloneable	TokenNameIdentifier
,	TokenNameCOMMA
Serializable	TokenNameIdentifier
,	TokenNameCOMMA
Bits	TokenNameIdentifier
{	TokenNameLBRACE
protected	TokenNameprotected
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
protected	TokenNameprotected
int	TokenNameint
wlen	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
OpenBitSet	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
numBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
numBits	TokenNameIdentifier
=	TokenNameEQUAL
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
long	TokenNamelong
[	TokenNameLBRACKET
bits2words	TokenNameIdentifier
(	TokenNameLPAREN
numBits	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
wlen	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
OpenBitSet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
64	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
OpenBitSet	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bits	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
numWords	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
bits	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
=	TokenNameEQUAL
numWords	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
numBits	TokenNameIdentifier
=	TokenNameEQUAL
wlen	TokenNameIdentifier
*	TokenNameMULTIPLY
64	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
DocIdSetIterator	TokenNameIdentifier
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
OpenBitSetIterator	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
isCacheable	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
capacity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
capacity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
cardinality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getBits	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setBits	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
bits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
bits	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getNumWords	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
wlen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setNumWords	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
nWords	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
=	TokenNameEQUAL
nWords	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
get	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
fastGet	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
get	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
fastGet	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getBit	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
bit	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&	TokenNameAND
0x01	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
set	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
expandingWordNum	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
fastSet	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
fastSet	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
set	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
startIndex	TokenNameIdentifier
,	TokenNameCOMMA
long	TokenNamelong
endIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
startIndex	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
startWord	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
startIndex	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
endWord	TokenNameIdentifier
=	TokenNameEQUAL
expandingWordNum	TokenNameIdentifier
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
startmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
startIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
endmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
-	TokenNameMINUS
endIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startWord	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
endWord	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
(	TokenNameLPAREN
startmask	TokenNameIdentifier
&	TokenNameAND
endmask	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
startmask	TokenNameIdentifier
;	TokenNameSEMICOLON
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
startWord	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
endWord	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1L	TokenNameLongLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
endWord	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
endmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
int	TokenNameint
expandingWordNum	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
wordNum	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureCapacity	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
wlen	TokenNameIdentifier
=	TokenNameEQUAL
wordNum	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
(	TokenNameLPAREN
numBits	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
numBits	TokenNameIdentifier
,	TokenNameCOMMA
index	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
wordNum	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
fastClear	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x03f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
fastClear	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
wordNum	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
wlen	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
startIndex	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
endIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
startIndex	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
startWord	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
startIndex	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startWord	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
wlen	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
endWord	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
startmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
startIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
endmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
-	TokenNameMINUS
endIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
startmask	TokenNameIdentifier
=	TokenNameEQUAL
~	TokenNameTWIDDLE
startmask	TokenNameIdentifier
;	TokenNameSEMICOLON
endmask	TokenNameIdentifier
=	TokenNameEQUAL
~	TokenNameTWIDDLE
endmask	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startWord	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
endWord	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
(	TokenNameLPAREN
startmask	TokenNameIdentifier
|	TokenNameOR
endmask	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
startmask	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
middle	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
wlen	TokenNameIdentifier
,	TokenNameCOMMA
endWord	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
startWord	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
middle	TokenNameIdentifier
,	TokenNameCOMMA
0L	TokenNameLongLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
endWord	TokenNameIdentifier
<	TokenNameLESS
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
endWord	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
endmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
startIndex	TokenNameIdentifier
,	TokenNameCOMMA
long	TokenNamelong
endIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
startIndex	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
startWord	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
startIndex	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startWord	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
wlen	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
endWord	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
startmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
startIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
endmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
-	TokenNameMINUS
endIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
startmask	TokenNameIdentifier
=	TokenNameEQUAL
~	TokenNameTWIDDLE
startmask	TokenNameIdentifier
;	TokenNameSEMICOLON
endmask	TokenNameIdentifier
=	TokenNameEQUAL
~	TokenNameTWIDDLE
endmask	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startWord	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
endWord	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
(	TokenNameLPAREN
startmask	TokenNameIdentifier
|	TokenNameOR
endmask	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
startmask	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
middle	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
wlen	TokenNameIdentifier
,	TokenNameCOMMA
endWord	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
startWord	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
middle	TokenNameIdentifier
,	TokenNameCOMMA
0L	TokenNameLongLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
endWord	TokenNameIdentifier
<	TokenNameLESS
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
endWord	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
endmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getAndSet	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
val	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
val	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
getAndSet	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
val	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
val	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
fastFlip	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
fastFlip	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
flip	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
expandingWordNum	TokenNameIdentifier
(	TokenNameLPAREN
index	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
flipAndGet	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
flipAndGet	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
index	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
index	TokenNameIdentifier
<	TokenNameLESS
numBits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
wordNum	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
bit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
bitmask	TokenNameIdentifier
=	TokenNameEQUAL
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
bit	TokenNameIdentifier
;	TokenNameSEMICOLON
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
bitmask	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
wordNum	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
bitmask	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
flip	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
startIndex	TokenNameIdentifier
,	TokenNameCOMMA
long	TokenNamelong
endIndex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
startIndex	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
int	TokenNameint
startWord	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
startIndex	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
endWord	TokenNameIdentifier
=	TokenNameEQUAL
expandingWordNum	TokenNameIdentifier
(	TokenNameLPAREN
endIndex	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
startmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
<<	TokenNameLEFT_SHIFT
startIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
endmask	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1L	TokenNameLongLiteral
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
-	TokenNameMINUS
endIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
startWord	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
endWord	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
(	TokenNameLPAREN
startmask	TokenNameIdentifier
&	TokenNameAND
endmask	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
startWord	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
startmask	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
startWord	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
endWord	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
~	TokenNameTWIDDLE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bits	TokenNameIdentifier
[	TokenNameLBRACKET
endWord	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
endmask	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
cardinality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_array	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
long	TokenNamelong
intersectionCount	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
OpenBitSet	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_intersect	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
long	TokenNamelong
unionCount	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
OpenBitSet	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
tot	TokenNameIdentifier
=	TokenNameEQUAL
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_union	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
<	TokenNameLESS
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tot	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_array	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
-	TokenNameMINUS
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
>	TokenNameGREATER
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tot	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_array	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
-	TokenNameMINUS
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
tot	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
long	TokenNamelong
andNotCount	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
OpenBitSet	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
tot	TokenNameIdentifier
=	TokenNameEQUAL
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_andnot	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
>	TokenNameGREATER
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tot	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_array	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
-	TokenNameMINUS
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
tot	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
long	TokenNamelong
xorCount	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
OpenBitSet	TokenNameIdentifier
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
tot	TokenNameIdentifier
=	TokenNameEQUAL
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_xor	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
<	TokenNameLESS
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tot	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_array	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
-	TokenNameMINUS
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
>	TokenNameGREATER
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tot	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
BitUtil	TokenNameIdentifier
.	TokenNameDOT
pop_array	TokenNameIdentifier
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
-	TokenNameMINUS
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
tot	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
nextSetBit	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
wlen	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
subIndex	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
>>	TokenNameRIGHT_SHIFT
subIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
i	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
subIndex	TokenNameIdentifier
+	TokenNamePLUS
BitUtil	TokenNameIdentifier
.	TokenNameDOT
ntz	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
<	TokenNameLESS
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
i	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
BitUtil	TokenNameIdentifier
.	TokenNameDOT
ntz	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
nextSetBit	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
wlen	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
subIndex	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
subIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
subIndex	TokenNameIdentifier
+	TokenNamePLUS
BitUtil	TokenNameIdentifier
.	TokenNameDOT
ntz	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
<	TokenNameLESS
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
BitUtil	TokenNameIdentifier
.	TokenNameDOT
ntz	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
prevSetBit	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
subIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
word	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
i	TokenNameIdentifier
=	TokenNameEQUAL
wlen	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
subIndex	TokenNameIdentifier
=	TokenNameEQUAL
63	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
subIndex	TokenNameIdentifier
=	TokenNameEQUAL
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
word	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
<<	TokenNameLEFT_SHIFT
(	TokenNameLPAREN
63	TokenNameIntegerLiteral
-	TokenNameMINUS
subIndex	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
i	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
subIndex	TokenNameIdentifier
-	TokenNameMINUS
Long	TokenNameIdentifier
.	TokenNameDOT
numberOfLeadingZeros	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
i	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
63	TokenNameIntegerLiteral
-	TokenNameMINUS
Long	TokenNameIdentifier
.	TokenNameDOT
numberOfLeadingZeros	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
prevSetBit	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
index	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
index	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
subIndex	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
word	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
i	TokenNameIdentifier
=	TokenNameEQUAL
wlen	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
subIndex	TokenNameIdentifier
=	TokenNameEQUAL
63	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
subIndex	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
index	TokenNameIdentifier
&	TokenNameAND
0x3f	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
word	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
<<	TokenNameLEFT_SHIFT
(	TokenNameLPAREN
63	TokenNameIntegerLiteral
-	TokenNameMINUS
subIndex	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
subIndex	TokenNameIdentifier
-	TokenNameMINUS
Long	TokenNameIdentifier
.	TokenNameDOT
numberOfLeadingZeros	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
word	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
word	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
63	TokenNameIntegerLiteral
-	TokenNameMINUS
Long	TokenNameIdentifier
.	TokenNameDOT
numberOfLeadingZeros	TokenNameIdentifier
(	TokenNameLPAREN
word	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
Object	TokenNameIdentifier
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
OpenBitSet	TokenNameIdentifier
obs	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
)	TokenNameRPAREN
super	TokenNamesuper
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
obs	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
=	TokenNameEQUAL
obs	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
obs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
CloneNotSupportedException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
intersect	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
newLen	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
thisArr	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
otherArr	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
newLen	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
pos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
thisArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
otherArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
>	TokenNameGREATER
newLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Arrays	TokenNameIdentifier
.	TokenNameDOT
fill	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
newLen	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
=	TokenNameEQUAL
newLen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
union	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
newLen	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
wlen	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ensureCapacityWords	TokenNameIdentifier
(	TokenNameLPAREN
newLen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
(	TokenNameLPAREN
numBits	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
numBits	TokenNameIdentifier
,	TokenNameCOMMA
numBits	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
thisArr	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
otherArr	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
wlen	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
pos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
thisArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
|=	TokenNameOR_EQUAL
otherArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
<	TokenNameLESS
newLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
otherArr	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
thisArr	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
newLen	TokenNameIdentifier
-	TokenNameMINUS
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
=	TokenNameEQUAL
newLen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
remove	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
wlen	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
thisArr	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
otherArr	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
idx	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
thisArr	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
&=	TokenNameAND_EQUAL
~	TokenNameTWIDDLE
otherArr	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
xor	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
newLen	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
wlen	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ensureCapacityWords	TokenNameIdentifier
(	TokenNameLPAREN
newLen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
(	TokenNameLPAREN
numBits	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
.	TokenNameDOT
numBits	TokenNameIdentifier
,	TokenNameCOMMA
numBits	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
thisArr	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
otherArr	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
wlen	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
pos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
thisArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
^=	TokenNameXOR_EQUAL
otherArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
<	TokenNameLESS
newLen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
otherArr	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
thisArr	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
newLen	TokenNameIdentifier
-	TokenNameMINUS
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
=	TokenNameEQUAL
newLen	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
and	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
intersect	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
or	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
union	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
andNot	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
remove	TokenNameIdentifier
(	TokenNameLPAREN
other	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
intersects	TokenNameIdentifier
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
other	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
,	TokenNameCOMMA
other	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
thisArr	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
[	TokenNameLBRACKET
]	TokenNameRBRACKET
otherArr	TokenNameIdentifier
=	TokenNameEQUAL
other	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
--	TokenNameMINUS_MINUS
pos	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
thisArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
otherArr	TokenNameIdentifier
[	TokenNameLBRACKET
pos	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
ensureCapacityWords	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
numWords	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
numWords	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
=	TokenNameEQUAL
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
grow	TokenNameIdentifier
(	TokenNameLPAREN
bits	TokenNameIdentifier
,	TokenNameCOMMA
numWords	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
ensureCapacity	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
numBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureCapacityWords	TokenNameIdentifier
(	TokenNameLPAREN
bits2words	TokenNameIdentifier
(	TokenNameLPAREN
numBits	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
trimTrailingZeros	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
wlen	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
idx	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
bits	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
idx	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
wlen	TokenNameIdentifier
=	TokenNameEQUAL
idx	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
int	TokenNameint
bits2words	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
numBits	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
numBits	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
equals	TokenNameIdentifier
(	TokenNameLPAREN
Object	TokenNameIdentifier
o	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
==	TokenNameEQUAL_EQUAL
o	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
o	TokenNameIdentifier
instanceof	TokenNameinstanceof
OpenBitSet	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
OpenBitSet	TokenNameIdentifier
a	TokenNameIdentifier
;	TokenNameSEMICOLON
OpenBitSet	TokenNameIdentifier
b	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
OpenBitSet	TokenNameIdentifier
)	TokenNameRPAREN
o	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
>	TokenNameGREATER
this	TokenNamethis
.	TokenNameDOT
wlen	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
a	TokenNameIdentifier
=	TokenNameEQUAL
b	TokenNameIdentifier
;	TokenNameSEMICOLON
b	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
a	TokenNameIdentifier
=	TokenNameEQUAL
this	TokenNamethis
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
a	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
b	TokenNameIdentifier
.	TokenNameDOT
wlen	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
a	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
b	TokenNameIdentifier
.	TokenNameDOT
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
hashCode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
long	TokenNamelong
h	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
--	TokenNameMINUS_MINUS
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
)	TokenNameRPAREN
{	TokenNameLBRACE
h	TokenNameIdentifier
^=	TokenNameXOR_EQUAL
bits	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
h	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
h	TokenNameIdentifier
<<	TokenNameLEFT_SHIFT
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
|	TokenNameOR
(	TokenNameLPAREN
h	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
63	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
h	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
32	TokenNameIntegerLiteral
)	TokenNameRPAREN
^	TokenNameXOR
h	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
0x98761234	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
