package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
Closeable	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
PrintStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collection	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collections	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Comparator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Date	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashMap	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashSet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
LinkedList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Map	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Set	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
concurrent	TokenNameIdentifier
.	TokenNameDOT
atomic	TokenNameIdentifier
.	TokenNameDOT
AtomicInteger	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
Analyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
LimitTokenCountAnalyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
.	TokenNameDOT
Document	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
OpenMode	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
Query	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
Similarity	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
AlreadyClosedException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
BufferedIndexInput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
Directory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
Lock	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
LockObtainFailedException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Constants	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
StringHelper	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ThreadInterruptedException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
TwoPhaseCommit	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Version	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
IndexWriter	TokenNameIdentifier
implements	TokenNameimplements
Closeable	TokenNameIdentifier
,	TokenNameCOMMA
TwoPhaseCommit	TokenNameIdentifier
{	TokenNameLBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
static	TokenNamestatic
long	TokenNamelong
WRITE_LOCK_TIMEOUT	TokenNameIdentifier
=	TokenNameEQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
WRITE_LOCK_TIMEOUT	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
writeLockTimeout	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
String	TokenNameIdentifier
WRITE_LOCK_NAME	TokenNameIdentifier
=	TokenNameEQUAL
"write.lock"	TokenNameStringLiteral
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
DISABLE_AUTO_FLUSH	TokenNameIdentifier
=	TokenNameEQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DISABLE_AUTO_FLUSH	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
DEFAULT_MAX_BUFFERED_DOCS	TokenNameIdentifier
=	TokenNameEQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_MAX_BUFFERED_DOCS	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
final	TokenNamefinal
static	TokenNamestatic
double	TokenNamedouble
DEFAULT_RAM_BUFFER_SIZE_MB	TokenNameIdentifier
=	TokenNameEQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_RAM_BUFFER_SIZE_MB	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
DEFAULT_MAX_BUFFERED_DELETE_TERMS	TokenNameIdentifier
=	TokenNameEQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_MAX_BUFFERED_DELETE_TERMS	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
DEFAULT_MAX_FIELD_LENGTH	TokenNameIdentifier
=	TokenNameEQUAL
MaxFieldLength	TokenNameIdentifier
.	TokenNameDOT
UNLIMITED	TokenNameIdentifier
.	TokenNameDOT
getLimit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
DEFAULT_TERM_INDEX_INTERVAL	TokenNameIdentifier
=	TokenNameEQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_TERM_INDEX_INTERVAL	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
MAX_TERM_LENGTH	TokenNameIdentifier
=	TokenNameEQUAL
DocumentsWriter	TokenNameIdentifier
.	TokenNameDOT
MAX_TERM_LENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
MERGE_READ_BUFFER_SIZE	TokenNameIdentifier
=	TokenNameEQUAL
4096	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
AtomicInteger	TokenNameIdentifier
MESSAGE_ID	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicInteger	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
messageID	TokenNameIdentifier
=	TokenNameEQUAL
MESSAGE_ID	TokenNameIdentifier
.	TokenNameDOT
getAndIncrement	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
volatile	TokenNamevolatile
private	TokenNameprivate
boolean	TokenNameboolean
hitOOM	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
Directory	TokenNameIdentifier
directory	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
Analyzer	TokenNameIdentifier
analyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Similarity	TokenNameIdentifier
similarity	TokenNameIdentifier
=	TokenNameEQUAL
Similarity	TokenNameIdentifier
.	TokenNameDOT
getDefault	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
long	TokenNamelong
changeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
lastCommitChangeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
rollbackSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
volatile	TokenNamevolatile
SegmentInfos	TokenNameIdentifier
pendingCommit	TokenNameIdentifier
;	TokenNameSEMICOLON
volatile	TokenNamevolatile
long	TokenNamelong
pendingCommitChangeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
SegmentInfos	TokenNameIdentifier
segmentInfos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
Collection	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
filesToCommit	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
DocumentsWriter	TokenNameIdentifier
docWriter	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
IndexFileDeleter	TokenNameIdentifier
deleter	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Map	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
>	TokenNameGREATER
segmentsToMerge	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
mergeMaxNumSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Lock	TokenNameIdentifier
writeLock	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
boolean	TokenNameboolean
closed	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
boolean	TokenNameboolean
closing	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
HashSet	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
mergingSegments	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
MergePolicy	TokenNameIdentifier
mergePolicy	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
MergeScheduler	TokenNameIdentifier
mergeScheduler	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
LinkedList	TokenNameIdentifier
<	TokenNameLESS
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
>	TokenNameGREATER
pendingMerges	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
LinkedList	TokenNameIdentifier
<	TokenNameLESS
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
Set	TokenNameIdentifier
<	TokenNameLESS
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
>	TokenNameGREATER
runningMerges	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
List	TokenNameIdentifier
<	TokenNameLESS
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
>	TokenNameGREATER
mergeExceptions	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
long	TokenNamelong
mergeGen	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
stopMerges	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
AtomicInteger	TokenNameIdentifier
flushCount	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicInteger	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
AtomicInteger	TokenNameIdentifier
flushDeletesCount	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicInteger	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
ReaderPool	TokenNameIdentifier
readerPool	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ReaderPool	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
BufferedDeletesStream	TokenNameIdentifier
bufferedDeletesStream	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
volatile	TokenNamevolatile
boolean	TokenNameboolean
poolReaders	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
IndexWriterConfig	TokenNameIdentifier
config	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
PayloadProcessorProvider	TokenNameIdentifier
payloadProcessorProvider	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
anyNonBulkMerges	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
IndexReader	TokenNameIdentifier
getReader	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
getReader	TokenNameIdentifier
(	TokenNameLPAREN
config	TokenNameIdentifier
.	TokenNameDOT
getReaderTermsIndexDivisor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
IndexReader	TokenNameIdentifier
getReader	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
getReader	TokenNameIdentifier
(	TokenNameLPAREN
config	TokenNameIdentifier
.	TokenNameDOT
getReaderTermsIndexDivisor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
IndexReader	TokenNameIdentifier
getReader	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
termInfosIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
getReader	TokenNameIdentifier
(	TokenNameLPAREN
termInfosIndexDivisor	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
IndexReader	TokenNameIdentifier
getReader	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
termInfosIndexDivisor	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
tStart	TokenNameIdentifier
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush at getReader"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
poolReaders	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
IndexReader	TokenNameIdentifier
r	TokenNameIdentifier
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
flush	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
r	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ReadOnlyDirectoryReader	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
,	TokenNameCOMMA
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
termInfosIndexDivisor	TokenNameIdentifier
,	TokenNameCOMMA
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"return reader version="	TokenNameStringLiteral
+	TokenNamePLUS
r	TokenNameIdentifier
.	TokenNameDOT
getVersion	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" reader="	TokenNameStringLiteral
+	TokenNamePLUS
r	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
maybeMerge	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"getReader took "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
tStart	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" msec"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
r	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
class	TokenNameclass
ReaderPool	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
Map	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
>	TokenNameGREATER
readerMap	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
infos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infos	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Map	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
>	TokenNameGREATER
ent	TokenNameIdentifier
:	TokenNameCOLON
readerMap	TokenNameIdentifier
.	TokenNameDOT
entrySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ent	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
hasChanges	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
infos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentReader	TokenNameIdentifier
r	TokenNameIdentifier
=	TokenNameEQUAL
readerMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
r	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
r	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
infoIsLive	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
idx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
:	TokenNameCOLON
"info="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
+	TokenNamePLUS
" isn't in pool"	TokenNameStringLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
idx	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
info	TokenNameIdentifier
:	TokenNameCOLON
"info="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
+	TokenNamePLUS
" doesn't match live info in segmentInfos"	TokenNameStringLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
SegmentInfo	TokenNameIdentifier
mapToLive	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
indexOf	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
idx	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
info	TokenNameIdentifier
=	TokenNameEQUAL
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
idx	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
info	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
release	TokenNameIdentifier
(	TokenNameLPAREN
SegmentReader	TokenNameIdentifier
sr	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
release	TokenNameIdentifier
(	TokenNameLPAREN
sr	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
release	TokenNameIdentifier
(	TokenNameLPAREN
SegmentReader	TokenNameIdentifier
sr	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
drop	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
boolean	TokenNameboolean
pooled	TokenNameIdentifier
=	TokenNameEQUAL
readerMap	TokenNameIdentifier
.	TokenNameDOT
containsKey	TokenNameIdentifier
(	TokenNameLPAREN
sr	TokenNameIdentifier
.	TokenNameDOT
getSegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
!	TokenNameNOT
pooled	TokenNameIdentifier
||	TokenNameOR_OR
readerMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
sr	TokenNameIdentifier
.	TokenNameDOT
getSegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
sr	TokenNameIdentifier
;	TokenNameSEMICOLON
sr	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pooled	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
drop	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
!	TokenNameNOT
poolReaders	TokenNameIdentifier
&&	TokenNameAND_AND
sr	TokenNameIdentifier
.	TokenNameDOT
getRefCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
!	TokenNameNOT
sr	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
||	TokenNameOR_OR
Thread	TokenNameIdentifier
.	TokenNameDOT
holdsLock	TokenNameIdentifier
(	TokenNameLPAREN
IndexWriter	TokenNameIdentifier
.	TokenNameDOT
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sr	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
&=	TokenNameAND_EQUAL
!	TokenNameNOT
drop	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
hasChanges	TokenNameIdentifier
=	TokenNameEQUAL
sr	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
;	TokenNameSEMICOLON
sr	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
readerMap	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
sr	TokenNameIdentifier
.	TokenNameDOT
getSegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
hasChanges	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
drop	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
infos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
infos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
drop	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
drop	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
SegmentReader	TokenNameIdentifier
sr	TokenNameIdentifier
=	TokenNameEQUAL
readerMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
sr	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
sr	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
readerMap	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sr	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
dropAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
:	TokenNameCOLON
readerMap	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
reader	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
reader	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
readerMap	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
Thread	TokenNameIdentifier
.	TokenNameDOT
holdsLock	TokenNameIdentifier
(	TokenNameLPAREN
IndexWriter	TokenNameIdentifier
.	TokenNameDOT
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Map	TokenNameIdentifier
.	TokenNameDOT
Entry	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
>	TokenNameGREATER
ent	TokenNameIdentifier
:	TokenNameCOLON
readerMap	TokenNameIdentifier
.	TokenNameDOT
entrySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
SegmentReader	TokenNameIdentifier
sr	TokenNameIdentifier
=	TokenNameEQUAL
ent	TokenNameIdentifier
.	TokenNameDOT
getValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
sr	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
infoIsLive	TokenNameIdentifier
(	TokenNameLPAREN
sr	TokenNameIdentifier
.	TokenNameDOT
getSegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sr	TokenNameIdentifier
.	TokenNameDOT
doCommit	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
sr	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
readerMap	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
commit	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
Thread	TokenNameIdentifier
.	TokenNameDOT
holdsLock	TokenNameIdentifier
(	TokenNameLPAREN
IndexWriter	TokenNameIdentifier
.	TokenNameDOT
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
infos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentReader	TokenNameIdentifier
sr	TokenNameIdentifier
=	TokenNameEQUAL
readerMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
sr	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
sr	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
infoIsLive	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sr	TokenNameIdentifier
.	TokenNameDOT
doCommit	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
SegmentReader	TokenNameIdentifier
getReadOnlyClone	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
doOpenStores	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
termInfosIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
SegmentReader	TokenNameIdentifier
sr	TokenNameIdentifier
=	TokenNameEQUAL
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
doOpenStores	TokenNameIdentifier
,	TokenNameCOMMA
BufferedIndexInput	TokenNameIdentifier
.	TokenNameDOT
BUFFER_SIZE	TokenNameIdentifier
,	TokenNameCOMMA
termInfosIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
SegmentReader	TokenNameIdentifier
)	TokenNameRPAREN
sr	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
sr	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
SegmentReader	TokenNameIdentifier
get	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
doOpenStores	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
doOpenStores	TokenNameIdentifier
,	TokenNameCOMMA
BufferedIndexInput	TokenNameIdentifier
.	TokenNameDOT
BUFFER_SIZE	TokenNameIdentifier
,	TokenNameCOMMA
config	TokenNameIdentifier
.	TokenNameDOT
getReaderTermsIndexDivisor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
SegmentReader	TokenNameIdentifier
get	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
doOpenStores	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
readBufferSize	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
termsIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
poolReaders	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
readBufferSize	TokenNameIdentifier
=	TokenNameEQUAL
BufferedIndexInput	TokenNameIdentifier
.	TokenNameDOT
BUFFER_SIZE	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
SegmentReader	TokenNameIdentifier
sr	TokenNameIdentifier
=	TokenNameEQUAL
readerMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
sr	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
sr	TokenNameIdentifier
=	TokenNameEQUAL
SegmentReader	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
info	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
,	TokenNameCOMMA
info	TokenNameIdentifier
,	TokenNameCOMMA
readBufferSize	TokenNameIdentifier
,	TokenNameCOMMA
doOpenStores	TokenNameIdentifier
,	TokenNameCOMMA
termsIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
directory	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
readerMap	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
sr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
doOpenStores	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
sr	TokenNameIdentifier
.	TokenNameDOT
openDocStores	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
termsIndexDivisor	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
sr	TokenNameIdentifier
.	TokenNameDOT
termsIndexLoaded	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
sr	TokenNameIdentifier
.	TokenNameDOT
loadTermsIndex	TokenNameIdentifier
(	TokenNameLPAREN
termsIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
directory	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
sr	TokenNameIdentifier
.	TokenNameDOT
incRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
sr	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
SegmentReader	TokenNameIdentifier
getIfExists	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
SegmentReader	TokenNameIdentifier
sr	TokenNameIdentifier
=	TokenNameEQUAL
readerMap	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
sr	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
sr	TokenNameIdentifier
.	TokenNameDOT
incRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
sr	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
=	TokenNameEQUAL
readerPool	TokenNameIdentifier
.	TokenNameDOT
getIfExists	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
reader	TokenNameIdentifier
.	TokenNameDOT
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
info	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
readerPool	TokenNameIdentifier
.	TokenNameDOT
release	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
final	TokenNamefinal
void	TokenNamevoid
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
includePendingClose	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
AlreadyClosedException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
closed	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
includePendingClose	TokenNameIdentifier
&&	TokenNameAND_AND
closing	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AlreadyClosedException	TokenNameIdentifier
(	TokenNameLPAREN
"this IndexWriter is closed"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
final	TokenNamefinal
void	TokenNamevoid
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
AlreadyClosedException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
message	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
message	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
infoStream	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"IW "	TokenNameStringLiteral
+	TokenNamePLUS
messageID	TokenNameIdentifier
+	TokenNamePLUS
" ["	TokenNameStringLiteral
+	TokenNamePLUS
new	TokenNamenew
Date	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"; "	TokenNameStringLiteral
+	TokenNamePLUS
Thread	TokenNameIdentifier
.	TokenNameDOT
currentThread	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"]: "	TokenNameStringLiteral
+	TokenNamePLUS
message	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
LogMergePolicy	TokenNameIdentifier
getLogMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
mergePolicy	TokenNameIdentifier
instanceof	TokenNameinstanceof
LogMergePolicy	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
(	TokenNameLPAREN
LogMergePolicy	TokenNameIdentifier
)	TokenNameRPAREN
mergePolicy	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"this method can only be called when the merge policy is the default LogMergePolicy"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getLogMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
value	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
getLogMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
setUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
value	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
Similarity	TokenNameIdentifier
similarity	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
similarity	TokenNameIdentifier
=	TokenNameEQUAL
similarity	TokenNameIdentifier
;	TokenNameSEMICOLON
docWriter	TokenNameIdentifier
.	TokenNameDOT
setSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
similarity	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
config	TokenNameIdentifier
.	TokenNameDOT
setSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
similarity	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
Similarity	TokenNameIdentifier
getSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
similarity	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setTermIndexInterval	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
interval	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
config	TokenNameIdentifier
.	TokenNameDOT
setTermIndexInterval	TokenNameIdentifier
(	TokenNameLPAREN
interval	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
getTermIndexInterval	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
config	TokenNameIdentifier
.	TokenNameDOT
getTermIndexInterval	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
IndexWriter	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
d	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
create	TokenNameIdentifier
,	TokenNameCOMMA
MaxFieldLength	TokenNameIdentifier
mfl	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
LockObtainFailedException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
d	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
IndexWriterConfig	TokenNameIdentifier
(	TokenNameLPAREN
Version	TokenNameIdentifier
.	TokenNameDOT
LUCENE_31	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
setOpenMode	TokenNameIdentifier
(	TokenNameLPAREN
create	TokenNameIdentifier
?	TokenNameQUESTION
OpenMode	TokenNameIdentifier
.	TokenNameDOT
CREATE	TokenNameIdentifier
:	TokenNameCOLON
OpenMode	TokenNameIdentifier
.	TokenNameDOT
APPEND	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setMaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
mfl	TokenNameIdentifier
.	TokenNameDOT
getLimit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
IndexWriter	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
d	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
MaxFieldLength	TokenNameIdentifier
mfl	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
LockObtainFailedException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
d	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
IndexWriterConfig	TokenNameIdentifier
(	TokenNameLPAREN
Version	TokenNameIdentifier
.	TokenNameDOT
LUCENE_31	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setMaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
mfl	TokenNameIdentifier
.	TokenNameDOT
getLimit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
IndexWriter	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
d	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
IndexDeletionPolicy	TokenNameIdentifier
deletionPolicy	TokenNameIdentifier
,	TokenNameCOMMA
MaxFieldLength	TokenNameIdentifier
mfl	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
LockObtainFailedException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
d	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
IndexWriterConfig	TokenNameIdentifier
(	TokenNameLPAREN
Version	TokenNameIdentifier
.	TokenNameDOT
LUCENE_31	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
setIndexDeletionPolicy	TokenNameIdentifier
(	TokenNameLPAREN
deletionPolicy	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setMaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
mfl	TokenNameIdentifier
.	TokenNameDOT
getLimit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
IndexWriter	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
d	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
create	TokenNameIdentifier
,	TokenNameCOMMA
IndexDeletionPolicy	TokenNameIdentifier
deletionPolicy	TokenNameIdentifier
,	TokenNameCOMMA
MaxFieldLength	TokenNameIdentifier
mfl	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
LockObtainFailedException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
d	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
IndexWriterConfig	TokenNameIdentifier
(	TokenNameLPAREN
Version	TokenNameIdentifier
.	TokenNameDOT
LUCENE_31	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
setOpenMode	TokenNameIdentifier
(	TokenNameLPAREN
create	TokenNameIdentifier
?	TokenNameQUESTION
OpenMode	TokenNameIdentifier
.	TokenNameDOT
CREATE	TokenNameIdentifier
:	TokenNameCOLON
OpenMode	TokenNameIdentifier
.	TokenNameDOT
APPEND	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
setIndexDeletionPolicy	TokenNameIdentifier
(	TokenNameLPAREN
deletionPolicy	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setMaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
mfl	TokenNameIdentifier
.	TokenNameDOT
getLimit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
IndexWriter	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
d	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
a	TokenNameIdentifier
,	TokenNameCOMMA
IndexDeletionPolicy	TokenNameIdentifier
deletionPolicy	TokenNameIdentifier
,	TokenNameCOMMA
MaxFieldLength	TokenNameIdentifier
mfl	TokenNameIdentifier
,	TokenNameCOMMA
IndexCommit	TokenNameIdentifier
commit	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
LockObtainFailedException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
d	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
IndexWriterConfig	TokenNameIdentifier
(	TokenNameLPAREN
Version	TokenNameIdentifier
.	TokenNameDOT
LUCENE_31	TokenNameIdentifier
,	TokenNameCOMMA
a	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
setOpenMode	TokenNameIdentifier
(	TokenNameLPAREN
OpenMode	TokenNameIdentifier
.	TokenNameDOT
APPEND	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
setIndexDeletionPolicy	TokenNameIdentifier
(	TokenNameLPAREN
deletionPolicy	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
setIndexCommit	TokenNameIdentifier
(	TokenNameLPAREN
commit	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setMaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
mfl	TokenNameIdentifier
.	TokenNameDOT
getLimit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
IndexWriter	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
d	TokenNameIdentifier
,	TokenNameCOMMA
IndexWriterConfig	TokenNameIdentifier
conf	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
LockObtainFailedException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
config	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
IndexWriterConfig	TokenNameIdentifier
)	TokenNameRPAREN
conf	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
directory	TokenNameIdentifier
=	TokenNameEQUAL
d	TokenNameIdentifier
;	TokenNameSEMICOLON
analyzer	TokenNameIdentifier
=	TokenNameEQUAL
conf	TokenNameIdentifier
.	TokenNameDOT
getAnalyzer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
infoStream	TokenNameIdentifier
=	TokenNameEQUAL
defaultInfoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
writeLockTimeout	TokenNameIdentifier
=	TokenNameEQUAL
conf	TokenNameIdentifier
.	TokenNameDOT
getWriteLockTimeout	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
similarity	TokenNameIdentifier
=	TokenNameEQUAL
conf	TokenNameIdentifier
.	TokenNameDOT
getSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergePolicy	TokenNameIdentifier
=	TokenNameEQUAL
conf	TokenNameIdentifier
.	TokenNameDOT
getMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
setIndexWriter	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeScheduler	TokenNameIdentifier
=	TokenNameEQUAL
conf	TokenNameIdentifier
.	TokenNameDOT
getMergeScheduler	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bufferedDeletesStream	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BufferedDeletesStream	TokenNameIdentifier
(	TokenNameLPAREN
messageID	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
setInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
poolReaders	TokenNameIdentifier
=	TokenNameEQUAL
conf	TokenNameIdentifier
.	TokenNameDOT
getReaderPooling	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writeLock	TokenNameIdentifier
=	TokenNameEQUAL
directory	TokenNameIdentifier
.	TokenNameDOT
makeLock	TokenNameIdentifier
(	TokenNameLPAREN
WRITE_LOCK_NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
writeLock	TokenNameIdentifier
.	TokenNameDOT
obtain	TokenNameIdentifier
(	TokenNameLPAREN
writeLockTimeout	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
LockObtainFailedException	TokenNameIdentifier
(	TokenNameLPAREN
"Index locked for write: "	TokenNameStringLiteral
+	TokenNamePLUS
writeLock	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
OpenMode	TokenNameIdentifier
mode	TokenNameIdentifier
=	TokenNameEQUAL
conf	TokenNameIdentifier
.	TokenNameDOT
getOpenMode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
create	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
mode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
OpenMode	TokenNameIdentifier
.	TokenNameDOT
CREATE	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
create	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
mode	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
OpenMode	TokenNameIdentifier
.	TokenNameDOT
APPEND	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
create	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
create	TokenNameIdentifier
=	TokenNameEQUAL
!	TokenNameNOT
IndexReader	TokenNameIdentifier
.	TokenNameDOT
indexExists	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
create	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
changeCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
changed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
IndexCommit	TokenNameIdentifier
commit	TokenNameIdentifier
=	TokenNameEQUAL
conf	TokenNameIdentifier
.	TokenNameDOT
getIndexCommit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
commit	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
commit	TokenNameIdentifier
.	TokenNameDOT
getDirectory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
directory	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"IndexCommit's directory doesn't match my directory"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentInfos	TokenNameIdentifier
oldInfos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
oldInfos	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
commit	TokenNameIdentifier
.	TokenNameDOT
getSegmentsFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
replace	TokenNameIdentifier
(	TokenNameLPAREN
oldInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
changeCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
changed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"init: loaded commit ""	TokenNameStringLiteral
+	TokenNamePLUS
commit	TokenNameIdentifier
.	TokenNameDOT
getSegmentsFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"""	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
rollbackSegments	TokenNameIdentifier
=	TokenNameEQUAL
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
createBackupSegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docWriter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
DocumentsWriter	TokenNameIdentifier
(	TokenNameLPAREN
config	TokenNameIdentifier
,	TokenNameCOMMA
directory	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
,	TokenNameCOMMA
getCurrentFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
bufferedDeletesStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docWriter	TokenNameIdentifier
.	TokenNameDOT
setInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docWriter	TokenNameIdentifier
.	TokenNameDOT
setMaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
maxFieldLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
deleter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IndexFileDeleter	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
conf	TokenNameIdentifier
.	TokenNameDOT
getIndexDeletionPolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
infoStream	TokenNameIdentifier
,	TokenNameCOMMA
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
deleter	TokenNameIdentifier
.	TokenNameDOT
startingCommitDeleted	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
changeCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
changed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
messageState	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"init: hit exception on init; releasing write lock"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
writeLock	TokenNameIdentifier
.	TokenNameDOT
release	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
writeLock	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
FieldInfos	TokenNameIdentifier
getFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
Directory	TokenNameIdentifier
cfsDir	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
cfsDir	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CompoundFileReader	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
COMPOUND_FILE_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
cfsDir	TokenNameIdentifier
=	TokenNameEQUAL
directory	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
new	TokenNamenew
FieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
cfsDir	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
FIELD_INFOS_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
cfsDir	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
cfsDir	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
FieldInfos	TokenNameIdentifier
getCurrentFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
FieldInfos	TokenNameIdentifier
fieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
getFormat	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_DIAGNOSTICS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fieldInfos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
FieldInfos	TokenNameIdentifier
segFieldInfos	TokenNameIdentifier
=	TokenNameEQUAL
getFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
fieldCount	TokenNameIdentifier
=	TokenNameEQUAL
segFieldInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
fieldNumber	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
fieldNumber	TokenNameIdentifier
<	TokenNameLESS
fieldCount	TokenNameIdentifier
;	TokenNameSEMICOLON
fieldNumber	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
segFieldInfos	TokenNameIdentifier
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
(	TokenNameLPAREN
fieldNumber	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fieldInfos	TokenNameIdentifier
=	TokenNameEQUAL
getFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
fieldInfos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
fieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
IndexWriterConfig	TokenNameIdentifier
getConfig	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
config	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
mp	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
mp	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
NullPointerException	TokenNameIdentifier
(	TokenNameLPAREN
"MergePolicy must be non-null"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
mergePolicy	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
mp	TokenNameIdentifier
)	TokenNameRPAREN
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergePolicy	TokenNameIdentifier
=	TokenNameEQUAL
mp	TokenNameIdentifier
;	TokenNameSEMICOLON
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
setIndexWriter	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pushMaxBufferedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"setMergePolicy "	TokenNameStringLiteral
+	TokenNamePLUS
mp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
config	TokenNameIdentifier
.	TokenNameDOT
setMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
mp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
MergePolicy	TokenNameIdentifier
getMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
mergePolicy	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
synchronized	TokenNamesynchronized
public	TokenNamepublic
void	TokenNamevoid
setMergeScheduler	TokenNameIdentifier
(	TokenNameLPAREN
MergeScheduler	TokenNameIdentifier
mergeScheduler	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
mergeScheduler	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
NullPointerException	TokenNameIdentifier
(	TokenNameLPAREN
"MergeScheduler must be non-null"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
this	TokenNamethis
.	TokenNameDOT
mergeScheduler	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
mergeScheduler	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
finishMerges	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
mergeScheduler	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
this	TokenNamethis
.	TokenNameDOT
mergeScheduler	TokenNameIdentifier
=	TokenNameEQUAL
mergeScheduler	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"setMergeScheduler "	TokenNameStringLiteral
+	TokenNamePLUS
mergeScheduler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
config	TokenNameIdentifier
.	TokenNameDOT
setMergeScheduler	TokenNameIdentifier
(	TokenNameLPAREN
mergeScheduler	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
MergeScheduler	TokenNameIdentifier
getMergeScheduler	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
mergeScheduler	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setMaxMergeDocs	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxMergeDocs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
getLogMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
setMaxMergeDocs	TokenNameIdentifier
(	TokenNameLPAREN
maxMergeDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
getMaxMergeDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getLogMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getMaxMergeDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setMaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxFieldLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
maxFieldLength	TokenNameIdentifier
=	TokenNameEQUAL
maxFieldLength	TokenNameIdentifier
;	TokenNameSEMICOLON
docWriter	TokenNameIdentifier
.	TokenNameDOT
setMaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
maxFieldLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"setMaxFieldLength "	TokenNameStringLiteral
+	TokenNamePLUS
maxFieldLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
getMaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
maxFieldLength	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setReaderTermsIndexDivisor	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
divisor	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
config	TokenNameIdentifier
.	TokenNameDOT
setReaderTermsIndexDivisor	TokenNameIdentifier
(	TokenNameLPAREN
divisor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"setReaderTermsIndexDivisor "	TokenNameStringLiteral
+	TokenNamePLUS
divisor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
getReaderTermsIndexDivisor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
config	TokenNameIdentifier
.	TokenNameDOT
getReaderTermsIndexDivisor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setMaxBufferedDocs	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxBufferedDocs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pushMaxBufferedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"setMaxBufferedDocs "	TokenNameStringLiteral
+	TokenNamePLUS
maxBufferedDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
config	TokenNameIdentifier
.	TokenNameDOT
setMaxBufferedDocs	TokenNameIdentifier
(	TokenNameLPAREN
maxBufferedDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
pushMaxBufferedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
config	TokenNameIdentifier
.	TokenNameDOT
getMaxBufferedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
DISABLE_AUTO_FLUSH	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
mp	TokenNameIdentifier
=	TokenNameEQUAL
mergePolicy	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
mp	TokenNameIdentifier
instanceof	TokenNameinstanceof
LogDocMergePolicy	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
LogDocMergePolicy	TokenNameIdentifier
lmp	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
LogDocMergePolicy	TokenNameIdentifier
)	TokenNameRPAREN
mp	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
maxBufferedDocs	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getMaxBufferedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lmp	TokenNameIdentifier
.	TokenNameDOT
getMinMergeDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
maxBufferedDocs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"now push maxBufferedDocs "	TokenNameStringLiteral
+	TokenNamePLUS
maxBufferedDocs	TokenNameIdentifier
+	TokenNamePLUS
" to LogDocMergePolicy"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
lmp	TokenNameIdentifier
.	TokenNameDOT
setMinMergeDocs	TokenNameIdentifier
(	TokenNameLPAREN
maxBufferedDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
getMaxBufferedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
config	TokenNameIdentifier
.	TokenNameDOT
getMaxBufferedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
double	TokenNamedouble
mb	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"setRAMBufferSizeMB "	TokenNameStringLiteral
+	TokenNamePLUS
mb	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
config	TokenNameIdentifier
.	TokenNameDOT
setRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
mb	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
double	TokenNamedouble
getRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
config	TokenNameIdentifier
.	TokenNameDOT
getRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setMaxBufferedDeleteTerms	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxBufferedDeleteTerms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"setMaxBufferedDeleteTerms "	TokenNameStringLiteral
+	TokenNamePLUS
maxBufferedDeleteTerms	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
config	TokenNameIdentifier
.	TokenNameDOT
setMaxBufferedDeleteTerms	TokenNameIdentifier
(	TokenNameLPAREN
maxBufferedDeleteTerms	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
getMaxBufferedDeleteTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
config	TokenNameIdentifier
.	TokenNameDOT
getMaxBufferedDeleteTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
mergeFactor	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
getLogMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
setMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
mergeFactor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
getMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getLogMergePolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getMergeFactor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
setDefaultInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
PrintStream	TokenNameIdentifier
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
IndexWriter	TokenNameIdentifier
.	TokenNameDOT
defaultInfoStream	TokenNameIdentifier
=	TokenNameEQUAL
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
PrintStream	TokenNameIdentifier
getDefaultInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
IndexWriter	TokenNameIdentifier
.	TokenNameDOT
defaultInfoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
PrintStream	TokenNameIdentifier
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
infoStream	TokenNameIdentifier
=	TokenNameEQUAL
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
docWriter	TokenNameIdentifier
.	TokenNameDOT
setInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
setInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
setInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
messageState	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
messageState	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
" dir="	TokenNameStringLiteral
+	TokenNamePLUS
directory	TokenNameIdentifier
+	TokenNamePLUS
" "	TokenNameStringLiteral
+	TokenNamePLUS
"index="	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" "	TokenNameStringLiteral
+	TokenNamePLUS
"version="	TokenNameStringLiteral
+	TokenNamePLUS
Constants	TokenNameIdentifier
.	TokenNameDOT
LUCENE_VERSION	TokenNameIdentifier
+	TokenNamePLUS
" "	TokenNameStringLiteral
+	TokenNamePLUS
config	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
PrintStream	TokenNameIdentifier
getInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
verbose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setWriteLockTimeout	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
writeLockTimeout	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
writeLockTimeout	TokenNameIdentifier
=	TokenNameEQUAL
writeLockTimeout	TokenNameIdentifier
;	TokenNameSEMICOLON
config	TokenNameIdentifier
.	TokenNameDOT
setWriteLockTimeout	TokenNameIdentifier
(	TokenNameLPAREN
writeLockTimeout	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
long	TokenNamelong
getWriteLockTimeout	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
writeLockTimeout	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
setDefaultWriteLockTimeout	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
writeLockTimeout	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
setDefaultWriteLockTimeout	TokenNameIdentifier
(	TokenNameLPAREN
writeLockTimeout	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
static	TokenNamestatic
long	TokenNamelong
getDefaultWriteLockTimeout	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
getDefaultWriteLockTimeout	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
close	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
close	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
waitForMerges	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
shouldClose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
rollbackInternal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
closeInternal	TokenNameIdentifier
(	TokenNameLPAREN
waitForMerges	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
private	TokenNameprivate
boolean	TokenNameboolean
shouldClose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
closed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
closing	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
closing	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
doWait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
closeInternal	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
waitForMerges	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pendingCommit	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"cannot close: prepareCommit was already called with no corresponding call to commit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"now flush at close waitForMerges="	TokenNameStringLiteral
+	TokenNamePLUS
waitForMerges	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
docWriter	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flush	TokenNameIdentifier
(	TokenNameLPAREN
waitForMerges	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
waitForMerges	TokenNameIdentifier
)	TokenNameRPAREN
mergeScheduler	TokenNameIdentifier
.	TokenNameDOT
merge	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
finishMerges	TokenNameIdentifier
(	TokenNameLPAREN
waitForMerges	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
stopMerges	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
mergeScheduler	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"now call final commit()"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
commitInternal	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"at close: "	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
readerPool	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docWriter	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
writeLock	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
writeLock	TokenNameIdentifier
.	TokenNameDOT
release	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writeLock	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
closed	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"closeInternal"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
closing	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
closed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception while closing"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
Directory	TokenNameIdentifier
getDirectory	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
directory	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Analyzer	TokenNameIdentifier
getAnalyzer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
analyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
int	TokenNameint
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
count	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docWriter	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
count	TokenNameIdentifier
=	TokenNameEQUAL
docWriter	TokenNameIdentifier
.	TokenNameDOT
getNumDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
count	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
totalDocCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
int	TokenNameint
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
count	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docWriter	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
count	TokenNameIdentifier
=	TokenNameEQUAL
docWriter	TokenNameIdentifier
.	TokenNameDOT
getNumDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
count	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
-	TokenNameMINUS
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
count	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
any	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
docWriter	TokenNameIdentifier
.	TokenNameDOT
anyDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
private	TokenNameprivate
int	TokenNameint
maxFieldLength	TokenNameIdentifier
=	TokenNameEQUAL
DEFAULT_MAX_FIELD_LENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
void	TokenNamevoid
addDocument	TokenNameIdentifier
(	TokenNameLPAREN
Document	TokenNameIdentifier
doc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
addDocument	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
,	TokenNameCOMMA
analyzer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addDocument	TokenNameIdentifier
(	TokenNameLPAREN
Document	TokenNameIdentifier
doc	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
analyzer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
docWriter	TokenNameIdentifier
.	TokenNameDOT
updateDocument	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
,	TokenNameCOMMA
analyzer	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
&&	TokenNameAND_AND
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception adding document"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doFlush	TokenNameIdentifier
)	TokenNameRPAREN
flush	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"addDocument"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addDocuments	TokenNameIdentifier
(	TokenNameLPAREN
Collection	TokenNameIdentifier
<	TokenNameLESS
Document	TokenNameIdentifier
>	TokenNameGREATER
docs	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
addDocuments	TokenNameIdentifier
(	TokenNameLPAREN
docs	TokenNameIdentifier
,	TokenNameCOMMA
analyzer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addDocuments	TokenNameIdentifier
(	TokenNameLPAREN
Collection	TokenNameIdentifier
<	TokenNameLESS
Document	TokenNameIdentifier
>	TokenNameGREATER
docs	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
analyzer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
updateDocuments	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
docs	TokenNameIdentifier
,	TokenNameCOMMA
analyzer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
updateDocuments	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
delTerm	TokenNameIdentifier
,	TokenNameCOMMA
Collection	TokenNameIdentifier
<	TokenNameLESS
Document	TokenNameIdentifier
>	TokenNameGREATER
docs	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
updateDocuments	TokenNameIdentifier
(	TokenNameLPAREN
delTerm	TokenNameIdentifier
,	TokenNameCOMMA
docs	TokenNameIdentifier
,	TokenNameCOMMA
analyzer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
updateDocuments	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
delTerm	TokenNameIdentifier
,	TokenNameCOMMA
Collection	TokenNameIdentifier
<	TokenNameLESS
Document	TokenNameIdentifier
>	TokenNameGREATER
docs	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
analyzer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
docWriter	TokenNameIdentifier
.	TokenNameDOT
updateDocuments	TokenNameIdentifier
(	TokenNameLPAREN
docs	TokenNameIdentifier
,	TokenNameCOMMA
analyzer	TokenNameIdentifier
,	TokenNameCOMMA
delTerm	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
&&	TokenNameAND_AND
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception updating document"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doFlush	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flush	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"updateDocuments"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
deleteDocuments	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
docWriter	TokenNameIdentifier
.	TokenNameDOT
deleteTerm	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
flush	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"deleteDocuments(Term)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
deleteDocuments	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
...	TokenNameELLIPSIS
terms	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
docWriter	TokenNameIdentifier
.	TokenNameDOT
deleteTerms	TokenNameIdentifier
(	TokenNameLPAREN
terms	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
flush	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"deleteDocuments(Term..)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
deleteDocuments	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
query	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
docWriter	TokenNameIdentifier
.	TokenNameDOT
deleteQuery	TokenNameIdentifier
(	TokenNameLPAREN
query	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
flush	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"deleteDocuments(Query)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
deleteDocuments	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
...	TokenNameELLIPSIS
queries	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
docWriter	TokenNameIdentifier
.	TokenNameDOT
deleteQueries	TokenNameIdentifier
(	TokenNameLPAREN
queries	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
flush	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"deleteDocuments(Query..)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
updateDocument	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
,	TokenNameCOMMA
Document	TokenNameIdentifier
doc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
updateDocument	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
,	TokenNameCOMMA
doc	TokenNameIdentifier
,	TokenNameCOMMA
getAnalyzer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
updateDocument	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
,	TokenNameCOMMA
Document	TokenNameIdentifier
doc	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
analyzer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
boolean	TokenNameboolean
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
docWriter	TokenNameIdentifier
.	TokenNameDOT
updateDocument	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
,	TokenNameCOMMA
analyzer	TokenNameIdentifier
,	TokenNameCOMMA
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
&&	TokenNameAND_AND
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception updating document"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doFlush	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flush	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"updateDocument"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
synchronized	TokenNamesynchronized
int	TokenNameint
getSegmentCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
synchronized	TokenNamesynchronized
int	TokenNameint
getNumBufferedDocuments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
docWriter	TokenNameIdentifier
.	TokenNameDOT
getNumDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
synchronized	TokenNamesynchronized
int	TokenNameint
getDocCount	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
i	TokenNameIdentifier
<	TokenNameLESS
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
getFlushCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
flushCount	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
getFlushDeletesCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
flushDeletesCount	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
String	TokenNameIdentifier
newSegmentName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
changeCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
changed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
"_"	TokenNameStringLiteral
+	TokenNamePLUS
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
counter	TokenNameIdentifier
++	TokenNamePLUS_PLUS
,	TokenNameCOMMA
Character	TokenNameIdentifier
.	TokenNameDOT
MAX_RADIX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
PrintStream	TokenNameIdentifier
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
PrintStream	TokenNameIdentifier
defaultInfoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
optimize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
forceMerge	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
optimize	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
forceMerge	TokenNameIdentifier
(	TokenNameLPAREN
maxNumSegments	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
optimize	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
doWait	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
forceMerge	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
doWait	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
forceMerge	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
forceMerge	TokenNameIdentifier
(	TokenNameLPAREN
maxNumSegments	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
forceMerge	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxNumSegments	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
doWait	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
maxNumSegments	TokenNameIdentifier
<	TokenNameLESS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"maxNumSegments must be >= 1; got "	TokenNameStringLiteral
+	TokenNamePLUS
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"forceMerge: index now "	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
message	TokenNameIdentifier
(	TokenNameLPAREN
"now flush at forceMerge"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
flush	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
resetMergeExceptions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segmentsToMerge	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
segmentsToMerge	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
.	TokenNameDOT
TRUE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
mergeMaxNumSegments	TokenNameIdentifier
=	TokenNameEQUAL
maxNumSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
:	TokenNameCOLON
pendingMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
=	TokenNameEQUAL
maxNumSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
segmentsToMerge	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
.	TokenNameDOT
TRUE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
:	TokenNameCOLON
runningMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
=	TokenNameEQUAL
maxNumSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
segmentsToMerge	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
.	TokenNameDOT
TRUE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
maybeMerge	TokenNameIdentifier
(	TokenNameLPAREN
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doWait	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"this writer hit an OutOfMemoryError; cannot complete forceMerge"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
mergeExceptions	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
mergeExceptions	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
size	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
=	TokenNameEQUAL
mergeExceptions	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
IOException	TokenNameIdentifier
err	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"background merge hit exception: "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
getException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
err	TokenNameIdentifier
.	TokenNameDOT
initCause	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
err	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
maxNumSegmentsMergesPending	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
doWait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
maxNumSegmentsMergesPending	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
:	TokenNameCOLON
pendingMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
:	TokenNameCOLON
runningMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
expungeDeletes	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
doWait	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
forceMergeDeletes	TokenNameIdentifier
(	TokenNameLPAREN
doWait	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
forceMergeDeletes	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
doWait	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
flush	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"forceMergeDeletes: index now "	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
spec	TokenNameIdentifier
=	TokenNameEQUAL
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
findForcedDeletesMerges	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
numMerges	TokenNameIdentifier
=	TokenNameEQUAL
spec	TokenNameIdentifier
.	TokenNameDOT
merges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numMerges	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
registerMerge	TokenNameIdentifier
(	TokenNameLPAREN
spec	TokenNameIdentifier
.	TokenNameDOT
merges	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
mergeScheduler	TokenNameIdentifier
.	TokenNameDOT
merge	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
doWait	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
numMerges	TokenNameIdentifier
=	TokenNameEQUAL
spec	TokenNameIdentifier
.	TokenNameDOT
merges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
running	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
running	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"this writer hit an OutOfMemoryError; cannot complete forceMergeDeletes"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
running	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numMerges	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
=	TokenNameEQUAL
spec	TokenNameIdentifier
.	TokenNameDOT
merges	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pendingMerges	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
||	TokenNameOR_OR
runningMerges	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
running	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
getException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
IOException	TokenNameIdentifier
ioe	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IOException	TokenNameIdentifier
(	TokenNameLPAREN
"background merge hit exception: "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ioe	TokenNameIdentifier
.	TokenNameDOT
initCause	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
ioe	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
running	TokenNameIdentifier
)	TokenNameRPAREN
doWait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
expungeDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
forceMergeDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
forceMergeDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
forceMergeDeletes	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
maybeMerge	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
maybeMerge	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
void	TokenNamevoid
maybeMerge	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
updatePendingMerges	TokenNameIdentifier
(	TokenNameLPAREN
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeScheduler	TokenNameIdentifier
.	TokenNameDOT
merge	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
void	TokenNamevoid
updatePendingMerges	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
maxNumSegments	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
maxNumSegments	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
stopMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
MergeSpecification	TokenNameIdentifier
spec	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
maxNumSegments	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
spec	TokenNameIdentifier
=	TokenNameEQUAL
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
findForcedMerges	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
maxNumSegments	TokenNameIdentifier
,	TokenNameCOMMA
Collections	TokenNameIdentifier
.	TokenNameDOT
unmodifiableMap	TokenNameIdentifier
(	TokenNameLPAREN
segmentsToMerge	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
numMerges	TokenNameIdentifier
=	TokenNameEQUAL
spec	TokenNameIdentifier
.	TokenNameDOT
merges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numMerges	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
=	TokenNameEQUAL
spec	TokenNameIdentifier
.	TokenNameDOT
merges	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
=	TokenNameEQUAL
maxNumSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
spec	TokenNameIdentifier
=	TokenNameEQUAL
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
findMerges	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
spec	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
numMerges	TokenNameIdentifier
=	TokenNameEQUAL
spec	TokenNameIdentifier
.	TokenNameDOT
merges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numMerges	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
registerMerge	TokenNameIdentifier
(	TokenNameLPAREN
spec	TokenNameIdentifier
.	TokenNameDOT
merges	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
Collection	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
getMergingSegments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
mergingSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
getNextMerge	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pendingMerges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
else	TokenNameelse
{	TokenNameLBRACE
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
=	TokenNameEQUAL
pendingMerges	TokenNameIdentifier
.	TokenNameDOT
removeFirst	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
runningMerges	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
merge	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
rollback	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
shouldClose	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
rollbackInternal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
rollbackInternal	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"rollback"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
finishMerges	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
stopMerges	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"rollback: done finish merges"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeScheduler	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pendingCommit	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
pendingCommit	TokenNameIdentifier
.	TokenNameDOT
rollbackCommit	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
pendingCommit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pendingCommit	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
rollbackSegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
rollbackSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"rollback: infos="	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
docWriter	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
"rollback before checkpoint"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
refresh	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
readerPool	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
lastCommitChangeCount	TokenNameIdentifier
=	TokenNameEQUAL
changeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"rollbackInternal"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
closing	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception during rollback"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
closeInternal	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
deleteAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
finishMerges	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
docWriter	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
refresh	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
readerPool	TokenNameIdentifier
.	TokenNameDOT
dropAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
changeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
changed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"deleteAll"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception during deleteAll"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
void	TokenNamevoid
finishMerges	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
waitForMerges	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
waitForMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
stopMerges	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
:	TokenNameCOLON
pendingMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"now abort pending merge "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeFinish	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pendingMerges	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
:	TokenNameCOLON
runningMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"now abort running merge "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
runningMerges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"now wait for "	TokenNameStringLiteral
+	TokenNamePLUS
runningMerges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" running merge to abort"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
doWait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
stopMerges	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
mergingSegments	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"all running merges have aborted"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
waitForMerges	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
waitForMerges	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"waitForMerges"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
pendingMerges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
runningMerges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
doWait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
mergingSegments	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"waitForMerges done"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
changeCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
changed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
void	TokenNamevoid
resetMergeExceptions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
mergeExceptions	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeGen	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
noDupDirs	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
...	TokenNameELLIPSIS
dirs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
HashSet	TokenNameIdentifier
<	TokenNameLESS
Directory	TokenNameIdentifier
>	TokenNameGREATER
dups	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
Directory	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
:	TokenNameCOLON
dirs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dups	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
dir	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Directory "	TokenNameStringLiteral
+	TokenNamePLUS
dir	TokenNameIdentifier
+	TokenNamePLUS
" appears more than once"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dir	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
directory	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Cannot add directory to itself"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
dups	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
dir	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
addIndexesNoOptimize	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
...	TokenNameELLIPSIS
dirs	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
addIndexes	TokenNameIdentifier
(	TokenNameLPAREN
dirs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addIndexes	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
...	TokenNameELLIPSIS
dirs	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
noDupDirs	TokenNameIdentifier
(	TokenNameLPAREN
dirs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush at addIndexes(Directory...)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
flush	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
infos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Comparator	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
versionComparator	TokenNameIdentifier
=	TokenNameEQUAL
StringHelper	TokenNameIdentifier
.	TokenNameDOT
getVersionComparator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
:	TokenNameCOLON
dirs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"addIndexes: process directory "	TokenNameStringLiteral
+	TokenNamePLUS
dir	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
SegmentInfos	TokenNameIdentifier
sis	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sis	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
dir	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
Set	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
dsFilesCopied	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
dsNames	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
sis	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
!	TokenNameNOT
infos	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
"dup info dir="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
+	TokenNamePLUS
" name="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
;	TokenNameSEMICOLON
String	TokenNameIdentifier
newSegName	TokenNameIdentifier
=	TokenNameEQUAL
newSegmentName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
dsName	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDocStoreSegment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"addIndexes: process segment origName="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
+	TokenNamePLUS
" newName="	TokenNameStringLiteral
+	TokenNamePLUS
newSegName	TokenNameIdentifier
+	TokenNamePLUS
" dsName="	TokenNameStringLiteral
+	TokenNamePLUS
dsName	TokenNameIdentifier
+	TokenNamePLUS
" info="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
copySegmentAsIs	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
newSegName	TokenNameIdentifier
,	TokenNameCOMMA
dsNames	TokenNameIdentifier
,	TokenNameCOMMA
dsFilesCopied	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
infos	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
addAll	TokenNameIdentifier
(	TokenNameLPAREN
infos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"addIndexes(Directory...)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addIndexes	TokenNameIdentifier
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
...	TokenNameELLIPSIS
readers	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush at addIndexes(IndexReader...)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
flush	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
mergedName	TokenNameIdentifier
=	TokenNameEQUAL
newSegmentName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentMerger	TokenNameIdentifier
merger	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentMerger	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
config	TokenNameIdentifier
.	TokenNameDOT
getTermIndexInterval	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
mergedName	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
payloadProcessorProvider	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
(	TokenNameLPAREN
FieldInfos	TokenNameIdentifier
)	TokenNameRPAREN
docWriter	TokenNameIdentifier
.	TokenNameDOT
getFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
:	TokenNameCOLON
readers	TokenNameIdentifier
)	TokenNameRPAREN
merger	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
docCount	TokenNameIdentifier
=	TokenNameEQUAL
merger	TokenNameIdentifier
.	TokenNameDOT
merge	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
mergedName	TokenNameIdentifier
,	TokenNameCOMMA
docCount	TokenNameIdentifier
,	TokenNameCOMMA
directory	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
merger	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
hasProx	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
merger	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
hasVectors	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setDiagnostics	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
"addIndexes(IndexReader...)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
useCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
stopMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
deleteNewFiles	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
useCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
useCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
merger	TokenNameIdentifier
.	TokenNameDOT
createCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
mergedName	TokenNameIdentifier
+	TokenNamePLUS
".cfs"	TokenNameStringLiteral
,	TokenNameCOMMA
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
deleteNewFiles	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
info	TokenNameIdentifier
.	TokenNameDOT
setUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
stopMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
deleteNewFiles	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"addIndexes(IndexReader...)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
copySegmentAsIs	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
segName	TokenNameIdentifier
,	TokenNameCOMMA
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
dsNames	TokenNameIdentifier
,	TokenNameCOMMA
Set	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
dsFilesCopied	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
String	TokenNameIdentifier
dsName	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDocStoreSegment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
newDsName	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dsName	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dsNames	TokenNameIdentifier
.	TokenNameDOT
containsKey	TokenNameIdentifier
(	TokenNameLPAREN
dsName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
newDsName	TokenNameIdentifier
=	TokenNameEQUAL
dsNames	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
dsName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
dsNames	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
dsName	TokenNameIdentifier
,	TokenNameCOMMA
segName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
newDsName	TokenNameIdentifier
=	TokenNameEQUAL
segName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
newDsName	TokenNameIdentifier
=	TokenNameEQUAL
segName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
String	TokenNameIdentifier
file	TokenNameIdentifier
:	TokenNameCOLON
info	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
String	TokenNameIdentifier
newFileName	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
isDocStoreFile	TokenNameIdentifier
(	TokenNameLPAREN
file	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
newFileName	TokenNameIdentifier
=	TokenNameEQUAL
newDsName	TokenNameIdentifier
+	TokenNamePLUS
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
stripSegmentName	TokenNameIdentifier
(	TokenNameLPAREN
file	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dsFilesCopied	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
newFileName	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
dsFilesCopied	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
newFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
newFileName	TokenNameIdentifier
=	TokenNameEQUAL
segName	TokenNameIdentifier
+	TokenNamePLUS
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
stripSegmentName	TokenNameIdentifier
(	TokenNameLPAREN
file	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
!	TokenNameNOT
directory	TokenNameIdentifier
.	TokenNameDOT
fileExists	TokenNameIdentifier
(	TokenNameLPAREN
newFileName	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
"file ""	TokenNameStringLiteral
+	TokenNamePLUS
newFileName	TokenNameIdentifier
+	TokenNamePLUS
"" already exists"	TokenNameStringLiteral
;	TokenNameSEMICOLON
info	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
.	TokenNameDOT
copy	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
file	TokenNameIdentifier
,	TokenNameCOMMA
newFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
info	TokenNameIdentifier
.	TokenNameDOT
setDocStore	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
getDocStoreOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
newDsName	TokenNameIdentifier
,	TokenNameCOMMA
info	TokenNameIdentifier
.	TokenNameDOT
getDocStoreIsCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
info	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
=	TokenNameEQUAL
directory	TokenNameIdentifier
;	TokenNameSEMICOLON
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
=	TokenNameEQUAL
segName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
doAfterFlush	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
void	TokenNamevoid
doBeforeFlush	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
prepareCommit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
prepareCommit	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
prepareCommit	TokenNameIdentifier
(	TokenNameLPAREN
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"this writer hit an OutOfMemoryError; cannot commit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
pendingCommit	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"prepareCommit was already called with no corresponding call to commit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"prepareCommit: flush"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
anySegmentsFlushed	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
SegmentInfos	TokenNameIdentifier
toCommit	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
anySegmentsFlushed	TokenNameIdentifier
=	TokenNameEQUAL
doFlush	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
readerPool	TokenNameIdentifier
.	TokenNameDOT
commit	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
toCommit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pendingCommitChangeCount	TokenNameIdentifier
=	TokenNameEQUAL
changeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
filesToCommit	TokenNameIdentifier
=	TokenNameEQUAL
toCommit	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
incRef	TokenNameIdentifier
(	TokenNameLPAREN
filesToCommit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
&&	TokenNameAND_AND
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception during prepareCommit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
doAfterFlush	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"prepareCommit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
anySegmentsFlushed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
maybeMerge	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
filesToCommit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
filesToCommit	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
startCommit	TokenNameIdentifier
(	TokenNameLPAREN
toCommit	TokenNameIdentifier
,	TokenNameCOMMA
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
Object	TokenNameIdentifier
commitLock	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Object	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
commit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
commit	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
void	TokenNamevoid
commit	TokenNameIdentifier
(	TokenNameLPAREN
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
commitInternal	TokenNameIdentifier
(	TokenNameLPAREN
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
void	TokenNamevoid
commitInternal	TokenNameIdentifier
(	TokenNameLPAREN
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"commit: start"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
commitLock	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"commit: enter lock"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
pendingCommit	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"commit: now prepare"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
prepareCommit	TokenNameIdentifier
(	TokenNameLPAREN
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"commit: already prepared"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finishCommit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
final	TokenNamefinal
void	TokenNamevoid
finishCommit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pendingCommit	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"commit: pendingCommit != null"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pendingCommit	TokenNameIdentifier
.	TokenNameDOT
finishCommit	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"commit: wrote segments file ""	TokenNameStringLiteral
+	TokenNamePLUS
pendingCommit	TokenNameIdentifier
.	TokenNameDOT
getSegmentsFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"""	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lastCommitChangeCount	TokenNameIdentifier
=	TokenNameEQUAL
pendingCommitChangeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
updateGeneration	TokenNameIdentifier
(	TokenNameLPAREN
pendingCommit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
setUserData	TokenNameIdentifier
(	TokenNameLPAREN
pendingCommit	TokenNameIdentifier
.	TokenNameDOT
getUserData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
rollbackSegments	TokenNameIdentifier
=	TokenNameEQUAL
pendingCommit	TokenNameIdentifier
.	TokenNameDOT
createBackupSegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
pendingCommit	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
filesToCommit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
filesToCommit	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
pendingCommit	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"commit: pendingCommit == null; skip"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"commit: done"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
protected	TokenNameprotected
final	TokenNamefinal
void	TokenNamevoid
flush	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
triggerMerge	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
flushDocStores	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
flushDeletes	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
flush	TokenNameIdentifier
(	TokenNameLPAREN
triggerMerge	TokenNameIdentifier
,	TokenNameCOMMA
flushDeletes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
protected	TokenNameprotected
final	TokenNamefinal
void	TokenNamevoid
flush	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
triggerMerge	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doFlush	TokenNameIdentifier
(	TokenNameLPAREN
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
triggerMerge	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
maybeMerge	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
doFlush	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"this writer hit an OutOfMemoryError; cannot flush"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
doBeforeFlush	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
"startDoFlush"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
flushControl	TokenNameIdentifier
.	TokenNameDOT
setFlushPendingNoWait	TokenNameIdentifier
(	TokenNameLPAREN
"explicit flush"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"  start flush: applyAllDeletes="	TokenNameStringLiteral
+	TokenNamePLUS
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
message	TokenNameIdentifier
(	TokenNameLPAREN
"  index before flush "	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
newSegment	TokenNameIdentifier
=	TokenNameEQUAL
docWriter	TokenNameIdentifier
.	TokenNameDOT
flush	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
,	TokenNameCOMMA
deleter	TokenNameIdentifier
,	TokenNameCOMMA
mergePolicy	TokenNameIdentifier
,	TokenNameCOMMA
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
newSegment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
setDiagnostics	TokenNameIdentifier
(	TokenNameLPAREN
newSegment	TokenNameIdentifier
,	TokenNameCOMMA
"flush"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
newSegment	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
flushControl	TokenNameIdentifier
.	TokenNameDOT
getFlushDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
||	TokenNameOR_OR
(	TokenNameLPAREN
config	TokenNameIdentifier
.	TokenNameDOT
getRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DISABLE_AUTO_FLUSH	TokenNameIdentifier
&&	TokenNameAND_AND
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
(	TokenNameLPAREN
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
config	TokenNameIdentifier
.	TokenNameDOT
getRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
/	TokenNameDIVIDE
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
applyAllDeletes	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"force apply deletes bytesUsed="	TokenNameStringLiteral
+	TokenNamePLUS
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs ramBuffer="	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
config	TokenNameIdentifier
.	TokenNameDOT
getRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
applyAllDeletes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"apply all deletes during flush"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
flushDeletesCount	TokenNameIdentifier
.	TokenNameDOT
incrementAndGet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
BufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
ApplyDeletesResult	TokenNameIdentifier
result	TokenNameIdentifier
=	TokenNameEQUAL
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
applyDeletes	TokenNameIdentifier
(	TokenNameLPAREN
readerPool	TokenNameIdentifier
,	TokenNameCOMMA
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
asList	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
anyDeletes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
keepFullyDeletedSegments	TokenNameIdentifier
&&	TokenNameAND_AND
result	TokenNameIdentifier
.	TokenNameDOT
allDeleted	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"drop 100% deleted segments: "	TokenNameStringLiteral
+	TokenNamePLUS
result	TokenNameIdentifier
.	TokenNameDOT
allDeleted	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
result	TokenNameIdentifier
.	TokenNameDOT
allDeleted	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
mergingSegments	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
readerPool	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
readerPool	TokenNameIdentifier
.	TokenNameDOT
drop	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
prune	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
!	TokenNameNOT
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
any	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
flushControl	TokenNameIdentifier
.	TokenNameDOT
clearDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"don't apply deletes now delTermCount="	TokenNameStringLiteral
+	TokenNamePLUS
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
numTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" bytesUsed="	TokenNameStringLiteral
+	TokenNamePLUS
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
doAfterFlush	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
flushCount	TokenNameIdentifier
.	TokenNameDOT
incrementAndGet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
newSegment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"doFlush"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
flushControl	TokenNameIdentifier
.	TokenNameDOT
clearFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
&&	TokenNameAND_AND
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception during flush"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
long	TokenNamelong
ramSizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
docWriter	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
final	TokenNamefinal
synchronized	TokenNamesynchronized
int	TokenNameint
numRamDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
docWriter	TokenNameIdentifier
.	TokenNameDOT
getNumDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
ensureValidMerge	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
MergeException	TokenNameIdentifier
(	TokenNameLPAREN
"MergePolicy selected a segment ("	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
+	TokenNamePLUS
") that is not in the current index "	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
directory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
private	TokenNameprivate
void	TokenNamevoid
commitMergedDeletes	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
mergedReader	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
"startCommitMergeDeletes"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
sourceSegments	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"commitMergeDeletes "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
docUpto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
delCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
long	TokenNamelong
minGen	TokenNameIdentifier
=	TokenNameEQUAL
Long	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
sourceSegments	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
sourceSegments	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
minGen	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
getBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
minGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
docCount	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
SegmentReader	TokenNameIdentifier
previousReader	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
readerClones	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
SegmentReader	TokenNameIdentifier
currentReader	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
readers	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
currentReader	TokenNameIdentifier
.	TokenNameDOT
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
previousReader	TokenNameIdentifier
.	TokenNameDOT
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
previousReader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
assert	TokenNameassert
currentReader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
currentReader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
mergedReader	TokenNameIdentifier
.	TokenNameDOT
doDelete	TokenNameIdentifier
(	TokenNameLPAREN
docUpto	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
docUpto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
docUpto	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
docCount	TokenNameIdentifier
-	TokenNameMINUS
previousReader	TokenNameIdentifier
.	TokenNameDOT
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
currentReader	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
currentReader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
mergedReader	TokenNameIdentifier
.	TokenNameDOT
doDelete	TokenNameIdentifier
(	TokenNameLPAREN
docUpto	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
docUpto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
docUpto	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
mergedReader	TokenNameIdentifier
.	TokenNameDOT
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
mergedReader	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
=	TokenNameEQUAL
delCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
!	TokenNameNOT
mergedReader	TokenNameIdentifier
.	TokenNameDOT
hasChanges	TokenNameIdentifier
||	TokenNameOR_OR
minGen	TokenNameIdentifier
>	TokenNameGREATER
mergedReader	TokenNameIdentifier
.	TokenNameDOT
getSegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergedReader	TokenNameIdentifier
.	TokenNameDOT
getSegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
setBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
minGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
private	TokenNameprivate
boolean	TokenNameboolean
commitMerge	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
mergedReader	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
"startCommitMerge"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"this writer hit an OutOfMemoryError; cannot complete merge"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"commitMerge: "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" index="	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
merge	TokenNameIdentifier
.	TokenNameDOT
registerDone	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
isAborted	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"commitMerge: skipping merge "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
": it was aborted"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
commitMergedDeletes	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
,	TokenNameCOMMA
mergedReader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
!	TokenNameNOT
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
allDeleted	TokenNameIdentifier
=	TokenNameEQUAL
mergedReader	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
allDeleted	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"merged segment "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
+	TokenNamePLUS
" is 100% deleted"	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
keepFullyDeletedSegments	TokenNameIdentifier
?	TokenNameQUESTION
""	TokenNameStringLiteral
:	TokenNameCOLON
"; skipping insert"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
boolean	TokenNameboolean
dropSegment	TokenNameIdentifier
=	TokenNameEQUAL
allDeleted	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
keepFullyDeletedSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
applyMergeChanges	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
,	TokenNameCOMMA
dropSegment	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dropSegment	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
readerPool	TokenNameIdentifier
.	TokenNameDOT
drop	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
deleteNewFiles	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
!	TokenNameNOT
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"after commit: "	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
closeMergeReaders	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
readerPool	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
!	TokenNameNOT
dropSegment	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
segmentsToMerge	TokenNameIdentifier
.	TokenNameDOT
containsKey	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
segmentsToMerge	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
,	TokenNameCOMMA
Boolean	TokenNameIdentifier
.	TokenNameDOT
FALSE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
private	TokenNameprivate
void	TokenNamevoid
handleMergeException	TokenNameIdentifier
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
,	TokenNameCOMMA
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"handleMergeException: merge="	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" exc="	TokenNameStringLiteral
+	TokenNamePLUS
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
setException	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
addMergeException	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
instanceof	TokenNameinstanceof
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
MergeAbortedException	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
isExternal	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
MergeAbortedException	TokenNameIdentifier
)	TokenNameRPAREN
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
instanceof	TokenNameinstanceof
IOException	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
(	TokenNameLPAREN
IOException	TokenNameIdentifier
)	TokenNameRPAREN
t	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
instanceof	TokenNameinstanceof
RuntimeException	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
(	TokenNameLPAREN
RuntimeException	TokenNameIdentifier
)	TokenNameRPAREN
t	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
t	TokenNameIdentifier
instanceof	TokenNameinstanceof
Error	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
(	TokenNameLPAREN
Error	TokenNameIdentifier
)	TokenNameRPAREN
t	TokenNameIdentifier
;	TokenNameSEMICOLON
else	TokenNameelse
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
merge	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
t0	TokenNameIdentifier
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
mergeInit	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"now merge   merge="	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
"   index="	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeMiddle	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergeSuccess	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleMergeException	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
,	TokenNameCOMMA
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
mergeFinish	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception during merge"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
!	TokenNameNOT
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
deleter	TokenNameIdentifier
.	TokenNameDOT
refresh	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
success	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
merge	TokenNameIdentifier
.	TokenNameDOT
isAborted	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
(	TokenNameLPAREN
!	TokenNameNOT
closed	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
closing	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
updatePendingMerges	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"merge"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"merge time "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
t0	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" msec for "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
+	TokenNamePLUS
" docs"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
void	TokenNamevoid
mergeSuccess	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
final	TokenNamefinal
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
registerMerge	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
MergeAbortedException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
registerDone	TokenNameIdentifier
)	TokenNameRPAREN
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
stopMerges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
MergeAbortedException	TokenNameIdentifier
(	TokenNameLPAREN
"merge is aborted: "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
isExternal	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
mergingSegments	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
directory	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
isExternal	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
segmentsToMerge	TokenNameIdentifier
.	TokenNameDOT
containsKey	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
=	TokenNameEQUAL
mergeMaxNumSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
ensureValidMerge	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pendingMerges	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"add merge to pendingMerges: "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" [total "	TokenNameStringLiteral
+	TokenNamePLUS
pendingMerges	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" pending]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
mergeGen	TokenNameIdentifier
=	TokenNameEQUAL
mergeGen	TokenNameIdentifier
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
isExternal	TokenNameIdentifier
=	TokenNameEQUAL
isExternal	TokenNameIdentifier
;	TokenNameSEMICOLON
message	TokenNameIdentifier
(	TokenNameLPAREN
"registerMerge merging="	TokenNameStringLiteral
+	TokenNamePLUS
mergingSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"registerMerge info="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergingSegments	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
registerDone	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
synchronized	TokenNamesynchronized
void	TokenNamevoid
mergeInit	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
_mergeInit	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception in mergeInit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
mergeFinish	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
private	TokenNameprivate
void	TokenNamevoid
_mergeInit	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
"startMergeInit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
merge	TokenNameIdentifier
.	TokenNameDOT
registerDone	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"this writer hit an OutOfMemoryError; cannot merge"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
isAborted	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
return	TokenNamereturn
;	TokenNameSEMICOLON
boolean	TokenNameboolean
hasVectors	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
sourceSegment	TokenNameIdentifier
:	TokenNameCOLON
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
sourceSegment	TokenNameIdentifier
.	TokenNameDOT
getHasVectors	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
hasVectors	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
newSegmentName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
directory	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
hasVectors	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
BufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
ApplyDeletesResult	TokenNameIdentifier
result	TokenNameIdentifier
=	TokenNameEQUAL
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
applyDeletes	TokenNameIdentifier
(	TokenNameLPAREN
readerPool	TokenNameIdentifier
,	TokenNameCOMMA
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
anyDeletes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
keepFullyDeletedSegments	TokenNameIdentifier
&&	TokenNameAND_AND
result	TokenNameIdentifier
.	TokenNameDOT
allDeleted	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"drop 100% deleted segments: "	TokenNameStringLiteral
+	TokenNamePLUS
result	TokenNameIdentifier
.	TokenNameDOT
allDeleted	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
result	TokenNameIdentifier
.	TokenNameDOT
allDeleted	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
mergingSegments	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
readerPool	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
readerPool	TokenNameIdentifier
.	TokenNameDOT
drop	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
allDeleted	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
setBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
prune	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
details	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
details	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
"mergeMaxNumSegments"	TokenNameStringLiteral
,	TokenNameCOMMA
""	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
maxNumSegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
details	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
"mergeFactor"	TokenNameStringLiteral
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
setDiagnostics	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
,	TokenNameCOMMA
"merge"	TokenNameStringLiteral
,	TokenNameCOMMA
details	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"merge seg="	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
merge	TokenNameIdentifier
.	TokenNameDOT
estimatedMergeBytes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
delCount	TokenNameIdentifier
=	TokenNameEQUAL
numDeletedDocs	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
delCount	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
double	TokenNamedouble
delRatio	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
(	TokenNameLPAREN
double	TokenNamedouble
)	TokenNameRPAREN
delCount	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
estimatedMergeBytes	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
info	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
*	TokenNameMULTIPLY
(	TokenNameLPAREN
1.0	TokenNameDoubleLiteral
-	TokenNameMINUS
delRatio	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
mergingSegments	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setDiagnostics	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
source	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
setDiagnostics	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
source	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
setDiagnostics	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
source	TokenNameIdentifier
,	TokenNameCOMMA
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
details	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
diagnostics	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
diagnostics	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
"source"	TokenNameStringLiteral
,	TokenNameCOMMA
source	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
diagnostics	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
"lucene.version"	TokenNameStringLiteral
,	TokenNameCOMMA
Constants	TokenNameIdentifier
.	TokenNameDOT
LUCENE_VERSION	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
diagnostics	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
"os"	TokenNameStringLiteral
,	TokenNameCOMMA
Constants	TokenNameIdentifier
.	TokenNameDOT
OS_NAME	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
diagnostics	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
"os.arch"	TokenNameStringLiteral
,	TokenNameCOMMA
Constants	TokenNameIdentifier
.	TokenNameDOT
OS_ARCH	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
diagnostics	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
"os.version"	TokenNameStringLiteral
,	TokenNameCOMMA
Constants	TokenNameIdentifier
.	TokenNameDOT
OS_VERSION	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
diagnostics	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
"java.version"	TokenNameStringLiteral
,	TokenNameCOMMA
Constants	TokenNameIdentifier
.	TokenNameDOT
JAVA_VERSION	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
diagnostics	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
"java.vendor"	TokenNameStringLiteral
,	TokenNameCOMMA
Constants	TokenNameIdentifier
.	TokenNameDOT
JAVA_VENDOR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
details	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
diagnostics	TokenNameIdentifier
.	TokenNameDOT
putAll	TokenNameIdentifier
(	TokenNameLPAREN
details	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
info	TokenNameIdentifier
.	TokenNameDOT
setDiagnostics	TokenNameIdentifier
(	TokenNameLPAREN
diagnostics	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
synchronized	TokenNamesynchronized
void	TokenNamevoid
mergeFinish	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
registerDone	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
sourceSegments	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
:	TokenNameCOLON
sourceSegments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
mergingSegments	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
mergingSegments	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
registerDone	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
runningMerges	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
synchronized	TokenNamesynchronized
void	TokenNamevoid
closeMergeReaders	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
suppressExceptions	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
numSegments	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
readers	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Throwable	TokenNameIdentifier
th	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
anyChanges	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
drop	TokenNameIdentifier
=	TokenNameEQUAL
!	TokenNameNOT
suppressExceptions	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
readers	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
anyChanges	TokenNameIdentifier
|=	TokenNameOR_EQUAL
readerPool	TokenNameIdentifier
.	TokenNameDOT
release	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
readers	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
drop	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
th	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
th	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
readers	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
merge	TokenNameIdentifier
.	TokenNameDOT
readerClones	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
merge	TokenNameIdentifier
.	TokenNameDOT
readerClones	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
readerClones	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
th	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
th	TokenNameIdentifier
=	TokenNameEQUAL
t	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
assert	TokenNameassert
merge	TokenNameIdentifier
.	TokenNameDOT
readerClones	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getRefCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
:	TokenNameCOLON
"refCount should be 0 but is "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
readerClones	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
getRefCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
readerClones	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
suppressExceptions	TokenNameIdentifier
&&	TokenNameAND_AND
anyChanges	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
suppressExceptions	TokenNameIdentifier
&&	TokenNameAND_AND
th	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
th	TokenNameIdentifier
instanceof	TokenNameinstanceof
IOException	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
(	TokenNameLPAREN
IOException	TokenNameIdentifier
)	TokenNameRPAREN
th	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
th	TokenNameIdentifier
instanceof	TokenNameinstanceof
RuntimeException	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
(	TokenNameLPAREN
RuntimeException	TokenNameIdentifier
)	TokenNameRPAREN
th	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
th	TokenNameIdentifier
instanceof	TokenNameinstanceof
Error	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
(	TokenNameLPAREN
Error	TokenNameIdentifier
)	TokenNameRPAREN
th	TokenNameIdentifier
;	TokenNameSEMICOLON
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
th	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
private	TokenNameprivate
int	TokenNameint
mergeMiddle	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
checkAborted	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
mergedName	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
mergedDocCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
sourceSegments	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
segments	TokenNameIdentifier
;	TokenNameSEMICOLON
SegmentMerger	TokenNameIdentifier
merger	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentMerger	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
config	TokenNameIdentifier
.	TokenNameDOT
getTermIndexInterval	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
mergedName	TokenNameIdentifier
,	TokenNameCOMMA
merge	TokenNameIdentifier
,	TokenNameCOMMA
payloadProcessorProvider	TokenNameIdentifier
,	TokenNameCOMMA
(	TokenNameLPAREN
(	TokenNameLPAREN
FieldInfos	TokenNameIdentifier
)	TokenNameRPAREN
docWriter	TokenNameIdentifier
.	TokenNameDOT
getFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"merging "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
segString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" mergeVectors="	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
getHasVectors	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
readers	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentReader	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
readerClones	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentReader	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
int	TokenNameint
totDocCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
segUpto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
segUpto	TokenNameIdentifier
<	TokenNameLESS
sourceSegments	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
sourceSegments	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
segUpto	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
=	TokenNameEQUAL
readerPool	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
MERGE_READ_BUFFER_SIZE	TokenNameIdentifier
,	TokenNameCOMMA
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
readers	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
SegmentReader	TokenNameIdentifier
clone	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
SegmentReader	TokenNameIdentifier
)	TokenNameRPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
readerClones	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
clone	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
clone	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
merger	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
clone	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
totDocCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
clone	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
segUpto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"merge: total "	TokenNameStringLiteral
+	TokenNamePLUS
totDocCount	TokenNameIdentifier
+	TokenNamePLUS
" docs"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
checkAborted	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
mergedDocCount	TokenNameIdentifier
=	TokenNameEQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
=	TokenNameEQUAL
merger	TokenNameIdentifier
.	TokenNameDOT
merge	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
setHasVectors	TokenNameIdentifier
(	TokenNameLPAREN
merger	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
hasVectors	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
mergedDocCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
totDocCount	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"merge store matchedCount="	TokenNameStringLiteral
+	TokenNamePLUS
merger	TokenNameIdentifier
.	TokenNameDOT
getMatchedSubReaderCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs "	TokenNameStringLiteral
+	TokenNamePLUS
merge	TokenNameIdentifier
.	TokenNameDOT
readers	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
anyNonBulkMerges	TokenNameIdentifier
|=	TokenNameOR_EQUAL
merger	TokenNameIdentifier
.	TokenNameDOT
getAnyNonBulkMerges	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
mergedDocCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
totDocCount	TokenNameIdentifier
:	TokenNameCOLON
"mergedDocCount="	TokenNameStringLiteral
+	TokenNamePLUS
mergedDocCount	TokenNameIdentifier
+	TokenNamePLUS
" vs "	TokenNameStringLiteral
+	TokenNamePLUS
totDocCount	TokenNameIdentifier
;	TokenNameSEMICOLON
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
setHasProx	TokenNameIdentifier
(	TokenNameLPAREN
merger	TokenNameIdentifier
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
hasProx	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
useCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
useCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
useCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
useCompoundFile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
compoundFileName	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
mergedName	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
COMPOUND_FILE_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"create compound file "	TokenNameStringLiteral
+	TokenNamePLUS
compoundFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
merger	TokenNameIdentifier
.	TokenNameDOT
createCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
compoundFileName	TokenNameIdentifier
,	TokenNameCOMMA
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IOException	TokenNameIdentifier
ioe	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
isAborted	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
handleMergeException	TokenNameIdentifier
(	TokenNameLPAREN
ioe	TokenNameIdentifier
,	TokenNameCOMMA
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleMergeException	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
,	TokenNameCOMMA
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception creating compound file during merge"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
deleteFile	TokenNameIdentifier
(	TokenNameLPAREN
compoundFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
deleteNewFiles	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
deleteNewFiles	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
isAborted	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"abort merge after building CFS"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
deleteFile	TokenNameIdentifier
(	TokenNameLPAREN
compoundFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
setUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
"merged segment size=%.3f MB vs estimate=%.3f MB"	TokenNameStringLiteral
,	TokenNameCOMMA
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
,	TokenNameCOMMA
merge	TokenNameIdentifier
.	TokenNameDOT
estimatedMergeBytes	TokenNameIdentifier
/	TokenNameDIVIDE
1024	TokenNameIntegerLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
IndexReaderWarmer	TokenNameIdentifier
mergedSegmentWarmer	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getMergedSegmentWarmer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
termsIndexDivisor	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
loadDocStores	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
mergedSegmentWarmer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
termsIndexDivisor	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getReaderTermsIndexDivisor	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
loadDocStores	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
termsIndexDivisor	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
loadDocStores	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
SegmentReader	TokenNameIdentifier
mergedReader	TokenNameIdentifier
=	TokenNameEQUAL
readerPool	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
,	TokenNameCOMMA
loadDocStores	TokenNameIdentifier
,	TokenNameCOMMA
BufferedIndexInput	TokenNameIdentifier
.	TokenNameDOT
BUFFER_SIZE	TokenNameIdentifier
,	TokenNameCOMMA
termsIndexDivisor	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
poolReaders	TokenNameIdentifier
&&	TokenNameAND_AND
mergedSegmentWarmer	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
mergedSegmentWarmer	TokenNameIdentifier
.	TokenNameDOT
warm	TokenNameIdentifier
(	TokenNameLPAREN
mergedReader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
commitMerge	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
,	TokenNameCOMMA
mergedReader	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
readerPool	TokenNameIdentifier
.	TokenNameDOT
release	TokenNameIdentifier
(	TokenNameLPAREN
mergedReader	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
checkpoint	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
closeMergeReaders	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
mergedDocCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
addMergeException	TokenNameIdentifier
(	TokenNameLPAREN
MergePolicy	TokenNameIdentifier
.	TokenNameDOT
OneMerge	TokenNameIdentifier
merge	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
merge	TokenNameIdentifier
.	TokenNameDOT
getException	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
mergeExceptions	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
&&	TokenNameAND_AND
mergeGen	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
merge	TokenNameIdentifier
.	TokenNameDOT
mergeGen	TokenNameIdentifier
)	TokenNameRPAREN
mergeExceptions	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
merge	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
getBufferedDeleteTermsSize	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
docWriter	TokenNameIdentifier
.	TokenNameDOT
getPendingDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
terms	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
getNumBufferedDeleteTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
docWriter	TokenNameIdentifier
.	TokenNameDOT
getPendingDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
numTermDeletes	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
SegmentInfo	TokenNameIdentifier
newestSegment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
String	TokenNameIdentifier
segString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
segString	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
String	TokenNameIdentifier
segString	TokenNameIdentifier
(	TokenNameLPAREN
Iterable	TokenNameIdentifier
<	TokenNameLESS
SegmentInfo	TokenNameIdentifier
>	TokenNameGREATER
infos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
StringBuilder	TokenNameIdentifier
buffer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
s	TokenNameIdentifier
:	TokenNameCOLON
infos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
buffer	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
buffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
' '	TokenNameCharacterLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
buffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
segString	TokenNameIdentifier
(	TokenNameLPAREN
s	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
buffer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
String	TokenNameIdentifier
segString	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
StringBuilder	TokenNameIdentifier
buffer	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
StringBuilder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
=	TokenNameEQUAL
readerPool	TokenNameIdentifier
.	TokenNameDOT
getIfExists	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
buffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
buffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
directory	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
buffer	TokenNameIdentifier
.	TokenNameDOT
append	TokenNameIdentifier
(	TokenNameLPAREN
"**"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
readerPool	TokenNameIdentifier
.	TokenNameDOT
release	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
buffer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
void	TokenNamevoid
doWait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
wait	TokenNameIdentifier
(	TokenNameLPAREN
1000	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InterruptedException	TokenNameIdentifier
ie	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ThreadInterruptedException	TokenNameIdentifier
(	TokenNameLPAREN
ie	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
keepFullyDeletedSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
void	TokenNamevoid
keepFullyDeletedSegments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
keepFullyDeletedSegments	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
getKeepFullyDeletedSegments	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
keepFullyDeletedSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
filesExist	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
toSync	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
Collection	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
files	TokenNameIdentifier
=	TokenNameEQUAL
toSync	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
final	TokenNamefinal
String	TokenNameIdentifier
fileName	TokenNameIdentifier
:	TokenNameCOLON
files	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
directory	TokenNameIdentifier
.	TokenNameDOT
fileExists	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
"file "	TokenNameStringLiteral
+	TokenNamePLUS
fileName	TokenNameIdentifier
+	TokenNamePLUS
" does not exist"	TokenNameStringLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
deleter	TokenNameIdentifier
.	TokenNameDOT
exists	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
"IndexFileDeleter doesn't know about file "	TokenNameStringLiteral
+	TokenNamePLUS
fileName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
startCommit	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
toSync	TokenNameIdentifier
,	TokenNameCOMMA
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
"startStartCommit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
pendingCommit	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hitOOM	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalStateException	TokenNameIdentifier
(	TokenNameLPAREN
"this writer hit an OutOfMemoryError; cannot commit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"startCommit(): start"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
lastCommitChangeCount	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
changeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pendingCommitChangeCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
lastCommitChangeCount	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"  skip startCommit(): no changes pending"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
filesToCommit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
filesToCommit	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
message	TokenNameIdentifier
(	TokenNameLPAREN
"startCommit index="	TokenNameStringLiteral
+	TokenNamePLUS
segString	TokenNameIdentifier
(	TokenNameLPAREN
toSync	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" changeCount="	TokenNameStringLiteral
+	TokenNamePLUS
changeCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
filesExist	TokenNameIdentifier
(	TokenNameLPAREN
toSync	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
commitUserData	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
toSync	TokenNameIdentifier
.	TokenNameDOT
setUserData	TokenNameIdentifier
(	TokenNameLPAREN
commitUserData	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
assert	TokenNameassert
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
"midStartCommit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
pendingCommitSet	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
directory	TokenNameIdentifier
.	TokenNameDOT
sync	TokenNameIdentifier
(	TokenNameLPAREN
toSync	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
"midStartCommit2"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
pendingCommit	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
assert	TokenNameassert
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
getGeneration	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
toSync	TokenNameIdentifier
.	TokenNameDOT
getGeneration	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
toSync	TokenNameIdentifier
.	TokenNameDOT
prepareCommit	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pendingCommitSet	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
pendingCommit	TokenNameIdentifier
=	TokenNameEQUAL
toSync	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"done all syncs"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
"midStartCommitSuccess"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
updateGeneration	TokenNameIdentifier
(	TokenNameLPAREN
toSync	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
pendingCommitSet	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit exception committing segments file"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
decRef	TokenNameIdentifier
(	TokenNameLPAREN
filesToCommit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
filesToCommit	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
oom	TokenNameIdentifier
,	TokenNameCOMMA
"startCommit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
"finishStartCommit"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
boolean	TokenNameboolean
isLocked	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
directory	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
directory	TokenNameIdentifier
.	TokenNameDOT
makeLock	TokenNameIdentifier
(	TokenNameLPAREN
WRITE_LOCK_NAME	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
isLocked	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
unlock	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
directory	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
directory	TokenNameIdentifier
.	TokenNameDOT
makeLock	TokenNameIdentifier
(	TokenNameLPAREN
IndexWriter	TokenNameIdentifier
.	TokenNameDOT
WRITE_LOCK_NAME	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
release	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
MaxFieldLength	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
int	TokenNameint
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
String	TokenNameIdentifier
name	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
MaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
name	TokenNameIdentifier
=	TokenNameEQUAL
name	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
limit	TokenNameIdentifier
=	TokenNameEQUAL
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
MaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
"User-specified"	TokenNameStringLiteral
,	TokenNameCOMMA
limit	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getLimit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
String	TokenNameIdentifier
toString	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
name	TokenNameIdentifier
+	TokenNamePLUS
":"	TokenNameStringLiteral
+	TokenNamePLUS
limit	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
MaxFieldLength	TokenNameIdentifier
UNLIMITED	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
"UNLIMITED"	TokenNameStringLiteral
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
MaxFieldLength	TokenNameIdentifier
LIMITED	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
"LIMITED"	TokenNameStringLiteral
,	TokenNameCOMMA
10000	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
abstract	TokenNameabstract
class	TokenNameclass
IndexReaderWarmer	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
abstract	TokenNameabstract
void	TokenNamevoid
warm	TokenNameIdentifier
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setMergedSegmentWarmer	TokenNameIdentifier
(	TokenNameLPAREN
IndexReaderWarmer	TokenNameIdentifier
warmer	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
config	TokenNameIdentifier
.	TokenNameDOT
setMergedSegmentWarmer	TokenNameIdentifier
(	TokenNameLPAREN
warmer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
IndexReaderWarmer	TokenNameIdentifier
getMergedSegmentWarmer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
config	TokenNameIdentifier
.	TokenNameDOT
getMergedSegmentWarmer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
handleOOM	TokenNameIdentifier
(	TokenNameLPAREN
OutOfMemoryError	TokenNameIdentifier
oom	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
location	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"hit OutOfMemoryError inside "	TokenNameStringLiteral
+	TokenNamePLUS
location	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
hitOOM	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
throw	TokenNamethrow
oom	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
nrtIsCurrent	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
infos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
infos	TokenNameIdentifier
.	TokenNameDOT
version	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
version	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
docWriter	TokenNameIdentifier
.	TokenNameDOT
anyChanges	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
any	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
isClosed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
closed	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
deleteUnusedFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
deletePendingFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
revisitPolicy	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
deletePendingFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
deletePendingFiles	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setPayloadProcessorProvider	TokenNameIdentifier
(	TokenNameLPAREN
PayloadProcessorProvider	TokenNameIdentifier
pcp	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
payloadProcessorProvider	TokenNameIdentifier
=	TokenNameEQUAL
pcp	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
PayloadProcessorProvider	TokenNameIdentifier
getPayloadProcessorProvider	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
ensureOpen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
payloadProcessorProvider	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
class	TokenNameclass
FlushControl	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
boolean	TokenNameboolean
flushPending	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
flushDeletes	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
flushing	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
setFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
reason	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
doWait	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
flushPending	TokenNameIdentifier
||	TokenNameOR_OR
flushing	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
doWait	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
flushPending	TokenNameIdentifier
||	TokenNameOR_OR
flushing	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
wait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InterruptedException	TokenNameIdentifier
ie	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ThreadInterruptedException	TokenNameIdentifier
(	TokenNameLPAREN
ie	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"now trigger flush reason="	TokenNameStringLiteral
+	TokenNamePLUS
reason	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
flushPending	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
flushPending	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
setFlushPendingNoWait	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
reason	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
setFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
reason	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
getFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
flushPending	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
getFlushDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
flushDeletes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
clearFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"clearFlushPending"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
flushPending	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
flushDeletes	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
docCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
clearDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
delCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
waitUpdate	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
docInc	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
delInc	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
waitUpdate	TokenNameIdentifier
(	TokenNameLPAREN
docInc	TokenNameIdentifier
,	TokenNameCOMMA
delInc	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
waitUpdate	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
docInc	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
delInc	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
skipWait	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
flushPending	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
wait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InterruptedException	TokenNameIdentifier
ie	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ThreadInterruptedException	TokenNameIdentifier
(	TokenNameLPAREN
ie	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
docCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
docInc	TokenNameIdentifier
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
delInc	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
skipWait	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
maxBufferedDocs	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getMaxBufferedDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
maxBufferedDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DISABLE_AUTO_FLUSH	TokenNameIdentifier
&&	TokenNameAND_AND
docCount	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
maxBufferedDocs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
setFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
"maxBufferedDocs"	TokenNameStringLiteral
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
maxBufferedDeleteTerms	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getMaxBufferedDeleteTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
maxBufferedDeleteTerms	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DISABLE_AUTO_FLUSH	TokenNameIdentifier
&&	TokenNameAND_AND
delCount	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
maxBufferedDeleteTerms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flushDeletes	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
setFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
"maxBufferedDeleteTerms"	TokenNameStringLiteral
,	TokenNameCOMMA
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
flushByRAMUsage	TokenNameIdentifier
(	TokenNameLPAREN
"add delete/doc"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
flushByRAMUsage	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
reason	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
double	TokenNamedouble
ramBufferSizeMB	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
ramBufferSizeMB	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DISABLE_AUTO_FLUSH	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
limit	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
(	TokenNameLPAREN
ramBufferSizeMB	TokenNameIdentifier
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
long	TokenNamelong
used	TokenNameIdentifier
=	TokenNameEQUAL
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
docWriter	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
used	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
docWriter	TokenNameIdentifier
.	TokenNameDOT
balanceRAM	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
used	TokenNameIdentifier
=	TokenNameEQUAL
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
docWriter	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
used	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
limit	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
setFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
"ram full: "	TokenNameStringLiteral
+	TokenNamePLUS
reason	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
FlushControl	TokenNameIdentifier
flushControl	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FlushControl	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
