package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
CharBuffer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
nio	TokenNameIdentifier
.	TokenNameDOT
ByteBuffer	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
class	TokenNameclass
IndexableBinaryStringTools	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
CodingCase	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
CODING_CASES	TokenNameIdentifier
=	TokenNameEQUAL
{	TokenNameLBRACE
new	TokenNamenew
CodingCase	TokenNameIdentifier
(	TokenNameLPAREN
7	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
CodingCase	TokenNameIdentifier
(	TokenNameLPAREN
14	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
,	TokenNameCOMMA
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
CodingCase	TokenNameIdentifier
(	TokenNameLPAREN
13	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
,	TokenNameCOMMA
3	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
CodingCase	TokenNameIdentifier
(	TokenNameLPAREN
12	TokenNameIntegerLiteral
,	TokenNameCOMMA
4	TokenNameIntegerLiteral
,	TokenNameCOMMA
4	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
CodingCase	TokenNameIdentifier
(	TokenNameLPAREN
11	TokenNameIntegerLiteral
,	TokenNameCOMMA
3	TokenNameIntegerLiteral
,	TokenNameCOMMA
5	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
CodingCase	TokenNameIdentifier
(	TokenNameLPAREN
10	TokenNameIntegerLiteral
,	TokenNameCOMMA
2	TokenNameIntegerLiteral
,	TokenNameCOMMA
6	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
CodingCase	TokenNameIdentifier
(	TokenNameLPAREN
9	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
7	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
new	TokenNamenew
CodingCase	TokenNameIdentifier
(	TokenNameLPAREN
8	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
}	TokenNameRBRACE
;	TokenNameSEMICOLON
private	TokenNameprivate
IndexableBinaryStringTools	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
static	TokenNamestatic
int	TokenNameint
getEncodedLength	TokenNameIdentifier
(	TokenNameLPAREN
ByteBuffer	TokenNameIdentifier
original	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IllegalArgumentException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
original	TokenNameIdentifier
.	TokenNameDOT
hasArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getEncodedLength	TokenNameIdentifier
(	TokenNameLPAREN
original	TokenNameIdentifier
.	TokenNameDOT
array	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
original	TokenNameIdentifier
.	TokenNameDOT
arrayOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
original	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
original	TokenNameIdentifier
.	TokenNameDOT
arrayOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"original argument must have a backing array"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
int	TokenNameint
getEncodedLength	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
inputArray	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
inputOffset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
inputLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
8L	TokenNameLongLiteral
*	TokenNameMULTIPLY
inputLength	TokenNameIdentifier
+	TokenNamePLUS
14L	TokenNameLongLiteral
)	TokenNameRPAREN
/	TokenNameDIVIDE
15L	TokenNameLongLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
static	TokenNamestatic
int	TokenNameint
getDecodedLength	TokenNameIdentifier
(	TokenNameLPAREN
CharBuffer	TokenNameIdentifier
encoded	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IllegalArgumentException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
encoded	TokenNameIdentifier
.	TokenNameDOT
hasArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
getDecodedLength	TokenNameIdentifier
(	TokenNameLPAREN
encoded	TokenNameIdentifier
.	TokenNameDOT
array	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
encoded	TokenNameIdentifier
.	TokenNameDOT
arrayOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
encoded	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
encoded	TokenNameIdentifier
.	TokenNameDOT
arrayOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"encoded argument must have a backing array"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
int	TokenNameint
getDecodedLength	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
encoded	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
offset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
numChars	TokenNameIdentifier
=	TokenNameEQUAL
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numChars	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
numFullBytesInFinalChar	TokenNameIdentifier
=	TokenNameEQUAL
encoded	TokenNameIdentifier
[	TokenNameLBRACKET
offset	TokenNameIdentifier
+	TokenNamePLUS
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
numEncodedChars	TokenNameIdentifier
=	TokenNameEQUAL
numChars	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
return	TokenNamereturn
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
numEncodedChars	TokenNameIdentifier
*	TokenNameMULTIPLY
15L	TokenNameLongLiteral
+	TokenNamePLUS
7L	TokenNameLongLiteral
)	TokenNameRPAREN
/	TokenNameDIVIDE
8L	TokenNameLongLiteral
+	TokenNamePLUS
numFullBytesInFinalChar	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
encode	TokenNameIdentifier
(	TokenNameLPAREN
ByteBuffer	TokenNameIdentifier
input	TokenNameIdentifier
,	TokenNameCOMMA
CharBuffer	TokenNameIdentifier
output	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
hasArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
output	TokenNameIdentifier
.	TokenNameDOT
hasArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
inputOffset	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
arrayOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
inputLength	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
inputOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
outputOffset	TokenNameIdentifier
=	TokenNameEQUAL
output	TokenNameIdentifier
.	TokenNameDOT
arrayOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
outputLength	TokenNameIdentifier
=	TokenNameEQUAL
getEncodedLength	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
array	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
inputOffset	TokenNameIdentifier
,	TokenNameCOMMA
inputLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
(	TokenNameLPAREN
outputLength	TokenNameIdentifier
+	TokenNamePLUS
outputOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
encode	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
array	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
inputOffset	TokenNameIdentifier
,	TokenNameCOMMA
inputLength	TokenNameIdentifier
,	TokenNameCOMMA
output	TokenNameIdentifier
.	TokenNameDOT
array	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
outputOffset	TokenNameIdentifier
,	TokenNameCOMMA
outputLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Arguments must have backing arrays"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
encode	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
inputArray	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
inputOffset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
inputLength	TokenNameIdentifier
,	TokenNameCOMMA
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
outputArray	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
outputOffset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
outputLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
(	TokenNameLPAREN
outputLength	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
getEncodedLength	TokenNameIdentifier
(	TokenNameLPAREN
inputArray	TokenNameIdentifier
,	TokenNameCOMMA
inputOffset	TokenNameIdentifier
,	TokenNameCOMMA
inputLength	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
inputLength	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
inputByteNum	TokenNameIdentifier
=	TokenNameEQUAL
inputOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
caseNum	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
outputCharNum	TokenNameIdentifier
=	TokenNameEQUAL
outputOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
CodingCase	TokenNameIdentifier
codingCase	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
inputByteNum	TokenNameIdentifier
+	TokenNamePLUS
CODING_CASES	TokenNameIdentifier
[	TokenNameLBRACKET
caseNum	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
numBytes	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
inputLength	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
outputCharNum	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
codingCase	TokenNameIdentifier
=	TokenNameEQUAL
CODING_CASES	TokenNameIdentifier
[	TokenNameLBRACKET
caseNum	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
codingCase	TokenNameIdentifier
.	TokenNameDOT
numBytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputCharNum	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputArray	TokenNameIdentifier
[	TokenNameLBRACKET
inputByteNum	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
initialShift	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputArray	TokenNameIdentifier
[	TokenNameLBRACKET
inputByteNum	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0xFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalShift	TokenNameIdentifier
)	TokenNameRPAREN
&	TokenNameAND
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalMask	TokenNameIdentifier
)	TokenNameRPAREN
&	TokenNameAND
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
0x7FFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputCharNum	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputArray	TokenNameIdentifier
[	TokenNameLBRACKET
inputByteNum	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
initialShift	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
inputArray	TokenNameIdentifier
[	TokenNameLBRACKET
inputByteNum	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0xFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
middleShift	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputArray	TokenNameIdentifier
[	TokenNameLBRACKET
inputByteNum	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0xFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalShift	TokenNameIdentifier
)	TokenNameRPAREN
&	TokenNameAND
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalMask	TokenNameIdentifier
)	TokenNameRPAREN
&	TokenNameAND
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
0x7FFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
inputByteNum	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
codingCase	TokenNameIdentifier
.	TokenNameDOT
advanceBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
caseNum	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CODING_CASES	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
caseNum	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
codingCase	TokenNameIdentifier
=	TokenNameEQUAL
CODING_CASES	TokenNameIdentifier
[	TokenNameLBRACKET
caseNum	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
inputByteNum	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
<	TokenNameLESS
inputLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputCharNum	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputArray	TokenNameIdentifier
[	TokenNameLBRACKET
inputByteNum	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
initialShift	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
(	TokenNameLPAREN
(	TokenNameLPAREN
inputArray	TokenNameIdentifier
[	TokenNameLBRACKET
inputByteNum	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
&	TokenNameAND
0xFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
middleShift	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
&	TokenNameAND
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
0x7FFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputCharNum	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
inputByteNum	TokenNameIdentifier
<	TokenNameLESS
inputLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputCharNum	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputArray	TokenNameIdentifier
[	TokenNameLBRACKET
inputByteNum	TokenNameIdentifier
]	TokenNameRBRACKET
&	TokenNameAND
0xFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
initialShift	TokenNameIdentifier
)	TokenNameRPAREN
&	TokenNameAND
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
0x7FFF	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputCharNum	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
caseNum	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
?	TokenNameQUESTION
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
1	TokenNameIntegerLiteral
:	TokenNameCOLON
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputCharNum	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
char	TokenNamechar
)	TokenNameRPAREN
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
decode	TokenNameIdentifier
(	TokenNameLPAREN
CharBuffer	TokenNameIdentifier
input	TokenNameIdentifier
,	TokenNameCOMMA
ByteBuffer	TokenNameIdentifier
output	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
hasArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
output	TokenNameIdentifier
.	TokenNameDOT
hasArray	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
inputOffset	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
arrayOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
inputLength	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
inputOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
outputOffset	TokenNameIdentifier
=	TokenNameEQUAL
output	TokenNameIdentifier
.	TokenNameDOT
arrayOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
outputLength	TokenNameIdentifier
=	TokenNameEQUAL
getDecodedLength	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
array	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
inputOffset	TokenNameIdentifier
,	TokenNameCOMMA
inputLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
limit	TokenNameIdentifier
(	TokenNameLPAREN
outputLength	TokenNameIdentifier
+	TokenNamePLUS
outputOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
decode	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
array	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
inputOffset	TokenNameIdentifier
,	TokenNameCOMMA
inputLength	TokenNameIdentifier
,	TokenNameCOMMA
output	TokenNameIdentifier
.	TokenNameDOT
array	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
outputOffset	TokenNameIdentifier
,	TokenNameCOMMA
outputLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"Arguments must have backing arrays"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
decode	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
inputArray	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
inputOffset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
inputLength	TokenNameIdentifier
,	TokenNameCOMMA
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
outputArray	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
outputOffset	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
outputLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
(	TokenNameLPAREN
outputLength	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
getDecodedLength	TokenNameIdentifier
(	TokenNameLPAREN
inputArray	TokenNameIdentifier
,	TokenNameCOMMA
inputOffset	TokenNameIdentifier
,	TokenNameCOMMA
inputLength	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
numInputChars	TokenNameIdentifier
=	TokenNameEQUAL
inputLength	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
numOutputBytes	TokenNameIdentifier
=	TokenNameEQUAL
outputLength	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numOutputBytes	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
caseNum	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
outputByteNum	TokenNameIdentifier
=	TokenNameEQUAL
outputOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
inputCharNum	TokenNameIdentifier
=	TokenNameEQUAL
inputOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
short	TokenNameshort
inputChar	TokenNameIdentifier
;	TokenNameSEMICOLON
CodingCase	TokenNameIdentifier
codingCase	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
;	TokenNameSEMICOLON
inputCharNum	TokenNameIdentifier
<	TokenNameLESS
numInputChars	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
inputCharNum	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
codingCase	TokenNameIdentifier
=	TokenNameEQUAL
CODING_CASES	TokenNameIdentifier
[	TokenNameLBRACKET
caseNum	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
inputChar	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
inputArray	TokenNameIdentifier
[	TokenNameLBRACKET
inputCharNum	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
codingCase	TokenNameIdentifier
.	TokenNameDOT
numBytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
caseNum	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
inputChar	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
initialShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
]	TokenNameRBRACKET
+=	TokenNamePLUS_EQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
inputChar	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
initialShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputChar	TokenNameIdentifier
&	TokenNameAND
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalMask	TokenNameIdentifier
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
]	TokenNameRBRACKET
+=	TokenNamePLUS_EQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
inputChar	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
initialShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputChar	TokenNameIdentifier
&	TokenNameAND
codingCase	TokenNameIdentifier
.	TokenNameDOT
middleMask	TokenNameIdentifier
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
middleShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputChar	TokenNameIdentifier
&	TokenNameAND
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalMask	TokenNameIdentifier
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
outputByteNum	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
codingCase	TokenNameIdentifier
.	TokenNameDOT
advanceBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
++	TokenNamePLUS_PLUS
caseNum	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
CODING_CASES	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
caseNum	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
inputChar	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
inputArray	TokenNameIdentifier
[	TokenNameLBRACKET
inputCharNum	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
codingCase	TokenNameIdentifier
=	TokenNameEQUAL
CODING_CASES	TokenNameIdentifier
[	TokenNameLBRACKET
caseNum	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
caseNum	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
]	TokenNameRBRACKET
+=	TokenNamePLUS_EQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
inputChar	TokenNameIdentifier
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
initialShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
bytesLeft	TokenNameIdentifier
=	TokenNameEQUAL
numOutputBytes	TokenNameIdentifier
-	TokenNameMINUS
outputByteNum	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bytesLeft	TokenNameIdentifier
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
codingCase	TokenNameIdentifier
.	TokenNameDOT
numBytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputChar	TokenNameIdentifier
&	TokenNameAND
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalMask	TokenNameIdentifier
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputChar	TokenNameIdentifier
&	TokenNameAND
codingCase	TokenNameIdentifier
.	TokenNameDOT
middleMask	TokenNameIdentifier
)	TokenNameRPAREN
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
middleShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
bytesLeft	TokenNameIdentifier
>	TokenNameGREATER
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
outputArray	TokenNameIdentifier
[	TokenNameLBRACKET
outputByteNum	TokenNameIdentifier
+	TokenNamePLUS
2	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
(	TokenNameLPAREN
byte	TokenNamebyte
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
inputChar	TokenNameIdentifier
&	TokenNameAND
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalMask	TokenNameIdentifier
)	TokenNameRPAREN
<<	TokenNameLEFT_SHIFT
codingCase	TokenNameIdentifier
.	TokenNameDOT
finalShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
static	TokenNamestatic
ByteBuffer	TokenNameIdentifier
decode	TokenNameIdentifier
(	TokenNameLPAREN
CharBuffer	TokenNameIdentifier
input	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
outputArray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
getDecodedLength	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
ByteBuffer	TokenNameIdentifier
output	TokenNameIdentifier
=	TokenNameEQUAL
ByteBuffer	TokenNameIdentifier
.	TokenNameDOT
wrap	TokenNameIdentifier
(	TokenNameLPAREN
outputArray	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
decode	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
,	TokenNameCOMMA
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
output	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Deprecated	TokenNameIdentifier
public	TokenNamepublic
static	TokenNamestatic
CharBuffer	TokenNameIdentifier
encode	TokenNameIdentifier
(	TokenNameLPAREN
ByteBuffer	TokenNameIdentifier
input	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
outputArray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
getEncodedLength	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
CharBuffer	TokenNameIdentifier
output	TokenNameIdentifier
=	TokenNameEQUAL
CharBuffer	TokenNameIdentifier
.	TokenNameDOT
wrap	TokenNameIdentifier
(	TokenNameLPAREN
outputArray	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
encode	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
,	TokenNameCOMMA
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
output	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
class	TokenNameclass
CodingCase	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
numBytes	TokenNameIdentifier
,	TokenNameCOMMA
initialShift	TokenNameIdentifier
,	TokenNameCOMMA
middleShift	TokenNameIdentifier
,	TokenNameCOMMA
finalShift	TokenNameIdentifier
,	TokenNameCOMMA
advanceBytes	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
short	TokenNameshort
middleMask	TokenNameIdentifier
,	TokenNameCOMMA
finalMask	TokenNameIdentifier
;	TokenNameSEMICOLON
CodingCase	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
initialShift	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
middleShift	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
finalShift	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
numBytes	TokenNameIdentifier
=	TokenNameEQUAL
3	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
initialShift	TokenNameIdentifier
=	TokenNameEQUAL
initialShift	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
middleShift	TokenNameIdentifier
=	TokenNameEQUAL
middleShift	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
finalShift	TokenNameIdentifier
=	TokenNameEQUAL
finalShift	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
finalMask	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
0xFF	TokenNameIntegerLiteral
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
finalShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
middleMask	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
0xFF	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
middleShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
CodingCase	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
initialShift	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
finalShift	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
numBytes	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
initialShift	TokenNameIdentifier
=	TokenNameEQUAL
initialShift	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
finalShift	TokenNameIdentifier
=	TokenNameEQUAL
finalShift	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
finalMask	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
short	TokenNameshort
)	TokenNameRPAREN
0xFF	TokenNameIntegerLiteral
>>>	TokenNameUNSIGNED_RIGHT_SHIFT
finalShift	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
finalShift	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
advanceBytes	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
