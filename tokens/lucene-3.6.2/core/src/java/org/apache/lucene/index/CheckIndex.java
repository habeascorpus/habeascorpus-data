package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
File	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
PrintStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
text	TokenNameIdentifier
.	TokenNameDOT
NumberFormat	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Comparator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Map	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
.	TokenNameDOT
AbstractField	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
.	TokenNameDOT
Document	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
IndexSearcher	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
TermQuery	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
Directory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
FSDirectory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
IndexInput	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
CommandLineUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
StringHelper	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
CheckIndex	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
PrintStream	TokenNameIdentifier
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
Status	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
boolean	TokenNameboolean
clean	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
missingSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
cantOpenSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
missingSegmentVersion	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
String	TokenNameIdentifier
segmentsFileName	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
numSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
String	TokenNameIdentifier
segmentFormat	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
List	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
segmentsChecked	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
toolOutOfDate	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
List	TokenNameIdentifier
<	TokenNameLESS
SegmentInfoStatus	TokenNameIdentifier
>	TokenNameGREATER
segmentInfos	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
SegmentInfoStatus	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
public	TokenNamepublic
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
SegmentInfos	TokenNameIdentifier
newSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
totLoseDocCount	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
numBadSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
partial	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
maxSegmentName	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
validCounter	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
userData	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
SegmentInfoStatus	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
String	TokenNameIdentifier
name	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
compound	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
numFiles	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
double	TokenNamedouble
sizeMB	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
String	TokenNameIdentifier
docStoreSegment	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
docStoreCompoundFile	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
hasDeletions	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
String	TokenNameIdentifier
deletionsFileName	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
numDeleted	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
openReaderPassed	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
numFields	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
hasProx	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
diagnostics	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
FieldNormStatus	TokenNameIdentifier
fieldNormStatus	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
TermIndexStatus	TokenNameIdentifier
termIndexStatus	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
StoredFieldStatus	TokenNameIdentifier
storedFieldStatus	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
TermVectorStatus	TokenNameIdentifier
termVectorStatus	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
FieldNormStatus	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
long	TokenNamelong
totFields	TokenNameIdentifier
=	TokenNameEQUAL
0L	TokenNameLongLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
Throwable	TokenNameIdentifier
error	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
TermIndexStatus	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
long	TokenNamelong
termCount	TokenNameIdentifier
=	TokenNameEQUAL
0L	TokenNameLongLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
long	TokenNamelong
totFreq	TokenNameIdentifier
=	TokenNameEQUAL
0L	TokenNameLongLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
long	TokenNamelong
totPos	TokenNameIdentifier
=	TokenNameEQUAL
0L	TokenNameLongLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
Throwable	TokenNameIdentifier
error	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
StoredFieldStatus	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
docCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
long	TokenNamelong
totFields	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
Throwable	TokenNameIdentifier
error	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
TermVectorStatus	TokenNameIdentifier
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
docCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
long	TokenNamelong
totVectors	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
public	TokenNamepublic
Throwable	TokenNameIdentifier
error	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
CheckIndex	TokenNameIdentifier
(	TokenNameLPAREN
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
dir	TokenNameIdentifier
=	TokenNameEQUAL
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
infoStream	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
PrintStream	TokenNameIdentifier
out	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
infoStream	TokenNameIdentifier
=	TokenNameEQUAL
out	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
msg	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
msg	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
infoStream	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
msg	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
MySegmentTermDocs	TokenNameIdentifier
extends	TokenNameextends
SegmentTermDocs	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
MySegmentTermDocs	TokenNameIdentifier
(	TokenNameLPAREN
SegmentReader	TokenNameIdentifier
p	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
p	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
seek	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
.	TokenNameDOT
seek	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
delCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
void	TokenNamevoid
skippingDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
delCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
Status	TokenNameIdentifier
checkIndex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
checkIndex	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Status	TokenNameIdentifier
checkIndex	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
onlySegments	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
NumberFormat	TokenNameIdentifier
nf	TokenNameIdentifier
=	TokenNameEQUAL
NumberFormat	TokenNameIdentifier
.	TokenNameDOT
getInstance	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
SegmentInfos	TokenNameIdentifier
sis	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Status	TokenNameIdentifier
result	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Status	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
=	TokenNameEQUAL
dir	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
sis	TokenNameIdentifier
.	TokenNameDOT
read	TokenNameIdentifier
(	TokenNameLPAREN
dir	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR: could not read any segments file in directory"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
missingSegments	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
t	TokenNameIdentifier
.	TokenNameDOT
printStackTrace	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
String	TokenNameIdentifier
oldest	TokenNameIdentifier
=	TokenNameEQUAL
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
Integer	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
newest	TokenNameIdentifier
=	TokenNameEQUAL
Integer	TokenNameIdentifier
.	TokenNameDOT
toString	TokenNameIdentifier
(	TokenNameLPAREN
Integer	TokenNameIdentifier
.	TokenNameDOT
MIN_VALUE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
oldSegs	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
boolean	TokenNameboolean
foundNonNullVersion	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
Comparator	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
versionComparator	TokenNameIdentifier
=	TokenNameEQUAL
StringHelper	TokenNameIdentifier
.	TokenNameDOT
getVersionComparator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
si	TokenNameIdentifier
:	TokenNameCOLON
sis	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
version	TokenNameIdentifier
=	TokenNameEQUAL
si	TokenNameIdentifier
.	TokenNameDOT
getVersion	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
version	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
oldSegs	TokenNameIdentifier
=	TokenNameEQUAL
"pre-3.1"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
version	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
"2.x"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
oldSegs	TokenNameIdentifier
=	TokenNameEQUAL
"2.x"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
foundNonNullVersion	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
versionComparator	TokenNameIdentifier
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
version	TokenNameIdentifier
,	TokenNameCOMMA
oldest	TokenNameIdentifier
)	TokenNameRPAREN
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
oldest	TokenNameIdentifier
=	TokenNameEQUAL
version	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
versionComparator	TokenNameIdentifier
.	TokenNameDOT
compare	TokenNameIdentifier
(	TokenNameLPAREN
version	TokenNameIdentifier
,	TokenNameCOMMA
newest	TokenNameIdentifier
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
newest	TokenNameIdentifier
=	TokenNameEQUAL
version	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
numSegments	TokenNameIdentifier
=	TokenNameEQUAL
sis	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
segmentsFileName	TokenNameIdentifier
=	TokenNameEQUAL
sis	TokenNameIdentifier
.	TokenNameDOT
getSegmentsFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
IndexInput	TokenNameIdentifier
input	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
input	TokenNameIdentifier
=	TokenNameEQUAL
dir	TokenNameIdentifier
.	TokenNameDOT
openInput	TokenNameIdentifier
(	TokenNameLPAREN
segmentsFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR: could not open segments file in directory"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
t	TokenNameIdentifier
.	TokenNameDOT
printStackTrace	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
cantOpenSegments	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
format	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
format	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
readInt	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR: could not read segment file version in directory"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
t	TokenNameIdentifier
.	TokenNameDOT
printStackTrace	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
missingSegmentVersion	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
input	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
input	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
String	TokenNameIdentifier
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
skip	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT [Lucene Pre-2.1]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_LOCKLESS	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT_LOCKLESS [Lucene 2.1]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_SINGLE_NORM_FILE	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_SHARED_DOC_STORE	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT_SHARED_DOC_STORE [Lucene 2.3]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_CHECKSUM	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT_CHECKSUM [Lucene 2.4]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_DEL_COUNT	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT_DEL_COUNT [Lucene 2.4]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_HAS_PROX	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT_HAS_PROX [Lucene 2.4]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_USER_DATA	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT_USER_DATA [Lucene 2.9]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_DIAGNOSTICS	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT_DIAGNOSTICS [Lucene 2.9]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_HAS_VECTORS	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT_HAS_VECTORS [Lucene 3.1]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
FORMAT_3_1	TokenNameIdentifier
)	TokenNameRPAREN
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"FORMAT_3_1 [Lucene 3.1+]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
CURRENT_FORMAT	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"BUG: You should update this tool!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
format	TokenNameIdentifier
<	TokenNameLESS
SegmentInfos	TokenNameIdentifier
.	TokenNameDOT
CURRENT_FORMAT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
"int="	TokenNameStringLiteral
+	TokenNamePLUS
format	TokenNameIdentifier
+	TokenNamePLUS
" [newer version of Lucene than this tool]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
skip	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
sFormat	TokenNameIdentifier
=	TokenNameEQUAL
format	TokenNameIdentifier
+	TokenNamePLUS
" [Lucene 1.3 or prior]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
result	TokenNameIdentifier
.	TokenNameDOT
segmentsFileName	TokenNameIdentifier
=	TokenNameEQUAL
segmentsFileName	TokenNameIdentifier
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
numSegments	TokenNameIdentifier
=	TokenNameEQUAL
numSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
segmentFormat	TokenNameIdentifier
=	TokenNameEQUAL
sFormat	TokenNameIdentifier
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
userData	TokenNameIdentifier
=	TokenNameEQUAL
sis	TokenNameIdentifier
.	TokenNameDOT
getUserData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
userDataString	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
sis	TokenNameIdentifier
.	TokenNameDOT
getUserData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
userDataString	TokenNameIdentifier
=	TokenNameEQUAL
" userData="	TokenNameStringLiteral
+	TokenNamePLUS
sis	TokenNameIdentifier
.	TokenNameDOT
getUserData	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
userDataString	TokenNameIdentifier
=	TokenNameEQUAL
""	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
String	TokenNameIdentifier
versionString	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
oldSegs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
foundNonNullVersion	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
versionString	TokenNameIdentifier
=	TokenNameEQUAL
"versions=["	TokenNameStringLiteral
+	TokenNamePLUS
oldSegs	TokenNameIdentifier
+	TokenNamePLUS
" .. "	TokenNameStringLiteral
+	TokenNamePLUS
newest	TokenNameIdentifier
+	TokenNamePLUS
"]"	TokenNameStringLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
versionString	TokenNameIdentifier
=	TokenNameEQUAL
"version="	TokenNameStringLiteral
+	TokenNamePLUS
oldSegs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
versionString	TokenNameIdentifier
=	TokenNameEQUAL
oldest	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
newest	TokenNameIdentifier
)	TokenNameRPAREN
?	TokenNameQUESTION
(	TokenNameLPAREN
"version="	TokenNameStringLiteral
+	TokenNamePLUS
oldest	TokenNameIdentifier
)	TokenNameRPAREN
:	TokenNameCOLON
(	TokenNameLPAREN
"versions=["	TokenNameStringLiteral
+	TokenNamePLUS
oldest	TokenNameIdentifier
+	TokenNamePLUS
" .. "	TokenNameStringLiteral
+	TokenNamePLUS
newest	TokenNameIdentifier
+	TokenNamePLUS
"]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"Segments file="	TokenNameStringLiteral
+	TokenNamePLUS
segmentsFileName	TokenNameIdentifier
+	TokenNamePLUS
" numSegments="	TokenNameStringLiteral
+	TokenNamePLUS
numSegments	TokenNameIdentifier
+	TokenNamePLUS
" "	TokenNameStringLiteral
+	TokenNamePLUS
versionString	TokenNameIdentifier
+	TokenNamePLUS
" format="	TokenNameStringLiteral
+	TokenNamePLUS
sFormat	TokenNameIdentifier
+	TokenNamePLUS
userDataString	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
onlySegments	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
.	TokenNameDOT
partial	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
infoStream	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
" Checking only these segments:"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
String	TokenNameIdentifier
s	TokenNameIdentifier
:	TokenNameCOLON
onlySegments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
infoStream	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
" "	TokenNameStringLiteral
+	TokenNamePLUS
s	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
result	TokenNameIdentifier
.	TokenNameDOT
segmentsChecked	TokenNameIdentifier
.	TokenNameDOT
addAll	TokenNameIdentifier
(	TokenNameLPAREN
onlySegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
":"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
skip	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
" ERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
toolOutOfDate	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
result	TokenNameIdentifier
.	TokenNameDOT
newSegments	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
SegmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
sis	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
newSegments	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
maxSegmentName	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numSegments	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
=	TokenNameEQUAL
sis	TokenNameIdentifier
.	TokenNameDOT
info	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
segmentName	TokenNameIdentifier
=	TokenNameEQUAL
Integer	TokenNameIdentifier
.	TokenNameDOT
parseInt	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
.	TokenNameDOT
substring	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
,	TokenNameCOMMA
Character	TokenNameIdentifier
.	TokenNameDOT
MAX_RADIX	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segmentName	TokenNameIdentifier
>	TokenNameGREATER
result	TokenNameIdentifier
.	TokenNameDOT
maxSegmentName	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
.	TokenNameDOT
maxSegmentName	TokenNameIdentifier
=	TokenNameEQUAL
segmentName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
onlySegments	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
!	TokenNameNOT
onlySegments	TokenNameIdentifier
.	TokenNameDOT
contains	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
Status	TokenNameIdentifier
.	TokenNameDOT
SegmentInfoStatus	TokenNameIdentifier
segInfoStat	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Status	TokenNameIdentifier
.	TokenNameDOT
SegmentInfoStatus	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
segInfoStat	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
"  "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
+	TokenNamePLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" of "	TokenNameStringLiteral
+	TokenNamePLUS
numSegments	TokenNameIdentifier
+	TokenNamePLUS
": name="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
+	TokenNamePLUS
" docCount="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
toLoseDocCount	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    compound="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
compound	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    hasProx="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
getHasProx	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
hasProx	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getHasProx	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    numFiles="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
numFiles	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
sizeMB	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
/	TokenNameDIVIDE
(	TokenNameLPAREN
1024.	TokenNameDoubleLiteral
*	TokenNameMULTIPLY
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    size (MB)="	TokenNameStringLiteral
+	TokenNamePLUS
nf	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
sizeMB	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Map	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
,	TokenNameCOMMA
String	TokenNameIdentifier
>	TokenNameGREATER
diagnostics	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDiagnostics	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
diagnostics	TokenNameIdentifier
=	TokenNameEQUAL
diagnostics	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
diagnostics	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    diagnostics = "	TokenNameStringLiteral
+	TokenNamePLUS
diagnostics	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDocStoreOffset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docStoreOffset	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    docStoreOffset="	TokenNameStringLiteral
+	TokenNamePLUS
docStoreOffset	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
docStoreOffset	TokenNameIdentifier
=	TokenNameEQUAL
docStoreOffset	TokenNameIdentifier
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    docStoreSegment="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
getDocStoreSegment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
docStoreSegment	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDocStoreSegment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    docStoreIsCompoundFile="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
getDocStoreIsCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
docStoreCompoundFile	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDocStoreIsCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
String	TokenNameIdentifier
delFileName	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDelFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
delFileName	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    no deletions"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    has deletions [delFileName="	TokenNameStringLiteral
+	TokenNamePLUS
delFileName	TokenNameIdentifier
+	TokenNamePLUS
"]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
deletionsFileName	TokenNameIdentifier
=	TokenNameEQUAL
delFileName	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
infoStream	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"    test: open reader........."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
reader	TokenNameIdentifier
=	TokenNameEQUAL
SegmentReader	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
info	TokenNameIdentifier
,	TokenNameCOMMA
IndexReader	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_TERMS_INDEX_DIVISOR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
openReaderPassed	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
numDocs	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
toLoseDocCount	TokenNameIdentifier
=	TokenNameEQUAL
numDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"delete count mismatch: info="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs deletedDocs.count()="	TokenNameStringLiteral
+	TokenNamePLUS
reader	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"too many deleted docs: maxDoc()="	TokenNameStringLiteral
+	TokenNamePLUS
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs deletedDocs.count()="	TokenNameStringLiteral
+	TokenNamePLUS
reader	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
-	TokenNameMINUS
numDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
info	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"delete count mismatch: info="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs reader="	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
-	TokenNameMINUS
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
numLive	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
numLive	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
numLive	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"liveDocs count mismatch: info="	TokenNameStringLiteral
+	TokenNamePLUS
numDocs	TokenNameIdentifier
+	TokenNamePLUS
", vs bits="	TokenNameStringLiteral
+	TokenNamePLUS
numLive	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
numDeleted	TokenNameIdentifier
=	TokenNameEQUAL
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
-	TokenNameMINUS
numDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
"OK ["	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
numDeleted	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" deleted docs]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"delete count mismatch: info="	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
getDelCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs reader="	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
-	TokenNameMINUS
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"liveDocs mismatch: info says no deletions but doc "	TokenNameStringLiteral
+	TokenNamePLUS
j	TokenNameIdentifier
+	TokenNamePLUS
" is deleted."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"OK"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"SegmentReader.maxDoc() "	TokenNameStringLiteral
+	TokenNamePLUS
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" != SegmentInfos.docCount "	TokenNameStringLiteral
+	TokenNamePLUS
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
infoStream	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"    test: fields.............."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
FieldInfos	TokenNameIdentifier
fieldInfos	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
getFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
"OK ["	TokenNameStringLiteral
+	TokenNamePLUS
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" fields]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
numFields	TokenNameIdentifier
=	TokenNameEQUAL
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
fieldNormStatus	TokenNameIdentifier
=	TokenNameEQUAL
testFieldNorms	TokenNameIdentifier
(	TokenNameLPAREN
fieldInfos	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
termIndexStatus	TokenNameIdentifier
=	TokenNameEQUAL
testTermIndex	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
fieldInfos	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
storedFieldStatus	TokenNameIdentifier
=	TokenNameEQUAL
testStoredFields	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
,	TokenNameCOMMA
nf	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
termVectorStatus	TokenNameIdentifier
=	TokenNameEQUAL
testTermVectors	TokenNameIdentifier
(	TokenNameLPAREN
info	TokenNameIdentifier
,	TokenNameCOMMA
reader	TokenNameIdentifier
,	TokenNameCOMMA
nf	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
fieldNormStatus	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Field Norm test failed"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
termIndexStatus	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Term Index test failed"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
storedFieldStatus	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Stored Field test failed"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
segInfoStat	TokenNameIdentifier
.	TokenNameDOT
termVectorStatus	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"Term Vector test failed"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
""	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"FAILED"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
comment	TokenNameIdentifier
;	TokenNameSEMICOLON
comment	TokenNameIdentifier
=	TokenNameEQUAL
"fixIndex() would remove reference to this segment"	TokenNameStringLiteral
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
"    WARNING: "	TokenNameStringLiteral
+	TokenNamePLUS
comment	TokenNameIdentifier
+	TokenNamePLUS
"; full exception:"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
t	TokenNameIdentifier
.	TokenNameDOT
printStackTrace	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
""	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
totLoseDocCount	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
toLoseDocCount	TokenNameIdentifier
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
numBadSegments	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
result	TokenNameIdentifier
.	TokenNameDOT
newSegments	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
)	TokenNameRPAREN
info	TokenNameIdentifier
.	TokenNameDOT
clone	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
result	TokenNameIdentifier
.	TokenNameDOT
numBadSegments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
.	TokenNameDOT
clean	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
msg	TokenNameIdentifier
(	TokenNameLPAREN
"WARNING: "	TokenNameStringLiteral
+	TokenNamePLUS
result	TokenNameIdentifier
.	TokenNameDOT
numBadSegments	TokenNameIdentifier
+	TokenNamePLUS
" broken segments (containing "	TokenNameStringLiteral
+	TokenNamePLUS
result	TokenNameIdentifier
.	TokenNameDOT
totLoseDocCount	TokenNameIdentifier
+	TokenNamePLUS
" documents) detected"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
validCounter	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
maxSegmentName	TokenNameIdentifier
<	TokenNameLESS
sis	TokenNameIdentifier
.	TokenNameDOT
counter	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
result	TokenNameIdentifier
.	TokenNameDOT
clean	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
newSegments	TokenNameIdentifier
.	TokenNameDOT
counter	TokenNameIdentifier
=	TokenNameEQUAL
result	TokenNameIdentifier
.	TokenNameDOT
maxSegmentName	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
msg	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR: Next segment name counter "	TokenNameStringLiteral
+	TokenNamePLUS
sis	TokenNameIdentifier
.	TokenNameDOT
counter	TokenNameIdentifier
+	TokenNamePLUS
" is not greater than max segment name "	TokenNameStringLiteral
+	TokenNamePLUS
result	TokenNameIdentifier
.	TokenNameDOT
maxSegmentName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
clean	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"No problems were detected with this index. "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
result	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Status	TokenNameIdentifier
.	TokenNameDOT
FieldNormStatus	TokenNameIdentifier
testFieldNorms	TokenNameIdentifier
(	TokenNameLPAREN
FieldInfos	TokenNameIdentifier
fieldInfos	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Status	TokenNameIdentifier
.	TokenNameDOT
FieldNormStatus	TokenNameIdentifier
status	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Status	TokenNameIdentifier
.	TokenNameDOT
FieldNormStatus	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
infoStream	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"    test: field norms........."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
b	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
FieldInfo	TokenNameIdentifier
fieldInfo	TokenNameIdentifier
:	TokenNameCOLON
fieldInfos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
hasNorms	TokenNameIdentifier
(	TokenNameLPAREN
fieldInfo	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
reader	TokenNameIdentifier
.	TokenNameDOT
norms	TokenNameIdentifier
(	TokenNameLPAREN
fieldInfo	TokenNameIdentifier
.	TokenNameDOT
name	TokenNameIdentifier
,	TokenNameCOMMA
b	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
status	TokenNameIdentifier
.	TokenNameDOT
totFields	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"OK ["	TokenNameStringLiteral
+	TokenNamePLUS
status	TokenNameIdentifier
.	TokenNameDOT
totFields	TokenNameIdentifier
+	TokenNamePLUS
" fields]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR ["	TokenNameStringLiteral
+	TokenNamePLUS
String	TokenNameIdentifier
.	TokenNameDOT
valueOf	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
status	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
=	TokenNameEQUAL
e	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
e	TokenNameIdentifier
.	TokenNameDOT
printStackTrace	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
status	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Status	TokenNameIdentifier
.	TokenNameDOT
TermIndexStatus	TokenNameIdentifier
testTermIndex	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
,	TokenNameCOMMA
FieldInfos	TokenNameIdentifier
fieldInfos	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Status	TokenNameIdentifier
.	TokenNameDOT
TermIndexStatus	TokenNameIdentifier
status	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Status	TokenNameIdentifier
.	TokenNameDOT
TermIndexStatus	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
IndexSearcher	TokenNameIdentifier
is	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IndexSearcher	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
infoStream	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"    test: terms, freq, prox..."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
TermEnum	TokenNameIdentifier
termEnum	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
terms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
TermPositions	TokenNameIdentifier
termPositions	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
termPositions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
MySegmentTermDocs	TokenNameIdentifier
myTermDocs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
MySegmentTermDocs	TokenNameIdentifier
(	TokenNameLPAREN
reader	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
maxDoc	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
maxDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Term	TokenNameIdentifier
lastTerm	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
String	TokenNameIdentifier
lastField	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
termEnum	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
status	TokenNameIdentifier
.	TokenNameDOT
termCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
final	TokenNamefinal
Term	TokenNameIdentifier
term	TokenNameIdentifier
=	TokenNameEQUAL
termEnum	TokenNameIdentifier
.	TokenNameDOT
term	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lastTerm	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
term	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
lastTerm	TokenNameIdentifier
)	TokenNameRPAREN
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"terms out of order: lastTerm="	TokenNameStringLiteral
+	TokenNamePLUS
lastTerm	TokenNameIdentifier
+	TokenNamePLUS
" term="	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lastTerm	TokenNameIdentifier
=	TokenNameEQUAL
term	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
field	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
lastField	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
FieldInfo	TokenNameIdentifier
fi	TokenNameIdentifier
=	TokenNameEQUAL
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
fieldInfo	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
.	TokenNameDOT
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
fi	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"terms inconsistent with fieldInfos, no fieldInfos for: "	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
.	TokenNameDOT
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
fi	TokenNameIdentifier
.	TokenNameDOT
isIndexed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"terms inconsistent with fieldInfos, isIndexed == false for: "	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
.	TokenNameDOT
field	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lastField	TokenNameIdentifier
=	TokenNameEQUAL
term	TokenNameIdentifier
.	TokenNameDOT
field	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
docFreq	TokenNameIdentifier
=	TokenNameEQUAL
termEnum	TokenNameIdentifier
.	TokenNameDOT
docFreq	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docFreq	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"docfreq: "	TokenNameStringLiteral
+	TokenNamePLUS
docFreq	TokenNameIdentifier
+	TokenNamePLUS
" is out of bounds"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
termPositions	TokenNameIdentifier
.	TokenNameDOT
seek	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
lastDoc	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
freq0	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
status	TokenNameIdentifier
.	TokenNameDOT
totFreq	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
docFreq	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
termPositions	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
freq0	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
doc	TokenNameIdentifier
=	TokenNameEQUAL
termPositions	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
freq	TokenNameIdentifier
=	TokenNameEQUAL
termPositions	TokenNameIdentifier
.	TokenNameDOT
freq	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doc	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
lastDoc	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"term "	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
+	TokenNamePLUS
": doc "	TokenNameStringLiteral
+	TokenNamePLUS
doc	TokenNameIdentifier
+	TokenNamePLUS
" <= lastDoc "	TokenNameStringLiteral
+	TokenNamePLUS
lastDoc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doc	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
maxDoc	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"term "	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
+	TokenNamePLUS
": doc "	TokenNameStringLiteral
+	TokenNamePLUS
doc	TokenNameIdentifier
+	TokenNamePLUS
" >= maxDoc "	TokenNameStringLiteral
+	TokenNamePLUS
maxDoc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
lastDoc	TokenNameIdentifier
=	TokenNameEQUAL
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
freq	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"term "	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
+	TokenNamePLUS
": doc "	TokenNameStringLiteral
+	TokenNamePLUS
doc	TokenNameIdentifier
+	TokenNamePLUS
": freq "	TokenNameStringLiteral
+	TokenNamePLUS
freq	TokenNameIdentifier
+	TokenNamePLUS
" is out of bounds"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
lastPos	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
status	TokenNameIdentifier
.	TokenNameDOT
totPos	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
freq	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
freq	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
termPositions	TokenNameIdentifier
.	TokenNameDOT
nextPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
<	TokenNameLESS
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"term "	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
+	TokenNamePLUS
": doc "	TokenNameStringLiteral
+	TokenNamePLUS
doc	TokenNameIdentifier
+	TokenNamePLUS
": pos "	TokenNameStringLiteral
+	TokenNamePLUS
pos	TokenNameIdentifier
+	TokenNamePLUS
" is out of bounds"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
<	TokenNameLESS
lastPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"term "	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
+	TokenNamePLUS
": doc "	TokenNameStringLiteral
+	TokenNamePLUS
doc	TokenNameIdentifier
+	TokenNamePLUS
": pos "	TokenNameStringLiteral
+	TokenNamePLUS
pos	TokenNameIdentifier
+	TokenNamePLUS
" < lastPos "	TokenNameStringLiteral
+	TokenNamePLUS
lastPos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lastPos	TokenNameIdentifier
=	TokenNameEQUAL
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
<	TokenNameLESS
7	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
skipDocID	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
int	TokenNameint
)	TokenNameRPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
idx	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
*	TokenNameMULTIPLY
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
maxDoc	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
8	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
termPositions	TokenNameIdentifier
.	TokenNameDOT
seek	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
termPositions	TokenNameIdentifier
.	TokenNameDOT
skipTo	TokenNameIdentifier
(	TokenNameLPAREN
skipDocID	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
docID	TokenNameIdentifier
=	TokenNameEQUAL
termPositions	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docID	TokenNameIdentifier
<	TokenNameLESS
skipDocID	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"term "	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
+	TokenNamePLUS
": skipTo(docID="	TokenNameStringLiteral
+	TokenNamePLUS
skipDocID	TokenNameIdentifier
+	TokenNamePLUS
") returned docID="	TokenNameStringLiteral
+	TokenNamePLUS
docID	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
freq	TokenNameIdentifier
=	TokenNameEQUAL
termPositions	TokenNameIdentifier
.	TokenNameDOT
freq	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
freq	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"termFreq "	TokenNameStringLiteral
+	TokenNamePLUS
freq	TokenNameIdentifier
+	TokenNamePLUS
" is out of bounds"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
lastPosition	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
posUpto	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
posUpto	TokenNameIdentifier
<	TokenNameLESS
freq	TokenNameIdentifier
;	TokenNameSEMICOLON
posUpto	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
pos	TokenNameIdentifier
=	TokenNameEQUAL
termPositions	TokenNameIdentifier
.	TokenNameDOT
nextPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
<	TokenNameLESS
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"position "	TokenNameStringLiteral
+	TokenNamePLUS
pos	TokenNameIdentifier
+	TokenNamePLUS
" is out of bounds"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
pos	TokenNameIdentifier
<	TokenNameLESS
lastPosition	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"position "	TokenNameStringLiteral
+	TokenNamePLUS
pos	TokenNameIdentifier
+	TokenNamePLUS
" is < lastPosition "	TokenNameStringLiteral
+	TokenNamePLUS
lastPosition	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lastPosition	TokenNameIdentifier
=	TokenNameEQUAL
pos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
termPositions	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
nextDocID	TokenNameIdentifier
=	TokenNameEQUAL
termPositions	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nextDocID	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
docID	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"term "	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
+	TokenNamePLUS
": skipTo(docID="	TokenNameStringLiteral
+	TokenNamePLUS
skipDocID	TokenNameIdentifier
+	TokenNamePLUS
"), then .next() returned docID="	TokenNameStringLiteral
+	TokenNamePLUS
nextDocID	TokenNameIdentifier
+	TokenNamePLUS
" vs prev docID="	TokenNameStringLiteral
+	TokenNamePLUS
docID	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
reader	TokenNameIdentifier
.	TokenNameDOT
hasDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
myTermDocs	TokenNameIdentifier
.	TokenNameDOT
seek	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
myTermDocs	TokenNameIdentifier
.	TokenNameDOT
next	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
delCount	TokenNameIdentifier
=	TokenNameEQUAL
myTermDocs	TokenNameIdentifier
.	TokenNameDOT
delCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
delCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
freq0	TokenNameIdentifier
+	TokenNamePLUS
delCount	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
docFreq	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"term "	TokenNameStringLiteral
+	TokenNamePLUS
term	TokenNameIdentifier
+	TokenNamePLUS
" docFreq="	TokenNameStringLiteral
+	TokenNamePLUS
docFreq	TokenNameIdentifier
+	TokenNamePLUS
" != num docs seen "	TokenNameStringLiteral
+	TokenNamePLUS
freq0	TokenNameIdentifier
+	TokenNamePLUS
" + num docs deleted "	TokenNameStringLiteral
+	TokenNamePLUS
delCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
lastTerm	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
is	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
TermQuery	TokenNameIdentifier
(	TokenNameLPAREN
lastTerm	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
long	TokenNamelong
uniqueTermCountAllFields	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
getUniqueTermCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
status	TokenNameIdentifier
.	TokenNameDOT
termCount	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
uniqueTermCountAllFields	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"termCount mismatch "	TokenNameStringLiteral
+	TokenNamePLUS
uniqueTermCountAllFields	TokenNameIdentifier
+	TokenNamePLUS
" vs "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
status	TokenNameIdentifier
.	TokenNameDOT
termCount	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
UnsupportedOperationException	TokenNameIdentifier
ex	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"OK ["	TokenNameStringLiteral
+	TokenNamePLUS
status	TokenNameIdentifier
.	TokenNameDOT
termCount	TokenNameIdentifier
+	TokenNamePLUS
" terms; "	TokenNameStringLiteral
+	TokenNamePLUS
status	TokenNameIdentifier
.	TokenNameDOT
totFreq	TokenNameIdentifier
+	TokenNamePLUS
" terms/docs pairs; "	TokenNameStringLiteral
+	TokenNamePLUS
status	TokenNameIdentifier
.	TokenNameDOT
totPos	TokenNameIdentifier
+	TokenNamePLUS
" tokens]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR ["	TokenNameStringLiteral
+	TokenNamePLUS
String	TokenNameIdentifier
.	TokenNameDOT
valueOf	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
status	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
=	TokenNameEQUAL
e	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
e	TokenNameIdentifier
.	TokenNameDOT
printStackTrace	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
status	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Status	TokenNameIdentifier
.	TokenNameDOT
StoredFieldStatus	TokenNameIdentifier
testStoredFields	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
,	TokenNameCOMMA
NumberFormat	TokenNameIdentifier
format	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Status	TokenNameIdentifier
.	TokenNameDOT
StoredFieldStatus	TokenNameIdentifier
status	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Status	TokenNameIdentifier
.	TokenNameDOT
StoredFieldStatus	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
infoStream	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"    test: stored fields......."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
j	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Document	TokenNameIdentifier
doc	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
status	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
status	TokenNameIdentifier
.	TokenNameDOT
totFields	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
doc	TokenNameIdentifier
.	TokenNameDOT
getFields	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
status	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
numDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
RuntimeException	TokenNameIdentifier
(	TokenNameLPAREN
"docCount="	TokenNameStringLiteral
+	TokenNamePLUS
status	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
+	TokenNamePLUS
" but saw "	TokenNameStringLiteral
+	TokenNamePLUS
status	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
+	TokenNamePLUS
" undeleted docs"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"OK ["	TokenNameStringLiteral
+	TokenNamePLUS
status	TokenNameIdentifier
.	TokenNameDOT
totFields	TokenNameIdentifier
+	TokenNamePLUS
" total field count; avg "	TokenNameStringLiteral
+	TokenNamePLUS
format	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
status	TokenNameIdentifier
.	TokenNameDOT
totFields	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
status	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" fields per doc]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR ["	TokenNameStringLiteral
+	TokenNamePLUS
String	TokenNameIdentifier
.	TokenNameDOT
valueOf	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
status	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
=	TokenNameEQUAL
e	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
e	TokenNameIdentifier
.	TokenNameDOT
printStackTrace	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
status	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
Status	TokenNameIdentifier
.	TokenNameDOT
TermVectorStatus	TokenNameIdentifier
testTermVectors	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
info	TokenNameIdentifier
,	TokenNameCOMMA
SegmentReader	TokenNameIdentifier
reader	TokenNameIdentifier
,	TokenNameCOMMA
NumberFormat	TokenNameIdentifier
format	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Status	TokenNameIdentifier
.	TokenNameDOT
TermVectorStatus	TokenNameIdentifier
status	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Status	TokenNameIdentifier
.	TokenNameDOT
TermVectorStatus	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
infoStream	TokenNameIdentifier
.	TokenNameDOT
print	TokenNameIdentifier
(	TokenNameLPAREN
"    test: term vectors........"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
info	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
j	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
reader	TokenNameIdentifier
.	TokenNameDOT
isDeleted	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
status	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
TermFreqVector	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
tfv	TokenNameIdentifier
=	TokenNameEQUAL
reader	TokenNameIdentifier
.	TokenNameDOT
getTermFreqVectors	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
tfv	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
status	TokenNameIdentifier
.	TokenNameDOT
totVectors	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
tfv	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"OK ["	TokenNameStringLiteral
+	TokenNamePLUS
status	TokenNameIdentifier
.	TokenNameDOT
totVectors	TokenNameIdentifier
+	TokenNamePLUS
" total vector count; avg "	TokenNameStringLiteral
+	TokenNamePLUS
format	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
(	TokenNameLPAREN
float	TokenNamefloat
)	TokenNameRPAREN
status	TokenNameIdentifier
.	TokenNameDOT
totVectors	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
status	TokenNameIdentifier
.	TokenNameDOT
docCount	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" term/freq vector fields per doc]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
msg	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR ["	TokenNameStringLiteral
+	TokenNamePLUS
String	TokenNameIdentifier
.	TokenNameDOT
valueOf	TokenNameIdentifier
(	TokenNameLPAREN
e	TokenNameIdentifier
.	TokenNameDOT
getMessage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"]"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
status	TokenNameIdentifier
.	TokenNameDOT
error	TokenNameIdentifier
=	TokenNameEQUAL
e	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
e	TokenNameIdentifier
.	TokenNameDOT
printStackTrace	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
status	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
fixIndex	TokenNameIdentifier
(	TokenNameLPAREN
Status	TokenNameIdentifier
result	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
partial	TokenNameIdentifier
)	TokenNameRPAREN
throw	TokenNamethrow
new	TokenNamenew
IllegalArgumentException	TokenNameIdentifier
(	TokenNameLPAREN
"can only fix an index that was fully checked (this status checked a subset of segments)"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
newSegments	TokenNameIdentifier
.	TokenNameDOT
changed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
result	TokenNameIdentifier
.	TokenNameDOT
newSegments	TokenNameIdentifier
.	TokenNameDOT
commit	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
dir	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
assertsOn	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
testAsserts	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assertsOn	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
boolean	TokenNameboolean
assertsOn	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
testAsserts	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
assertsOn	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
void	TokenNamevoid
main	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
args	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
,	TokenNameCOMMA
InterruptedException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
doFix	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
List	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
onlySegments	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
String	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
String	TokenNameIdentifier
indexPath	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
String	TokenNameIdentifier
dirImpl	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
i	TokenNameIdentifier
<	TokenNameLESS
args	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
String	TokenNameIdentifier
arg	TokenNameIdentifier
=	TokenNameEQUAL
args	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
"-fix"	TokenNameStringLiteral
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
arg	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
doFix	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
args	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
"-segment"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
args	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR: missing name for -segment option"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
exit	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
onlySegments	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
args	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
"-dir-impl"	TokenNameStringLiteral
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
arg	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
i	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
args	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR: missing value for -dir-impl option"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
exit	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
dirImpl	TokenNameIdentifier
=	TokenNameEQUAL
args	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
indexPath	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR: unexpected extra argument '"	TokenNameStringLiteral
+	TokenNamePLUS
args	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
+	TokenNamePLUS
"'"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
exit	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
indexPath	TokenNameIdentifier
=	TokenNameEQUAL
args	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
indexPath	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
" ERROR: index path not specified"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
" Usage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-segment X] [-segment Y] [-dir-impl X] "	TokenNameStringLiteral
+	TokenNamePLUS
" "	TokenNameStringLiteral
+	TokenNamePLUS
"  -fix: actually write a new segments_N file, removing any problematic segments "	TokenNameStringLiteral
+	TokenNamePLUS
"  -segment X: only check the specified segments.  This can be specified multiple "	TokenNameStringLiteral
+	TokenNamePLUS
"              times, to check more than one segment, eg '-segment _2 -segment _a'. "	TokenNameStringLiteral
+	TokenNamePLUS
"              You can't use this with the -fix option "	TokenNameStringLiteral
+	TokenNamePLUS
"  -dir-impl X: use a specific "	TokenNameStringLiteral
+	TokenNamePLUS
FSDirectory	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
.	TokenNameDOT
getSimpleName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" implementation. "	TokenNameStringLiteral
+	TokenNamePLUS
"If no package is specified the "	TokenNameStringLiteral
+	TokenNamePLUS
FSDirectory	TokenNameIdentifier
.	TokenNameDOT
class	TokenNameclass
.	TokenNameDOT
getPackage	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" package will be used. "	TokenNameStringLiteral
+	TokenNamePLUS
"**WARNING**: -fix should only be used on an emergency basis as it will cause "	TokenNameStringLiteral
+	TokenNamePLUS
"documents (perhaps many) to be permanently removed from the index.  Always make "	TokenNameStringLiteral
+	TokenNamePLUS
"a backup copy of your index before running this!  Do not run this tool on an index "	TokenNameStringLiteral
+	TokenNamePLUS
"that is actively being written to.  You have been warned! "	TokenNameStringLiteral
+	TokenNamePLUS
" "	TokenNameStringLiteral
+	TokenNamePLUS
"Run without -fix, this tool will open the index, report version information "	TokenNameStringLiteral
+	TokenNamePLUS
"and report any exceptions it hits and what action it would take if -fix were "	TokenNameStringLiteral
+	TokenNamePLUS
"specified.  With -fix, this tool will remove any segments that have issues and "	TokenNameStringLiteral
+	TokenNamePLUS
"write a new segments_N file.  This means all documents contained in the affected "	TokenNameStringLiteral
+	TokenNamePLUS
"segments will be removed. "	TokenNameStringLiteral
+	TokenNamePLUS
" "	TokenNameStringLiteral
+	TokenNamePLUS
"This tool exits with exit code 1 if the index cannot be opened or has any "	TokenNameStringLiteral
+	TokenNamePLUS
"corruption, else 0. "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
exit	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
assertsOn	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
" NOTE: testing will be more thorough if you run java with '-ea:org.apache.lucene...', so assertions are enabled"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
onlySegments	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
onlySegments	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
doFix	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR: cannot specify both -fix and -segment"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
exit	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
" Opening index @ "	TokenNameStringLiteral
+	TokenNamePLUS
indexPath	TokenNameIdentifier
+	TokenNamePLUS
" "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Directory	TokenNameIdentifier
dir	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
dirImpl	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
dir	TokenNameIdentifier
=	TokenNameEQUAL
FSDirectory	TokenNameIdentifier
.	TokenNameDOT
open	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
File	TokenNameIdentifier
(	TokenNameLPAREN
indexPath	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
dir	TokenNameIdentifier
=	TokenNameEQUAL
CommandLineUtil	TokenNameIdentifier
.	TokenNameDOT
newFSDirectory	TokenNameIdentifier
(	TokenNameLPAREN
dirImpl	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
File	TokenNameIdentifier
(	TokenNameLPAREN
indexPath	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"ERROR: could not open directory ""	TokenNameStringLiteral
+	TokenNamePLUS
indexPath	TokenNameIdentifier
+	TokenNamePLUS
""; exiting"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
t	TokenNameIdentifier
.	TokenNameDOT
printStackTrace	TokenNameIdentifier
(	TokenNameLPAREN
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
exit	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
CheckIndex	TokenNameIdentifier
checker	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CheckIndex	TokenNameIdentifier
(	TokenNameLPAREN
dir	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checker	TokenNameIdentifier
.	TokenNameDOT
setInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Status	TokenNameIdentifier
result	TokenNameIdentifier
=	TokenNameEQUAL
checker	TokenNameIdentifier
.	TokenNameDOT
checkIndex	TokenNameIdentifier
(	TokenNameLPAREN
onlySegments	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
missingSegments	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
exit	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
result	TokenNameIdentifier
.	TokenNameDOT
clean	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
doFix	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"WARNING: would write new segments file, and "	TokenNameStringLiteral
+	TokenNamePLUS
result	TokenNameIdentifier
.	TokenNameDOT
totLoseDocCount	TokenNameIdentifier
+	TokenNamePLUS
" documents would be lost, if -fix were specified "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"WARNING: "	TokenNameStringLiteral
+	TokenNamePLUS
result	TokenNameIdentifier
.	TokenNameDOT
totLoseDocCount	TokenNameIdentifier
+	TokenNamePLUS
" documents will be lost "	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"NOTE: will write new segments file in 5 seconds; this will remove "	TokenNameStringLiteral
+	TokenNamePLUS
result	TokenNameIdentifier
.	TokenNameDOT
totLoseDocCount	TokenNameIdentifier
+	TokenNamePLUS
" docs from the index. THIS IS YOUR LAST CHANCE TO CTRL+C!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
s	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
s	TokenNameIdentifier
<	TokenNameLESS
5	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
s	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
Thread	TokenNameIdentifier
.	TokenNameDOT
sleep	TokenNameIdentifier
(	TokenNameLPAREN
1000	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"  "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
5	TokenNameIntegerLiteral
-	TokenNameMINUS
s	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
"..."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"Writing..."	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
checker	TokenNameIdentifier
.	TokenNameDOT
fixIndex	TokenNameIdentifier
(	TokenNameLPAREN
result	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"OK"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
"Wrote new segments file ""	TokenNameStringLiteral
+	TokenNamePLUS
result	TokenNameIdentifier
.	TokenNameDOT
newSegments	TokenNameIdentifier
.	TokenNameDOT
getSegmentsFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
"""	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
System	TokenNameIdentifier
.	TokenNameDOT
out	TokenNameIdentifier
.	TokenNameDOT
println	TokenNameIdentifier
(	TokenNameLPAREN
""	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
exitCode	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
result	TokenNameIdentifier
.	TokenNameDOT
clean	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
true	TokenNametrue
)	TokenNameRPAREN
exitCode	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
else	TokenNameelse
exitCode	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
exit	TokenNameIdentifier
(	TokenNameLPAREN
exitCode	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
