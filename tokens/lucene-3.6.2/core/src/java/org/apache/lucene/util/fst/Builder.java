package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
fst	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
IntsRef	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
RamUsageEstimator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
fst	TokenNameIdentifier
.	TokenNameDOT
FST	TokenNameIdentifier
.	TokenNameDOT
INPUT_TYPE	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
Builder	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
NodeHash	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
dedupHash	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
FST	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
fst	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
T	TokenNameIdentifier
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
minSuffixCount1	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
minSuffixCount2	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
doShareNonSingletonNodes	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
shareMaxTailLength	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
IntsRef	TokenNameIdentifier
lastInput	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IntsRef	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
[	TokenNameLBRACKET
]	TokenNameRBRACKET
frontier	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
static	TokenNamestatic
abstract	TokenNameabstract
class	TokenNameclass
FreezeTail	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
public	TokenNamepublic
abstract	TokenNameabstract
void	TokenNamevoid
freeze	TokenNameIdentifier
(	TokenNameLPAREN
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
[	TokenNameLBRACKET
]	TokenNameRBRACKET
frontier	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
prefixLenPlus1	TokenNameIdentifier
,	TokenNameCOMMA
IntsRef	TokenNameIdentifier
prevInput	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
FreezeTail	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
freezeTail	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Builder	TokenNameIdentifier
(	TokenNameLPAREN
FST	TokenNameIdentifier
.	TokenNameDOT
INPUT_TYPE	TokenNameIdentifier
inputType	TokenNameIdentifier
,	TokenNameCOMMA
Outputs	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
outputs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
(	TokenNameLPAREN
inputType	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
Integer	TokenNameIdentifier
.	TokenNameDOT
MAX_VALUE	TokenNameIdentifier
,	TokenNameCOMMA
outputs	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
Builder	TokenNameIdentifier
(	TokenNameLPAREN
FST	TokenNameIdentifier
.	TokenNameDOT
INPUT_TYPE	TokenNameIdentifier
inputType	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
minSuffixCount1	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
minSuffixCount2	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
doShareSuffix	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
doShareNonSingletonNodes	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
shareMaxTailLength	TokenNameIdentifier
,	TokenNameCOMMA
Outputs	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
outputs	TokenNameIdentifier
,	TokenNameCOMMA
FreezeTail	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
freezeTail	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
willPackFST	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
minSuffixCount1	TokenNameIdentifier
=	TokenNameEQUAL
minSuffixCount1	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
minSuffixCount2	TokenNameIdentifier
=	TokenNameEQUAL
minSuffixCount2	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
freezeTail	TokenNameIdentifier
=	TokenNameEQUAL
freezeTail	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
doShareNonSingletonNodes	TokenNameIdentifier
=	TokenNameEQUAL
doShareNonSingletonNodes	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
shareMaxTailLength	TokenNameIdentifier
=	TokenNameEQUAL
shareMaxTailLength	TokenNameIdentifier
;	TokenNameSEMICOLON
fst	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FST	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
inputType	TokenNameIdentifier
,	TokenNameCOMMA
outputs	TokenNameIdentifier
,	TokenNameCOMMA
willPackFST	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doShareSuffix	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
dedupHash	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
NodeHash	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
fst	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
dedupHash	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
NO_OUTPUT	TokenNameIdentifier
=	TokenNameEQUAL
outputs	TokenNameIdentifier
.	TokenNameDOT
getNoOutput	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
{	TokenNameLBRACE
"rawtypes"	TokenNameStringLiteral
,	TokenNameCOMMA
"unchecked"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
[	TokenNameLBRACKET
]	TokenNameRBRACKET
f	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
[	TokenNameLBRACKET
]	TokenNameRBRACKET
)	TokenNameRPAREN
new	TokenNamenew
UnCompiledNode	TokenNameIdentifier
[	TokenNameLBRACKET
10	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
frontier	TokenNameIdentifier
=	TokenNameEQUAL
f	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
<	TokenNameLESS
frontier	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
this	TokenNamethis
,	TokenNameCOMMA
idx	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getTotStateCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fst	TokenNameIdentifier
.	TokenNameDOT
nodeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
long	TokenNamelong
getTermCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
inputCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
int	TokenNameint
getMappedStateCount	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
dedupHash	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
0	TokenNameIntegerLiteral
:	TokenNameCOLON
fst	TokenNameIdentifier
.	TokenNameDOT
nodeCount	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setAllowArrayArcs	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
b	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
fst	TokenNameIdentifier
.	TokenNameDOT
setAllowArrayArcs	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
CompiledNode	TokenNameIdentifier
compileNode	TokenNameIdentifier
(	TokenNameLPAREN
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
nodeIn	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
tailLength	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
node	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
dedupHash	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
(	TokenNameLPAREN
doShareNonSingletonNodes	TokenNameIdentifier
||	TokenNameOR_OR
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
tailLength	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
shareMaxTailLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
nodeIn	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
node	TokenNameIdentifier
=	TokenNameEQUAL
fst	TokenNameIdentifier
.	TokenNameDOT
addNode	TokenNameIdentifier
(	TokenNameLPAREN
nodeIn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
node	TokenNameIdentifier
=	TokenNameEQUAL
dedupHash	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
nodeIn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
node	TokenNameIdentifier
=	TokenNameEQUAL
fst	TokenNameIdentifier
.	TokenNameDOT
addNode	TokenNameIdentifier
(	TokenNameLPAREN
nodeIn	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
node	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
-	TokenNameMINUS
2	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
nodeIn	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
CompiledNode	TokenNameIdentifier
fn	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CompiledNode	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fn	TokenNameIdentifier
.	TokenNameDOT
node	TokenNameIdentifier
=	TokenNameEQUAL
node	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
fn	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
freezeTail	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
prefixLenPlus1	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
freezeTail	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
freezeTail	TokenNameIdentifier
.	TokenNameDOT
freeze	TokenNameIdentifier
(	TokenNameLPAREN
frontier	TokenNameIdentifier
,	TokenNameCOMMA
prefixLenPlus1	TokenNameIdentifier
,	TokenNameCOMMA
lastInput	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
downTo	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
max	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
prefixLenPlus1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
lastInput	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
downTo	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
boolean	TokenNameboolean
doPrune	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
boolean	TokenNameboolean
doCompile	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
node	TokenNameIdentifier
=	TokenNameEQUAL
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
parent	TokenNameIdentifier
=	TokenNameEQUAL
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
node	TokenNameIdentifier
.	TokenNameDOT
inputCount	TokenNameIdentifier
<	TokenNameLESS
minSuffixCount1	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
doPrune	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
doCompile	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
idx	TokenNameIdentifier
>	TokenNameGREATER
prefixLenPlus1	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
parent	TokenNameIdentifier
.	TokenNameDOT
inputCount	TokenNameIdentifier
<	TokenNameLESS
minSuffixCount2	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
minSuffixCount2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
parent	TokenNameIdentifier
.	TokenNameDOT
inputCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
idx	TokenNameIdentifier
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
doPrune	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
doPrune	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
doCompile	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
doCompile	TokenNameIdentifier
=	TokenNameEQUAL
minSuffixCount2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
node	TokenNameIdentifier
.	TokenNameDOT
inputCount	TokenNameIdentifier
<	TokenNameLESS
minSuffixCount2	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
minSuffixCount2	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
node	TokenNameIdentifier
.	TokenNameDOT
inputCount	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
&&	TokenNameAND_AND
idx	TokenNameIdentifier
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
arcIdx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
<	TokenNameLESS
node	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
{	TokenNameLBRACE
"rawtypes"	TokenNameStringLiteral
,	TokenNameCOMMA
"unchecked"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
target	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
)	TokenNameRPAREN
node	TokenNameIdentifier
.	TokenNameDOT
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
target	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
node	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doPrune	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
node	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
parent	TokenNameIdentifier
.	TokenNameDOT
deleteLast	TokenNameIdentifier
(	TokenNameLPAREN
lastInput	TokenNameIdentifier
.	TokenNameDOT
ints	TokenNameIdentifier
[	TokenNameLBRACKET
lastInput	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
idx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
node	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
minSuffixCount2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
compileAllTargets	TokenNameIdentifier
(	TokenNameLPAREN
node	TokenNameIdentifier
,	TokenNameCOMMA
lastInput	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
idx	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
T	TokenNameIdentifier
nextFinalOutput	TokenNameIdentifier
=	TokenNameEQUAL
node	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
isFinal	TokenNameIdentifier
=	TokenNameEQUAL
node	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
||	TokenNameOR_OR
node	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doCompile	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
parent	TokenNameIdentifier
.	TokenNameDOT
replaceLast	TokenNameIdentifier
(	TokenNameLPAREN
lastInput	TokenNameIdentifier
.	TokenNameDOT
ints	TokenNameIdentifier
[	TokenNameLBRACKET
lastInput	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
idx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
compileNode	TokenNameIdentifier
(	TokenNameLPAREN
node	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
+	TokenNamePLUS
lastInput	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
idx	TokenNameIdentifier
)	TokenNameRPAREN
,	TokenNameCOMMA
nextFinalOutput	TokenNameIdentifier
,	TokenNameCOMMA
isFinal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
parent	TokenNameIdentifier
.	TokenNameDOT
replaceLast	TokenNameIdentifier
(	TokenNameLPAREN
lastInput	TokenNameIdentifier
.	TokenNameDOT
ints	TokenNameIdentifier
[	TokenNameLBRACKET
lastInput	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
idx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
node	TokenNameIdentifier
,	TokenNameCOMMA
nextFinalOutput	TokenNameIdentifier
,	TokenNameCOMMA
isFinal	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
this	TokenNamethis
,	TokenNameCOMMA
idx	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
add	TokenNameIdentifier
(	TokenNameLPAREN
IntsRef	TokenNameIdentifier
input	TokenNameIdentifier
,	TokenNameCOMMA
T	TokenNameIdentifier
output	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
output	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
output	TokenNameIdentifier
=	TokenNameEQUAL
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
lastInput	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
input	TokenNameIdentifier
.	TokenNameDOT
compareTo	TokenNameIdentifier
(	TokenNameLPAREN
lastInput	TokenNameIdentifier
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
:	TokenNameCOLON
"inputs are added out of order lastInput="	TokenNameStringLiteral
+	TokenNamePLUS
lastInput	TokenNameIdentifier
+	TokenNamePLUS
" vs input="	TokenNameStringLiteral
+	TokenNamePLUS
input	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
validOutput	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
inputCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
isFinal	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
fst	TokenNameIdentifier
.	TokenNameDOT
setEmptyOutput	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
pos1	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
pos2	TokenNameIdentifier
=	TokenNameEQUAL
input	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
pos1Stop	TokenNameIdentifier
=	TokenNameEQUAL
Math	TokenNameIdentifier
.	TokenNameDOT
min	TokenNameIdentifier
(	TokenNameLPAREN
lastInput	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
,	TokenNameCOMMA
input	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
pos1	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
inputCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pos1	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
pos1Stop	TokenNameIdentifier
||	TokenNameOR_OR
lastInput	TokenNameIdentifier
.	TokenNameDOT
ints	TokenNameIdentifier
[	TokenNameLBRACKET
pos1	TokenNameIdentifier
]	TokenNameRBRACKET
!=	TokenNameNOT_EQUAL
input	TokenNameIdentifier
.	TokenNameDOT
ints	TokenNameIdentifier
[	TokenNameLBRACKET
pos2	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pos1	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
pos2	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
int	TokenNameint
prefixLenPlus1	TokenNameIdentifier
=	TokenNameEQUAL
pos1	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
frontier	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
<	TokenNameLESS
input	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
{	TokenNameLBRACE
"rawtypes"	TokenNameStringLiteral
,	TokenNameCOMMA
"unchecked"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
[	TokenNameLBRACKET
]	TokenNameRBRACKET
next	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
UnCompiledNode	TokenNameIdentifier
[	TokenNameLBRACKET
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
oversize	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_OBJECT_REF	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
frontier	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
next	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
frontier	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
frontier	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
<	TokenNameLESS
next	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
next	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
this	TokenNamethis
,	TokenNameCOMMA
idx	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
frontier	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
freezeTail	TokenNameIdentifier
(	TokenNameLPAREN
prefixLenPlus1	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
prefixLenPlus1	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
input	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
addArc	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
ints	TokenNameIdentifier
[	TokenNameLBRACKET
input	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
idx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
inputCount	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
lastNode	TokenNameIdentifier
=	TokenNameEQUAL
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
input	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
lastNode	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
lastNode	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
idx	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
<	TokenNameLESS
prefixLenPlus1	TokenNameIdentifier
;	TokenNameSEMICOLON
idx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
node	TokenNameIdentifier
=	TokenNameEQUAL
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
parentNode	TokenNameIdentifier
=	TokenNameEQUAL
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
idx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
final	TokenNamefinal
T	TokenNameIdentifier
lastOutput	TokenNameIdentifier
=	TokenNameEQUAL
parentNode	TokenNameIdentifier
.	TokenNameDOT
getLastOutput	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
ints	TokenNameIdentifier
[	TokenNameLBRACKET
input	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
idx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
validOutput	TokenNameIdentifier
(	TokenNameLPAREN
lastOutput	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
T	TokenNameIdentifier
commonOutputPrefix	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
T	TokenNameIdentifier
wordSuffix	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
lastOutput	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
commonOutputPrefix	TokenNameIdentifier
=	TokenNameEQUAL
fst	TokenNameIdentifier
.	TokenNameDOT
outputs	TokenNameIdentifier
.	TokenNameDOT
common	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
,	TokenNameCOMMA
lastOutput	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
validOutput	TokenNameIdentifier
(	TokenNameLPAREN
commonOutputPrefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
wordSuffix	TokenNameIdentifier
=	TokenNameEQUAL
fst	TokenNameIdentifier
.	TokenNameDOT
outputs	TokenNameIdentifier
.	TokenNameDOT
subtract	TokenNameIdentifier
(	TokenNameLPAREN
lastOutput	TokenNameIdentifier
,	TokenNameCOMMA
commonOutputPrefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
validOutput	TokenNameIdentifier
(	TokenNameLPAREN
wordSuffix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
parentNode	TokenNameIdentifier
.	TokenNameDOT
setLastOutput	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
ints	TokenNameIdentifier
[	TokenNameLBRACKET
input	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
idx	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
commonOutputPrefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
node	TokenNameIdentifier
.	TokenNameDOT
prependOutput	TokenNameIdentifier
(	TokenNameLPAREN
wordSuffix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
commonOutputPrefix	TokenNameIdentifier
=	TokenNameEQUAL
wordSuffix	TokenNameIdentifier
=	TokenNameEQUAL
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
output	TokenNameIdentifier
=	TokenNameEQUAL
fst	TokenNameIdentifier
.	TokenNameDOT
outputs	TokenNameIdentifier
.	TokenNameDOT
subtract	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
,	TokenNameCOMMA
commonOutputPrefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
validOutput	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
lastInput	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
input	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
&&	TokenNameAND_AND
prefixLenPlus1	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
1	TokenNameIntegerLiteral
+	TokenNamePLUS
input	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
lastNode	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
fst	TokenNameIdentifier
.	TokenNameDOT
outputs	TokenNameIdentifier
.	TokenNameDOT
merge	TokenNameIdentifier
(	TokenNameLPAREN
lastNode	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
,	TokenNameCOMMA
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
prefixLenPlus1	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
setLastOutput	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
.	TokenNameDOT
ints	TokenNameIdentifier
[	TokenNameLBRACKET
input	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
+	TokenNamePLUS
prefixLenPlus1	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
,	TokenNameCOMMA
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
lastInput	TokenNameIdentifier
.	TokenNameDOT
copyInts	TokenNameIdentifier
(	TokenNameLPAREN
input	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
validOutput	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
output	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
output	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
NO_OUTPUT	TokenNameIdentifier
||	TokenNameOR_OR
!	TokenNameNOT
output	TokenNameIdentifier
.	TokenNameDOT
equals	TokenNameIdentifier
(	TokenNameLPAREN
NO_OUTPUT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
FST	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
root	TokenNameIdentifier
=	TokenNameEQUAL
frontier	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
freezeTail	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
root	TokenNameIdentifier
.	TokenNameDOT
inputCount	TokenNameIdentifier
<	TokenNameLESS
minSuffixCount1	TokenNameIdentifier
||	TokenNameOR_OR
root	TokenNameIdentifier
.	TokenNameDOT
inputCount	TokenNameIdentifier
<	TokenNameLESS
minSuffixCount2	TokenNameIdentifier
||	TokenNameOR_OR
root	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
fst	TokenNameIdentifier
.	TokenNameDOT
emptyOutput	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
minSuffixCount1	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
minSuffixCount2	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
minSuffixCount2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
compileAllTargets	TokenNameIdentifier
(	TokenNameLPAREN
root	TokenNameIdentifier
,	TokenNameCOMMA
lastInput	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
fst	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
compileNode	TokenNameIdentifier
(	TokenNameLPAREN
root	TokenNameIdentifier
,	TokenNameCOMMA
lastInput	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
node	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
fst	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
compileAllTargets	TokenNameIdentifier
(	TokenNameLPAREN
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
node	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
tailLength	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
arcIdx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
<	TokenNameLESS
node	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
=	TokenNameEQUAL
node	TokenNameIdentifier
.	TokenNameDOT
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
.	TokenNameDOT
isCompiled	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
{	TokenNameLBRACE
"rawtypes"	TokenNameStringLiteral
,	TokenNameCOMMA
"unchecked"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
final	TokenNamefinal
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
n	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
)	TokenNameRPAREN
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
n	TokenNameIdentifier
.	TokenNameDOT
numArcs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
=	TokenNameEQUAL
n	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
compileNode	TokenNameIdentifier
(	TokenNameLPAREN
n	TokenNameIdentifier
,	TokenNameCOMMA
tailLength	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
class	TokenNameclass
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
label	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Node	TokenNameIdentifier
target	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
isFinal	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
T	TokenNameIdentifier
output	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
T	TokenNameIdentifier
nextFinalOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
interface	TokenNameinterface
Node	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
isCompiled	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
CompiledNode	TokenNameIdentifier
implements	TokenNameimplements
Node	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
node	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
isCompiled	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
static	TokenNamestatic
final	TokenNamefinal
class	TokenNameclass
UnCompiledNode	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
implements	TokenNameimplements
Node	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
Builder	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
owner	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
int	TokenNameint
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
[	TokenNameLBRACKET
]	TokenNameRBRACKET
arcs	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
T	TokenNameIdentifier
output	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
isFinal	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
long	TokenNamelong
inputCount	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
final	TokenNamefinal
int	TokenNameint
depth	TokenNameIdentifier
;	TokenNameSEMICOLON
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
{	TokenNameLBRACE
"rawtypes"	TokenNameStringLiteral
,	TokenNameCOMMA
"unchecked"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
public	TokenNamepublic
UnCompiledNode	TokenNameIdentifier
(	TokenNameLPAREN
Builder	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
owner	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
depth	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
owner	TokenNameIdentifier
=	TokenNameEQUAL
owner	TokenNameIdentifier
;	TokenNameSEMICOLON
arcs	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
[	TokenNameLBRACKET
]	TokenNameRBRACKET
)	TokenNameRPAREN
new	TokenNamenew
Arc	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
output	TokenNameIdentifier
=	TokenNameEQUAL
owner	TokenNameIdentifier
.	TokenNameDOT
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
depth	TokenNameIdentifier
=	TokenNameEQUAL
depth	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
isCompiled	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
numArcs	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
isFinal	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
output	TokenNameIdentifier
=	TokenNameEQUAL
owner	TokenNameIdentifier
.	TokenNameDOT
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
inputCount	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
T	TokenNameIdentifier
getLastOutput	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
labelToMatch	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
numArcs	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
labelToMatch	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
output	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
addArc	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
label	TokenNameIdentifier
,	TokenNameCOMMA
Node	TokenNameIdentifier
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
label	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
numArcs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
label	TokenNameIdentifier
>	TokenNameGREATER
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
label	TokenNameIdentifier
:	TokenNameCOLON
"arc[-1].label="	TokenNameStringLiteral
+	TokenNamePLUS
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
label	TokenNameIdentifier
+	TokenNamePLUS
" new label="	TokenNameStringLiteral
+	TokenNamePLUS
label	TokenNameIdentifier
+	TokenNamePLUS
" numArcs="	TokenNameStringLiteral
+	TokenNamePLUS
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numArcs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
arcs	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
@	TokenNameAT
SuppressWarnings	TokenNameIdentifier
(	TokenNameLPAREN
{	TokenNameLBRACE
"rawtypes"	TokenNameStringLiteral
,	TokenNameCOMMA
"unchecked"	TokenNameStringLiteral
}	TokenNameRBRACE
)	TokenNameRPAREN
final	TokenNamefinal
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newArcs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Arc	TokenNameIdentifier
[	TokenNameLBRACKET
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
oversize	TokenNameIdentifier
(	TokenNameLPAREN
numArcs	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_OBJECT_REF	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
arcs	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newArcs	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
arcs	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
arcIdx	TokenNameIdentifier
=	TokenNameEQUAL
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
<	TokenNameLESS
newArcs	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
newArcs	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
arcs	TokenNameIdentifier
=	TokenNameEQUAL
newArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
=	TokenNameEQUAL
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
numArcs	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
=	TokenNameEQUAL
label	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
=	TokenNameEQUAL
owner	TokenNameIdentifier
.	TokenNameDOT
NO_OUTPUT	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
replaceLast	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
labelToMatch	TokenNameIdentifier
,	TokenNameCOMMA
Node	TokenNameIdentifier
target	TokenNameIdentifier
,	TokenNameCOMMA
T	TokenNameIdentifier
nextFinalOutput	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
isFinal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
numArcs	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
=	TokenNameEQUAL
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
assert	TokenNameassert
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
labelToMatch	TokenNameIdentifier
:	TokenNameCOLON
"arc.label="	TokenNameStringLiteral
+	TokenNamePLUS
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
+	TokenNamePLUS
" vs "	TokenNameStringLiteral
+	TokenNamePLUS
labelToMatch	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
target	TokenNameIdentifier
=	TokenNameEQUAL
target	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
nextFinalOutput	TokenNameIdentifier
=	TokenNameEQUAL
nextFinalOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
isFinal	TokenNameIdentifier
=	TokenNameEQUAL
isFinal	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
deleteLast	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
label	TokenNameIdentifier
,	TokenNameCOMMA
Node	TokenNameIdentifier
target	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
numArcs	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
label	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
target	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
.	TokenNameDOT
target	TokenNameIdentifier
;	TokenNameSEMICOLON
numArcs	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
setLastOutput	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
labelToMatch	TokenNameIdentifier
,	TokenNameCOMMA
T	TokenNameIdentifier
newOutput	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
owner	TokenNameIdentifier
.	TokenNameDOT
validOutput	TokenNameIdentifier
(	TokenNameLPAREN
newOutput	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
numArcs	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
Arc	TokenNameIdentifier
<	TokenNameLESS
T	TokenNameIdentifier
>	TokenNameGREATER
arc	TokenNameIdentifier
=	TokenNameEQUAL
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
numArcs	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
assert	TokenNameassert
arc	TokenNameIdentifier
.	TokenNameDOT
label	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
labelToMatch	TokenNameIdentifier
;	TokenNameSEMICOLON
arc	TokenNameIdentifier
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
newOutput	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
prependOutput	TokenNameIdentifier
(	TokenNameLPAREN
T	TokenNameIdentifier
outputPrefix	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
owner	TokenNameIdentifier
.	TokenNameDOT
validOutput	TokenNameIdentifier
(	TokenNameLPAREN
outputPrefix	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
arcIdx	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
<	TokenNameLESS
numArcs	TokenNameIdentifier
;	TokenNameSEMICOLON
arcIdx	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
output	TokenNameIdentifier
=	TokenNameEQUAL
owner	TokenNameIdentifier
.	TokenNameDOT
fst	TokenNameIdentifier
.	TokenNameDOT
outputs	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
outputPrefix	TokenNameIdentifier
,	TokenNameCOMMA
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
owner	TokenNameIdentifier
.	TokenNameDOT
validOutput	TokenNameIdentifier
(	TokenNameLPAREN
arcs	TokenNameIdentifier
[	TokenNameLBRACKET
arcIdx	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
isFinal	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
output	TokenNameIdentifier
=	TokenNameEQUAL
owner	TokenNameIdentifier
.	TokenNameDOT
fst	TokenNameIdentifier
.	TokenNameDOT
outputs	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
outputPrefix	TokenNameIdentifier
,	TokenNameCOMMA
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
owner	TokenNameIdentifier
.	TokenNameDOT
validOutput	TokenNameIdentifier
(	TokenNameLPAREN
output	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
