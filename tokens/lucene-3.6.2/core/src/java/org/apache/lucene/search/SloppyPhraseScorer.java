package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Arrays	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Comparator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashMap	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashSet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
LinkedHashMap	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
Term	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
OpenBitSet	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
class	TokenNameclass
SloppyPhraseScorer	TokenNameIdentifier
extends	TokenNameextends
PhraseScorer	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
slop	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
numPostings	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
PhraseQueue	TokenNameIdentifier
pq	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
end	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
hasRpts	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
checkedRpts	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
hasMultiTermRpts	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rptGroups	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rptStack	TokenNameIdentifier
;	TokenNameSEMICOLON
SloppyPhraseScorer	TokenNameIdentifier
(	TokenNameLPAREN
Weight	TokenNameIdentifier
weight	TokenNameIdentifier
,	TokenNameCOMMA
PhraseQuery	TokenNameIdentifier
.	TokenNameDOT
PostingsAndFreq	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
postings	TokenNameIdentifier
,	TokenNameCOMMA
Similarity	TokenNameIdentifier
similarity	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
slop	TokenNameIdentifier
,	TokenNameCOMMA
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
norms	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
weight	TokenNameIdentifier
,	TokenNameCOMMA
postings	TokenNameIdentifier
,	TokenNameCOMMA
similarity	TokenNameIdentifier
,	TokenNameCOMMA
norms	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
slop	TokenNameIdentifier
=	TokenNameEQUAL
slop	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
numPostings	TokenNameIdentifier
=	TokenNameEQUAL
postings	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
0	TokenNameIntegerLiteral
:	TokenNameCOLON
postings	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
pq	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
PhraseQueue	TokenNameIdentifier
(	TokenNameLPAREN
postings	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
float	TokenNamefloat
phraseFreq	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
initPhrasePositions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
0.0f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
float	TokenNamefloat
freq	TokenNameIdentifier
=	TokenNameEQUAL
0.0f	TokenNameFloatingPointLiteral
;	TokenNameSEMICOLON
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
=	TokenNameEQUAL
pq	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
matchLength	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
-	TokenNameMINUS
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
next	TokenNameIdentifier
=	TokenNameEQUAL
pq	TokenNameIdentifier
.	TokenNameDOT
top	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
position	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
advancePP	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hasRpts	TokenNameIdentifier
&&	TokenNameAND_AND
!	TokenNameNOT
advanceRpts	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
>	TokenNameGREATER
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
matchLength	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
slop	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
freq	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
getSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
sloppyFreq	TokenNameIdentifier
(	TokenNameLPAREN
matchLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pq	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pp	TokenNameIdentifier
=	TokenNameEQUAL
pq	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
next	TokenNameIdentifier
=	TokenNameEQUAL
pq	TokenNameIdentifier
.	TokenNameDOT
top	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
position	TokenNameIdentifier
;	TokenNameSEMICOLON
matchLength	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
-	TokenNameMINUS
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
matchLength2	TokenNameIdentifier
=	TokenNameEQUAL
end	TokenNameIdentifier
-	TokenNameMINUS
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
matchLength2	TokenNameIdentifier
<	TokenNameLESS
matchLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
matchLength	TokenNameIdentifier
=	TokenNameEQUAL
matchLength2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
matchLength	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
slop	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
freq	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
getSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
sloppyFreq	TokenNameIdentifier
(	TokenNameLPAREN
matchLength	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
freq	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
advancePP	TokenNameIdentifier
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
pp	TokenNameIdentifier
.	TokenNameDOT
nextPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
>	TokenNameGREATER
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
end	TokenNameIdentifier
=	TokenNameEQUAL
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
advanceRpts	TokenNameIdentifier
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pp	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rg	TokenNameIdentifier
=	TokenNameEQUAL
rptGroups	TokenNameIdentifier
[	TokenNameLBRACKET
pp	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
OpenBitSet	TokenNameIdentifier
bits	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
OpenBitSet	TokenNameIdentifier
(	TokenNameLPAREN
rg	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
k0	TokenNameIdentifier
=	TokenNameEQUAL
pp	TokenNameIdentifier
.	TokenNameDOT
rptInd	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
k	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
k	TokenNameIdentifier
=	TokenNameEQUAL
collide	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
pp	TokenNameIdentifier
=	TokenNameEQUAL
lesser	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
,	TokenNameCOMMA
rg	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
advancePP	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
k	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
k0	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
k	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
int	TokenNameint
n	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
bits	TokenNameIdentifier
.	TokenNameDOT
cardinality	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
PhrasePositions	TokenNameIdentifier
pp2	TokenNameIdentifier
=	TokenNameEQUAL
pq	TokenNameIdentifier
.	TokenNameDOT
pop	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
rptStack	TokenNameIdentifier
[	TokenNameLBRACKET
n	TokenNameIdentifier
++	TokenNamePLUS_PLUS
]	TokenNameRBRACKET
=	TokenNameEQUAL
pp2	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pp2	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
&&	TokenNameAND_AND
bits	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
pp2	TokenNameIdentifier
.	TokenNameDOT
rptInd	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
bits	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
pp2	TokenNameIdentifier
.	TokenNameDOT
rptInd	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
n	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
--	TokenNameMINUS_MINUS
)	TokenNameRPAREN
{	TokenNameLBRACE
pq	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
rptStack	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
PhrasePositions	TokenNameIdentifier
lesser	TokenNameIdentifier
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
,	TokenNameCOMMA
PhrasePositions	TokenNameIdentifier
pp2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
<	TokenNameLESS
pp2	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
||	TokenNameOR_OR
(	TokenNameLPAREN
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
pp2	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
&&	TokenNameAND_AND
pp	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
<	TokenNameLESS
pp2	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
pp	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
pp2	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
int	TokenNameint
collide	TokenNameIdentifier
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
tpPos	TokenNameIdentifier
=	TokenNameEQUAL
tpPos	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rg	TokenNameIdentifier
=	TokenNameEQUAL
rptGroups	TokenNameIdentifier
[	TokenNameLBRACKET
pp	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
rg	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
PhrasePositions	TokenNameIdentifier
pp2	TokenNameIdentifier
=	TokenNameEQUAL
rg	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pp2	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
pp	TokenNameIdentifier
&&	TokenNameAND_AND
tpPos	TokenNameIdentifier
(	TokenNameLPAREN
pp2	TokenNameIdentifier
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
tpPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
pp2	TokenNameIdentifier
.	TokenNameDOT
rptInd	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
initPhrasePositions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
end	TokenNameIdentifier
=	TokenNameEQUAL
Integer	TokenNameIdentifier
.	TokenNameDOT
MIN_VALUE	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
checkedRpts	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
initFirstTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
hasRpts	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
initSimple	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
initComplex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
initSimple	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
pq	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
=	TokenNameEQUAL
min	TokenNameIdentifier
,	TokenNameCOMMA
prev	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
prev	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
max	TokenNameIdentifier
;	TokenNameSEMICOLON
pp	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
prev	TokenNameIdentifier
=	TokenNameEQUAL
pp	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pp	TokenNameIdentifier
.	TokenNameDOT
firstPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
>	TokenNameGREATER
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
end	TokenNameIdentifier
=	TokenNameEQUAL
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pq	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
initComplex	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
placeFirstPositions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
advanceRepeatGroups	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
fillQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
placeFirstPositions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
=	TokenNameEQUAL
min	TokenNameIdentifier
,	TokenNameCOMMA
prev	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
prev	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
max	TokenNameIdentifier
;	TokenNameSEMICOLON
pp	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
prev	TokenNameIdentifier
=	TokenNameEQUAL
pp	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pp	TokenNameIdentifier
.	TokenNameDOT
firstPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
fillQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
pq	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
=	TokenNameEQUAL
min	TokenNameIdentifier
,	TokenNameCOMMA
prev	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
prev	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
max	TokenNameIdentifier
;	TokenNameSEMICOLON
pp	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
prev	TokenNameIdentifier
=	TokenNameEQUAL
pp	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
>	TokenNameGREATER
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
end	TokenNameIdentifier
=	TokenNameEQUAL
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pq	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
advanceRepeatGroups	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rg	TokenNameIdentifier
:	TokenNameCOLON
rptGroups	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
hasMultiTermRpts	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
incr	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
rg	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
incr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
incr	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
=	TokenNameEQUAL
rg	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
int	TokenNameint
k	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
k	TokenNameIdentifier
=	TokenNameEQUAL
collide	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
PhrasePositions	TokenNameIdentifier
pp2	TokenNameIdentifier
=	TokenNameEQUAL
lesser	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
,	TokenNameCOMMA
rg	TokenNameIdentifier
[	TokenNameLBRACKET
k	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
advancePP	TokenNameIdentifier
(	TokenNameLPAREN
pp2	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
pp2	TokenNameIdentifier
.	TokenNameDOT
rptInd	TokenNameIdentifier
<	TokenNameLESS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
incr	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
rg	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
k	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
k	TokenNameIdentifier
<	TokenNameLESS
j	TokenNameIdentifier
;	TokenNameSEMICOLON
k	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
rg	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
nextPosition	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
boolean	TokenNameboolean
initFirstTime	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
checkedRpts	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
placeFirstPositions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
LinkedHashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
rptTerms	TokenNameIdentifier
=	TokenNameEQUAL
repeatingTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hasRpts	TokenNameIdentifier
=	TokenNameEQUAL
!	TokenNameNOT
rptTerms	TokenNameIdentifier
.	TokenNameDOT
isEmpty	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
hasRpts	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
rptStack	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
numPostings	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
ArrayList	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
rgs	TokenNameIdentifier
=	TokenNameEQUAL
gatherRptGroups	TokenNameIdentifier
(	TokenNameLPAREN
rptTerms	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sortRptGroups	TokenNameIdentifier
(	TokenNameLPAREN
rgs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
advanceRepeatGroups	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
fillQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
sortRptGroups	TokenNameIdentifier
(	TokenNameLPAREN
ArrayList	TokenNameIdentifier
<	TokenNameLESS
ArrayList	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
rgs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
rptGroups	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
rgs	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
Comparator	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>	TokenNameGREATER
cmprtr	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
Comparator	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
public	TokenNamepublic
int	TokenNameint
compare	TokenNameIdentifier
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp1	TokenNameIdentifier
,	TokenNameCOMMA
PhrasePositions	TokenNameIdentifier
pp2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
pp1	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
-	TokenNameMINUS
pp2	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
rptGroups	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rg	TokenNameIdentifier
=	TokenNameEQUAL
rgs	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
toArray	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Arrays	TokenNameIdentifier
.	TokenNameDOT
sort	TokenNameIdentifier
(	TokenNameLPAREN
rg	TokenNameIdentifier
,	TokenNameCOMMA
cmprtr	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
rptGroups	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
rg	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
rg	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
rg	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
rptInd	TokenNameIdentifier
=	TokenNameEQUAL
j	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
ArrayList	TokenNameIdentifier
<	TokenNameLESS
ArrayList	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
gatherRptGroups	TokenNameIdentifier
(	TokenNameLPAREN
LinkedHashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
rptTerms	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rpp	TokenNameIdentifier
=	TokenNameEQUAL
repeatingPPs	TokenNameIdentifier
(	TokenNameLPAREN
rptTerms	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
ArrayList	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
res	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
ArrayList	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
hasMultiTermRpts	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
rpp	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
=	TokenNameEQUAL
rpp	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pp	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
continue	TokenNamecontinue
;	TokenNameSEMICOLON
int	TokenNameint
tpPos	TokenNameIdentifier
=	TokenNameEQUAL
tpPos	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
j	TokenNameIdentifier
<	TokenNameLESS
rpp	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
j	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
PhrasePositions	TokenNameIdentifier
pp2	TokenNameIdentifier
=	TokenNameEQUAL
rpp	TokenNameIdentifier
[	TokenNameLBRACKET
j	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pp2	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
pp2	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
pp	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
||	TokenNameOR_OR
tpPos	TokenNameIdentifier
(	TokenNameLPAREN
pp2	TokenNameIdentifier
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
tpPos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
continue	TokenNamecontinue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
g	TokenNameIdentifier
=	TokenNameEQUAL
pp	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
g	TokenNameIdentifier
<	TokenNameLESS
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
g	TokenNameIdentifier
=	TokenNameEQUAL
res	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pp	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
=	TokenNameEQUAL
g	TokenNameIdentifier
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>	TokenNameGREATER
rl	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
rl	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
res	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
rl	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pp2	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
=	TokenNameEQUAL
g	TokenNameIdentifier
;	TokenNameSEMICOLON
res	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
g	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
pp2	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ArrayList	TokenNameIdentifier
<	TokenNameLESS
HashSet	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
tmp	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
HashSet	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>>	TokenNameRIGHT_SHIFT
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
ArrayList	TokenNameIdentifier
<	TokenNameLESS
OpenBitSet	TokenNameIdentifier
>	TokenNameGREATER
bb	TokenNameIdentifier
=	TokenNameEQUAL
ppTermsBitSets	TokenNameIdentifier
(	TokenNameLPAREN
rpp	TokenNameIdentifier
,	TokenNameCOMMA
rptTerms	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
unionTermGroups	TokenNameIdentifier
(	TokenNameLPAREN
bb	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
HashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
tg	TokenNameIdentifier
=	TokenNameEQUAL
termGroups	TokenNameIdentifier
(	TokenNameLPAREN
rptTerms	TokenNameIdentifier
,	TokenNameCOMMA
bb	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
HashSet	TokenNameIdentifier
<	TokenNameLESS
Integer	TokenNameIdentifier
>	TokenNameGREATER
distinctGroupIDs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
Integer	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
tg	TokenNameIdentifier
.	TokenNameDOT
values	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
distinctGroupIDs	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
tmp	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
:	TokenNameCOLON
rpp	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Term	TokenNameIdentifier
t	TokenNameIdentifier
:	TokenNameCOLON
pp	TokenNameIdentifier
.	TokenNameDOT
terms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
rptTerms	TokenNameIdentifier
.	TokenNameDOT
containsKey	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
g	TokenNameIdentifier
=	TokenNameEQUAL
tg	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tmp	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
g	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
pp	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
||	TokenNameOR_OR
pp	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
g	TokenNameIdentifier
;	TokenNameSEMICOLON
pp	TokenNameIdentifier
.	TokenNameDOT
rptGroup	TokenNameIdentifier
=	TokenNameEQUAL
g	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
for	TokenNamefor
(	TokenNameLPAREN
HashSet	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>	TokenNameGREATER
hs	TokenNameIdentifier
:	TokenNameCOLON
tmp	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
res	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
hs	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
res	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
tpPos	TokenNameIdentifier
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
pp	TokenNameIdentifier
.	TokenNameDOT
position	TokenNameIdentifier
+	TokenNamePLUS
pp	TokenNameIdentifier
.	TokenNameDOT
offset	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
LinkedHashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
repeatingTerms	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
LinkedHashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
tord	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
LinkedHashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
HashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
tcnt	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
=	TokenNameEQUAL
min	TokenNameIdentifier
,	TokenNameCOMMA
prev	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
prev	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
max	TokenNameIdentifier
;	TokenNameSEMICOLON
pp	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
prev	TokenNameIdentifier
=	TokenNameEQUAL
pp	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Term	TokenNameIdentifier
t	TokenNameIdentifier
:	TokenNameCOLON
pp	TokenNameIdentifier
.	TokenNameDOT
terms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
Integer	TokenNameIdentifier
cnt0	TokenNameIdentifier
=	TokenNameEQUAL
tcnt	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Integer	TokenNameIdentifier
cnt	TokenNameIdentifier
=	TokenNameEQUAL
cnt0	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
new	TokenNamenew
Integer	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
:	TokenNameCOLON
new	TokenNamenew
Integer	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
+	TokenNamePLUS
cnt0	TokenNameIdentifier
.	TokenNameDOT
intValue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
tcnt	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
,	TokenNameCOMMA
cnt	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
cnt	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
2	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
tord	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
,	TokenNameCOMMA
tord	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
tord	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
repeatingPPs	TokenNameIdentifier
(	TokenNameLPAREN
HashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
rptTerms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ArrayList	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>	TokenNameGREATER
rp	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
PhrasePositions	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
=	TokenNameEQUAL
min	TokenNameIdentifier
,	TokenNameCOMMA
prev	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
prev	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
max	TokenNameIdentifier
;	TokenNameSEMICOLON
pp	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
prev	TokenNameIdentifier
=	TokenNameEQUAL
pp	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Term	TokenNameIdentifier
t	TokenNameIdentifier
:	TokenNameCOLON
pp	TokenNameIdentifier
.	TokenNameDOT
terms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
rptTerms	TokenNameIdentifier
.	TokenNameDOT
containsKey	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
rp	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
pp	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
hasMultiTermRpts	TokenNameIdentifier
|=	TokenNameOR_EQUAL
(	TokenNameLPAREN
pp	TokenNameIdentifier
.	TokenNameDOT
terms	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
rp	TokenNameIdentifier
.	TokenNameDOT
toArray	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
ArrayList	TokenNameIdentifier
<	TokenNameLESS
OpenBitSet	TokenNameIdentifier
>	TokenNameGREATER
ppTermsBitSets	TokenNameIdentifier
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
rpp	TokenNameIdentifier
,	TokenNameCOMMA
HashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
tord	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ArrayList	TokenNameIdentifier
<	TokenNameLESS
OpenBitSet	TokenNameIdentifier
>	TokenNameGREATER
bb	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
OpenBitSet	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
rpp	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
PhrasePositions	TokenNameIdentifier
pp	TokenNameIdentifier
:	TokenNameCOLON
rpp	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
OpenBitSet	TokenNameIdentifier
b	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
OpenBitSet	TokenNameIdentifier
(	TokenNameLPAREN
tord	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Integer	TokenNameIdentifier
ord	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Term	TokenNameIdentifier
t	TokenNameIdentifier
:	TokenNameCOLON
pp	TokenNameIdentifier
.	TokenNameDOT
terms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
ord	TokenNameIdentifier
=	TokenNameEQUAL
tord	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
ord	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
bb	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
b	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
bb	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
unionTermGroups	TokenNameIdentifier
(	TokenNameLPAREN
ArrayList	TokenNameIdentifier
<	TokenNameLESS
OpenBitSet	TokenNameIdentifier
>	TokenNameGREATER
bb	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
incr	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
bb	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
incr	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
incr	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
int	TokenNameint
j	TokenNameIdentifier
=	TokenNameEQUAL
i	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
j	TokenNameIdentifier
<	TokenNameLESS
bb	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bb	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
intersects	TokenNameIdentifier
(	TokenNameLPAREN
bb	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
bb	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
union	TokenNameIdentifier
(	TokenNameLPAREN
bb	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bb	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
j	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
incr	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
++	TokenNamePLUS_PLUS
j	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
HashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
termGroups	TokenNameIdentifier
(	TokenNameLPAREN
LinkedHashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
tord	TokenNameIdentifier
,	TokenNameCOMMA
ArrayList	TokenNameIdentifier
<	TokenNameLESS
OpenBitSet	TokenNameIdentifier
>	TokenNameGREATER
bb	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
HashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
tg	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
Term	TokenNameIdentifier
,	TokenNameCOMMA
Integer	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Term	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
t	TokenNameIdentifier
=	TokenNameEQUAL
tord	TokenNameIdentifier
.	TokenNameDOT
keySet	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
toArray	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Term	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
bb	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
DocIdSetIterator	TokenNameIdentifier
bits	TokenNameIdentifier
=	TokenNameEQUAL
bb	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
.	TokenNameDOT
iterator	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
int	TokenNameint
ord	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
(	TokenNameLPAREN
ord	TokenNameIdentifier
=	TokenNameEQUAL
bits	TokenNameIdentifier
.	TokenNameDOT
nextDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
!=	TokenNameNOT_EQUAL
NO_MORE_DOCS	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
tg	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
t	TokenNameIdentifier
[	TokenNameLBRACKET
ord	TokenNameIdentifier
]	TokenNameRBRACKET
,	TokenNameCOMMA
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
tg	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
