package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
PrintStream	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
text	TokenNameIdentifier
.	TokenNameDOT
NumberFormat	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayList	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
Collection	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashMap	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
HashSet	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
List	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
concurrent	TokenNameIdentifier
.	TokenNameDOT
atomic	TokenNameIdentifier
.	TokenNameDOT
AtomicLong	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
analysis	TokenNameIdentifier
.	TokenNameDOT
Analyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
document	TokenNameIdentifier
.	TokenNameDOT
Document	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
Query	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
.	TokenNameDOT
Similarity	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
AlreadyClosedException	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
Directory	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
store	TokenNameIdentifier
.	TokenNameDOT
RAMFile	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ArrayUtil	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
BitVector	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
RamUsageEstimator	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
ThreadInterruptedException	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
class	TokenNameclass
DocumentsWriter	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
AtomicLong	TokenNameIdentifier
bytesUsed	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
AtomicLong	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
IndexWriter	TokenNameIdentifier
writer	TokenNameIdentifier
;	TokenNameSEMICOLON
Directory	TokenNameIdentifier
directory	TokenNameIdentifier
;	TokenNameSEMICOLON
String	TokenNameIdentifier
segment	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
nextDocID	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
int	TokenNameint
numDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
DocumentsWriterThreadState	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
threadStates	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
DocumentsWriterThreadState	TokenNameIdentifier
[	TokenNameLBRACKET
0	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
HashMap	TokenNameIdentifier
<	TokenNameLESS
Thread	TokenNameIdentifier
,	TokenNameCOMMA
DocumentsWriterThreadState	TokenNameIdentifier
>	TokenNameGREATER
threadBindings	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashMap	TokenNameIdentifier
<	TokenNameLESS
Thread	TokenNameIdentifier
,	TokenNameCOMMA
DocumentsWriterThreadState	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
boolean	TokenNameboolean
bufferIsFull	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
aborting	TokenNameIdentifier
;	TokenNameSEMICOLON
PrintStream	TokenNameIdentifier
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
maxFieldLength	TokenNameIdentifier
=	TokenNameEQUAL
IndexWriter	TokenNameIdentifier
.	TokenNameDOT
DEFAULT_MAX_FIELD_LENGTH	TokenNameIdentifier
;	TokenNameSEMICOLON
Similarity	TokenNameIdentifier
similarity	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
int	TokenNameint
maxThreadStates	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
BufferedDeletes	TokenNameIdentifier
pendingDeletes	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BufferedDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
static	TokenNamestatic
class	TokenNameclass
DocState	TokenNameIdentifier
{	TokenNameLBRACE
DocumentsWriter	TokenNameIdentifier
docWriter	TokenNameIdentifier
;	TokenNameSEMICOLON
Analyzer	TokenNameIdentifier
analyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
maxFieldLength	TokenNameIdentifier
;	TokenNameSEMICOLON
PrintStream	TokenNameIdentifier
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
Similarity	TokenNameIdentifier
similarity	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
Document	TokenNameIdentifier
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
String	TokenNameIdentifier
maxTermPrefix	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
boolean	TokenNameboolean
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
name	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
docWriter	TokenNameIdentifier
.	TokenNameDOT
writer	TokenNameIdentifier
.	TokenNameDOT
testPoint	TokenNameIdentifier
(	TokenNameLPAREN
name	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
doc	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
analyzer	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
abstract	TokenNameabstract
static	TokenNamestatic
class	TokenNameclass
DocWriter	TokenNameIdentifier
{	TokenNameLBRACE
DocWriter	TokenNameIdentifier
next	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
abstract	TokenNameabstract
void	TokenNamevoid
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
abstract	TokenNameabstract
void	TokenNamevoid
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
abstract	TokenNameabstract
long	TokenNamelong
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
void	TokenNamevoid
setNext	TokenNameIdentifier
(	TokenNameLPAREN
DocWriter	TokenNameIdentifier
next	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
next	TokenNameIdentifier
=	TokenNameEQUAL
next	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
PerDocBuffer	TokenNameIdentifier
newPerDocBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
new	TokenNamenew
PerDocBuffer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
class	TokenNameclass
PerDocBuffer	TokenNameIdentifier
extends	TokenNameextends
RAMFile	TokenNameIdentifier
{	TokenNameLBRACE
@	TokenNameAT
Override	TokenNameIdentifier
protected	TokenNameprotected
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newBuffer	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
size	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
size	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
PER_DOC_BLOCK_SIZE	TokenNameIdentifier
;	TokenNameSEMICOLON
return	TokenNamereturn
perDocAllocator	TokenNameIdentifier
.	TokenNameDOT
getByteBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
recycle	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
buffers	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
setLength	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
perDocAllocator	TokenNameIdentifier
.	TokenNameDOT
recycleByteBlocks	TokenNameIdentifier
(	TokenNameLPAREN
buffers	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
buffers	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
sizeInBytes	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
numBuffers	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
abstract	TokenNameabstract
static	TokenNamestatic
class	TokenNameclass
IndexingChain	TokenNameIdentifier
{	TokenNameLBRACE
abstract	TokenNameabstract
DocConsumer	TokenNameIdentifier
getChain	TokenNameIdentifier
(	TokenNameLPAREN
DocumentsWriter	TokenNameIdentifier
documentsWriter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
static	TokenNamestatic
final	TokenNamefinal
IndexingChain	TokenNameIdentifier
defaultIndexingChain	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
IndexingChain	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
@	TokenNameAT
Override	TokenNameIdentifier
DocConsumer	TokenNameIdentifier
getChain	TokenNameIdentifier
(	TokenNameLPAREN
DocumentsWriter	TokenNameIdentifier
documentsWriter	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
TermsHashConsumer	TokenNameIdentifier
termVectorsWriter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
TermVectorsTermsWriter	TokenNameIdentifier
(	TokenNameLPAREN
documentsWriter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
TermsHashConsumer	TokenNameIdentifier
freqProxWriter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FreqProxTermsWriter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
InvertedDocConsumer	TokenNameIdentifier
termsHash	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
TermsHash	TokenNameIdentifier
(	TokenNameLPAREN
documentsWriter	TokenNameIdentifier
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
freqProxWriter	TokenNameIdentifier
,	TokenNameCOMMA
new	TokenNamenew
TermsHash	TokenNameIdentifier
(	TokenNameLPAREN
documentsWriter	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
termVectorsWriter	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
NormsWriter	TokenNameIdentifier
normsWriter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
NormsWriter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
DocInverter	TokenNameIdentifier
docInverter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
DocInverter	TokenNameIdentifier
(	TokenNameLPAREN
termsHash	TokenNameIdentifier
,	TokenNameCOMMA
normsWriter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
new	TokenNamenew
DocFieldProcessor	TokenNameIdentifier
(	TokenNameLPAREN
documentsWriter	TokenNameIdentifier
,	TokenNameCOMMA
docInverter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
;	TokenNameSEMICOLON
final	TokenNamefinal
DocConsumer	TokenNameIdentifier
consumer	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
IndexWriterConfig	TokenNameIdentifier
config	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
boolean	TokenNameboolean
closed	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
FieldInfos	TokenNameIdentifier
fieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
BufferedDeletesStream	TokenNameIdentifier
bufferedDeletesStream	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
final	TokenNamefinal
IndexWriter	TokenNameIdentifier
.	TokenNameDOT
FlushControl	TokenNameIdentifier
flushControl	TokenNameIdentifier
;	TokenNameSEMICOLON
DocumentsWriter	TokenNameIdentifier
(	TokenNameLPAREN
IndexWriterConfig	TokenNameIdentifier
config	TokenNameIdentifier
,	TokenNameCOMMA
Directory	TokenNameIdentifier
directory	TokenNameIdentifier
,	TokenNameCOMMA
IndexWriter	TokenNameIdentifier
writer	TokenNameIdentifier
,	TokenNameCOMMA
FieldInfos	TokenNameIdentifier
fieldInfos	TokenNameIdentifier
,	TokenNameCOMMA
BufferedDeletesStream	TokenNameIdentifier
bufferedDeletesStream	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
directory	TokenNameIdentifier
=	TokenNameEQUAL
directory	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
writer	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
similarity	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
maxThreadStates	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getMaxThreadStates	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
fieldInfos	TokenNameIdentifier
=	TokenNameEQUAL
fieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
bufferedDeletesStream	TokenNameIdentifier
=	TokenNameEQUAL
bufferedDeletesStream	TokenNameIdentifier
;	TokenNameSEMICOLON
flushControl	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
flushControl	TokenNameIdentifier
;	TokenNameSEMICOLON
consumer	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getIndexingChain	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getChain	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
this	TokenNamethis
.	TokenNameDOT
config	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
deleteDocID	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
docIDUpto	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
addDocID	TokenNameIdentifier
(	TokenNameLPAREN
docIDUpto	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
deleteQueries	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
...	TokenNameELLIPSIS
queries	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
boolean	TokenNameboolean
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
flushControl	TokenNameIdentifier
.	TokenNameDOT
waitUpdate	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
queries	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Query	TokenNameIdentifier
query	TokenNameIdentifier
:	TokenNameCOLON
queries	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
addQuery	TokenNameIdentifier
(	TokenNameLPAREN
query	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
doFlush	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
deleteQuery	TokenNameIdentifier
(	TokenNameLPAREN
Query	TokenNameIdentifier
query	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
boolean	TokenNameboolean
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
flushControl	TokenNameIdentifier
.	TokenNameDOT
waitUpdate	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
addQuery	TokenNameIdentifier
(	TokenNameLPAREN
query	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
doFlush	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
deleteTerms	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
...	TokenNameELLIPSIS
terms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
boolean	TokenNameboolean
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
flushControl	TokenNameIdentifier
.	TokenNameDOT
waitUpdate	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
terms	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
:	TokenNameCOLON
terms	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
addTerm	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
doFlush	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
deleteTerm	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
term	TokenNameIdentifier
,	TokenNameCOMMA
boolean	TokenNameboolean
skipWait	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
boolean	TokenNameboolean
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
flushControl	TokenNameIdentifier
.	TokenNameDOT
waitUpdate	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
skipWait	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
addTerm	TokenNameIdentifier
(	TokenNameLPAREN
term	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
doFlush	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
FieldInfos	TokenNameIdentifier
getFieldInfos	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
fieldInfos	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
setInfoStream	TokenNameIdentifier
(	TokenNameLPAREN
PrintStream	TokenNameIdentifier
infoStream	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
infoStream	TokenNameIdentifier
=	TokenNameEQUAL
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
threadStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
docState	TokenNameIdentifier
.	TokenNameDOT
infoStream	TokenNameIdentifier
=	TokenNameEQUAL
infoStream	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
setMaxFieldLength	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
maxFieldLength	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
maxFieldLength	TokenNameIdentifier
=	TokenNameEQUAL
maxFieldLength	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
threadStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
docState	TokenNameIdentifier
.	TokenNameDOT
maxFieldLength	TokenNameIdentifier
=	TokenNameEQUAL
maxFieldLength	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
setSimilarity	TokenNameIdentifier
(	TokenNameLPAREN
Similarity	TokenNameIdentifier
similarity	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
similarity	TokenNameIdentifier
=	TokenNameEQUAL
similarity	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
threadStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
docState	TokenNameIdentifier
.	TokenNameDOT
similarity	TokenNameIdentifier
=	TokenNameEQUAL
similarity	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
String	TokenNameIdentifier
getSegment	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
segment	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
int	TokenNameint
getNumDocs	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
numDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
message	TokenNameIdentifier
(	TokenNameLPAREN
String	TokenNameIdentifier
message	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
writer	TokenNameIdentifier
.	TokenNameDOT
message	TokenNameIdentifier
(	TokenNameLPAREN
"DW: "	TokenNameStringLiteral
+	TokenNamePLUS
message	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
setAborting	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"setAborting"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
aborting	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"docWriter: abort"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
waitQueue	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
waitIdle	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"docWriter: abort waitIdle done"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
waitQueue	TokenNameIdentifier
.	TokenNameDOT
numWaiting	TokenNameIdentifier
:	TokenNameCOLON
"waitQueue.numWaiting="	TokenNameStringLiteral
+	TokenNamePLUS
waitQueue	TokenNameIdentifier
.	TokenNameDOT
numWaiting	TokenNameIdentifier
;	TokenNameSEMICOLON
waitQueue	TokenNameIdentifier
.	TokenNameDOT
waitingBytes	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
DocumentsWriterThreadState	TokenNameIdentifier
threadState	TokenNameIdentifier
:	TokenNameCOLON
threadStates	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
threadState	TokenNameIdentifier
.	TokenNameDOT
consumer	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
try	TokenNametry
{	TokenNameLBRACE
consumer	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
doAfterFlush	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
aborting	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"docWriter: done abort; success="	TokenNameStringLiteral
+	TokenNamePLUS
success	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
doAfterFlush	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
allThreadsIdle	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
threadBindings	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
waitQueue	TokenNameIdentifier
.	TokenNameDOT
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
segment	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
numDocs	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
nextDocID	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
bufferIsFull	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
threadStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
doAfterFlush	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
allThreadsIdle	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
threadStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
.	TokenNameDOT
isIdle	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
return	TokenNamereturn
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
anyChanges	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
numDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
any	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
BufferedDeletes	TokenNameIdentifier
getPendingDeletes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
pendingDeletes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
pushDeletes	TokenNameIdentifier
(	TokenNameLPAREN
SegmentInfo	TokenNameIdentifier
newSegment	TokenNameIdentifier
,	TokenNameCOMMA
SegmentInfos	TokenNameIdentifier
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
delGen	TokenNameIdentifier
=	TokenNameEQUAL
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
getNextGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
any	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
newSegment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
FrozenBufferedDeletes	TokenNameIdentifier
packet	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
FrozenBufferedDeletes	TokenNameIdentifier
(	TokenNameLPAREN
pendingDeletes	TokenNameIdentifier
,	TokenNameCOMMA
delGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush: push buffered deletes startSize="	TokenNameStringLiteral
+	TokenNamePLUS
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" frozenSize="	TokenNameStringLiteral
+	TokenNamePLUS
packet	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
push	TokenNameIdentifier
(	TokenNameLPAREN
packet	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush: delGen="	TokenNameStringLiteral
+	TokenNamePLUS
packet	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
newSegment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
newSegment	TokenNameIdentifier
.	TokenNameDOT
setBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
packet	TokenNameIdentifier
.	TokenNameDOT
gen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush: drop buffered deletes: no segments"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
if	TokenNameif
(	TokenNameLPAREN
newSegment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
newSegment	TokenNameIdentifier
.	TokenNameDOT
setBufferedDeletesGen	TokenNameIdentifier
(	TokenNameLPAREN
delGen	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
boolean	TokenNameboolean
anyDeletions	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
any	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
SegmentInfo	TokenNameIdentifier
flush	TokenNameIdentifier
(	TokenNameLPAREN
IndexWriter	TokenNameIdentifier
writer	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileDeleter	TokenNameIdentifier
deleter	TokenNameIdentifier
,	TokenNameCOMMA
MergePolicy	TokenNameIdentifier
mergePolicy	TokenNameIdentifier
,	TokenNameCOMMA
SegmentInfos	TokenNameIdentifier
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
long	TokenNamelong
startTime	TokenNameIdentifier
=	TokenNameEQUAL
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
Thread	TokenNameIdentifier
.	TokenNameDOT
holdsLock	TokenNameIdentifier
(	TokenNameLPAREN
writer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
waitIdle	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
numDocs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush: no docs; skipping"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pushDeletes	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
aborting	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush: skip because aborting is set"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
SegmentInfo	TokenNameIdentifier
newSegment	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
assert	TokenNameassert
nextDocID	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
numDocs	TokenNameIdentifier
:	TokenNameCOLON
"nextDocID="	TokenNameStringLiteral
+	TokenNamePLUS
nextDocID	TokenNameIdentifier
+	TokenNamePLUS
" numDocs="	TokenNameStringLiteral
+	TokenNamePLUS
numDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
waitQueue	TokenNameIdentifier
.	TokenNameDOT
numWaiting	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
:	TokenNameCOLON
"numWaiting="	TokenNameStringLiteral
+	TokenNamePLUS
waitQueue	TokenNameIdentifier
.	TokenNameDOT
numWaiting	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
waitQueue	TokenNameIdentifier
.	TokenNameDOT
waitingBytes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush postings as segment "	TokenNameStringLiteral
+	TokenNamePLUS
segment	TokenNameIdentifier
+	TokenNamePLUS
" numDocs="	TokenNameStringLiteral
+	TokenNamePLUS
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
SegmentWriteState	TokenNameIdentifier
flushState	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentWriteState	TokenNameIdentifier
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
,	TokenNameCOMMA
directory	TokenNameIdentifier
,	TokenNameCOMMA
segment	TokenNameIdentifier
,	TokenNameCOMMA
fieldInfos	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
,	TokenNameCOMMA
writer	TokenNameIdentifier
.	TokenNameDOT
getConfig	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
.	TokenNameDOT
getTermIndexInterval	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
pendingDeletes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
docIDs	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
flushState	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
BitVector	TokenNameIdentifier
(	TokenNameLPAREN
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
delDocID	TokenNameIdentifier
:	TokenNameCOLON
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
docIDs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flushState	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
delDocID	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
docIDs	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
*	TokenNameMULTIPLY
BufferedDeletes	TokenNameIdentifier
.	TokenNameDOT
BYTES_PER_DEL_DOCID	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
docIDs	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
newSegment	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SegmentInfo	TokenNameIdentifier
(	TokenNameLPAREN
segment	TokenNameIdentifier
,	TokenNameCOMMA
numDocs	TokenNameIdentifier
,	TokenNameCOMMA
directory	TokenNameIdentifier
,	TokenNameCOMMA
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
fieldInfos	TokenNameIdentifier
.	TokenNameDOT
hasProx	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
false	TokenNamefalse
)	TokenNameRPAREN
;	TokenNameSEMICOLON
Collection	TokenNameIdentifier
<	TokenNameLESS
DocConsumerPerThread	TokenNameIdentifier
>	TokenNameGREATER
threads	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
HashSet	TokenNameIdentifier
<	TokenNameLESS
DocConsumerPerThread	TokenNameIdentifier
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
DocumentsWriterThreadState	TokenNameIdentifier
threadState	TokenNameIdentifier
:	TokenNameCOLON
threadStates	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
threads	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
threadState	TokenNameIdentifier
.	TokenNameDOT
consumer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
double	TokenNamedouble
startMBUsed	TokenNameIdentifier
=	TokenNameEQUAL
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
consumer	TokenNameIdentifier
.	TokenNameDOT
flush	TokenNameIdentifier
(	TokenNameLPAREN
threads	TokenNameIdentifier
,	TokenNameCOMMA
flushState	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
newSegment	TokenNameIdentifier
.	TokenNameDOT
setHasVectors	TokenNameIdentifier
(	TokenNameLPAREN
flushState	TokenNameIdentifier
.	TokenNameDOT
hasVectors	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"new segment has "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
flushState	TokenNameIdentifier
.	TokenNameDOT
hasVectors	TokenNameIdentifier
?	TokenNameQUESTION
"vectors"	TokenNameStringLiteral
:	TokenNameCOLON
"no vectors"	TokenNameStringLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
flushState	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"new segment has "	TokenNameStringLiteral
+	TokenNamePLUS
flushState	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" deleted docs"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flushedFiles="	TokenNameStringLiteral
+	TokenNamePLUS
newSegment	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
mergePolicy	TokenNameIdentifier
.	TokenNameDOT
useCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
segmentInfos	TokenNameIdentifier
,	TokenNameCOMMA
newSegment	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
String	TokenNameIdentifier
cfsFileName	TokenNameIdentifier
=	TokenNameEQUAL
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
segmentFileName	TokenNameIdentifier
(	TokenNameLPAREN
segment	TokenNameIdentifier
,	TokenNameCOMMA
IndexFileNames	TokenNameIdentifier
.	TokenNameDOT
COMPOUND_FILE_EXTENSION	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush: create compound file ""	TokenNameStringLiteral
+	TokenNamePLUS
cfsFileName	TokenNameIdentifier
+	TokenNamePLUS
"""	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
CompoundFileWriter	TokenNameIdentifier
cfsWriter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
CompoundFileWriter	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
cfsFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
String	TokenNameIdentifier
fileName	TokenNameIdentifier
:	TokenNameCOLON
newSegment	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
cfsWriter	TokenNameIdentifier
.	TokenNameDOT
addFile	TokenNameIdentifier
(	TokenNameLPAREN
fileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
cfsWriter	TokenNameIdentifier
.	TokenNameDOT
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
deleter	TokenNameIdentifier
.	TokenNameDOT
deleteNewFiles	TokenNameIdentifier
(	TokenNameLPAREN
newSegment	TokenNameIdentifier
.	TokenNameDOT
files	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
newSegment	TokenNameIdentifier
.	TokenNameDOT
setUseCompoundFile	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
flushState	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
delCount	TokenNameIdentifier
=	TokenNameEQUAL
flushState	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
count	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
delCount	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
newSegment	TokenNameIdentifier
.	TokenNameDOT
setDelCount	TokenNameIdentifier
(	TokenNameLPAREN
delCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
newSegment	TokenNameIdentifier
.	TokenNameDOT
advanceDelGen	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
String	TokenNameIdentifier
delFileName	TokenNameIdentifier
=	TokenNameEQUAL
newSegment	TokenNameIdentifier
.	TokenNameDOT
getDelFileName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush: write "	TokenNameStringLiteral
+	TokenNamePLUS
delCount	TokenNameIdentifier
+	TokenNamePLUS
" deletes to "	TokenNameStringLiteral
+	TokenNamePLUS
delFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
success2	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
flushState	TokenNameIdentifier
.	TokenNameDOT
deletedDocs	TokenNameIdentifier
.	TokenNameDOT
write	TokenNameIdentifier
(	TokenNameLPAREN
directory	TokenNameIdentifier
,	TokenNameCOMMA
delFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success2	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
directory	TokenNameIdentifier
.	TokenNameDOT
deleteFile	TokenNameIdentifier
(	TokenNameLPAREN
delFileName	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush: segment="	TokenNameStringLiteral
+	TokenNamePLUS
newSegment	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
double	TokenNamedouble
newSegmentSizeNoStore	TokenNameIdentifier
=	TokenNameEQUAL
newSegment	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
double	TokenNamedouble
newSegmentSize	TokenNameIdentifier
=	TokenNameEQUAL
newSegment	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
;	TokenNameSEMICOLON
message	TokenNameIdentifier
(	TokenNameLPAREN
"  ramUsed="	TokenNameStringLiteral
+	TokenNamePLUS
nf	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
startMBUsed	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" MB"	TokenNameStringLiteral
+	TokenNamePLUS
" newFlushedSize="	TokenNameStringLiteral
+	TokenNamePLUS
nf	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
newSegmentSize	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" MB"	TokenNameStringLiteral
+	TokenNamePLUS
" ("	TokenNameStringLiteral
+	TokenNamePLUS
nf	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
newSegmentSizeNoStore	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" MB w/o doc stores)"	TokenNameStringLiteral
+	TokenNamePLUS
" docs/MB="	TokenNameStringLiteral
+	TokenNamePLUS
nf	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
numDocs	TokenNameIdentifier
/	TokenNameDIVIDE
newSegmentSize	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" new/old="	TokenNameStringLiteral
+	TokenNamePLUS
nf	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
100.0	TokenNameDoubleLiteral
*	TokenNameMULTIPLY
newSegmentSizeNoStore	TokenNameIdentifier
/	TokenNameDIVIDE
startMBUsed	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
"%"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
segment	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
deleter	TokenNameIdentifier
.	TokenNameDOT
refresh	TokenNameIdentifier
(	TokenNameLPAREN
segment	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
doAfterFlush	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
pushDeletes	TokenNameIdentifier
(	TokenNameLPAREN
newSegment	TokenNameIdentifier
,	TokenNameCOMMA
segmentInfos	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"flush time "	TokenNameStringLiteral
+	TokenNamePLUS
(	TokenNameLPAREN
System	TokenNameIdentifier
.	TokenNameDOT
currentTimeMillis	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
startTime	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" msec"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
newSegment	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
close	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
closed	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
DocumentsWriterThreadState	TokenNameIdentifier
getThreadState	TokenNameIdentifier
(	TokenNameLPAREN
Term	TokenNameIdentifier
delTerm	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
docCount	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
Thread	TokenNameIdentifier
currentThread	TokenNameIdentifier
=	TokenNameEQUAL
Thread	TokenNameIdentifier
.	TokenNameDOT
currentThread	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
!	TokenNameNOT
Thread	TokenNameIdentifier
.	TokenNameDOT
holdsLock	TokenNameIdentifier
(	TokenNameLPAREN
writer	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
DocumentsWriterThreadState	TokenNameIdentifier
state	TokenNameIdentifier
=	TokenNameEQUAL
threadBindings	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
currentThread	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
state	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
DocumentsWriterThreadState	TokenNameIdentifier
minThreadState	TokenNameIdentifier
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
DocumentsWriterThreadState	TokenNameIdentifier
ts	TokenNameIdentifier
=	TokenNameEQUAL
threadStates	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
minThreadState	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
ts	TokenNameIdentifier
.	TokenNameDOT
numThreads	TokenNameIdentifier
<	TokenNameLESS
minThreadState	TokenNameIdentifier
.	TokenNameDOT
numThreads	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
minThreadState	TokenNameIdentifier
=	TokenNameEQUAL
ts	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
minThreadState	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
&&	TokenNameAND_AND
(	TokenNameLPAREN
minThreadState	TokenNameIdentifier
.	TokenNameDOT
numThreads	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
||	TokenNameOR_OR
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
maxThreadStates	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
=	TokenNameEQUAL
minThreadState	TokenNameIdentifier
;	TokenNameSEMICOLON
state	TokenNameIdentifier
.	TokenNameDOT
numThreads	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
DocumentsWriterThreadState	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newArray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
DocumentsWriterThreadState	TokenNameIdentifier
[	TokenNameLBRACKET
1	TokenNameIntegerLiteral
+	TokenNamePLUS
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
threadStates	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newArray	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
state	TokenNameIdentifier
=	TokenNameEQUAL
newArray	TokenNameIdentifier
[	TokenNameLBRACKET
threadStates	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
new	TokenNamenew
DocumentsWriterThreadState	TokenNameIdentifier
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
;	TokenNameSEMICOLON
threadStates	TokenNameIdentifier
=	TokenNameEQUAL
newArray	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
threadBindings	TokenNameIdentifier
.	TokenNameDOT
put	TokenNameIdentifier
(	TokenNameLPAREN
currentThread	TokenNameIdentifier
,	TokenNameCOMMA
state	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
waitReady	TokenNameIdentifier
(	TokenNameLPAREN
state	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
segment	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
segment	TokenNameIdentifier
=	TokenNameEQUAL
writer	TokenNameIdentifier
.	TokenNameDOT
newSegmentName	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assert	TokenNameassert
numDocs	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
state	TokenNameIdentifier
.	TokenNameDOT
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
=	TokenNameEQUAL
nextDocID	TokenNameIdentifier
;	TokenNameSEMICOLON
nextDocID	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
delTerm	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
addTerm	TokenNameIdentifier
(	TokenNameLPAREN
delTerm	TokenNameIdentifier
,	TokenNameCOMMA
state	TokenNameIdentifier
.	TokenNameDOT
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
numDocs	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
state	TokenNameIdentifier
.	TokenNameDOT
isIdle	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
return	TokenNamereturn
state	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
addDocument	TokenNameIdentifier
(	TokenNameLPAREN
Document	TokenNameIdentifier
doc	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
analyzer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
updateDocument	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
,	TokenNameCOMMA
analyzer	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
updateDocument	TokenNameIdentifier
(	TokenNameLPAREN
Document	TokenNameIdentifier
doc	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
analyzer	TokenNameIdentifier
,	TokenNameCOMMA
Term	TokenNameIdentifier
delTerm	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
flushControl	TokenNameIdentifier
.	TokenNameDOT
waitUpdate	TokenNameIdentifier
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
delTerm	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
DocumentsWriterThreadState	TokenNameIdentifier
state	TokenNameIdentifier
=	TokenNameEQUAL
getThreadState	TokenNameIdentifier
(	TokenNameLPAREN
delTerm	TokenNameIdentifier
,	TokenNameCOMMA
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
DocState	TokenNameIdentifier
docState	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
.	TokenNameDOT
docState	TokenNameIdentifier
;	TokenNameSEMICOLON
docState	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
=	TokenNameEQUAL
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
docState	TokenNameIdentifier
.	TokenNameDOT
analyzer	TokenNameIdentifier
=	TokenNameEQUAL
analyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
final	TokenNamefinal
DocWriter	TokenNameIdentifier
perDoc	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
perDoc	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
.	TokenNameDOT
consumer	TokenNameIdentifier
.	TokenNameDOT
processDocument	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
docState	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finishDocument	TokenNameIdentifier
(	TokenNameLPAREN
state	TokenNameIdentifier
,	TokenNameCOMMA
perDoc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
doFlush	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
flushControl	TokenNameIdentifier
.	TokenNameDOT
clearFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"exception in updateDocument aborting="	TokenNameStringLiteral
+	TokenNamePLUS
aborting	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
.	TokenNameDOT
isIdle	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
aborting	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
skipDocWriter	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
=	TokenNameEQUAL
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success2	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
waitQueue	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
skipDocWriter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success2	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
deleteDocID	TokenNameIdentifier
(	TokenNameLPAREN
state	TokenNameIdentifier
.	TokenNameDOT
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
doFlush	TokenNameIdentifier
|=	TokenNameOR_EQUAL
flushControl	TokenNameIdentifier
.	TokenNameDOT
flushByRAMUsage	TokenNameIdentifier
(	TokenNameLPAREN
"new document"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
doFlush	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
boolean	TokenNameboolean
updateDocuments	TokenNameIdentifier
(	TokenNameLPAREN
Collection	TokenNameIdentifier
<	TokenNameLESS
Document	TokenNameIdentifier
>	TokenNameGREATER
docs	TokenNameIdentifier
,	TokenNameCOMMA
Analyzer	TokenNameIdentifier
analyzer	TokenNameIdentifier
,	TokenNameCOMMA
Term	TokenNameIdentifier
delTerm	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
CorruptIndexException	TokenNameIdentifier
,	TokenNameCOMMA
IOException	TokenNameIdentifier
{	TokenNameLBRACE
boolean	TokenNameboolean
doFlush	TokenNameIdentifier
=	TokenNameEQUAL
flushControl	TokenNameIdentifier
.	TokenNameDOT
waitUpdate	TokenNameIdentifier
(	TokenNameLPAREN
docs	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
,	TokenNameCOMMA
delTerm	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
?	TokenNameQUESTION
1	TokenNameIntegerLiteral
:	TokenNameCOLON
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
docCount	TokenNameIdentifier
=	TokenNameEQUAL
docs	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
DocumentsWriterThreadState	TokenNameIdentifier
state	TokenNameIdentifier
=	TokenNameEQUAL
getThreadState	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
docCount	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
DocState	TokenNameIdentifier
docState	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
.	TokenNameDOT
docState	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
startDocID	TokenNameIdentifier
=	TokenNameEQUAL
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
docID	TokenNameIdentifier
=	TokenNameEQUAL
startDocID	TokenNameIdentifier
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
Document	TokenNameIdentifier
doc	TokenNameIdentifier
:	TokenNameCOLON
docs	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
docState	TokenNameIdentifier
.	TokenNameDOT
doc	TokenNameIdentifier
=	TokenNameEQUAL
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
docState	TokenNameIdentifier
.	TokenNameDOT
analyzer	TokenNameIdentifier
=	TokenNameEQUAL
analyzer	TokenNameIdentifier
;	TokenNameSEMICOLON
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
=	TokenNameEQUAL
docID	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
final	TokenNamefinal
DocWriter	TokenNameIdentifier
perDoc	TokenNameIdentifier
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
perDoc	TokenNameIdentifier
=	TokenNameEQUAL
state	TokenNameIdentifier
.	TokenNameDOT
consumer	TokenNameIdentifier
.	TokenNameDOT
processDocument	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
docState	TokenNameIdentifier
.	TokenNameDOT
clear	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
balanceRAM	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
aborting	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
perDoc	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
perDoc	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
boolean	TokenNameboolean
doPause	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
perDoc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
waitQueue	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
perDoc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
skipDocWriter	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
=	TokenNameEQUAL
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
waitQueue	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
skipDocWriter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
doFlush	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"clearFlushPending!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
flushControl	TokenNameIdentifier
.	TokenNameDOT
clearFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"exception in updateDocuments aborting="	TokenNameStringLiteral
+	TokenNamePLUS
aborting	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
.	TokenNameDOT
isIdle	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
aborting	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
endDocID	TokenNameIdentifier
=	TokenNameEQUAL
startDocID	TokenNameIdentifier
+	TokenNamePLUS
docCount	TokenNameIdentifier
;	TokenNameSEMICOLON
docID	TokenNameIdentifier
=	TokenNameEQUAL
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
docID	TokenNameIdentifier
<	TokenNameLESS
endDocID	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
skipDocWriter	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
=	TokenNameEQUAL
docID	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success2	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
waitQueue	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
skipDocWriter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
success2	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success2	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
docID	TokenNameIdentifier
=	TokenNameEQUAL
startDocID	TokenNameIdentifier
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
docID	TokenNameIdentifier
<	TokenNameLESS
startDocID	TokenNameIdentifier
+	TokenNamePLUS
docs	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
deleteDocID	TokenNameIdentifier
(	TokenNameLPAREN
docID	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
waitQueue	TokenNameIdentifier
.	TokenNameDOT
doPause	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
waitForWaitQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
aborting	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
state	TokenNameIdentifier
.	TokenNameDOT
isIdle	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doFlush	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"clearFlushPending!"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
flushControl	TokenNameIdentifier
.	TokenNameDOT
clearFlushPending	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
delTerm	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
addTerm	TokenNameIdentifier
(	TokenNameLPAREN
delTerm	TokenNameIdentifier
,	TokenNameCOMMA
startDocID	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
state	TokenNameIdentifier
.	TokenNameDOT
isIdle	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
doFlush	TokenNameIdentifier
|=	TokenNameOR_EQUAL
flushControl	TokenNameIdentifier
.	TokenNameDOT
flushByRAMUsage	TokenNameIdentifier
(	TokenNameLPAREN
"new document"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
doFlush	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
public	TokenNamepublic
synchronized	TokenNamesynchronized
void	TokenNamevoid
waitIdle	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
allThreadsIdle	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
wait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InterruptedException	TokenNameIdentifier
ie	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ThreadInterruptedException	TokenNameIdentifier
(	TokenNameLPAREN
ie	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
waitReady	TokenNameIdentifier
(	TokenNameLPAREN
DocumentsWriterThreadState	TokenNameIdentifier
state	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
closed	TokenNameIdentifier
&&	TokenNameAND_AND
(	TokenNameLPAREN
!	TokenNameNOT
state	TokenNameIdentifier
.	TokenNameDOT
isIdle	TokenNameIdentifier
||	TokenNameOR_OR
aborting	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
wait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InterruptedException	TokenNameIdentifier
ie	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ThreadInterruptedException	TokenNameIdentifier
(	TokenNameLPAREN
ie	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
closed	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
AlreadyClosedException	TokenNameIdentifier
(	TokenNameLPAREN
"this IndexWriter is closed"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
finishDocument	TokenNameIdentifier
(	TokenNameLPAREN
DocumentsWriterThreadState	TokenNameIdentifier
perThread	TokenNameIdentifier
,	TokenNameCOMMA
DocWriter	TokenNameIdentifier
docWriter	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
balanceRAM	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
docWriter	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
||	TokenNameOR_OR
docWriter	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
perThread	TokenNameIdentifier
.	TokenNameDOT
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
aborting	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
docWriter	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
docWriter	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
Throwable	TokenNameIdentifier
t	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
perThread	TokenNameIdentifier
.	TokenNameDOT
isIdle	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
boolean	TokenNameboolean
doPause	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
docWriter	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
doPause	TokenNameIdentifier
=	TokenNameEQUAL
waitQueue	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
docWriter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
skipDocWriter	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
=	TokenNameEQUAL
perThread	TokenNameIdentifier
.	TokenNameDOT
docState	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
doPause	TokenNameIdentifier
=	TokenNameEQUAL
waitQueue	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
skipDocWriter	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doPause	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
waitForWaitQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
perThread	TokenNameIdentifier
.	TokenNameDOT
isIdle	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
notifyAll	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
waitForWaitQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
do	TokenNamedo
{	TokenNameLBRACE
try	TokenNametry
{	TokenNameLBRACE
wait	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
InterruptedException	TokenNameIdentifier
ie	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
throw	TokenNamethrow
new	TokenNamenew
ThreadInterruptedException	TokenNameIdentifier
(	TokenNameLPAREN
ie	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
while	TokenNamewhile
(	TokenNameLPAREN
!	TokenNameNOT
waitQueue	TokenNameIdentifier
.	TokenNameDOT
doResume	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
SkipDocWriter	TokenNameIdentifier
extends	TokenNameextends
DocWriter	TokenNameIdentifier
{	TokenNameLBRACE
@	TokenNameAT
Override	TokenNameIdentifier
void	TokenNamevoid
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
void	TokenNamevoid
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
long	TokenNamelong
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
SkipDocWriter	TokenNameIdentifier
skipDocWriter	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
SkipDocWriter	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
NumberFormat	TokenNameIdentifier
nf	TokenNameIdentifier
=	TokenNameEQUAL
NumberFormat	TokenNameIdentifier
.	TokenNameDOT
getInstance	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BYTE_BLOCK_SHIFT	TokenNameIdentifier
=	TokenNameEQUAL
15	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BYTE_BLOCK_SIZE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
BYTE_BLOCK_SHIFT	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BYTE_BLOCK_MASK	TokenNameIdentifier
=	TokenNameEQUAL
BYTE_BLOCK_SIZE	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
BYTE_BLOCK_NOT_MASK	TokenNameIdentifier
=	TokenNameEQUAL
~	TokenNameTWIDDLE
BYTE_BLOCK_MASK	TokenNameIdentifier
;	TokenNameSEMICOLON
private	TokenNameprivate
class	TokenNameclass
ByteBlockAllocator	TokenNameIdentifier
extends	TokenNameextends
ByteBlockPool	TokenNameIdentifier
.	TokenNameDOT
Allocator	TokenNameIdentifier
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
blockSize	TokenNameIdentifier
;	TokenNameSEMICOLON
ByteBlockAllocator	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
blockSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
blockSize	TokenNameIdentifier
=	TokenNameEQUAL
blockSize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
ArrayList	TokenNameIdentifier
<	TokenNameLESS
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
freeByteBlocks	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
@	TokenNameAT
Override	TokenNameIdentifier
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getByteBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
DocumentsWriter	TokenNameIdentifier
.	TokenNameDOT
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
b	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
size	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
byte	TokenNamebyte
[	TokenNameLBRACKET
blockSize	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
blockSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
b	TokenNameIdentifier
=	TokenNameEQUAL
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
size	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
b	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
void	TokenNamevoid
recycleByteBlocks	TokenNameIdentifier
(	TokenNameLPAREN
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
blocks	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
DocumentsWriter	TokenNameIdentifier
.	TokenNameDOT
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
blocks	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
blocks	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
void	TokenNamevoid
recycleByteBlocks	TokenNameIdentifier
(	TokenNameLPAREN
List	TokenNameIdentifier
<	TokenNameLESS
byte	TokenNamebyte
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
blocks	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
DocumentsWriter	TokenNameIdentifier
.	TokenNameDOT
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
blocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
size	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
blocks	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
blocks	TokenNameIdentifier
.	TokenNameDOT
set	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
,	TokenNameCOMMA
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
INT_BLOCK_SHIFT	TokenNameIdentifier
=	TokenNameEQUAL
13	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
INT_BLOCK_SIZE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
INT_BLOCK_SHIFT	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
INT_BLOCK_MASK	TokenNameIdentifier
=	TokenNameEQUAL
INT_BLOCK_SIZE	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
List	TokenNameIdentifier
<	TokenNameLESS
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
freeIntBlocks	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getIntBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
freeIntBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
b	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
size	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
b	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
int	TokenNameint
[	TokenNameLBRACKET
INT_BLOCK_SIZE	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
INT_BLOCK_SIZE	TokenNameIdentifier
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
b	TokenNameIdentifier
=	TokenNameEQUAL
freeIntBlocks	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
size	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
b	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
numBytes	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
numBytes	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
long	TokenNamelong
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
pendingDeletes	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
get	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
recycleIntBlocks	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
blocks	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
start	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
end	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
start	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
end	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
freeIntBlocks	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
blocks	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
blocks	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
ByteBlockAllocator	TokenNameIdentifier
byteBlockAllocator	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ByteBlockAllocator	TokenNameIdentifier
(	TokenNameLPAREN
BYTE_BLOCK_SIZE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
PER_DOC_BLOCK_SIZE	TokenNameIdentifier
=	TokenNameEQUAL
1024	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
ByteBlockAllocator	TokenNameIdentifier
perDocAllocator	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ByteBlockAllocator	TokenNameIdentifier
(	TokenNameLPAREN
PER_DOC_BLOCK_SIZE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
CHAR_BLOCK_SHIFT	TokenNameIdentifier
=	TokenNameEQUAL
14	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
CHAR_BLOCK_SIZE	TokenNameIdentifier
=	TokenNameEQUAL
1	TokenNameIntegerLiteral
<<	TokenNameLEFT_SHIFT
CHAR_BLOCK_SHIFT	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
CHAR_BLOCK_MASK	TokenNameIdentifier
=	TokenNameEQUAL
CHAR_BLOCK_SIZE	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
final	TokenNamefinal
static	TokenNamestatic
int	TokenNameint
MAX_TERM_LENGTH	TokenNameIdentifier
=	TokenNameEQUAL
CHAR_BLOCK_SIZE	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
private	TokenNameprivate
ArrayList	TokenNameIdentifier
<	TokenNameLESS
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
freeCharBlocks	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
ArrayList	TokenNameIdentifier
<	TokenNameLESS
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
>	TokenNameGREATER
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
synchronized	TokenNamesynchronized
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
getCharBlock	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
int	TokenNameint
size	TokenNameIdentifier
=	TokenNameEQUAL
freeCharBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
c	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
size	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
CHAR_BLOCK_SIZE	TokenNameIdentifier
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_CHAR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
c	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
char	TokenNamechar
[	TokenNameLBRACKET
CHAR_BLOCK_SIZE	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
c	TokenNameIdentifier
=	TokenNameEQUAL
freeCharBlocks	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
size	TokenNameIdentifier
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
return	TokenNamereturn
c	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
recycleCharBlocks	TokenNameIdentifier
(	TokenNameLPAREN
char	TokenNamechar
[	TokenNameLBRACKET
]	TokenNameRBRACKET
[	TokenNameLBRACKET
]	TokenNameRBRACKET
blocks	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
numBlocks	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numBlocks	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
freeCharBlocks	TokenNameIdentifier
.	TokenNameDOT
add	TokenNameIdentifier
(	TokenNameLPAREN
blocks	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
)	TokenNameRPAREN
;	TokenNameSEMICOLON
blocks	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
String	TokenNameIdentifier
toMB	TokenNameIdentifier
(	TokenNameLPAREN
long	TokenNamelong
v	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
nf	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
v	TokenNameIdentifier
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
void	TokenNamevoid
balanceRAM	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
boolean	TokenNameboolean
doBalance	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
deletesRAMUsed	TokenNameIdentifier
;	TokenNameSEMICOLON
deletesRAMUsed	TokenNameIdentifier
=	TokenNameEQUAL
bufferedDeletesStream	TokenNameIdentifier
.	TokenNameDOT
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
ramBufferSize	TokenNameIdentifier
;	TokenNameSEMICOLON
final	TokenNamefinal
double	TokenNamedouble
mb	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
mb	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DISABLE_AUTO_FLUSH	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
ramBufferSize	TokenNameIdentifier
=	TokenNameEQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DISABLE_AUTO_FLUSH	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
ramBufferSize	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
(	TokenNameLPAREN
mb	TokenNameIdentifier
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
ramBufferSize	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DISABLE_AUTO_FLUSH	TokenNameIdentifier
||	TokenNameOR_OR
bufferIsFull	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
;	TokenNameSEMICOLON
}	TokenNameRBRACE
doBalance	TokenNameIdentifier
=	TokenNameEQUAL
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
deletesRAMUsed	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
ramBufferSize	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
doBalance	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"  RAM: balance allocations: usedMB="	TokenNameStringLiteral
+	TokenNamePLUS
toMB	TokenNameIdentifier
(	TokenNameLPAREN
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
" vs trigger="	TokenNameStringLiteral
+	TokenNamePLUS
toMB	TokenNameIdentifier
(	TokenNameLPAREN
ramBufferSize	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" deletesMB="	TokenNameStringLiteral
+	TokenNamePLUS
toMB	TokenNameIdentifier
(	TokenNameLPAREN
deletesRAMUsed	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" byteBlockFree="	TokenNameStringLiteral
+	TokenNamePLUS
toMB	TokenNameIdentifier
(	TokenNameLPAREN
byteBlockAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
*	TokenNameMULTIPLY
BYTE_BLOCK_SIZE	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" perDocFree="	TokenNameStringLiteral
+	TokenNamePLUS
toMB	TokenNameIdentifier
(	TokenNameLPAREN
perDocAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
*	TokenNameMULTIPLY
PER_DOC_BLOCK_SIZE	TokenNameIdentifier
)	TokenNameRPAREN
+	TokenNamePLUS
" charBlockFree="	TokenNameStringLiteral
+	TokenNamePLUS
toMB	TokenNameIdentifier
(	TokenNameLPAREN
freeCharBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
*	TokenNameMULTIPLY
CHAR_BLOCK_SIZE	TokenNameIdentifier
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_CHAR	TokenNameIdentifier
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
final	TokenNamefinal
long	TokenNamelong
startBytesUsed	TokenNameIdentifier
=	TokenNameEQUAL
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
deletesRAMUsed	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
iter	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
boolean	TokenNameboolean
any	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
freeLevel	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
(	TokenNameLPAREN
0.95	TokenNameDoubleLiteral
*	TokenNameMULTIPLY
ramBufferSize	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
deletesRAMUsed	TokenNameIdentifier
>	TokenNameGREATER
freeLevel	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
synchronized	TokenNamesynchronized
(	TokenNameLPAREN
this	TokenNamethis
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
perDocAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
byteBlockAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
freeCharBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
freeIntBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
&&	TokenNameAND_AND
!	TokenNameNOT
any	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
bufferIsFull	TokenNameIdentifier
=	TokenNameEQUAL
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
deletesRAMUsed	TokenNameIdentifier
>	TokenNameGREATER
ramBufferSize	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
deletesRAMUsed	TokenNameIdentifier
>	TokenNameGREATER
ramBufferSize	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"    nothing to free; set bufferIsFull"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"    nothing to free"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
iter	TokenNameIdentifier
%	TokenNameREMAINDER
5	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
byteBlockAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
byteBlockAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
byteBlockAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
BYTE_BLOCK_SIZE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
1	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
iter	TokenNameIdentifier
%	TokenNameREMAINDER
5	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
freeCharBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
freeCharBlocks	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
freeCharBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
CHAR_BLOCK_SIZE	TokenNameIdentifier
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_CHAR	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
2	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
iter	TokenNameIdentifier
%	TokenNameREMAINDER
5	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
freeIntBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
freeIntBlocks	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
freeIntBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
INT_BLOCK_SIZE	TokenNameIdentifier
*	TokenNameMULTIPLY
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_INT	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
3	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
iter	TokenNameIdentifier
%	TokenNameREMAINDER
5	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
perDocAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
>	TokenNameGREATER
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
32	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
++	TokenNamePLUS_PLUS
i	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
perDocAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
remove	TokenNameIdentifier
(	TokenNameLPAREN
perDocAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
1	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
bytesUsed	TokenNameIdentifier
.	TokenNameDOT
addAndGet	TokenNameIdentifier
(	TokenNameLPAREN
-	TokenNameMINUS
PER_DOC_BLOCK_SIZE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
perDocAllocator	TokenNameIdentifier
.	TokenNameDOT
freeByteBlocks	TokenNameIdentifier
.	TokenNameDOT
size	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
(	TokenNameLPAREN
4	TokenNameIntegerLiteral
==	TokenNameEQUAL_EQUAL
iter	TokenNameIdentifier
%	TokenNameREMAINDER
5	TokenNameIntegerLiteral
)	TokenNameRPAREN
&&	TokenNameAND_AND
any	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
any	TokenNameIdentifier
=	TokenNameEQUAL
consumer	TokenNameIdentifier
.	TokenNameDOT
freeRAM	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
iter	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
if	TokenNameif
(	TokenNameLPAREN
infoStream	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
message	TokenNameIdentifier
(	TokenNameLPAREN
"    after free: freedMB="	TokenNameStringLiteral
+	TokenNamePLUS
nf	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
startBytesUsed	TokenNameIdentifier
-	TokenNameMINUS
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
-	TokenNameMINUS
deletesRAMUsed	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
" usedMB="	TokenNameStringLiteral
+	TokenNamePLUS
nf	TokenNameIdentifier
.	TokenNameDOT
format	TokenNameIdentifier
(	TokenNameLPAREN
(	TokenNameLPAREN
bytesUsed	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
+	TokenNamePLUS
deletesRAMUsed	TokenNameIdentifier
)	TokenNameRPAREN
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
/	TokenNameDIVIDE
1024.	TokenNameDoubleLiteral
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
final	TokenNamefinal
WaitQueue	TokenNameIdentifier
waitQueue	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
WaitQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
class	TokenNameclass
WaitQueue	TokenNameIdentifier
{	TokenNameLBRACE
DocWriter	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
waiting	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
nextWriteDocID	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
nextWriteLoc	TokenNameIdentifier
;	TokenNameSEMICOLON
int	TokenNameint
numWaiting	TokenNameIdentifier
;	TokenNameSEMICOLON
long	TokenNamelong
waitingBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
WaitQueue	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
waiting	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
DocWriter	TokenNameIdentifier
[	TokenNameLBRACKET
10	TokenNameIntegerLiteral
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
reset	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
assert	TokenNameassert
numWaiting	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
waitingBytes	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
nextWriteDocID	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
doResume	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
double	TokenNamedouble
mb	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
waitQueueResumeBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
mb	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DISABLE_AUTO_FLUSH	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
waitQueueResumeBytes	TokenNameIdentifier
=	TokenNameEQUAL
2	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
waitQueueResumeBytes	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
(	TokenNameLPAREN
mb	TokenNameIdentifier
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
0.05	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
waitingBytes	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
waitQueueResumeBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
boolean	TokenNameboolean
doPause	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
double	TokenNamedouble
mb	TokenNameIdentifier
=	TokenNameEQUAL
config	TokenNameIdentifier
.	TokenNameDOT
getRAMBufferSizeMB	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
final	TokenNamefinal
long	TokenNamelong
waitQueuePauseBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
mb	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
IndexWriterConfig	TokenNameIdentifier
.	TokenNameDOT
DISABLE_AUTO_FLUSH	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
waitQueuePauseBytes	TokenNameIdentifier
=	TokenNameEQUAL
4	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
waitQueuePauseBytes	TokenNameIdentifier
=	TokenNameEQUAL
(	TokenNameLPAREN
long	TokenNamelong
)	TokenNameRPAREN
(	TokenNameLPAREN
mb	TokenNameIdentifier
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
0.1	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
waitingBytes	TokenNameIdentifier
>	TokenNameGREATER
waitQueuePauseBytes	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
void	TokenNamevoid
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
count	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
waiting	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
final	TokenNamefinal
DocWriter	TokenNameIdentifier
doc	TokenNameIdentifier
=	TokenNameEQUAL
waiting	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
doc	TokenNameIdentifier
.	TokenNameDOT
abort	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
waiting	TokenNameIdentifier
[	TokenNameLBRACKET
i	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
count	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
waitingBytes	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
assert	TokenNameassert
count	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
numWaiting	TokenNameIdentifier
;	TokenNameSEMICOLON
numWaiting	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
private	TokenNameprivate
void	TokenNamevoid
writeDocument	TokenNameIdentifier
(	TokenNameLPAREN
DocWriter	TokenNameIdentifier
doc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
doc	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
skipDocWriter	TokenNameIdentifier
||	TokenNameOR_OR
nextWriteDocID	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
doc	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
;	TokenNameSEMICOLON
boolean	TokenNameboolean
success	TokenNameIdentifier
=	TokenNameEQUAL
false	TokenNamefalse
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
doc	TokenNameIdentifier
.	TokenNameDOT
finish	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
nextWriteDocID	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
nextWriteLoc	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
assert	TokenNameassert
nextWriteLoc	TokenNameIdentifier
<=	TokenNameLESS_EQUAL
waiting	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
nextWriteLoc	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
waiting	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
nextWriteLoc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
success	TokenNameIdentifier
=	TokenNameEQUAL
true	TokenNametrue
;	TokenNameSEMICOLON
}	TokenNameRBRACE
finally	TokenNamefinally
{	TokenNameLBRACE
if	TokenNameif
(	TokenNameLPAREN
!	TokenNameNOT
success	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
setAborting	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
synchronized	TokenNamesynchronized
public	TokenNamepublic
boolean	TokenNameboolean
add	TokenNameIdentifier
(	TokenNameLPAREN
DocWriter	TokenNameIdentifier
doc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assert	TokenNameassert
doc	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
nextWriteDocID	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doc	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
==	TokenNameEQUAL_EQUAL
nextWriteDocID	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
writeDocument	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
while	TokenNamewhile
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
{	TokenNameLBRACE
doc	TokenNameIdentifier
=	TokenNameEQUAL
waiting	TokenNameIdentifier
[	TokenNameLBRACKET
nextWriteLoc	TokenNameIdentifier
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
doc	TokenNameIdentifier
!=	TokenNameNOT_EQUAL
null	TokenNamenull
)	TokenNameRPAREN
{	TokenNameLBRACE
numWaiting	TokenNameIdentifier
--	TokenNameMINUS_MINUS
;	TokenNameSEMICOLON
waiting	TokenNameIdentifier
[	TokenNameLBRACKET
nextWriteLoc	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
waitingBytes	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
doc	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
writeDocument	TokenNameIdentifier
(	TokenNameLPAREN
doc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
break	TokenNamebreak
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
else	TokenNameelse
{	TokenNameLBRACE
int	TokenNameint
gap	TokenNameIdentifier
=	TokenNameEQUAL
doc	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
-	TokenNameMINUS
nextWriteDocID	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
gap	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
waiting	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
DocWriter	TokenNameIdentifier
[	TokenNameLBRACKET
]	TokenNameRBRACKET
newArray	TokenNameIdentifier
=	TokenNameEQUAL
new	TokenNamenew
DocWriter	TokenNameIdentifier
[	TokenNameLBRACKET
ArrayUtil	TokenNameIdentifier
.	TokenNameDOT
oversize	TokenNameIdentifier
(	TokenNameLPAREN
gap	TokenNameIdentifier
,	TokenNameCOMMA
RamUsageEstimator	TokenNameIdentifier
.	TokenNameDOT
NUM_BYTES_OBJECT_REF	TokenNameIdentifier
)	TokenNameRPAREN
]	TokenNameRBRACKET
;	TokenNameSEMICOLON
assert	TokenNameassert
nextWriteLoc	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
waiting	TokenNameIdentifier
,	TokenNameCOMMA
nextWriteLoc	TokenNameIdentifier
,	TokenNameCOMMA
newArray	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
waiting	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
nextWriteLoc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
System	TokenNameIdentifier
.	TokenNameDOT
arraycopy	TokenNameIdentifier
(	TokenNameLPAREN
waiting	TokenNameIdentifier
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
,	TokenNameCOMMA
newArray	TokenNameIdentifier
,	TokenNameCOMMA
waiting	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
-	TokenNameMINUS
nextWriteLoc	TokenNameIdentifier
,	TokenNameCOMMA
nextWriteLoc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
nextWriteLoc	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
waiting	TokenNameIdentifier
=	TokenNameEQUAL
newArray	TokenNameIdentifier
;	TokenNameSEMICOLON
gap	TokenNameIdentifier
=	TokenNameEQUAL
doc	TokenNameIdentifier
.	TokenNameDOT
docID	TokenNameIdentifier
-	TokenNameMINUS
nextWriteDocID	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
int	TokenNameint
loc	TokenNameIdentifier
=	TokenNameEQUAL
nextWriteLoc	TokenNameIdentifier
+	TokenNamePLUS
gap	TokenNameIdentifier
;	TokenNameSEMICOLON
if	TokenNameif
(	TokenNameLPAREN
loc	TokenNameIdentifier
>=	TokenNameGREATER_EQUAL
waiting	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
loc	TokenNameIdentifier
-=	TokenNameMINUS_EQUAL
waiting	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assert	TokenNameassert
loc	TokenNameIdentifier
<	TokenNameLESS
waiting	TokenNameIdentifier
.	TokenNameDOT
length	TokenNameIdentifier
;	TokenNameSEMICOLON
assert	TokenNameassert
waiting	TokenNameIdentifier
[	TokenNameLBRACKET
loc	TokenNameIdentifier
]	TokenNameRBRACKET
==	TokenNameEQUAL_EQUAL
null	TokenNamenull
;	TokenNameSEMICOLON
waiting	TokenNameIdentifier
[	TokenNameLBRACKET
loc	TokenNameIdentifier
]	TokenNameRBRACKET
=	TokenNameEQUAL
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
numWaiting	TokenNameIdentifier
++	TokenNamePLUS_PLUS
;	TokenNameSEMICOLON
waitingBytes	TokenNameIdentifier
+=	TokenNamePLUS_EQUAL
doc	TokenNameIdentifier
.	TokenNameDOT
sizeInBytes	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
return	TokenNamereturn
doPause	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
