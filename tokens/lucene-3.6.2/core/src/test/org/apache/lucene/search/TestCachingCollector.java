package	TokenNamepackage
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
search	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
index	TokenNameIdentifier
.	TokenNameDOT
IndexReader	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
org	TokenNameIdentifier
.	TokenNameDOT
apache	TokenNameIdentifier
.	TokenNameDOT
lucene	TokenNameIdentifier
.	TokenNameDOT
util	TokenNameIdentifier
.	TokenNameDOT
LuceneTestCase	TokenNameIdentifier
;	TokenNameSEMICOLON
import	TokenNameimport
java	TokenNameIdentifier
.	TokenNameDOT
io	TokenNameIdentifier
.	TokenNameDOT
IOException	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
class	TokenNameclass
TestCachingCollector	TokenNameIdentifier
extends	TokenNameextends
LuceneTestCase	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
static	TokenNamestatic
final	TokenNamefinal
double	TokenNamedouble
ONE_BYTE	TokenNameIdentifier
=	TokenNameEQUAL
1.0	TokenNameDoubleLiteral
/	TokenNameDIVIDE
(	TokenNameLPAREN
1024	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
1024	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
MockScorer	TokenNameIdentifier
extends	TokenNameextends
Scorer	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
MockScorer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
super	TokenNamesuper
(	TokenNameLPAREN
(	TokenNameLPAREN
Weight	TokenNameIdentifier
)	TokenNameRPAREN
null	TokenNamenull
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
float	TokenNamefloat
score	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
docID	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
nextDoc	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
int	TokenNameint
advance	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
target	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
return	TokenNamereturn
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
private	TokenNameprivate
static	TokenNamestatic
class	TokenNameclass
NoOpCollector	TokenNameIdentifier
extends	TokenNameextends
Collector	TokenNameIdentifier
{	TokenNameLBRACE
private	TokenNameprivate
final	TokenNamefinal
boolean	TokenNameboolean
acceptDocsOutOfOrder	TokenNameIdentifier
;	TokenNameSEMICOLON
public	TokenNamepublic
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
boolean	TokenNameboolean
acceptDocsOutOfOrder	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
this	TokenNamethis
.	TokenNameDOT
acceptDocsOutOfOrder	TokenNameIdentifier
=	TokenNameEQUAL
acceptDocsOutOfOrder	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setScorer	TokenNameIdentifier
(	TokenNameLPAREN
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
collect	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
doc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setNextReader	TokenNameIdentifier
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
docBase	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
acceptsDocsOutOfOrder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
acceptDocsOutOfOrder	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
testBasic	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
Exception	TokenNameIdentifier
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
boolean	TokenNameboolean
cacheScores	TokenNameIdentifier
:	TokenNameCOLON
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
}	TokenNameRBRACE
)	TokenNameRPAREN
{	TokenNameLBRACE
CachingCollector	TokenNameIdentifier
cc	TokenNameIdentifier
=	TokenNameEQUAL
CachingCollector	TokenNameIdentifier
.	TokenNameDOT
create	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
,	TokenNameCOMMA
cacheScores	TokenNameIdentifier
,	TokenNameCOMMA
1.0	TokenNameDoubleLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
setScorer	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
MockScorer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
1000	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
cc	TokenNameIdentifier
.	TokenNameDOT
collect	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
cc	TokenNameIdentifier
.	TokenNameDOT
replay	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
Collector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
prevDocID	TokenNameIdentifier
=	TokenNameEQUAL
-	TokenNameMINUS
1	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setScorer	TokenNameIdentifier
(	TokenNameLPAREN
Scorer	TokenNameIdentifier
scorer	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
setNextReader	TokenNameIdentifier
(	TokenNameLPAREN
IndexReader	TokenNameIdentifier
reader	TokenNameIdentifier
,	TokenNameCOMMA
int	TokenNameint
docBase	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
void	TokenNamevoid
collect	TokenNameIdentifier
(	TokenNameLPAREN
int	TokenNameint
doc	TokenNameIdentifier
)	TokenNameRPAREN
throws	TokenNamethrows
IOException	TokenNameIdentifier
{	TokenNameLBRACE
assertEquals	TokenNameIdentifier
(	TokenNameLPAREN
prevDocID	TokenNameIdentifier
+	TokenNamePLUS
1	TokenNameIntegerLiteral
,	TokenNameCOMMA
doc	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
prevDocID	TokenNameIdentifier
=	TokenNameEQUAL
doc	TokenNameIdentifier
;	TokenNameSEMICOLON
}	TokenNameRBRACE
@	TokenNameAT
Override	TokenNameIdentifier
public	TokenNamepublic
boolean	TokenNameboolean
acceptsDocsOutOfOrder	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
{	TokenNameLBRACE
return	TokenNamereturn
false	TokenNamefalse
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
testIllegalStateOnReplay	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
Exception	TokenNameIdentifier
{	TokenNameLBRACE
CachingCollector	TokenNameIdentifier
cc	TokenNameIdentifier
=	TokenNameEQUAL
CachingCollector	TokenNameIdentifier
.	TokenNameDOT
create	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
50	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
ONE_BYTE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
setScorer	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
MockScorer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
130	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
{	TokenNameLBRACE
cc	TokenNameIdentifier
.	TokenNameDOT
collect	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
assertFalse	TokenNameIdentifier
(	TokenNameLPAREN
"CachingCollector should not be cached due to low memory limit"	TokenNameStringLiteral
,	TokenNameCOMMA
cc	TokenNameIdentifier
.	TokenNameDOT
isCached	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
cc	TokenNameIdentifier
.	TokenNameDOT
replay	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fail	TokenNameIdentifier
(	TokenNameLPAREN
"replay should fail if CachingCollector is not cached"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IllegalStateException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
testIllegalCollectorOnReplay	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
Exception	TokenNameIdentifier
{	TokenNameLBRACE
CachingCollector	TokenNameIdentifier
cc	TokenNameIdentifier
=	TokenNameEQUAL
CachingCollector	TokenNameIdentifier
.	TokenNameDOT
create	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
50	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
ONE_BYTE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
setScorer	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
MockScorer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
cc	TokenNameIdentifier
.	TokenNameDOT
collect	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
replay	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
replay	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
=	TokenNameEQUAL
CachingCollector	TokenNameIdentifier
.	TokenNameDOT
create	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
,	TokenNameCOMMA
true	TokenNametrue
,	TokenNameCOMMA
50	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
ONE_BYTE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
setScorer	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
MockScorer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
10	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
cc	TokenNameIdentifier
.	TokenNameDOT
collect	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
replay	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
try	TokenNametry
{	TokenNameLBRACE
cc	TokenNameIdentifier
.	TokenNameDOT
replay	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
fail	TokenNameIdentifier
(	TokenNameLPAREN
"should have failed if an in-order Collector was given to replay(), "	TokenNameStringLiteral
+	TokenNamePLUS
"while CachingCollector was initialized with out-of-order collection"	TokenNameStringLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
catch	TokenNamecatch
(	TokenNameLPAREN
IllegalArgumentException	TokenNameIdentifier
e	TokenNameIdentifier
)	TokenNameRPAREN
{	TokenNameLBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
testCachedArraysAllocation	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
Exception	TokenNameIdentifier
{	TokenNameLBRACE
int	TokenNameint
numDocs	TokenNameIdentifier
=	TokenNameEQUAL
random	TokenNameIdentifier
.	TokenNameDOT
nextInt	TokenNameIdentifier
(	TokenNameLPAREN
10000	TokenNameIntegerLiteral
)	TokenNameRPAREN
+	TokenNamePLUS
150	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
boolean	TokenNameboolean
cacheScores	TokenNameIdentifier
:	TokenNameCOLON
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
}	TokenNameRBRACE
)	TokenNameRPAREN
{	TokenNameLBRACE
int	TokenNameint
bytesPerDoc	TokenNameIdentifier
=	TokenNameEQUAL
cacheScores	TokenNameIdentifier
?	TokenNameQUESTION
8	TokenNameIntegerLiteral
:	TokenNameCOLON
4	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
CachingCollector	TokenNameIdentifier
cc	TokenNameIdentifier
=	TokenNameEQUAL
CachingCollector	TokenNameIdentifier
.	TokenNameDOT
create	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
false	TokenNamefalse
)	TokenNameRPAREN
,	TokenNameCOMMA
cacheScores	TokenNameIdentifier
,	TokenNameCOMMA
bytesPerDoc	TokenNameIdentifier
*	TokenNameMULTIPLY
ONE_BYTE	TokenNameIdentifier
*	TokenNameMULTIPLY
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
setScorer	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
MockScorer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
for	TokenNamefor
(	TokenNameLPAREN
int	TokenNameint
i	TokenNameIdentifier
=	TokenNameEQUAL
0	TokenNameIntegerLiteral
;	TokenNameSEMICOLON
i	TokenNameIdentifier
<	TokenNameLESS
numDocs	TokenNameIdentifier
;	TokenNameSEMICOLON
i	TokenNameIdentifier
++	TokenNamePLUS_PLUS
)	TokenNameRPAREN
cc	TokenNameIdentifier
.	TokenNameDOT
collect	TokenNameIdentifier
(	TokenNameLPAREN
i	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assertTrue	TokenNameIdentifier
(	TokenNameLPAREN
cc	TokenNameIdentifier
.	TokenNameDOT
isCached	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
collect	TokenNameIdentifier
(	TokenNameLPAREN
numDocs	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assertFalse	TokenNameIdentifier
(	TokenNameLPAREN
cc	TokenNameIdentifier
.	TokenNameDOT
isCached	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
public	TokenNamepublic
void	TokenNamevoid
testNoWrappedCollector	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
throws	TokenNamethrows
Exception	TokenNameIdentifier
{	TokenNameLBRACE
for	TokenNamefor
(	TokenNameLPAREN
boolean	TokenNameboolean
cacheScores	TokenNameIdentifier
:	TokenNameCOLON
new	TokenNamenew
boolean	TokenNameboolean
[	TokenNameLBRACKET
]	TokenNameRBRACKET
{	TokenNameLBRACE
false	TokenNamefalse
,	TokenNameCOMMA
true	TokenNametrue
}	TokenNameRBRACE
)	TokenNameRPAREN
{	TokenNameLBRACE
CachingCollector	TokenNameIdentifier
cc	TokenNameIdentifier
=	TokenNameEQUAL
CachingCollector	TokenNameIdentifier
.	TokenNameDOT
create	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
,	TokenNameCOMMA
cacheScores	TokenNameIdentifier
,	TokenNameCOMMA
50	TokenNameIntegerLiteral
*	TokenNameMULTIPLY
ONE_BYTE	TokenNameIdentifier
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
setNextReader	TokenNameIdentifier
(	TokenNameLPAREN
null	TokenNamenull
,	TokenNameCOMMA
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
setScorer	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
MockScorer	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
collect	TokenNameIdentifier
(	TokenNameLPAREN
0	TokenNameIntegerLiteral
)	TokenNameRPAREN
;	TokenNameSEMICOLON
assertTrue	TokenNameIdentifier
(	TokenNameLPAREN
cc	TokenNameIdentifier
.	TokenNameDOT
isCached	TokenNameIdentifier
(	TokenNameLPAREN
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
cc	TokenNameIdentifier
.	TokenNameDOT
replay	TokenNameIdentifier
(	TokenNameLPAREN
new	TokenNamenew
NoOpCollector	TokenNameIdentifier
(	TokenNameLPAREN
true	TokenNametrue
)	TokenNameRPAREN
)	TokenNameRPAREN
;	TokenNameSEMICOLON
}	TokenNameRBRACE
}	TokenNameRBRACE
}	TokenNameRBRACE
